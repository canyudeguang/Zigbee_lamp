/*
 * Copyright (c) 2016-2017 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 */
// Copyright (c) 2018 Qualcomm Technologies, Inc.
// All rights reserved.
// Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) 
// provided that the following conditions are met:
// Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// Redistributions in binary form must reproduce the above copyright notice, 
// this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
// Neither the name of Qualcomm Technologies, Inc. nor the names of its contributors may be used to endorse or promote products derived 
// from this software without specific prior written permission.
// NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, 
// BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
// OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "qapi_otp_tlv.h"
#include "qapi_timer.h"
#include "qurt_timer.h"    /* Timer for Throughput Calculation.         */
#include "spple_demo.h"    /* Main Application Prototypes and Constants.*/
#include "qcli_util.h"

#include "ble_ota_service.h" /* OTA service API.                        */

#include "qapi_fs.h"

   /* Demo Constants.                                                   */

#ifndef V2
   #define QAPI_BLE_LAT_ANONYMOUS_E                   255
#endif

   /* Some MACROs for accessing little-endian unaligned values.         */
#define READ_UNALIGNED_BYTE_LITTLE_ENDIAN(_x)  (((uint8_t *)(_x))[0])
#define READ_UNALIGNED_WORD_LITTLE_ENDIAN(_x)  ((uint16_t)((((uint16_t)(((uint8_t *)(_x))[1])) << 8) | ((uint16_t)(((uint8_t *)(_x))[0]))))

#define ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(_x, _y)        \
{                                                                       \
  ((uint8_t *)(_x))[0] = ((uint8_t)(((uint16_t)(_y)) & 0xFF));          \
  ((uint8_t *)(_x))[1] = ((uint8_t)((((uint16_t)(_y)) >> 8) & 0xFF));   \
}

#define CONVERT_TO_BASEBAND_SLOTS(_x)                             ((unsigned long)((((8000L * ((unsigned long)(_x))) / 500L) + 5L)/10L))

   /* Determine the Name we will use for this compilation.              */
#define DEVICE_FRIENDLY_NAME                       "lpw-spple-demo"

   /* The following MACRO is used to convert an ASCII character into the*/
   /* equivalent decimal value.  The MACRO converts lower case          */
   /* characters to upper case before the conversion.                   */
#define ToInt(_x)                                  (((_x) > 0x39)?(((_x) & ~0x20)-0x37):((_x)-0x30))

   /* Generic Access Profile (GAP) Constants.                           */

#define DEFAULT_IO_CAPABILITY      (QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E)
                                                         /* Denotes the       */
                                                         /* default I/O       */
                                                         /* Capability that is*/
                                                         /* used with Pairing.*/

#define DEFAULT_MITM_PROTECTION                  (TRUE)  /* Denotes the       */
                                                         /* default value used*/
                                                         /* for Man in the    */
                                                         /* Middle (MITM)     */
                                                         /* protection used   */
                                                         /* with Secure Simple*/
                                                         /* Pairing.          */

#define DEFAULT_SECURE_CONNECTIONS               (TRUE)  /* Denotes the       */
                                                         /* default value used*/
                                                         /* for Secure        */
                                                         /* Connections used  */
                                                         /* with Secure Simple*/
                                                         /* Pairing.          */

   /* Automation IO Service (AIOS) Constants.                           */

#define AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS   (2)   /* Denotes the number*/
                                                         /* of                */
                                                         /* characteristics   */
                                                         /* supported by the  */
                                                         /* AIOS Server.      */

#define AIOP_NUMBER_OF_SUPPORTED_INSTANCES         (2)   /* Denotes the number*/
                                                         /* of                */
                                                         /* instances for each*/
                                                         /* Characteristic    */
                                                         /* supported by the  */
                                                         /* AIOS Server.      */

#define AIOP_DEFAULT_INPUT_CHARACTERISTIC_PROPERTY_FLAGS  (QAPI_BLE_AIOS_INPUT_CHARACTERISTIC_PROPERTY_FLAGS_NOTIFY)
                                                         /* Denotes the default*/
                                                         /* input              */
                                                         /* Characteristic     */
                                                         /* Property Flags.    */

#define AIOP_DEFAULT_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS (QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE | \
                                                           QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_READ  | \
                                                           QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_NOTIFY)
                                                         /* Denotes the default*/
                                                         /* output             */
                                                         /* Characteristic     */
                                                         /* Property Flags.    */

   /* Battery Alert Service (BAS) Constants.                            */

#define MAX_SUPPORTED_BATTERY_INSTANCES            (1)   /* Denotes the       */
                                                         /* maximum number of */
                                                         /* Battery Service   */
                                                         /* Instances that are*/
                                                         /* supported by this */
                                                         /* application.      */


   /* HID over GATT Service (HOGP) Constants.                           */

#define MAX_SUPPORTED_HID_INSTANCES                (1)   /* Denotes the       */
                                                         /* maximum number of */
                                                         /* HID Service       */
                                                         /* Instances that are*/
                                                         /* supported by this */
                                                         /* application.      */

#define HIDS_MAXIMUM_NUMBER_REPORTS                (5)   /* Denotes the       */
                                                         /* maximum number of */
                                                         /* supported HIDS    */
                                                         /* reports.          */

#define HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES (5) /* Denotes the     */
                                                         /* maximum number of */
                                                         /* supported HIDS    */
                                                         /* external report   */
                                                         /* references.       */

#define HID_KEYBOARD_INPUT_REPORT_SIZE               (8) /* Defines the size  */
                                                         /* of the application*/
                                                         /* keyboard input    */
                                                         /* report.           */

#define HID_KEYBOARD_OUTPUT_REPORT_SIZE              (1) /* Defines the size  */
                                                         /* of the application*/
                                                         /* keyboard output   */
                                                         /* report.           */

#define HID_MOUSE_INPUT_REPORT_SIZE                  (8) /* Defines the size  */
                                                         /* of the application*/
                                                         /* mouse input       */
                                                         /* report.           */

   /* The following define the valid bits that may be set as part of the*/
   /* Keyboard Output Report.                                           */
#define HID_KEYBOARD_OUTPUT_REPORT_NUM_LOCK         0x01
#define HID_KEYBOARD_OUTPUT_REPORT_CAPS_LOCK        0x02
#define HID_KEYBOARD_OUTPUT_REPORT_SCOLL_LOCK       0x04
#define HID_KEYBOARD_OUTPUT_REPORT_COMPOSE          0x08
#define HID_KEYBOARD_OUTPUT_REPORT_KANA             0x10

   /* The following define the report IDs to be used with HID reports.  */
#define HID_KEYBOARD_INPUT_REPORT_ID                1
#define HID_KEYBOARD_OUTPUT_REPORT_ID               2
#define HID_MOUSE_INPUT_REPORT_ID                   3

   /* The following MACRO is used to calculate if an ASCII              */
   /* characteristic is valid.                                          */
#define CHECK_ASCII_VALID(_x)                         (((_x) >= ' ') && ((_x) <= '~'))

   /* 6LoWPAN for BLE (SLoWP) Constants.                                */

   /* The following constants represent the application's default SLoWP */
   /* channel parameters.                                               */
#define SLoWP_CHANNEL_PARAMETERS_FLAGS              (0)
#define SLoWP_CHANNEL_PARAMETERS_MAX_SDU_SIZE       (1280)
#define SLoWP_CHANNEL_PARAMETERS_MAX_PDU_SIZE       (237)
#define SLoWP_CHANNEL_PARAMETERS_PDU_QUEUE_DEPTH    (5)
#define SLoWP_CHANNEL_PARAMETERS_MAX_CREDITS        (5)

   /* The following constants represent the application's default       */
   /* queuing parameters for sending packet data over the SLoWP         */
   /* connection.                                                       */
#define SLoWP_QP_DATA_PACKET_QUEUEING_FLAGS         (QAPI_BLE_L2CA_QUEUEING_FLAG_LIMIT_BY_PACKETS)
#define SLoWP_QP_MAXIMUM_NUMBER_QUEUED_DATA_PACKETS (3)
#define SLoWP_QP_QUEUED_DATA_PACKETS_THRESHOLD      (2)

   /* Serial Port Profile over LE (SPPLE) Constants.                    */

#ifndef SPPLE_DATA_BUFFER_LENGTH
#define SPPLE_DATA_BUFFER_LENGTH    (517)
                                                         /* Defines the length*/
                                                         /* of a SPPLE Data   */
                                                         /* Buffer.           */
#endif

#define SPPLE_DATA_CREDITS        (SPPLE_DATA_BUFFER_LENGTH*3)
                                                         /* Defines the       */
                                                         /* number of credits */
                                                         /* in an SPPLE Buffer*/

   /* Generic Access Profile (GAP) structures.                          */

   /* Structure used to hold all of the GAP LE Parameters.              */
typedef struct _tagGAPLE_Parameters_t
{
   qapi_BLE_GAP_LE_Connectability_Mode_t ConnectableMode;
   qapi_BLE_GAP_Discoverability_Mode_t   DiscoverabilityMode;
   qapi_BLE_GAP_LE_IO_Capability_t       IOCapability;
   boolean_t                             MITMProtection;
   boolean_t                             SecureConnections;
   boolean_t                             OOBDataPresent;
} GAPLE_Parameters_t;

#define GAPLE_PARAMETERS_DATA_SIZE                       (sizeof(GAPLE_Parameters_t))

   /* The following bit mask values may be used for the Flags field of  */
   /* the BLEParameters_t structure.                                    */
#define BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID   0x00000001
#define BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID          0x00000002
#define BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID    0x00000004

   /* The following structure is used to hold the Scan Window and       */
   /* Interval parameters for LE Scanning.                              */
typedef struct _tagBLEScanParameters_t
{
   uint16_t ScanInterval;
   uint16_t ScanWindow;
} BLEScanParameters_t;

   /* The following structure is used to hold information on the        */
   /* configured Scan/Advertising/Connection Parameters.                */
typedef struct _tagBLEParameters_t
{
   unsigned long                            Flags;
   qapi_BLE_GAP_LE_Advertising_Parameters_t AdvertisingParameters;
   qapi_BLE_GAP_LE_Connection_Parameters_t  ConnectionParameters;
   BLEScanParameters_t                      ScanParameters;
} BLEParameters_t;

   /* Automation IO Service (AIOS) structures.                          */

   /* The following structure contains the information for an AIOS      */
   /* Characteristic instance that the AIOS Server will need to store.  */
   /* * NOTE * The Instance_Entry below will need to be copied to the   */
   /*          qapi_BLE_AIOS_Characteristic_Entry_t structure, a        */
   /*          sub-structure of qapi_BLE_AIOS_Initialize_Data_t         */
   /*          structure, that is expected as a parameter to            */
   /*          qapi_BLE_AIOS_Initialize_Service().  This is REQUIRED to */
   /*          intialize the service and allows us to retain the        */
   /*          information that we used to initialize the service.      */
   /* * NOTE * Some fields of this structure will not be used.  The     */
   /*          fields depend on the optional AIOS Characteristic        */
   /*          descriptors included for this Characteristic instance    */
   /*          specified by the Instance_Entry field and whether this   */
   /*          instance is a Digital or Analog Characteristic.          */
   /* * NOTE * The AIOS Server will support 8 digital signals (2 octets)*/
   /*          for each Digital Characteristic for simplicity.          */
typedef struct _tagAIOP_Server_Instance_Data_t
{
   qapi_BLE_AIOS_Characteristic_Instance_Entry_t Instance_Entry;

   union
   {
      uint8_t                                    Digital[2];
      uint16_t                                   Analog;
   } Data;

   uint16_t                                      Client_Configuration;
   qapi_BLE_AIOS_Presentation_Format_Data_t      Presentation_Format;
   uint8_t                                       Number_Of_Digitals;
} AIOP_Server_Instance_Data_t;

#define AIOP_SERVER_INSTANCE_DATA_SIZE                   (sizeof(AIOP_Server_Instance_Data_t))

   /* The following structure contains the information for each AIOS    */
   /* Digital/Analog Characteristc that the AIOS Server will need to    */
   /* store.  Information for each AIOS Characteristic instance will be */
   /* stored by the Instances field.                                    */
   /* * NOTE * The Characteristic_Entry field below will need to be     */
   /*          copied to the qapi_BLE_AIOS_Initialize_Data_t structure  */
   /*          that is expected as a parameter to                       */
   /*          qapi_BLE_AIOS_Initialize_Service().  This is REQUIRED to */
   /*          initialize the service and allows us to retain the       */
   /*          information that we used to intialize the service.       */
   /* * NOTE * The AIOS Server will support two instances of each AIOS  */
   /*          Characteristic (Digital and Analog) for simplicity.      */
typedef struct _tagAIOP_Server_Characteristic_Data_t
{
   qapi_BLE_AIOS_Characteristic_Entry_t Characteristic_Entry;
   AIOP_Server_Instance_Data_t          Instances[AIOP_NUMBER_OF_SUPPORTED_INSTANCES];
} AIOP_Server_Characteristic_Data_t;

#define AIOP_SERVER_CHARACTERISTIC_DATA_SIZE             (sizeof(AIOP_Server_Characteristic_Data_t))

   /* The following structure contains the AIOS Server information.     */
   /* This information (and sub structures) are needed to initialize the*/
   /* AIOS Server with a call to qapi_BLE_AIOS_Initialize_Service().    */
   /* This structure will also hold the information needed to process   */
   /* AIOS Server events and will retain the values for AIOS            */
   /* Characteristics and descriptors.                                  */
   /* * NOTE * Some fields below will need to be copied to the          */
   /*          qapi_BLE_AIOS_Initialize_Data_t structure that is        */
   /*          expected as a parameter to                               */
   /*          qapi_BLE_AIOS_Initialize_Service().  This is REQUIRED to */
   /*          initialize the service and allows us to retain the       */
   /*          information that we used to intialize the service.       */
   /* * NOTE * The AIOS Server will support two characteristics: the    */
   /*          Digital and Analog Characteristics, for simplicity.      */
typedef struct _tagAIOP_Server_Information_t
{
   AIOP_Server_Characteristic_Data_t Characteristic[AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS];
} AIOP_Server_Information_t;

#define AIOP_SERVER_INFORMATION_DATA_SIZE                (sizeof(AIOP_Server_Information_t))

   /* The following enumeration will be used to determine the correct   */
   /* Attribute Handle to select for an AIOS Characteristic or          */
   /* Descriptor.                                                       */
typedef enum
{
   ahtCharacteristic,
   ahtClientCharacteristicConfig,
   ahtPresentationFormat,
   ahtNumberOfDigitals
} AIOP_Attribute_Handle_Type_t;

   /* The following structure holds the request information that the    */
   /* AIOP Client MUST store before issuing a GATT request to the AIOS  */
   /* Server.  This is so that we can easily handle the response.       */
   /* * NOTE * The Type and ID fields MUST be valid for all requests    */
   /*          since this information is required to quickly look up the*/
   /*          AIOS Characteristic Instance's information associated    */
   /*          with the request in the GATT_ClientEventCallback_AIOS()  */
   /*          when the response is received.                           */
   /* * NOTE * The AttributeHandleType field (Mandatory) allows us to   */
   /*          specify the type of the attribute handle we are expecting*/
   /*          in the response.  This way with the Type and ID fields,  */
   /*          we can quickly locate the correct attribute handle to    */
   /*          verify.  Otherwise we would need to check every attribute*/
   /*          handle for a match to know how to process the response.  */
typedef struct _tagAIOP_Client_Request_Info_t
{
   qapi_BLE_AIOS_Characteristic_Type_t Type;
   uint16_t                            ID;
   AIOP_Attribute_Handle_Type_t        AttributeHandleType;
} AIOP_Client_Request_Info_t;

   /* The following structure contains the information that needs to be */
   /* stored by an AIOS Client for each AIOS Characteristic instance    */
   /* discovered during service discovery.  This struture also stores   */
   /* the information that the AIOP Client needs to store when          */
   /* read/writing AIOS Characteristic instances.                       */
   /* * NOTE * The Properties field will simply be used to store the    */
   /*          Characteristic instance properties found during service  */
   /*          discovery.                                               */
   /* * NOTE * The Number_Of_Digitals will hold the number of digitals  */
   /*          that has been automatically read by the AIOS Client if   */
   /*          the Aggregate Characteristic is discoverd and after      */
   /*          service discovery has been peformed.  This is REQUIRED   */
   /*          since in order to decode the Aggregate Characteristic we */
   /*          MUST know how many digitals are included for each Digital*/
   /*          Characteristic that is part of the Aggregate             */
   /*          Characteristic.                                          */
   /* * NOTE * Either the Digital_Characteristic_Handle or              */
   /*          Analog_Charactersitic_Handle will be cached.  Only one   */
   /*          will be cached for this instance and can be determined by*/
   /*          the Characteristic type (Type field) of the parent       */
   /*          structure below.                                         */
   /* * NOTE * The AIOS_Number_Of_Digitals_Handle will only be cached if*/
   /*          the instance is for a Digital Characteristic.            */
typedef struct _tagAIOP_Client_Instance_Info_t
{
   boolean_t               Valid;
   uint8_t                 Properties;
   qapi_BLE_AIOS_IO_Type_t IOType;
   uint8_t                 Number_Of_Digitals;

   uint16_t                Analog_Charactersitic_Handle;
   uint16_t                Digital_Characteristic_Handle;
   uint16_t                CCCD_Handle;
   uint16_t                Presentation_Format_Handle;
   uint16_t                Number_Of_Digitals_Handle;
} AIOP_Client_Instance_Info_t;

#define AIOP_CLIENT_INSTANCE_INFO_SIZE                   (sizeof(AIOP_Client_Instance_Info_t))

   /* The following structure contains the information that needs to be */
   /* stored by an AIOS Client for a specified AIOS Characteristic type */
   /* and all of its instances that may be cached by an AIOP Client     */
   /* during service discovery.                                         */
typedef struct _tagAIOP_Client_Characteristic_Info_t
{
   qapi_BLE_AIOS_Characteristic_Type_t Type;
   AIOP_Client_Instance_Info_t         Instances[AIOP_NUMBER_OF_SUPPORTED_INSTANCES];
} AIOP_Client_Characteristic_Info_t;

#define AIOP_CLIENT_CHARACTERISTIC_INFO_SIZE             (sizeof(AIOP_Client_Characteristic_Info_t))

   /* The following structure contains the information that will need to*/
   /* be cached by a AIOS Client in order to only do service discovery  */
   /* once.  This structure also contains the information that needs to */
   /* be stored by an AIOP Client when read/writing AIOS Characteristic */
   /* instances.                                                        */
   /* ** NOTE ** This demo will only support the demo's AIOS Server.  If*/
   /*            it is used to against another AIOS Server, then        */
   /*            optional Characteristics and descriptors, the Aggregate*/
   /*            Characteristic, and more Digital and Analog            */
   /*            Characteristics instances greater than the maximum     */
   /*            supported by the demo's AIOS Server will not be cached */
   /*            by the demo's AIOS Client.  This constraint applies to */
   /*            all sub structures.                                    */
   /* * NOTE * The Characteristics field may only be valid for a Digital*/
   /*          or Analog Characteristic.                                */
   /* * NOTE * The Number_Digital_Characteristics_In_Aggregate field    */
   /*          will be used to quickly determine how many Digital       */
   /*          Characteristics are included in the Aggregate            */
   /*          Characteristic during service discovery.  We can use this*/
   /*          information to automatically issue GATT read requests    */
   /*          (after service discovery has been peformed) for the      */
   /*          Number Of Digitals descriptor for each Digital           */
   /*          Characteristic included in the Aggregate that needs to be*/
   /*          cached in order to decode the Aggregate Characteristic.  */
typedef struct _tagAIOP_Client_Information_t
{
   AIOP_Client_Characteristic_Info_t Characteristics[AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS];
   AIOP_Client_Request_Info_t        Client_Request_Info;
} AIOP_Client_Information_t;

#define AIOP_CLIENT_INFORMATION_DATA_SIZE                (sizeof(AIOP_Client_Information_t))

   /* HID over GATT (HIDS) structures.                                  */

   /* The following structure defines a key mapping.                    */
typedef struct _tagKeyMapping_t
{
   char    Ascii;
   uint8_t HID;
   uint8_t Modifiers;
} KeyMapping_t;

   /* Serial Port Profile over LE (SPPLE) structures.                   */

   /* The following structure holds status information about a send     */
   /* process.                                                          */
typedef struct _tagSend_Info_t
{
   uint32_t BytesToSend;
   uint32_t BytesSent;
} Send_Info_t;

   /* The following defines the format of a SPPLE Data Buffer.          */
typedef struct __tagSPPLE_Data_Buffer_t
{
   unsigned int  InIndex;
   unsigned int  OutIndex;
   unsigned int  BytesFree;
   unsigned int  BufferSize;
   uint8_t       Buffer[SPPLE_DATA_BUFFER_LENGTH*3];
} SPPLE_Data_Buffer_t;

   /* Generic Access Profile Service (GAPS) structures.                 */

   /* The following structure represents the information we will store  */
   /* on a Discovered GAP Service.                                      */
typedef struct _tagGAPS_Client_Info_t
{
   uint16_t DeviceNameHandle;
   uint16_t DeviceAppearanceHandle;
} GAPS_Client_Info_t;

   /* The following structure holds information on known Device         */
   /* Appearance Values.                                                */
typedef struct _tagGAPS_Device_Appearance_Mapping_t
{
   uint16_t  Appearance;
   char     *String;
} GAPS_Device_Appearance_Mapping_t;

   /* Remote Device Information structure.                              */

   /* The following bit mask values may be used for the Flags field of  */
   /* the DeviceInfo_t structure.                                       */
#define DEVICE_INFO_FLAGS_LTK_VALID                         0x01
#define DEVICE_INFO_FLAGS_SPPLE_SERVER                      0x02
#define DEVICE_INFO_FLAGS_SPPLE_CLIENT                      0x04
#define DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING     0x08
#define DEVICE_INFO_FLAGS_IRK_VALID                         0x10
#define DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST               0x20
#define DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST           0x40

   /* The following structure holds information on known HIDS reports.  */
typedef struct _tagHIDS_Report_t
{
   qapi_BLE_HIDS_Report_Reference_Data_t ReportReferenceData;
   uint16_t                              Handle;
   uint16_t                              ReportReferenceHandle;
   uint16_t                              CCCDHandle;
} HIDS_Report_t;

typedef struct _tagHIDS_External_Report_t
{
   uint16_t             ExternalReportReferenceHandle;
   qapi_BLE_GATT_UUID_t ExternalReportReference;
} HIDS_External_Report_t;

   /* The following enum represents the report names of HID Service     */
   /* reports for use in application functions.                         */
typedef enum
{
   hrtHIDSInputReport             = 1,
   hrtHIDSOutputReport            = 2,
   hrtHIDSFeatureReport           = 3,
   hrtHIDSBootKeyboardInputReport = 4,
   hrtHIDSBootKeyboardOuputReport = 5,
   hrtHIDSBootMouseInputReport    = 6
} HIDS_Report_Type_Value_t;

   /* The following structure represents the information we will store  */
   /* for a discovered HID Service.                                     */
typedef struct _tagHIDS_Client_Info_t
{
   qapi_BLE_GATT_Attribute_Handle_Group_t  ServiceHandleRange;
   uint8_t                                *ReportMap;
   unsigned int                            ReportMapLength;
   qapi_BLE_HIDS_HID_Information_Data_t    HIDSInformation;
   HIDS_Report_t                           Reports[HIDS_MAXIMUM_NUMBER_REPORTS];
   HIDS_External_Report_t                  ExternalReportReferences[HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES];
   qapi_BLE_DIS_PNP_ID_Data_t              PNP_ID_Data;
   uint16_t                                ProtocolModeHandle;
   uint16_t                                ReportMapHandle;
   uint16_t                                BootKeyboardInputReport;
   uint16_t                                BootKeyboardOutputReport;
   uint16_t                                BootMouseInputReport;
   uint16_t                                HIDSInformationHandle;
   uint16_t                                ControlPoint;
   uint16_t                                BootKeyboardInputReport_CCCD;
   uint16_t                                BootMouseInputReport_CCCD;
   qapi_BLE_HIDS_Protocol_Mode_t           ProtocolMode;
} HIDS_Client_Info_t;

   /* The following holds all the information stored for a HID Server   */
   /* role per device.                                                  */
typedef struct _tagHIDS_Server_Info_t
{
   uint16_t BootMouseInputConfiguration;
   uint16_t BootKeyboardInputConfiguration;
   uint16_t ReportKeyboardInputConfiguration;
   uint16_t ReportMouseInputConfiguration;
} HIDS_Server_Info_t;

/* The following structure is used to track the sending and receiving*/
/* of data for the throughput test.                                  */
typedef struct _tagXferInfo_t
{
   uint64_t  RxCount;
   boolean_t TimingStarted;
   uint64_t  FirstTime;
   uint64_t  LastTime;
} XferInfo_t;

   /* The following structure holds the information that needs to be    */
   /* stored for a connected remote device.                             */
   /* * NOTE * If the local device pairs with the remote device, then   */
   /*          the LTK MUST ve valid, and the remote device information */
   /*          MUST persist between connections.  If the local device   */
   /*          does NOT pair with the remote device, then the LTK will  */
   /*          NOT be valid, and the remote device information will be  */
   /*          deleted when the remote device is disconnected.          */
   /* * NOTE * The ConnectionID will be used to indicate that a remote  */
   /*          device is currently connected.  Otherwise it will be set */
   /*          to zero to indicate that the remote device is currently  */
   /*          disconnected.                                            */
   /* * NOTE * The SelectedRemoteBD_ADDR will correspond to the         */
   /*          RemoteAddress field of the remote device that is         */
   /*          currently connected.                                     */
typedef struct _tagDeviceInfo_t
{
   uint8_t                                Flags;
   unsigned int                           ConnectionID;
   boolean_t                              RemoteDeviceIsMaster;
   qapi_BLE_BD_ADDR_t                     RemoteAddress;
   qapi_BLE_GAP_LE_Address_Type_t         RemoteAddressType;
   qapi_BLE_GAP_LE_Address_Type_t         IdentityAddressType;
   qapi_BLE_BD_ADDR_t                     IdentityAddressBD_ADDR;
   uint8_t                                EncryptionKeySize;
   qapi_BLE_Long_Term_Key_t               LTK;
   qapi_BLE_Encryption_Key_t              IRK;
   qapi_BLE_Random_Number_t               Rand;
   uint16_t                               EDIV;
   qapi_BLE_GAP_LE_White_List_Entry_t     WhiteListEntry;
   qapi_BLE_GAP_LE_Resolving_List_Entry_t ResolvingListEntry;
   AIOP_Client_Information_t              AIOPClientInfo;
   uint16_t                               AIOPServerConfiguration;
   qapi_BLE_BAS_Client_Information_t      BASClientInfo[MAX_SUPPORTED_BATTERY_INSTANCES];
   qapi_BLE_BAS_Server_Information_t      BASServerInfo[MAX_SUPPORTED_BATTERY_INSTANCES];
   GAPS_Client_Info_t                     GAPSClientInfo;
   qapi_BLE_SCPS_Client_Information_t     SCPSClientInfo;
   qapi_BLE_SCPS_Server_Information_t     SCPSServerInfo;
   HIDS_Client_Info_t                     HIDSClientInfo[MAX_SUPPORTED_HID_INSTANCES];
   HIDS_Server_Info_t                     HIDSServerInfo;
   qapi_BLE_HRS_Client_Information_t      HRSClientInfo;
   SPPLE_Client_Info_t                    ClientInfo;
   SPPLE_Server_Info_t                    ServerInfo;
   unsigned int                           TransmitCredits;
   SPPLE_Data_Buffer_t                    ReceiveBuffer;
   SPPLE_Data_Buffer_t                    TransmitBuffer;
   XferInfo_t                             XferInfo;
   boolean_t                              ThroughputModeActive;
   struct _tagDeviceInfo_t               *NextDeviceInfoInfoPtr;
} DeviceInfo_t;

#define DEVICE_INFO_DATA_SIZE                            (sizeof(DeviceInfo_t))

typedef struct _tagPersistentRemoteDeviceData_t
{
   uint8_t                        Flags;
   qapi_BLE_BD_ADDR_t             LastAddress;
   qapi_BLE_GAP_LE_Address_Type_t LastAddressType;
   qapi_BLE_BD_ADDR_t             IdentityAddress;
   qapi_BLE_GAP_LE_Address_Type_t IdentityAddressType;
   uint8_t                        EncryptionKeySize;
   qapi_BLE_Long_Term_Key_t       LTK;
   qapi_BLE_Encryption_Key_t      IRK;
} PersistentRemoteDeviceData_t;

#define PERSISTENT_REMOTE_DEVICE_DATA_SIZE               (sizeof(PersistentRemoteDeviceData_t))

#define PERSISTENT_REMOTE_DEVICE_DATA_FLAG_LTK_VALID        0x01
#define PERSISTENT_REMOTE_DEVICE_DATA_FLAG_IDENTITY_VALID   0x02

typedef struct _tagPersistentData_t
{
   qapi_BLE_BD_ADDR_t LocalAddress;
   uint8_t NumberRemoteDevices;
   PersistentRemoteDeviceData_t RemoteDevices[1];
} PersistentData_t;

#define PERSISTENT_DATA_SIZE(_x)                         (QAPI_BLE_BTPS_STRUCTURE_OFFSET(PersistentData_t, RemoteDevices) + (PERSISTENT_REMOTE_DEVICE_DATA_SIZE * (_x)))

   /* Internal Variables to this Module (Remember that all variables    */
   /* declared static are initialized to 0 automatically by the         */
   /* compiler as part of standard C/C++).                              */

static QCLI_Group_Handle_t ble_group;               /* Handle for our main QCLI Command*/
                                                    /* Group.                          */

static uint32_t            BluetoothStackID;        /* Variable which holds the Handle */
                                                    /* of the opened Bluetooth Protocol*/
                                                    /* Stack.                          */

static uint32_t            ScanTimerID;             /* Scan Timer ID.                  */

static qapi_BLE_HCI_DriverInformation_t HCI_DriverInformation;
                                                    /* The HCI Driver structure that   */
                                                    /* holds the HCI Transports        */
                                                    /* settings used to initialize     */
                                                    /* Bluetopia.                      */

static unsigned int        ConnectionCount;         /* Holds the number of connected   */
                                                    /* remote devices.                 */

static DeviceInfo_t       *DeviceInfoList;          /* Holds the list head for the     */
                                                    /* remote device info list         */

typedef char               BoardStr_t[16];          /* User to represent a structure to*/
                                                    /* hold a BD_ADDR return from      */
                                                    /* BD_ADDRToStr.                   */

   /* Generic Access Profile (GAPLE) Internal Variables.                */

static GAPLE_Parameters_t  LE_Parameters;           /* Holds GAP Parameters like       */
                                                    /* Discoverability, Connectability */
                                                    /* Modes.                          */

static BLEParameters_t     BLEParameters;           /* Variable which is used to hold  */
                                                    /* the BLE Scan/Advertising/...    */
                                                    /* Connection Parameters that have */
                                                    /* been configured at the CLI.     */

static qapi_BLE_BD_ADDR_t  LocalBD_ADDR;            /* Holds the BD_ADDR of the        */
                                                    /* local device.                   */

static qapi_BLE_BD_ADDR_t  SelectedRemoteBD_ADDR;   /* Holds the BD_ADDR of the        */
                                                    /* connected remote device that is */
                                                    /* currently selected.             */

static qapi_BLE_BD_ADDR_t  SecurityRemoteBD_ADDR;   /* Variable which holds the        */
                                                    /* current BD_ADDR of the device   */
                                                    /* which is currently pairing or   */
                                                    /* authenticating.                 */

static qapi_BLE_Encryption_Key_t ER = {0x28, 0xBA, 0xE1, 0x37, 0x13, 0xB2, 0x20, 0x45, 0x16, 0xB2, 0x19, 0xD0, 0x80, 0xEE, 0x4A, 0x51};
                                                    /* The Encryption Root Key should  */
                                                    /* be generated in such a way as   */
                                                    /* to guarantee 128 bits of        */
                                                    /* entropy.                        */

static qapi_BLE_Encryption_Key_t IR = {0x41, 0x09, 0xA0, 0x88, 0x09, 0x6B, 0x70, 0xC0, 0x95, 0x23, 0x3C, 0x8C, 0x48, 0xFC, 0xC9, 0xFE};
                                                    /* The Identity Root Key should    */
                                                    /* be generated in such a way as   */
                                                    /* to guarantee 128 bits of        */
                                                    /* entropy.                        */

static qapi_BLE_Encryption_Key_t DHK;               /* The DHK key can be              */
                                                    /* regenerated on the fly using the*/
                                                    /* constant IR and ER keys and     */
                                                    /* are used globally, for all      */
                                                    /* devices.                        */

static qapi_BLE_Encryption_Key_t IRK;               /* The IRK key can be              */
                                                    /* regenerated on the fly using the*/
                                                    /* constant IR and ER keys and     */
                                                    /* are used globally, for all      */
                                                    /* devices.                        */

static boolean_t           ScanInProgress;          /* A boolean flag to show if a scan*/
                                                    /* is in process                   */

static boolean_t           LocalDeviceIsMaster;     /* Variable which indicates if the */
                                                    /* local device is the master      */
                                                    /* of the connection.              */

static qapi_BLE_GAP_LE_Address_Type_t  RemoteAddressType;
                                                    /* Variable which holds the remote */
                                                    /* address type for a connected    */
                                                    /* remote device until it can be   */
                                                    /* stored in the remote device     */
                                                    /* information.                    */

static qapi_Persist_Handle_t PersistHandle;         /* Variable which holds the handle */
                                                    /* to a persistent storage         */
                                                    /* instance.                       */

static boolean_t                                  LocalOOBValid; /* Variable which     */
                                                    /* holds if we have received OOB   */
                                                    /* from Local device.              */

static qapi_BLE_Secure_Connections_Randomizer_t   LocalOOBRandomizer; /* Variable      */
                                                    /* which holds Local OOB           */
                                                    /* Randomizer.                     */

static qapi_BLE_Secure_Connections_Confirmation_t LocalOOBConfirmation; /* Variable    */
                                                    /* which holds Local OOB           */
                                                    /* Confirmation.                   */

static boolean_t                                  RemoteOOBValid; /* Variable which    */
                                                    /* holds if we have received OOB   */
                                                    /* from remote device.             */

static qapi_BLE_Secure_Connections_Randomizer_t   RemoteOOBRandomizer; /* Variable     */
                                                    /* which holds remote OOB          */
                                                    /* Randomizer.                     */

static qapi_BLE_Secure_Connections_Confirmation_t RemoteOOBConfirmation; /* Variable   */
                                                    /* which holds remote OOB          */
                                                    /* Confirmation.                   */

   /* BT5 Internal Variables.                                           */
#ifdef V2

   static QCLI_Group_Handle_t bt5_group;            /* Handle for our HCI Command      */
                                                    /* Group.                          */

#endif

   /* Automation IO Service (AIOS) Internal Variables.                  */

static QCLI_Group_Handle_t aios_group;              /* Handle for our AIOS Command     */
                                                    /* Group.                          */

static uint32_t            AIOSInstanceID;          /* The following holds the AIOS    */
                                                    /* Instance ID that is returned    */
                                                    /* from                            */
                                                    /* qapi_BLE_GATT_Register_Service()*/

static AIOP_Server_Information_t  AIOSServerInfo;   /* Variable which holds the        */
                                                    /* information that needs to be    */
                                                    /* stored by the AIOS Server.      */

   /* Battery Alert Service (BAS) Internal Variables.                   */

static QCLI_Group_Handle_t bas_group;               /* Handle for our BAS Command      */
                                                    /* Group.                          */

static uint32_t            BASInstanceID[MAX_SUPPORTED_BATTERY_INSTANCES];
                                                    /* The following holds the BAS     */
                                                    /* Instance IDs that are returned  */
                                                    /* from BAS_Initialize_Service().  */

static unsigned int        BASInstanceIDIndex;      /* Index used to navigate          */
                                                    /* BASInstanceID[] array while     */
                                                    /* Populating BAS Handles          */

static uint8_t             BatteryLevel[MAX_SUPPORTED_BATTERY_INSTANCES];
                                                    /* Variable which is used to hold  */
                                                    /* the Battery Level of all        */
                                                    /* instances a Device.             */

   /* Device Information Service (DIS) Internal Variables.              */

static uint32_t            DISInstanceID;           /* Holds the Instance ID for the   */
                                                    /* DIS Service.                    */

   /* Generic Access Profile Service (GAPS) Internal Variables.         */

static QCLI_Group_Handle_t gaps_group;              /* Handle for our GAPS Command     */
                                                    /* Group.                          */

static uint32_t            GAPSInstanceID;          /* Holds the Instance ID for the   */
                                                    /* GAP Service.                    */

   /* HID over GATT (HOGP) Internal Variables.                          */

static unsigned int        HIDSInstanceID;          /* The following holds the HIDS    */
                                                    /* Instance ID that is returned    */
                                                    /* from HIDS_Initialize_Service(). */

static QCLI_Group_Handle_t hids_group;              /* Handle for our HIDS Command     */
                                                    /* Group.                          */

static unsigned int        HIDSInstanceIDIndex;     /* Index used to navigate          */
                                                    /* HIDSInstanceID[] array while    */
                                                    /* Populating HID Handles          */

static qapi_BLE_UUID_128_t NULL_UUID_128;           /* Holds a NULL UUID 128 for       */
                                                    /* comparison.                     */

static uint8_t             MouseInputReport[HID_MOUSE_INPUT_REPORT_SIZE]; /* Holds the*/
                                                   /* current HID mouse input report. */

static unsigned int        MouseInputReportSize = HID_MOUSE_INPUT_REPORT_SIZE;
                                                   /* Holds the current HID mouse     */
                                                   /* input report size.              */

static uint8_t             KeyboardInputReport[HID_KEYBOARD_INPUT_REPORT_SIZE];
                                                   /* Holds the current HID keyboard  */
                                                   /* input report.                   */

static unsigned int        KeyboardInputReportSize = HID_KEYBOARD_INPUT_REPORT_SIZE;
                                                   /* Holds the current HID keyboard  */
                                                   /* input report size.              */

static uint8_t             KeyboardOutputReport[HID_KEYBOARD_OUTPUT_REPORT_SIZE];
                                                   /* Holds the current HID keyboard  */
                                                   /* output report.                  */

static unsigned int        KeyboardOutputReportSize = HID_KEYBOARD_OUTPUT_REPORT_SIZE;
                                                   /* Holds the current HID keyboard  */
                                                   /* output report size.             */

static qapi_BLE_HIDS_Protocol_Mode_t HIDS_Protocol_Mode;
                                                   /* Holds the current mode of the   */
                                                   /* HID connection (Boot vs Report).*/

   /* The following table represent the Keyboard Report Descriptor for  */
   /* this HID Keyboard Device.                                         */
static uint8_t KeyboardReportDescriptor[] =
{
    0x05, 0x01,  /* USAGE_PAGE (Generic Desktop)                        */
    0x09, 0x06,  /* USAGE (Keyboard)                                    */
    0xa1, 0x01,  /* COLLECTION (Application)                            */
    0x85, 0x01,  /* REPORT_ID (1)                                       */
    0x05, 0x07,  /* USAGE_PAGE (Keyboard)                               */
    0x19, 0xe0,  /* USAGE_MINIMUM (Keyboard LeftControl)                */
    0x29, 0xe7,  /* USAGE_MAXIMUM (Keyboard Right GUI)                  */
    0x15, 0x00,  /* LOGICAL_MINIMUM (0)                                 */
    0x25, 0x01,  /* LOGICAL_MAXIMUM (1)                                 */
    0x75, 0x01,  /* REPORT_SIZE (1)                                     */
    0x95, 0x08,  /* REPORT_COUNT (8)                                    */
    0x81, 0x02,  /* INPUT (Data,Var,Abs)                                */
    0x95, 0x01,  /* REPORT_COUNT (1)                                    */
    0x75, 0x08,  /* REPORT_SIZE (8)                                     */
    0x81, 0x03,  /* INPUT (Cnst,Var,Abs)                                */
    0x95, 0x05,  /* REPORT_COUNT (5)                                    */
    0x75, 0x01,  /* REPORT_SIZE (1)                                     */
    0x05, 0x08,  /* USAGE_PAGE (LEDs)                                   */
    0x19, 0x01,  /* USAGE_MINIMUM (Num Lock)                            */
    0x29, 0x05,  /* USAGE_MAXIMUM (Kana)                                */
    0x91, 0x02,  /* OUTPUT (Data,Var,Abs)                               */
    0x95, 0x01,  /* REPORT_COUNT (1)                                    */
    0x75, 0x03,  /* REPORT_SIZE (3)                                     */
    0x91, 0x03,  /* OUTPUT (Cnst,Var,Abs)                               */
    0x95, 0x06,  /* REPORT_COUNT (6)                                    */
    0x75, 0x08,  /* REPORT_SIZE (8)                                     */
    0x15, 0x00,  /* LOGICAL_MINIMUM (0)                                 */
    0x25, 0x65,  /* LOGICAL_MAXIMUM (101)                               */
    0x05, 0x07,  /* USAGE_PAGE (Keyboard)                               */
    0x19, 0x00,  /* USAGE_MINIMUM (Reserved (no event indicated))       */
    0x29, 0x65,  /* USAGE_MAXIMUM (Keyboard Application)                */
    0x81, 0x00,  /* INPUT (Data,Ary,Abs)                                */
    0xc0         /* END_COLLECTION                                      */
};

   /* The following table maps printable ASCII characters (starting with*/
   /* ' ' [0x20]) to a HID Usage Code and applicable modifiers. To do a */
   /* lookup, make sure the character falls between 0x20 and 0x7E, then */
   /* do KeyTable[c - ' '].                                             */
static KeyMapping_t KeyTable[] =
{
   { ' ',  0x2C, 0x00 },
   { '!',  0x1E, 0x02 },
   { '"',  0x34, 0x02 },
   { '#',  0x20, 0x02 },
   { '$',  0x21, 0x02 },
   { '%',  0x22, 0x02 },
   { '&',  0x24, 0x02 },
   { '\'', 0x34, 0x00 },
   { '(',  0x26, 0x02 },
   { ')',  0x27, 0x02 },
   { '*',  0x25, 0x02 },
   { '+',  0x2E, 0x02 },
   { ',',  0x36, 0x00 },
   { '-',  0x2D, 0x00 },
   { '.',  0x37, 0x00 },
   { '/',  0x38, 0x00 },
   { '0',  0x27, 0x00 },
   { '1',  0x1E, 0x00 },
   { '2',  0x1F, 0x00 },
   { '3',  0x20, 0x00 },
   { '4',  0x21, 0x00 },
   { '5',  0x22, 0x00 },
   { '6',  0x23, 0x00 },
   { '7',  0x24, 0x00 },
   { '8',  0x25, 0x00 },
   { '9',  0x26, 0x00 },
   { ':',  0x33, 0x02 },
   { ';',  0x33, 0x00 },
   { '<',  0x36, 0x02 },
   { '=',  0x2E, 0x00 },
   { '>',  0x37, 0x02 },
   { '?',  0x38, 0x02 },
   { '@',  0x1F, 0x02 },
   { 'A',  0x04, 0x02 },
   { 'B',  0x05, 0x02 },
   { 'C',  0x06, 0x02 },
   { 'D',  0x07, 0x02 },
   { 'E',  0x08, 0x02 },
   { 'F',  0x09, 0x02 },
   { 'G',  0x0A, 0x02 },
   { 'H',  0x0B, 0x02 },
   { 'I',  0x0C, 0x02 },
   { 'J',  0x0D, 0x02 },
   { 'K',  0x0E, 0x02 },
   { 'L',  0x0F, 0x02 },
   { 'M',  0x10, 0x02 },
   { 'N',  0x11, 0x02 },
   { 'O',  0x12, 0x02 },
   { 'P',  0x13, 0x02 },
   { 'Q',  0x14, 0x02 },
   { 'R',  0x15, 0x02 },
   { 'S',  0x16, 0x02 },
   { 'T',  0x17, 0x02 },
   { 'U',  0x18, 0x02 },
   { 'V',  0x19, 0x02 },
   { 'W',  0x1A, 0x02 },
   { 'X',  0x1B, 0x02 },
   { 'Y',  0x1C, 0x02 },
   { 'Z',  0x1D, 0x02 },
   { '[',  0x2F, 0x00 },
   { '\\', 0x31, 0x00 },
   { ']',  0x30, 0x00 },
   { '^',  0x23, 0x02 },
   { '_',  0x2D, 0x02 },
   { '`',  0x35, 0x00 },
   { 'a',  0x04, 0x00 },
   { 'b',  0x05, 0x00 },
   { 'c',  0x06, 0x00 },
   { 'd',  0x07, 0x00 },
   { 'e',  0x08, 0x00 },
   { 'f',  0x09, 0x00 },
   { 'g',  0x0A, 0x00 },
   { 'h',  0x0B, 0x00 },
   { 'i',  0x0C, 0x00 },
   { 'j',  0x0D, 0x00 },
   { 'k',  0x0E, 0x00 },
   { 'l',  0x0F, 0x00 },
   { 'm',  0x10, 0x00 },
   { 'n',  0x11, 0x00 },
   { 'o',  0x12, 0x00 },
   { 'p',  0x13, 0x00 },
   { 'q',  0x14, 0x00 },
   { 'r',  0x15, 0x00 },
   { 's',  0x16, 0x00 },
   { 't',  0x17, 0x00 },
   { 'u',  0x18, 0x00 },
   { 'v',  0x19, 0x00 },
   { 'w',  0x1A, 0x00 },
   { 'x',  0x1B, 0x00 },
   { 'y',  0x1C, 0x00 },
   { 'z',  0x1D, 0x00 },
   { '{',  0x2F, 0x02 },
   { '|',  0x31, 0x02 },
   { '}',  0x30, 0x02 },
   { '~',  0x35, 0x02 }
};

   /* Heart Rate Service (HRS) Internal Variables.                      */

static QCLI_Group_Handle_t hrs_group;               /* Handle for our HRS Command      */
                                                    /* Group.                          */
   /* Over the Air Service Internal Variables.                          */

static QCLI_Group_Handle_t ota_group;               /* Handle for our OTA Command      */
                                                    /* Group.                          */

static uint32_t            OTAInstanceID;           /* The following holds the OTA     */
                                                    /* Instance ID.                    */

static boolean_t           OTAClientInitialized;    /* Indicates if an OTA client has  */
                                                    /* been initialized.               */

typedef struct BLE_OTA_Demo_Image_Info_s
{
   int   ImageFd;            /* File descriptor for the image file. */
   char *FilePath;           /* File path for the image file. */
} BLE_OTA_Demo_Image_Info_t;

   /* Default server image data. */
static BLE_OTA_Server_Image_Data_t DefaultOTAServerImageData[] =
{  /* FileName                    Version ImageLength ImageID */
   {"ImgConfig.bin",              2,      0,          0},
   {"Quartz_HASHED.elf",          2,      0,          0},
   {"ioe_ram_m0_threadx_ipt.mbn", 2,      0,          0}
};

   /* Default image info. */
static BLE_OTA_Demo_Image_Info_t DefaultOTAImageInfo[] =
{
   /* FD FilePath */
   {  0, "/spinor/ImgConfig.bin"},
   {  0, "/spinor/Quartz_HASHED.elf"},
   {  0, "/spinor/ioe_ram_m0_threadx_ipt.mbn"}
};

#define BLE_OTA_DEMO_MAX_MANUAL_IMAGES              (5)

   /* Structure to hold information for images manually registered outside the defaults. */
static BLE_OTA_Server_Image_Data_t ManualOTAServerImageData[BLE_OTA_DEMO_MAX_MANUAL_IMAGES];
static BLE_OTA_Demo_Image_Info_t   ManualOTAImageInfo[BLE_OTA_DEMO_MAX_MANUAL_IMAGES];

static boolean_t           UseOTADefaultImages;

   /* Scan Parameter Service (SCPS) Internal Variables.                 */

static QCLI_Group_Handle_t scps_group;              /* Handle for our SCSP Command     */
                                                    /* Group.                          */

static uint32_t            SCPSInstanceID;          /* The following holds the SCPS    */
                                                    /* Instance ID.                    */


   /* Serial Port Profile over LE (SPPLE) Internal Variables.           */

static QCLI_Group_Handle_t spple_group;             /* Handle for our SPPLE Command    */
                                                    /* Group.                          */

static QCLI_Group_Handle_t ble_fpga_group;          /* Handle for our FPGA Command     */
                                                    /* Group.                          */

static uint32_t            SPPLEServiceID;          /* The following holds the SPP LE  */
                                                    /* Service ID that is returned from*/
                                                    /* qapi_BLE_GATT_Register_Service()*/

static uint8_t             SPPLEBuffer[SPPLE_DATA_BUFFER_LENGTH+1];  /* Buffer that is */
                                                    /* used for Sending/Receiving      */
                                                    /* SPPLE Service Data.             */

static Send_Info_t         SendInfo;                /* Variable that contains          */
                                                    /* information about a data        */
                                                    /* transfer process.               */

static boolean_t           LoopbackActive;          /* Variable which flags whether or */
                                                    /* not the application is currently*/
                                                    /* operating in Loopback Mode      */
                                                    /* (TRUE) or not (FALSE).          */

static boolean_t           DisplayRawData;          /* Variable which flags whether or */
                                                    /* not the application is to       */
                                                    /* simply display the Raw Data     */
                                                    /* when it is received (when not   */
                                                    /* operating in Loopback Mode).    */

static boolean_t           AutomaticReadActive;     /* Variable which flags whether or */
                                                    /* not the application is to       */
                                                    /* automatically read all data     */
                                                    /* as it is received.              */

static boolean_t           DisplayAdvertisingEventData; /* Flag to indicate if we      */
                                                    /* should have verbose adv report  */
                                                    /* outputs.                        */

   /* 6LoWPAN (SLoWP) Internal Variables.                               */

static QCLI_Group_Handle_t slowp_group;             /* Handle for our SLoWP Command    */
                                                    /* Group.                          */

static qapi_BLE_BD_ADDR_t  SLoWPRouterAddress;      /* Holds address of currently      */
                                                    /* connected router.               */

static boolean_t           SLoWPInitialized;        /* Variable which holds if SLoWP is*/
                                                    /* initialized.                    */

static boolean_t           SLoWPNodeInitialized;    /* Variable which holds if SLoWP   */
                                                    /* Node role is initialized.       */

static boolean_t           SLoWPConnected;          /* Variable which holds if SLoWP is*/
                                                    /* connected to remote Router.     */

   /* Transport Power Service (TPS) Internal Variables.                 */

static uint32_t            TPSInstanceID;           /* Holds the Instance ID for the   */
                                                    /* TPS Service.                    */

   /* The following is used to map from ATT Error Codes to a printable  */
   /* string.                                                           */
static char *ErrorCodeStr[] =
{
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_NO_ERROR",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_HANDLE",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_READ_NOT_PERMITTED",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_WRITE_NOT_PERMITTED",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_PDU",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_AUTHENTICATION",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_REQUEST_NOT_SUPPORTED",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_OFFSET",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_AUTHORIZATION",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_PREPARE_QUEUE_FULL",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_ATTRIBUTE_NOT_FOUND",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_ATTRIBUTE_NOT_LONG",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION_KEY_SIZE",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_ATTRIBUTE_VALUE_LENGTH",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNSUPPORTED_GROUP_TYPE",
   "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_RESOURCES"
} ;

#define NUMBER_OF_ERROR_CODES     (sizeof(ErrorCodeStr)/sizeof(char *))

   /* The following array is used to map Device Appearance Values to    */
   /* strings.                                                          */
static GAPS_Device_Appearance_Mapping_t AppearanceMappings[] =
{
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_UNKNOWN,                        "Unknown"                   },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_PHONE,                  "Generic Phone"             },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_COMPUTER,               "Generic Computer"          },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_WATCH,                  "Generic Watch"             },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_SPORTS_WATCH,                   "Sports Watch"              },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_CLOCK,                  "Generic Clock"             },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_DISPLAY,                "Generic Display"           },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_GENERIC_REMOTE_CONTROL, "Generic Remote Control"    },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_EYE_GLASSES,            "Eye Glasses"               },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_TAG,                    "Generic Tag"               },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_KEYRING,                "Generic Keyring"           },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_MEDIA_PLAYER,           "Generic Media Player"      },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_BARCODE_SCANNER,        "Generic Barcode Scanner"   },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_THERMOMETER,            "Generic Thermometer"       },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_THERMOMETER_EAR,                "Ear Thermometer"           },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_HEART_RATE_SENSOR,      "Generic Heart Rate Sensor" },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_BELT_HEART_RATE_SENSOR,         "Belt Heart Rate Sensor"    },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_BLOOD_PRESSURE,         "Generic Blood Pressure"    },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_BLOOD_PRESSURE_ARM,             "Blood Pressure: ARM"       },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_BLOOD_PRESSURE_WRIST,           "Blood Pressure: Wrist"     },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HUMAN_INTERFACE_DEVICE,         "Human Interface Device"    },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_KEYBOARD,                   "HID Keyboard"              },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_MOUSE,                      "HID Mouse"                 },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_JOYSTICK,                   "HID Joystick"              },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_GAMEPAD,                    "HID Gamepad"               },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_DIGITIZER_TABLET,           "HID Digitizer Tablet"      },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_CARD_READER,                "HID Card Reader"           },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_DIGITAL_PEN,                "HID Digitizer Pen"         },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_BARCODE_SCANNER,            "HID Bardcode Scanner"      },
   { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_GLUCOSE_METER,          "Generic Glucose Meter"     }
} ;

#define NUMBER_OF_APPEARANCE_MAPPINGS     (sizeof(AppearanceMappings)/sizeof(GAPS_Device_Appearance_Mapping_t))

   /* The following string table is used to map HCI Version information */
   /* to an easily displayable version string.                          */
static const char *HCIVersionStrings[] =
{
   "1.0b",
   "1.1",
   "1.2",
   "2.0",
   "2.1",
   "3.0",
   "4.0",
   "4.1",
   "4.2",
   "5.0",
   "Unknown (greater 5.0)"
} ;

#define NUM_SUPPORTED_HCI_VERSIONS              (sizeof(HCIVersionStrings)/sizeof(char *) - 1)

   /* The following string table is used to map the API I/O Capabilities*/
   /* values to an easily displayable string.                           */
static const char *IOCapabilitiesStrings[] =
{
   "Display Only",
   "Display Yes/No",
   "Keyboard Only",
   "No Input/Output",
   "Keyboard/Display"
} ;

   /* Internal Variables to this Module (Remember that all variables    */
   /* declared static are initialized to 0 automatically by the         */
   /* compiler as part of standard C/C++).                              */
#define CURRENT_TEST_NONE                       0
#define CURRENT_TEST_TX_ACL                     1
#define CURRENT_TEST_RX_ACL                     3
#define CURRENT_TEST_PERIODIC                   4

#define MAXIMUM_TEST_BUFFER                  1024

static unsigned int        CurrentTest = CURRENT_TEST_NONE;
static unsigned int        NumberACLPackets;
static unsigned int        NumberOutstandingACLPackets;
static unsigned int        MaxACLPacketSize;
static unsigned long       StartTime;
static unsigned long       EndTime;
static unsigned long       NumberBytes;
static unsigned long       PacketLength;
static unsigned char       TestBuffer[MAXIMUM_TEST_BUFFER];
static uint16_t            ConnectionHandle;
static uint32_t            TransmitPeriod;
static qapi_TIMER_handle_t PeriodicSendTimer;

   /* The following defines a data sequence that will be used to        */
   /* generate message data.                                            */
static char  DataStr[]  = "~!@#$%^&*()_+`1234567890-=:;\"'<>?,./@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]`abcdefghijklmnopqrstuvwxyz{|}<>\n";
static int   DataStrLen = (sizeof(DataStr)-1);

   /*********************************************************************/
   /**                     SPPLE Service Table                         **/
   /*********************************************************************/

   /* The SPPLE Service Declaration UUID.                               */
static const qapi_BLE_GATT_Primary_Service_128_Entry_t SPPLE_Service_UUID =
{
   SPPLE_SERVICE_UUID_CONSTANT
} ;

   /* The Tx Characteristic Declaration.                                */
static const qapi_BLE_GATT_Characteristic_Declaration_128_Entry_t SPPLE_Tx_Declaration =
{
   QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_NOTIFY,
   SPPLE_TX_CHARACTERISTIC_UUID_CONSTANT
} ;

   /* The Tx Characteristic Value.                                      */
static const qapi_BLE_GATT_Characteristic_Value_128_Entry_t  SPPLE_Tx_Value =
{
   SPPLE_TX_CHARACTERISTIC_UUID_CONSTANT,
   0,
   NULL
} ;

   /* The Tx Credits Characteristic Declaration.                        */
static const qapi_BLE_GATT_Characteristic_Declaration_128_Entry_t SPPLE_Tx_Credits_Declaration =
{
   (QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ|QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE_WITHOUT_RESPONSE|QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE),
   SPPLE_TX_CREDITS_CHARACTERISTIC_UUID_CONSTANT
} ;

   /* The Tx Credits Characteristic Value.                              */
static const qapi_BLE_GATT_Characteristic_Value_128_Entry_t SPPLE_Tx_Credits_Value =
{
   SPPLE_TX_CREDITS_CHARACTERISTIC_UUID_CONSTANT,
   0,
   NULL
} ;

   /* The SPPLE RX Characteristic Declaration.                          */
static const qapi_BLE_GATT_Characteristic_Declaration_128_Entry_t SPPLE_Rx_Declaration =
{
   (QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE_WITHOUT_RESPONSE),
   SPPLE_RX_CHARACTERISTIC_UUID_CONSTANT
} ;

   /* The SPPLE RX Characteristic Value.                                */
static const qapi_BLE_GATT_Characteristic_Value_128_Entry_t  SPPLE_Rx_Value =
{
   SPPLE_RX_CHARACTERISTIC_UUID_CONSTANT,
   0,
   NULL
} ;

   /* The SPPLE Rx Credits Characteristic Declaration.                  */
static const qapi_BLE_GATT_Characteristic_Declaration_128_Entry_t SPPLE_Rx_Credits_Declaration =
{
   (QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ|QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_NOTIFY),
   SPPLE_RX_CREDITS_CHARACTERISTIC_UUID_CONSTANT
};

   /* The SPPLE Rx Credits Characteristic Value.                        */
static const qapi_BLE_GATT_Characteristic_Value_128_Entry_t SPPLE_Rx_Credits_Value =
{
   SPPLE_RX_CREDITS_CHARACTERISTIC_UUID_CONSTANT,
   0,
   NULL
};

   /* Client Characteristic Configuration Descriptor.                   */
static qapi_BLE_GATT_Characteristic_Descriptor_16_Entry_t Client_Characteristic_Configuration =
{
   QAPI_BLE_GATT_CLIENT_CHARACTERISTIC_CONFIGURATION_BLUETOOTH_UUID_CONSTANT,
   QAPI_BLE_GATT_CLIENT_CHARACTERISTIC_CONFIGURATION_LENGTH,
   NULL
};

   /* The following defines the SPPLE service that is registered with   */
   /* the GATT_Register_Service function call.                          */
   /* * NOTE * This array will be registered with GATT in the call to   */
   /*          GATT_Register_Service.                                   */
const qapi_BLE_GATT_Service_Attribute_Entry_t SPPLE_Service[] =
{
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_PRIMARY_SERVICE_128_E,            (uint8_t *)&SPPLE_Service_UUID                  },
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_DECLARATION_128_E, (uint8_t *)&SPPLE_Tx_Declaration                },
   { 0,                                               QAPI_BLE_AET_CHARACTERISTIC_VALUE_128_E,       (uint8_t *)&SPPLE_Tx_Value                      },
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE_WRITABLE, QAPI_BLE_AET_CHARACTERISTIC_DESCRIPTOR_16_E,   (uint8_t *)&Client_Characteristic_Configuration },
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_DECLARATION_128_E, (uint8_t *)&SPPLE_Tx_Credits_Declaration        },
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE_WRITABLE, QAPI_BLE_AET_CHARACTERISTIC_VALUE_128_E,       (uint8_t *)&SPPLE_Tx_Credits_Value              },
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_DECLARATION_128_E, (uint8_t *)&SPPLE_Rx_Declaration                },
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_WRITABLE,          QAPI_BLE_AET_CHARACTERISTIC_VALUE_128_E,       (uint8_t *)&SPPLE_Rx_Value                      },
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_DECLARATION_128_E, (uint8_t *)&SPPLE_Rx_Credits_Declaration        },
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_VALUE_128_E,       (uint8_t *)&SPPLE_Rx_Credits_Value              },
   { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE_WRITABLE, QAPI_BLE_AET_CHARACTERISTIC_DESCRIPTOR_16_E,   (uint8_t *)&Client_Characteristic_Configuration }
} ;

#define SPPLE_SERVICE_ATTRIBUTE_COUNT               (sizeof(SPPLE_Service)/sizeof(qapi_BLE_GATT_Service_Attribute_Entry_t))

#define SPPLE_TX_CHARACTERISTIC_ATTRIBUTE_OFFSET               2
#define SPPLE_TX_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET           3
#define SPPLE_TX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET       5
#define SPPLE_RX_CHARACTERISTIC_ATTRIBUTE_OFFSET               7
#define SPPLE_RX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET       9
#define SPPLE_RX_CREDITS_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET   10

   /*********************************************************************/
   /**                    END OF SERVICE TABLE                         **/
   /*********************************************************************/

   /* External function prototypes.                                     */
extern int HCI_VS_GetPatchVersion(unsigned int BluetoothStackID, uint32_t *ProductID, uint32_t *BuildVersion);
extern int HCI_VS_EnableBBIF(unsigned int BluetoothStackID, boolean_t Enable);
extern int HCI_VS_SetRadio(unsigned int BluetoothStackID, unsigned int RadioNumber);

   /* Demo QCLI command functions.                                      */
static QCLI_Command_Status_t InitializeBluetooth(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ShutdownBluetooth(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetVersion(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetBLERadio(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* Demo helper functions.                                            */
static DeviceInfo_t *CreateNewDeviceInfoEntry(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress);
static DeviceInfo_t *SearchDeviceInfoEntryByBD_ADDR(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress);
static DeviceInfo_t *SearchDeviceInfoEntryTypeAddress(DeviceInfo_t **ListHead, qapi_BLE_GAP_LE_Address_Type_t AddressType, qapi_BLE_BD_ADDR_t RemoteAddress);
static DeviceInfo_t *SearchDeviceInfoEntryByConnectionID(DeviceInfo_t **ListHead, unsigned int ConnectionID);
static DeviceInfo_t *DeleteDeviceInfoEntry(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress);
static void FreeDeviceInfoEntryMemory(DeviceInfo_t *EntryToFree);
static void FreeDeviceInfoList(DeviceInfo_t **ListHead);

static void BD_ADDRToStr(qapi_BLE_BD_ADDR_t Board_Address, BoardStr_t BoardStr);
static unsigned int StringToUnsignedInteger(char *StringInteger);

static int OpenStack(qapi_BLE_HCI_DriverInformation_t *HCI_DriverInformation);
static int CloseStack(void);

static int RegisterForHCIEvents(void);
static int RegisterForACLData(void);

static void GenerateData2Send(unsigned int Length, uint8_t *Data);
static void Period_Tx_Callback(uint32_t data);
static int  SendACLData(unsigned int Length, unsigned char *Data);

static void EventCallback(uint32_t BluetoothStackID, qapi_BLE_HCI_Event_Data_t *HCI_Event_Data, uint32_t CallbackParameter);
static void ACLDataCallback(uint32_t BluetoothStackID, uint16_t Connection_Handle, uint16_t Flags, uint16_t ACLDataLength, uint8_t *ACLData, uint32_t CallbackParameter);

static QCLI_Command_Status_t StartTXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t StartRXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t StopTXRXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* Generic Access Profile (GAPLE) QCLI command functions.            */
static QCLI_Command_Status_t SetDiscoverabilityMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetConnectabilityMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetPairabilityMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ChangePairingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t LEPassKeyResponse(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t LEQueryEncryption(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t LESetPasskey(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetLocalAddress(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t AdvertiseLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ScanLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConnectLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t DisconnectLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t CancelConnectLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t PairLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t UnPairRemoteDevice(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SelectRemoteDevice(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t DisplayRemoteDevices(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t AddDeviceToWhiteList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t RemoveDeviceFromWhiteList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t AddDeviceToResolvingList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t RemoveDeviceFromResolvingList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetAuthenticatedPayloadTimeout(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetScanParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetScanParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetAdvertisingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetAdvertisingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetConnectionParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetConnectionParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetTestDataPeriod(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetDataLength(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t StorePersistentData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t LoadPersistentData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t DeletePersistentData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureAdvReportDisplay(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t QueryLocalOOBData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetRemoteOOOBData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

#ifndef V1
   static QCLI_Command_Status_t LowPowerTransmitOverride(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
#endif

   /* Generic Access Profile (GAPLE) helper functions.                  */
static int SetDisc(void);
static int SetConnect(void);
static int SetPairable(void);
static int StartScan(uint32_t BluetoothStackID, qapi_BLE_GAP_LE_Filter_Policy_t FilterPolicy, unsigned int ScanDuration);
static int StopScan(uint32_t BluetoothStackID);
static int ConnectLEDevice(uint32_t BluetoothStackID, boolean_t UseWhiteList, qapi_BLE_BD_ADDR_t *BD_ADDR, qapi_BLE_GAP_LE_Address_Type_t AddressType);
static void ConfigureCapabilities(qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t *Capabilities);
static int SendPairingRequest(qapi_BLE_BD_ADDR_t BD_ADDR, boolean_t ConnectionMaster);
static int SlavePairingRequestResponse(qapi_BLE_BD_ADDR_t BD_ADDR);
static int EncryptionInformationRequestResponse(qapi_BLE_BD_ADDR_t BD_ADDR, uint8_t KeySize, qapi_BLE_GAP_LE_Authentication_Response_Information_t *GAP_LE_Authentication_Response_Information);
static void DisplayIOCapabilities(void);

static void DisplayLegacyPairingInformation(qapi_BLE_GAP_LE_Pairing_Capabilities_t *Pairing_Capabilities);
static void DisplayPairingInformation(qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t *Pairing_Capabilities);
static void DisplayUUID(qapi_BLE_GATT_UUID_t *UUID);
static void DisplayFunctionError(char *Function, int Status);
static void GenerateRandomKeys(void);

   /* v2 QCLI command functions.                                        */
#ifdef V2
   char *PHYToString(qapi_BLE_GAP_LE_PHY_Type_t PHY);
   static QCLI_Command_Status_t ReadPHY(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
   static QCLI_Command_Status_t SetPHY(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
   static QCLI_Command_Status_t SetExtendedAdvertisingParams(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
   static QCLI_Command_Status_t EnableExtendedAdvertising(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
   static QCLI_Command_Status_t SetExtendedScanParams(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
   static QCLI_Command_Status_t EnableExtendedScan(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
   static QCLI_Command_Status_t ExtendedConnect(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
#endif

   /* Generic Attribute Profile (GATT) QCLI command functions.          */
static QCLI_Command_Status_t DiscoverServices(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetGATTMTU(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetGATTMTU(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* Generic Attribute Profile (GATT) helper functions.                */
static int EnableDisableNotificationsIndications(uint16_t ClientConfigurationHandle, uint16_t ClientConfigurationValue, unsigned int ConnectionID, qapi_BLE_GATT_Client_Event_Callback_t ClientEventCallback);

   /* Automation IO Service (AIOS) QCLI command functions.              */
static QCLI_Command_Status_t RegisterAIOS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t UnregisterAIOS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureRemoteAIOS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadAIOSCharacteristic(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t WriteAIOSDigitalOutput(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t WriteAIOSAnalogOutput(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadAIOSPresentationFormat(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadAIOSNumberOfDigitals(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetAIOSDigitalInput(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetAIOSAnalogInput(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t NotifyAIOSCharacteristic(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* Automation IO Service (AIOS) helper functions.                    */
static void ConfigureAIOSServer(void);
static AIOP_Server_Instance_Data_t *GetAIOSServerInstanceInfoPtr(qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo);
static AIOP_Client_Instance_Info_t *GetAIOSClientInstanceInfoPtr(AIOP_Client_Information_t *ClientInfo);
static void AIOSPopulateHandles(AIOP_Client_Information_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);
static void StoreDescriptorHandles(AIOP_Client_Instance_Info_t *InstanceInfoPtr, qapi_BLE_GATT_Characteristic_Information_t *CharacteristicInfoPtr);
static void DisplayAIOSCharacteristicInfo(qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo);
static void DisplayDigitalCharacteristic(qapi_BLE_AIOS_Digital_Characteristic_Data_t *DigitalData, uint32_t ID);
static void DisplayDigitalByte(uint8_t DigitalByte);
static void DisplayAnalogCharacteristic(uint16_t AnalogData, uint32_t ID);
static void DisplayAIOSPresentationFormatData(qapi_BLE_AIOS_Presentation_Format_Data_t *PresentationFormatData);
static void DecodeDisplayDigitalCharacteristic(uint16_t ValueLength, uint8_t *Value, uint32_t ID);
static void DecodeDisplayAnalogCharacteristic(uint16_t ValueLength, uint8_t *Value, uint32_t ID);

   /* Battery Alert Service (BAS) QCLI command functions.               */
static QCLI_Command_Status_t RegisterBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t UnregisterBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureRemoteBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t NotifyBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetBatteryLevelPresentationFormat(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetBatteryLevelPresentationFormat(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* Battery Alert Service (BAS) helper functions.                     */
static void BASPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);
static boolean_t IsBatteryLevelHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo);
static boolean_t IsBatteryLevelPresentationFormatHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo);
static boolean_t IsBASClientConfigurationHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo);

   /* Generic Access Profile Service (GAPS) QCLI command functions.     */
static QCLI_Command_Status_t ReadLocalName(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetLocalName(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadRemoteName(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadLocalAppearance(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetLocalAppearance(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadRemoteAppearance(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* Generic Access Profile Service (GAPS) helper functions.           */
static void GAPSPopulateHandles(GAPS_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceInfo);
static void DumpAppearanceMappings(void);
static boolean_t AppearanceToString(uint16_t Appearance, char **String);
static boolean_t AppearanceIndexToAppearance(unsigned int Index, uint16_t *Appearance);

   /* HID over GATT Service (HIDS) QCLI command functions.              */
static QCLI_Command_Status_t RegisterHIDS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t UnregisterHIDS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureHIDS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadHIDSConfiguration(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetReport(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetReport(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetSuspend(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetProtocolMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SendReport(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SendKeyString(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* HID over GATT Service (HIDS) helper functions.                    */
static void HIDSPopulateHandles(HIDS_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);
static void ReadHIDSInfo(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo);
static int  HIDSGetReport(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo, uint8_t ReportType, uint8_t ReportID);
static int  HIDSSetReport(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo, uint8_t ReportType, uint8_t ReportID, uint8_t *Value, unsigned int ValueLength, boolean_t ResponseExpected);
static unsigned int ExtractHexString(char *String, uint8_t **Buffer);

   /* Heart Rate Service (HRS) QCLI command functions.                  */
static QCLI_Command_Status_t ConfigureRemoteHRS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* Heart Rate Service (HRS) helper functions.                        */
static void HRSPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);
static qapi_BLE_HRS_Heart_Rate_Measurement_Data_t *DecodeDisplayHeartRate(unsigned int ValueLength, uint8_t *Value, boolean_t PrintData);

   /* OTA Service QCLI command functions.                               */
static QCLI_Command_Status_t RegisterOTA(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t UnregisterOTA(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t RegisterImage(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t UnregisterImage(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetRegisteredImages(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t DiscoverOTA(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t QueryOTAImage(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadOTAImage(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* OTA service helper functions.                                     */
static void PopulateDefaultOTAImageSizes(void);

   /* 6LoWPAN for BLE (SLoWP) QCLI command functions.                   */
static QCLI_Command_Status_t RegisterSLoWPNode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t UnregisterSLoWPNode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConnectSLoWPNode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t DisconnectSLoWPRouter(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetSLoWPConnectionMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetSLoWPConnectionMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* Scan Parameter Service (SCPS) QCLI command functions.             */
static QCLI_Command_Status_t RegisterSCPS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t UnregisterSCPS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureRemoteSCPS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetScanIntervalWindow(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t NotifyScanRefresh(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

   /* Scan Parameter Service (SCPS) helper functions.                   */
static void SCPSPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);

   /* Serial Port over LE (SPPLE) QCLI command functions.               */
static QCLI_Command_Status_t RegisterSPPLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t UnregisterSPPLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureSPPLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SendDataCommand(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadDataCommand(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t Loopback(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t DisplayRawModeData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t AutomaticReadMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetThroughputMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

#ifdef V2
   static QCLI_Command_Status_t EnableBBIF(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
   static QCLI_Command_Status_t SetOTPAddress(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
#endif

   /* Serial Port over LE (SPPLE) helper functions.                     */
static void DisplayThroughput(DeviceInfo_t *DeviceInfo);
static char *SecondsToString(uint32_t Seconds, uint8_t BufferLength, char *Buffer);
static void SPPLEPopulateHandles(SPPLE_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceInfo);
static unsigned int AddDataToBuffer(SPPLE_Data_Buffer_t *DataBuffer, unsigned int DataLength, uint8_t *Data);
static unsigned int RemoveDataFromBuffer(SPPLE_Data_Buffer_t *DataBuffer, unsigned int BufferLength, uint8_t *Buffer);
static void InitializeBuffer(SPPLE_Data_Buffer_t *DataBuffer);
static unsigned int FillBufferWithString(SPPLE_Data_Buffer_t *DataBuffer, unsigned *CurrentBufferLength, unsigned int MaxLength, uint8_t *Buffer);
static void SendProcess(DeviceInfo_t *DeviceInfo);
static void SendCredits(DeviceInfo_t *DeviceInfo, unsigned int DataLength);
static boolean_t ReceiveCreditEvent(DeviceInfo_t *DeviceInfo, unsigned int Credits);
static boolean_t SendData(DeviceInfo_t *DeviceInfo, unsigned int DataLength, uint8_t *Data);
static boolean_t DataIndicationEvent(DeviceInfo_t *DeviceInfo, unsigned int DataLength, uint8_t *Data);
static int ReadData(DeviceInfo_t *DeviceInfo, unsigned int BufferLength, uint8_t *Buffer);

   /* Tx Power Service (TPS) helper functions.                          */
static boolean_t QueryTxPowerLevel(boolean_t ConnectionTxPower, int8_t *TxPowerLevel);

   /* BSC Timer Callback function prototype.                            */
void BSC_Timer_Callback(uint32_t BluetoothStackID, uint32_t TimerID, uint32_t CallbackParameter);

   /* Generic Access Profile (GAPLE) Event Callback function prototypes.*/
static void QAPI_BLE_BTPSAPI GAP_LE_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GAP_LE_Event_Data_t *GAP_LE_Event_Data, uint32_t CallbackParameter);

   /* Generic Attribute Profile (GATT) Event Callback function          */
   /* prototypes.                                                       */
static void QAPI_BLE_BTPSAPI GATT_Connection_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GATT_Connection_Event_Data_t *GATT_Connection_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_Service_Discovery_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GATT_Service_Discovery_Event_Data_t *GATT_Service_Discovery_Event_Data, uint32_t CallbackParameter);

   /* Generic Attribute Profile (GATT) Service/Profile Event Callback   */
   /* function prototypes (Server).                                     */
static void QAPI_BLE_BTPSAPI AIOS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_AIOS_Event_Data_t *AIOS_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI BAS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_BAS_Event_Data_t *BAS_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI HIDS_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_HIDS_Event_Data_t *HIDS_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI SCPS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_SCPS_Event_Data_t *SCPS_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI SLoWP_EventCallback(uint32_t BluetoothStackID, qapi_BLE_SLoWP_Event_Data_t *SLoWP_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ServerEventCallback_SPPLE(uint32_t BluetoothStackID, qapi_BLE_GATT_Server_Event_Data_t *GATT_ServerEventData, uint32_t CallbackParameter);

   /* Generic Attribute Profile (GATT) Service Event Callback function  */
   /* prototypes (Client).                                              */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_AIOS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_BAS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_GAPS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_HIDS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_HRS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_SCPS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_SPPLE(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);

   /* Over the air demo service event callback.                         */
static void OTA_EventCallback(uint32_t BluetoothStackID, BLE_OTA_Server_Event_Data_t *BLE_OTA_Server_Event_Data, void *CallbackParameter);

   /*********************************************************************/
   /* qcli Command Group Definitions                                    */
   /*********************************************************************/

#ifdef V2

const QCLI_Command_t bt5_cmd_list[] =
{
   // cmd_function                 start_thread   cmd_string                 usage_string description
   { ReadPHY,                      false,         "ReadPHYS",                "",                                                                                                                                            "Reads the current PHY for the specified connection."      },
   { SetPHY,                       false,         "SetPHYS",                 "[TX_PHY (bit mask 0=No Preference,0x0001=1M,0x0002=2M)] [RX_PHY (bit mask 0=No Preference,0x0001=1M,0x0002=2M)]",                             "Sets the PHY for the specified connection."               },
   { SetExtendedAdvertisingParams, false,         "SetExtAdvertisingParams", "[AdvertisingHandle] [EventProperties] [Adv Tx Power (-127 - 126, 127 = Don't care)]",                                                         "Sets Extended Advertising Parameters."                    },
   { EnableExtendedAdvertising,    false,         "EnableExtAdvertising",    "[Enable (0 = Disable, 1 = Enable)] [NumberOfSets] [AdvertisingHandle] [Duration (ms, if Enable)] [MaxExtendedAdvertisingEvents (if Enable)]", "Enables/Disabled Extended Advertising."                   },
   { SetExtendedScanParams,        false,         "SetExtScanParams",        "[Scan Interval (ms)] [Scan Window (ms)] [0=No Filter,1=Filter using white list]",                                                                                                     "Sets the Extended Scanning Parameters."                   },
   { EnableExtendedScan,           false,         "EnableExtScan",           "[Enable (0 = Disable, 1 = Enable)] [Duration (ms)] [Period (ms)]",                                                                            "Enables/Disables Extended Scanning."                      },
   { ExtendedConnect,              false,         "ExtendedConnect",         "[BD_ADDR] [ADDR Type (0 = Public, 1 = Random, 2 = Public Identity, 3 = Random Identity)]",                                                    "Sends an Extended Connection request to a remote device." },
};

const QCLI_Command_Group_t bt5_cmd_group =
{
    "Extended (BT v5.0)",
    (sizeof(bt5_cmd_list) / sizeof(bt5_cmd_list[0])),
    bt5_cmd_list
};

#endif

const QCLI_Command_t aios_cmd_list[] =
{
   // cmd_function               start_thread   cmd_string                   usage_string description
   { RegisterAIOS,               false,         "RegisterAIOS",              "",                                                                                                                             "Registers an AIOS instance with the GATT layer."                                         },
   { UnregisterAIOS,             false,         "UnregisterAIOS",            "",                                                                                                                             "Un-registers an AIOS instance."                                                          },
   { ConfigureRemoteAIOS,        false,         "ConfigureRemoteAIOS",       "[Characteristic Type (0 = digital, 1 = analog)] [Characteristic ID (0-1)] [Configure Notification (0 = disable, 1 = enable)]", "Configures discovered AIOS service on a remote device."                                  },
   { ReadAIOSCharacteristic,     false,         "ReadCharacteristic",        "[Characteristic Type (0 = digital, 1 = analog)] [Characteristic ID (0-1)]",                                                    "Reads an AIOS Characteristic's Value on a remote device."                                },
   { ReadAIOSPresentationFormat, false,         "ReadPresentationFormat",    "[Characteristic Type (0 = digital, 1 = analog)] [Characteristic ID (0-1)]",                                                    "Reads an AIOS Characteristic's Presentation Format Descriptor on a remote device."       },
   { ReadAIOSNumberOfDigitals,   false,         "ReadNumberOfDigitals",      "[Characteristic ID (0-1)]",                                                                                                    "Reads an AIOS Digital Characteristic's Number of Digitals Descriptor on a remote device."},
   { WriteAIOSDigitalOutput,     false,         "WriteDigitalOutput",        "[Characteristic ID (0-1)] [Digital Octet 1] [Digital Octet 2]",                                                                "Writes an AIOS Digital Output Characteristic."                                           },
   { WriteAIOSAnalogOutput,      false,         "WriteAnalogOutput",         "[Characteristic ID (0-1)] [Analog Value]",                                                                                     "Writes an AIOS Analog Output Characteristic."                                            },
   { SetAIOSDigitalInput,        false,         "SetDigitalInput",           "[Characteristic ID (0-1)] [Digital Octet 1] [Digital Octet 2]",                                                                "Sets an AIOS Digital Input Characteristic on the AIOS Server."                           },
   { SetAIOSAnalogInput,         false,         "SetAnalogInput",            "[Characteristic ID (0-1)] [Analog Value]",                                                                                     "Sets an AIOS Analog Input Characteristic on the AIOS Server."                            },
   { NotifyAIOSCharacteristic,   false,         "NotifyAIOSCharacteristic",  "[Characteristic Type (0= digital, 1 = analog)] [Characteristic ID (0-1)]",                                                     "Sets an AIOS Characteristic to an AIOS Client."                                          },
};

const QCLI_Command_Group_t aios_cmd_group =
{
    "AIOS",
    (sizeof(aios_cmd_list) / sizeof(aios_cmd_list[0])),
    aios_cmd_list
};

const QCLI_Command_t bas_cmd_list[] =
{
   // cmd_function       start_thread      cmd_string                 usage_string description
   { RegisterBAS,                       false, "RegisterBAS",                       "",                                                                                                                                   "Registers a local BAS service with GATT layer."                             },
   { UnregisterBAS,                     false, "UnregisterBAS",                     "",                                                                                                                                   "Un-registers local BAS service."                                            },

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

   { ConfigureRemoteBAS,                false, "ConfigureRemoteBAS",                "[Battery Level Notification (0 = disable, 1 = enable)] [InstanceID]",                                                                "Configures discovered BAS service on remote device."                        },
   { GetBatteryLevel,                   false, "GetBatteryLevel",                   "[InstanceID]",                                                                                                                       "Get current battery level."                                                 },
   { SetBatteryLevel,                   false, "SetBatteryLevel",                   "[Value (0 - 100)] [InstanceID]",                                                                                                     "Set current battery level."                                                 },
   { NotifyBatteryLevel,                false, "NotifyBatteryLevel",                "[Value (0 - 100)] [InstanceID]",                                                                                                     "Notify current battery level."                                              },
   { GetBatteryLevelPresentationFormat, false, "GetBatteryLevelPresentationFormat", "[InstanceID]",                                                                                                                       "Get current battery level presentation format."                             },
   { SetBatteryLevelPresentationFormat, false, "SetBatteryLevelPresentationFormat", "[Namespace (0x00 - 0xFF)] [Description (0x0000 - 0xFFFF)] [InstanceID]",                                                             "Set current battery level presentation format."                             },

#else

   { ConfigureRemoteBAS,                false, "ConfigureRemoteBAS",                "[Battery Level Notification (0 = disable, 1 = enable)]",                                                                             "Configures discovered BAS service on remote device."                        },
   { GetBatteryLevel,                   false, "GetBatteryLevel",                   "",                                                                                                                                   "Get current battery level."                                                 },
   { SetBatteryLevel,                   false, "SetBatteryLevel",                   "[Value (0 - 100)]",                                                                                                                  "Set current battery level."                                                 },
   { NotifyBatteryLevel,                false, "NotifyBatteryLevel",                "[Value (0 - 100)]",                                                                                                                  "Notify current battery level."                                              },
   { GetBatteryLevelPresentationFormat, false, "GetBatteryLevelPresentationFormat", "",                                                                                                                                   "Get current battery level presentation format."                             },
   { SetBatteryLevelPresentationFormat, false, "SetBatteryLevelPresentationFormat", "[Namespace (0x00 - 0xFF)] [Description (0x0000 - 0xFFFF)]",                                                                          "Set current battery level presentation format."                             },

#endif
};

const QCLI_Command_Group_t bas_cmd_group =
{
    "BAS",
    (sizeof(bas_cmd_list) / sizeof(bas_cmd_list[0])),
    bas_cmd_list
};

const QCLI_Command_t gaps_cmd_list[] =
{
   // cmd_function       start_thread      cmd_string                 usage_string description
   { ReadLocalName,                  false, "ReadLocalName",                 "",                                                                                                                                   "Reads local friendly name."                                                   },
   { SetLocalName,                   false, "SetLocalName",                  "[Name]",                                                                                                                             "Sets local friendly name."                                                    },
   { ReadRemoteName,                 false, "ReadRemoteName",                "",                                                                                                                                   "Read friendly name of remote device."                                         },
   { ReadLocalAppearance,            false, "ReadLocalAppearance",           "",                                                                                                                                   "Reads local device apperance value."                                          },
   { SetLocalAppearance,             false, "SetLocalAppearance",            "[Appearance Index]",                                                                                                                 "Set local device appearance value."                                           },
   { ReadRemoteAppearance,           false, "ReadRemoteAppearance",          "",                                                                                                                                   "Reads device appearance of remote device."                                    },
};

const QCLI_Command_Group_t gaps_cmd_group =
{
    "GAPS",
    (sizeof(gaps_cmd_list) / sizeof(gaps_cmd_list[0])),
    gaps_cmd_list
};

const QCLI_Command_t hogp_cmd_list[] =
{
   // cmd_function       start_thread      cmd_string                 usage_string description
   { RegisterHIDS,                   false, "RegisterHIDS",                  "",                                                                                                                                   "Register HID over GATT Service."                                              },
   { UnregisterHIDS,                 false, "UnRegisterHIDS",                "",                                                                                                                                   "UnRegister HID over GATT Service."                                            },
   { ConfigureHIDS,                  false, "ConfigureHIDS",                 "[InstanceID] [Report Notify (0 = disable, 1 = enable)]",                                                                             "Configure remote HID Service."                                                },
   { ReadHIDSConfiguration,          false, "ReadHIDSConfiguration",         "[InstanceID]",                                                                                                                       "Read's remote devices HID configuration."                                     },
   { GetReport,                      false, "GetReport",                     "[InstanceID] [ReportType] [ReportID (0 = None]\n"
                                                                             "ReportType = \n"
                                                                             " Input                 = 1\n"
                                                                             " Output                = 2\n"
                                                                             " Feature               = 3\n"
                                                                             " Boot Keyboard Input   = 4\n"
                                                                             " Boot Keyboard Output  = 5\n"
                                                                             " Boot Mouse Input      = 6\n",
                                                                             "Get specified report data."                                                                                                                                                                                         },
   { SetReport,                      false, "SetReport",                     "",                                                                                                                                   ""                                                                             },
   { SetSuspend,                     false, "SetSuspend",                    "[InstanceID] [(0 = Exit Suspend, 1 = Suspend)]",                                                                                     "Set suspend mode on remote device."                                           },
   { SetProtocolMode,                false, "SetProtocolMode",               "[InstanceID] [(0 = Boot, 1 = Report)]",                                                                                              "Set report mode on remote device."                                            },
   { SendReport,                     false, "SendReport",                    "[Keyboard/Mouse (Keyboard = 0, Mouse = 1)]]",                                                                                        "Send HID Report to remote device."                                            },
   { SendKeyString,                  false, "SendKeyString",                 "[String to send] [Convert '+' to ' ' (0/1) (Optional)]",                                                                             "Send Key Ring to remote device."                                              },
};

const QCLI_Command_Group_t hogp_cmd_group =
{
    "HOGP",
    (sizeof(hogp_cmd_list) / sizeof(hogp_cmd_list[0])),
    hogp_cmd_list
};

const QCLI_Command_t hrs_cmd_list[] =
{
   // cmd_function       start_thread      cmd_string                 usage_string description
   { ConfigureRemoteHRS,       false,      "ConfigureRemoteHRS",      "[HRS Measurement Notification (0 = disable, 1 = enable)]",                                                                                 "Configure remote HRS Service."                                                 },
};

const QCLI_Command_Group_t hrs_cmd_group =
{
    "HRS",
    (sizeof(hrs_cmd_list) / sizeof(hrs_cmd_list[0])),
    hrs_cmd_list
};

const QCLI_Command_t ota_cmd_list[] =
{
   // cmd_function        start_thread  cmd_string             usage_string                                                     description
   { RegisterOTA,         false,        "RegisterOTA",         "[UseDefaultImages [0=False,1=True (optional, default = True)]", "Registers a local OTA service with GATT layer."  },
   { UnregisterOTA,       false,        "UnregisterOTA",       "",                                                              "Unregisters local OTA service."                  },
   { RegisterImage,       false,        "RegisterImage",       "[FileName] [FilePath] [Version] [ImageID (optional)]",          "Registers an image with the OTA service."        },
   { UnregisterImage,     false,        "UnregisterImage",     "[ImageID]",                                                     "Unregisters an image with the OTA service."      },
   { GetRegisteredImages, false,        "GetRegisteredImages", "",                                                              "Gets the images registered with the OTA service."},
   { DiscoverOTA,         false,        "DiscoverOTA",         "[BD_ADDR]",                                                     "Discovers an OTA service on a remote device."    },
   { QueryOTAImage,       false,        "QueryOTAImage",       "[BD_ADDR] [FileName] [Version]",                                "Queries an OTA server for a newer image."        },
   { ReadOTAImage,        false,        "ReadOTAImage",        "[BD_ADDR] [ImageID] [DataLength] [FileOffset]",                 "Reads image data from an OTA server."            }
};

const QCLI_Command_Group_t ota_cmd_group =
{
    "OTA",
    (sizeof(ota_cmd_list) / sizeof(ota_cmd_list[0])),
    ota_cmd_list
};

const QCLI_Command_t slowp_cmd_list[] =
{
   // cmd_function                start_thread  cmd_string                   usage_string                                              description
   { RegisterSLoWPNode,           false,        "RegisterNode",              "",                                                       "Registers for the 6LoWPAN Node Role."                     },
   { UnregisterSLoWPNode,         false,        "UnregisterNode",            "",                                                       "Un-register for the 6LoWPAN Node Role."                   },
   { ConnectSLoWPNode,            false,        "ConnectNode",               "[Credit Mode (0=Auto, 1=Manual)]",                       "Opens a SLoWP connection from a router to a node."        },
   { DisconnectSLoWPRouter,       false,        "DisconnectRouter",          "",                                                       "Disconnects the SLoWP connection from a node to a router."},
   { SetSLoWPConnectionMode,      false,        "SetNodeConnectionMode",     "[Mode (0=Auto-Accept, 1=Auto-Reject, 2=Manual-Accept)]", "Sets the connection mode for a node."                     },
   { GetSLoWPConnectionMode,      false,        "GetNodeConnectionMode",     "",                                                       "Queries the connection mode for a node."                  },
};

const QCLI_Command_Group_t slowp_cmd_group =
{
    "SLoWP",
    (sizeof(slowp_cmd_list) / sizeof(slowp_cmd_list[0])),
    slowp_cmd_list
};

const QCLI_Command_t scps_cmd_list[] =
{
   // cmd_function                start_thread  cmd_string                   usage_string description
   { RegisterSCPS,                       false, "RegisterSCPS",              "",                                                                                                                                   "Registers a local Scan Parameter service with GATT layer."                    },
   { UnregisterSCPS,                     false, "UnregisterSCPS",            "",                                                                                                                                   "Un-registers local Scan Parameter service."                                   },
   { ConfigureRemoteSCPS,                false, "ConfigureRemoteSCPS",       "[Scan Refresh Notification (0 = disable, 1 = enable)]",                                                                              "Configure's remote devices Scan Parameter service."                           },
   { SetScanIntervalWindow,              false, "SCPSSetScanIntervalWindow", "[LE_Scan_Interval uint16] [LE_Scan_Window uint16]",                                                                                  "Configures LE Scan Interval and Window stored in SCP Service."                },
   { NotifyScanRefresh,                  false, "NotifyScanRefresh",         "",                                                                                                                                   "Send notification of scan refresh characteristic."                            },
};

const QCLI_Command_Group_t scps_cmd_group =
{
    "SCPS",
    (sizeof(scps_cmd_list) / sizeof(scps_cmd_list[0])),
    scps_cmd_list
};

const QCLI_Command_t spple_cmd_list[] =
{
   // cmd_function       start_thread      cmd_string                 usage_string description
   { RegisterSPPLE,                  false, "RegisterSPPLE",                 "",                                                                                                                                   "Registers a local SPPLE service with GATT layer."                             },
   { UnregisterSPPLE,                false, "UnregisterSPPLE",               "",                                                                                                                                   "Un-registers local SPPLE service."                                            },
   { ConfigureSPPLE,                 false, "ConfigureSPPLE",                "",                                                                                                                                   "Configures discovered SPPLE service on remote device."                        },
   { SendDataCommand,                false, "SendDataCommand",               "[Number of bytes to send]",                                                                                                          "Sends data using SPPLE to remote device."                                     },
   { ReadDataCommand,                false, "ReadDataCommand",               "",                                                                                                                                   "Reads data received via SPPLE from remote device."                            },
   { Loopback,                       false, "Loopback",                      "[(0=Disable,1=Enable)]",                                                                                                             "Enables/Disables loopback mode."                                              },
   { DisplayRawModeData,             false, "DisplayRawModeData",            "[(0=Disable,1=Enable)]",                                                                                                             "Enables/Disables display data mode."                                          },
   { AutomaticReadMode,              false, "AutomaticReadMode",             "[(0=Disable,1=Enable)]",                                                                                                             "Enables/Disables automatic data read mode."                                   },
   { SetThroughputMode,              false, "SetThroughputMode",             "[(0=Disable,1=Enable)]",                                                                                                             "Enables/Disables throughput calculation mode." },
};

const QCLI_Command_Group_t spple_cmd_group =
{
    "SPPLE",
    (sizeof(spple_cmd_list) / sizeof(spple_cmd_list[0])),
    spple_cmd_list
};

const QCLI_Command_t ble_cmd_list[] =
{
   // cmd_function       start_thread      cmd_string                 usage_string description
   { InitializeBluetooth,            false, "InitializeBluetooth",           "",                                                                                                                                   "Initializes the Bluetopia stack (must be called before any other commands). " },
   { ShutdownBluetooth,              false, "ShutdownBluetooth",             "",                                                                                                                                   "Shuts down the Bluetopia stack. "                                             },
   { GetVersion,                     false, "QueryVersion",                  "",                                                                                                                                   "Queries version of Bluetopia and Bluetooth Controller."                       },
   { SetBLERadio,                    false, "SetBLERadio",                   "[Radio (1/2)]",                                                                                                                      "Sets the radio that BLE uses."                                                },
   { SetDiscoverabilityMode,         false, "SetDiscoverabilityMode",        "[Mode(0 = Non Discoverable, 1 = Limited Discoverable, 2 = General Discoverable)]",                                                   "Set device discoverability mode (for use during advertising)."                },
   { SetConnectabilityMode,          false, "SetConnectabilityMode",         "[(0 = NonConectable, 1 = Connectable, 2 = Direct Connectable)]",                                                                     "Set device connectability mode (for use during advertising)."                 },
   { SetPairabilityMode,             false, "SetPairabilityMode",            "[Mode (0 = Non Pairable, 1 = Pairable, 2 = Pairable w/ Secure Connections]",                                                         "Set device pairability mode."                                                 },
   { ChangePairingParameters,        false, "ChangePairingParameters",       "[I/O Capability (0=DisplayOnly, 1=Display Yes/No, 2=Keyboard Only, 3=No Input/Output, 4=Keyboard/Display)] [MITM Req (0=No,1=Yes)] [Secure Connections (0 = None, 1 = Yes)", "Changes IO Capabilities used during pairing."      },
   { LEPassKeyResponse,              false, "LEPassKeyResponse",             "[Numeric Passkey(0 - 999999)]",                                                                                                      "Responds to passkey request."                                                 },
   { LEQueryEncryption,              false, "LEQueryEncryption",             "",                                                                                                                                   "Queries encryption state of LE connection."                                   },
   { LESetPasskey,                   false, "LESetPasskey",                  "[(0 = Clear, 1 = Set) Passkey] [6 Digit Passkey (optional)]",                                                                        "Sets fixed passkey to use when IO caps are Display Only."                     },
   { GetLocalAddress,                false, "GetLocalAddress",               "",                                                                                                                                   "Querys Bluetooth Address of local Bluetooth controller."                      },
#ifndef V1
   { AdvertiseLE,                    false, "AdvertiseLE",                   "[(0 = Disable, 1 = Enable)] [Direct BD_ADDR (Optional)]",                                                                            "Starts/Stops Advertising Process."                                            },
#else
   { AdvertiseLE,                    false, "AdvertiseLE",                   "[(0 = Disable, 1 = Enable Channels 37 and 38, 2 = Enable Channel 37, 3 = Enable Channel 38, 4 = Enable Channel 39)] [Direct BD_ADDR (Optional)]", "Starts/Stops Advertising Process."                                            },
#endif
   { ScanLE,                         false, "ScanLE",                        "[(0 = Disable, 1 = Enable)] [Filter Policy (0=No Filter, 1=White List, 2=No White List Directed RPA, 3=White List Directed RPA) (Optional)] [Duration (if enabling scan) (seconds, optional)]", "Starts/Stops Scan Process."     },
   { ConnectLE,                      false, "ConnectLE",                     "[Use White List (0=False, 1=True)] [BD_ADDR (If Use White List=0)] [ADDR Type (0 = Public, 1 = Random, 2 = Public Identity, 3 = Random Identity) (If Use White List=0)] ", "Sends an LE connection request to a remote device."  },
   { DisconnectLE,                   false, "DisconnectLE",                  "",                                                                                                                                   "Disconnects active LE connection."                                            },
   { CancelConnectLE,                false, "CancelConnectLE",               "",                                                                                                                                   "Cancels active LE connection process."                                        },
   { DiscoverServices,               false, "DiscoverServices",              "",                                                                                                                                   "Starts process to discover all GATT Service on active LE connection."         },
   { PairLE,                         false, "PairLE",                        "",                                                                                                                                   "Starts pairing process with active LE connection."                            },
   { UnPairRemoteDevice,             false, "UnPairRemoteDevice",            "[Connection ID]",                                                                                                                    "Unpairs a remote device based on the GATT Connection ID."                     },
   { SelectRemoteDevice,             false, "SelectRemoteDevice",            "[Connection ID]",                                                                                                                    "Selects a remote device based on the GATT Connection ID."                     },
   { DisplayRemoteDevices,           false, "DisplayRemoteDevices",          "",                                                                                                                                   "Displays information for paired devices."                                     },
   { AddDeviceToWhiteList,           false, "AddDeviceToWhiteList",          "[BD_ADDR] [Address Type (0=Public, 1=Random, 2=Public Identity, 3=Random Identity,255=Anonymous Address)]",                          "Adds a device to the white list in the controller."                           },
   { RemoveDeviceFromWhiteList,      false, "RemoveDeviceFromWhiteList",     "[BD_ADDR (all zeros to remove anonymous address type)]",                                                                             "Removes a device from the white list in the controller."                      },
   { AddDeviceToResolvingList,       false, "AddDeviceToResolvingList",      "[BD_ADDR]",                                                                                                                          "Adds a device to the resolving list in the controller."                       },
   { RemoveDeviceFromResolvingList,  false, "RemoveDeviceFromResolvingList", "[BD_ADDR]",                                                                                                                          "Removes a device from the resolving list in the controller."                  },
   { SetAuthenticatedPayloadTimeout, false, "SetAuthPayloadTimeout",         "[BD_ADDR] [Timeout (ms)]",                                                                                                           "Sets the authentication payload timeout for the specified remote device."     },
   { GetGATTMTU,                     false, "GetGATTMTU",                    "",                                                                                                                                   "Queries maximum supported GATT MTU."                                          },
   { SetGATTMTU,                     false, "SetGATTMTU",                    "[MTU]",                                                                                                                              "Changes the maximum supported GATT MTU."                                      },
   { GetScanParameters,              false, "GetScanParameters",             "",                                                                                                                                   "Query the current BLE scan parameters."                                       },
   { SetScanParameters,              false, "SetScanParameters",             "[Scan Interval (ms)] [Scan Window (ms)]",                                                                                            "Set BLE scan parameters."                                                     },
   { GetAdvertisingParameters,       false, "GetAdvertisingParameters",      "",                                                                                                                                   "Query the current BLE advertising parameters."                                },
   { SetAdvertisingParameters,       false, "SetAdvertisingParameters",      "[Minimum Advertising Interval (ms)] [Maximum Advertising Interval (ms)]",                                                            "Set BLE advertising parameters."                                              },
   { GetConnectionParameters,        false, "GetConnectionParameters",       "",                                                                                                                                   "Query the current BLE connection parameters."                                 },
   { SetConnectionParameters,        false, "SetConnectionParameters",       "[Minimum Connection Interval (ms)] [Maximum Connection Interval (ms)] [Slave Latency (number of Connection Events)]",                "Set BLE connection parameters."                                               },
   { SetTestDataPeriod,              false, "SetTestDataPeriod",             "[BD_ADDR] [Period to wakeup and send data (milliseconds)] [Size of data to send (Bytes, >= 1)]",                                     "Sets a the periodic interval to wakeup and send data on connected device."    },
   { SetDataLength,                  false, "SetDataLength",                 "[Suggested Packet Size]",                                                                                                            "Set suggested BLE packet size for connection."                                },
   { StorePersistentData,            false, "StorePersistentData",           "",                                                                                                                                   "Store application data to persistent storage."                                },
   { LoadPersistentData,             false, "LoadPersistentData",            "[Force (1=true) (optional)]",                                                                                                        "Load application from to persistent storage."                                 },
   { DeletePersistentData,           false, "DeletePersistentData",          "",                                                                                                                                   "Delete application data from persistent storage."                             },
   { ConfigureAdvReportDisplay,      false, "ConfigureAdvReportDisplay",     "[0 = Limited Advertising Display, 1 = Verbose Advertising Display]",                                                                  "Configure how much advertising data to display."                              },
   { QueryLocalOOBData,              false, "QueryLocalOOBData",             "",                                                                                                                                    "Query local out of band data to send to remote device."                       },
   { SetRemoteOOOBData,              false, "SetRemoteOOOBData",             "[Confirmation] [Randomizer]",                                                                                                         "Configures OOB data received from remote device."                             },

#ifndef V1
   { LowPowerTransmitOverride,       false, "LowPowerTransmitOverride",      "[Enable (1=true)] [Tx Power Level (-128 to 127, 127 means don't care)] [FEM Mode (0=shutdown,1=rx)]",                                "Override Tx Power by choosing Tx step and FEM control settings. Tx Power Level and FEM Mode parameters are only used when the mode is enabled." },
#endif
   { StartTXTest,                    false, "StartACLTxTest",                "[BD_ADDR] [Packet Size (Bytes, >= 1)]",                                                                                                                                      "Starts HCI Transmit Packet Test."                                             },
   { StartRXTest,                    false, "StartRxTest",                   "[BD_ADDR]",                                                                                                                                                                  "Starts Data Receive Packet Test."                                             },
   { StopTXRXTest,                   false, "StopTxRxTest",                  "",                                                                                                                                                                           "Stops Data Transmit/Receive Packet Test."                                     },
};

const QCLI_Command_Group_t ble_cmd_group =
{
    "BLE",
    (sizeof(ble_cmd_list) / sizeof(ble_cmd_list[0])),
    ble_cmd_list
};

#ifdef V2
const QCLI_Command_t ble_fpga_cmd_list[] =
{
   // cmd_function  start_thread  cmd_string       usage_string      description
   { EnableBBIF,    false,        "EnableBBIF",    "[Enable (0/1)]", "Enables or disables BLE BBIF." },
   { SetOTPAddress, false,        "SetOTPAddress", "[BD_ADDR]",      "Set the bluetooth address used by BLE.  This msut be set before BLE is initialized." },
};

const QCLI_Command_Group_t ble_fpga_cmd_group =
{
    "FPGA",
    (sizeof(ble_fpga_cmd_list) / sizeof(ble_fpga_cmd_list[0])),
    ble_fpga_cmd_list
};
#endif

   /* Demo QCLI command functions.                                      */

   /* The following function is responsible for initializing the stack. */
   /* This function returns QCLI_STATUS_SUCCESS_E on success or an error*/
   /* enumeration if an error occurs.                                   */
static QCLI_Command_Status_t InitializeBluetooth(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val;

   /* First, check that the stack is not currently initialized.         */
   if(!BluetoothStackID)
   {
      /* Attempt to open the stack.                                     */
      Result = OpenStack(&HCI_DriverInformation);
      if(!Result)
      {
         /* Set the default pairability.                                */
         Result = SetPairable();
         if(!Result)
         {
            /* Set the default discoverability.                         */
            Result = SetDisc();
            if(!Result)
            {
               /* Set the default connectability.                       */
               Result = SetConnect();
            }
         }

         /* If the failure occurred after the stack initialized then    */
         /* shut it down.                                               */
         if(Result)
            CloseStack();
      }

      /* Set the QCLI error type appropriately.                         */
      if(!Result)
         ret_val = QCLI_STATUS_SUCCESS_E;
      else
         ret_val = QCLI_STATUS_ERROR_E;
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      QCLI_Printf(ble_group, "Bluetooth stack is already initialized.");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for shutting down the stack.*/
   /* This function returns QCLI_STATUS_SUCCESS_E on success or an error*/
   /* enumeration if an error occurs.                                   */
static QCLI_Command_Status_t ShutdownBluetooth(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First, check that the stack is currently initialized.             */
   if(BluetoothStackID)
   {
      /* Close the stack and set the QCLI error code.                   */
      if(!CloseStack())
         ret_val = QCLI_STATUS_SUCCESS_E;
      else
         ret_val = QCLI_STATUS_ERROR_E;
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      QCLI_Printf(ble_group, "Bluetooth stack is not initialized.");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for returning the current   */
   /* version of the stack and the controller.  This function returns   */
   /* QCLI_STATUS_SUCCESS_E on success or an error enumeration if an    */
   /* error occurs.                                                     */
static QCLI_Command_Status_t GetVersion(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   char                  *HostVersion;
   uint8_t                Status;
   uint8_t                Version;
   uint16_t               Revision;
   uint8_t                LMPVersion;
   uint16_t               ManufacturerName;
   uint16_t               LMPSubversion;
   uint32_t               ProductID;
   uint32_t               BuildVersion;
   QCLI_Command_Status_t  ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Print the Bluetopia Version first..                            */
      HostVersion = qapi_BLE_BSC_Query_Host_Version();

      QCLI_Printf(ble_group, "        Bluetopia        : %s.\n", HostVersion?HostVersion:"Unknown");

      /* Print the Controller Version.                                  */
      if(((Result = qapi_BLE_HCI_Read_Local_Version_Information(BluetoothStackID, &Status, &Version, &Revision, &LMPVersion, &ManufacturerName, &LMPSubversion)) == 0) && (!Status))
      {
         QCLI_Printf(ble_group, "\n        HCI Version      : 0x%02X.\n", Version);
         QCLI_Printf(ble_group, "        HCI Revision     : 0x%04X.\n", Revision);
         QCLI_Printf(ble_group, "        LMP Version      : 0x%02X.\n", LMPVersion);
         QCLI_Printf(ble_group, "        LMP Sub Version  : 0x%04X.\n", LMPSubversion);
         QCLI_Printf(ble_group, "        Manufacturer Name: 0x%04X.\n", ManufacturerName);
      }
      else
         QCLI_Printf(ble_group, "\n        Error retrieving Version Information: %d.\n", (!Result?Status:Result));

      /* Now attempt to query the patch version information.            */
      Result = HCI_VS_GetPatchVersion(BluetoothStackID, &ProductID, &BuildVersion);
      if(!Result)
      {
         QCLI_Printf(ble_group, "\n        Product ID       : 0x%08X.\n", ProductID);
         QCLI_Printf(ble_group, "        Build Version    : 0x%08X.\n", BuildVersion);
      }
      else
         QCLI_Printf(ble_group, "\n        Error retrieving Patch Version Information: %d.\n", Result);

      /* Flag success to the caller.                                    */
      ret_val = QCLI_STATUS_SUCCESS_E;
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the radio that  */
   /* is used for BLE.  This function returns QCLI_STATUS_SUCCESS_E on  */
   /* success or an error enumeration if an error occurs.               */
static QCLI_Command_Status_t SetBLERadio(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Make sure that all of the parameters required for this function*/
      /* appear to be at least semi-valid.                              */
      if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && ((Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= 2)))
      {
         /* Now attempt to query the version of the Bluetooth           */
         /* Controller.                                                 */
         Result = HCI_VS_SetRadio(BluetoothStackID, Parameter_List[0].Integer_Value);
         if(!Result)
            QCLI_Printf(ble_group, "        Success setting Radio %d.\n", Parameter_List[0].Integer_Value);
         else
            QCLI_Printf(ble_group, "        Error %d setting Radio %d.\n", Result, Parameter_List[0].Integer_Value);

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         /* One or more of the necessary parameters is/are invalid.     */
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* Demo helper functions.                                            */

   /* The following function will create a device information entry and */
   /* add it to the specified List.  This function, if successful, will */
   /* return a pointer to the Entry that has been created and added to  */
   /* the specified list.  This function will return NULL if NO Entry   */
   /* was added.  This can occur if the element passed in was deemed    */
   /* invalid or the actual List Head was invalid.                      */
   /* ** NOTE ** This function does not insert duplicate entries into   */
   /*            the list.  An element is considered a duplicate if the */
   /*            RemoteAddress already exists for an entry.  When this  */
   /*            occurs, this function returns NULL.                    */
static DeviceInfo_t *CreateNewDeviceInfoEntry(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress)
{
   DeviceInfo_t *ret_val = NULL;
   boolean_t     Result;

   /* Verify that the passed in parameters seem semi-valid.             */
   if((ListHead) && (!QAPI_BLE_COMPARE_NULL_BD_ADDR(RemoteAddress)))
   {
      /* Allocate the memory for the entry.                             */
      if((ret_val = malloc(sizeof(DeviceInfo_t))) != NULL)
      {
         /* Initialize the entry.                                       */
         memset(ret_val, 0, sizeof(DeviceInfo_t));

         /* Store the remote device address.                            */
         ret_val->RemoteAddress = RemoteAddress;

         Result = qapi_BLE_BSC_AddGenericListEntry_Actual(QAPI_BLE_EK_BD_ADDR_T_E, QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, RemoteAddress), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, NextDeviceInfoInfoPtr), (void **)(ListHead), (void *)(ret_val));
         if(!Result)
         {
            /* Failed to add to list so we should free the memory that  */
            /* we allocated for the entry.                              */
            free(ret_val);
         }
      }
   }

   return(ret_val);
}

   /* The following function searches the specified List for the        */
   /* specified Connection BD_ADDR.  This function returns NULL if      */
   /* either the List Head is invalid, the BD_ADDR is invalid, or the   */
   /* Connection BD_ADDR was NOT found.                                 */
static DeviceInfo_t *SearchDeviceInfoEntryByBD_ADDR(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress)
{
   BoardStr_t    BoardStr;
   DeviceInfo_t *ret_val = NULL;
   DeviceInfo_t *DeviceInfo;

   /* Verify the list head.                                             */
   if(ListHead)
   {
      /* Loop through the device information.                           */
      DeviceInfo = *ListHead;
      while(DeviceInfo)
      {
         /* If the BD_ADDR is a match then we found the remote device   */
         /* information.                                                */
         if(QAPI_BLE_COMPARE_BD_ADDR(DeviceInfo->RemoteAddress, RemoteAddress))
         {
            /* Set the remote device information pointer to the return  */
            /* value and break since we are done.                       */
            ret_val = DeviceInfo;
            break;
         }
         else
         {
            /* Determine if the remote device is using a resolvable     */
            /* private address (RPA).                                   */
            if(QAPI_BLE_GAP_LE_TEST_RESOLVABLE_ADDRESS_BITS(RemoteAddress))
            {
               /* Check if we stored the Identity Resolving Key (IRK)   */
               /* for the remote device.                                */
               if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_IRK_VALID)
               {
                  /* Use the IRK to resolve the address.                */
                  if(qapi_BLE_GAP_LE_Resolve_Address(BluetoothStackID, &(DeviceInfo->IRK), RemoteAddress))
                  {
                     /* If we resolved the address let's update the     */
                     /* Bluetooth address stored for the remote device. */
                     /* * NOTE * We are doing this so we don't have to  */
                     /*          re-resolve the remote device address   */
                     /*          for future connections.  However, if   */
                     /*          the resolvable address changes we will */
                     /*          need to resolve it again.              */
                     DeviceInfo->RemoteAddress     = RemoteAddress;
                     DeviceInfo->RemoteAddressType = QAPI_BLE_LAT_RANDOM_E;

                     /* Inform the user we resolved the address.        */
                     QCLI_Printf(ble_group, "\n");
                     QCLI_Printf(ble_group, "Resolved Address (");
                     BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
                     QCLI_Printf(ble_group, "%s", BoardStr);
                     QCLI_Printf(ble_group, ")\n");
                     QCLI_Printf(ble_group, "   Identity Address:       ");
                     BD_ADDRToStr(DeviceInfo->IdentityAddressBD_ADDR, BoardStr);
                     QCLI_Printf(ble_group, "%s\n", BoardStr);
                     QCLI_Printf(ble_group, "   Identity Address Type:  %s\n", ((DeviceInfo->IdentityAddressType == QAPI_BLE_LAT_PUBLIC_IDENTITY_E) ? "Public Identity" : "Random Identity"));

                     /* Set the remote device information pointer to the*/
                     /* return value and break since we are done.       */
                     ret_val = DeviceInfo;
                     break;
                  }
               }
            }
         }

         DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
      }
   }

   return(ret_val);
}

   /* The following function searches the specified List for the        */
   /* specified Address and Type.  This function returns NULL if        */
   /* either the List Head is invalid, the BD_ADDR is invalid, or the   */
   /* Connection BD_ADDR was NOT found.                                 */
static DeviceInfo_t *SearchDeviceInfoEntryTypeAddress(DeviceInfo_t **ListHead, qapi_BLE_GAP_LE_Address_Type_t AddressType, qapi_BLE_BD_ADDR_t RemoteAddress)
{
   BoardStr_t                      BoardStr;
   DeviceInfo_t                   *ret_val = NULL;
   DeviceInfo_t                   *DeviceInfo;
   qapi_BLE_GAP_LE_Address_Type_t  TempType;

   /* Verify the list head.                                             */
   if(ListHead)
   {
      /* Loop through the device information.                           */
      DeviceInfo = *ListHead;
      while(DeviceInfo)
      {
         /* If the BD_ADDR is a match then we found the remote device   */
         /* information.                                                */
         if((DeviceInfo->RemoteAddressType == AddressType) && (QAPI_BLE_COMPARE_BD_ADDR(DeviceInfo->RemoteAddress, RemoteAddress)))
         {
            /* Set the remote device information pointer to the return  */
            /* value and break since we are done.                       */
            ret_val = DeviceInfo;
            break;
         }
         else
         {
            /* Check to see if this is an identity address.             */
            if((AddressType == QAPI_BLE_LAT_PUBLIC_IDENTITY_E) || (AddressType == QAPI_BLE_LAT_RANDOM_IDENTITY_E))
            {
               /* Convert the address type.                             */
               if(AddressType == QAPI_BLE_LAT_PUBLIC_IDENTITY_E)
                  TempType = QAPI_BLE_LAT_PUBLIC_E;
               else
                  TempType = QAPI_BLE_LAT_RANDOM_E;

               /* Check if the identity address field is valid.         */
               if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_IRK_VALID)
               {
                  /* Compare the identity address and type.             */
                  if((DeviceInfo->IdentityAddressType == TempType) && (QAPI_BLE_COMPARE_BD_ADDR(DeviceInfo->IdentityAddressBD_ADDR, RemoteAddress)))
                  {
                     /* Update the address field for this entry.        */
                     DeviceInfo->RemoteAddressType = AddressType;
                     DeviceInfo->RemoteAddress     = DeviceInfo->IdentityAddressBD_ADDR;

                     /* Set the remote device information pointer to the*/
                     /* return value and break since we are done.       */
                     ret_val = DeviceInfo;
                     break;
                  }
               }
            }
            else
            {
                /* Determine if the remote device is using a resolvable */
                /* private address (RPA).                               */
                if((AddressType == QAPI_BLE_LAT_RANDOM_E) && (QAPI_BLE_GAP_LE_TEST_RESOLVABLE_ADDRESS_BITS(RemoteAddress)))
                {
                   /* Check if we stored the Identity Resolving Key     */
                   /* (IRK) for the remote device.                      */
                   if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_IRK_VALID)
                   {
                      /* Use the IRK to resolve the address.            */
                      if(qapi_BLE_GAP_LE_Resolve_Address(BluetoothStackID, &(DeviceInfo->IRK), RemoteAddress))
                      {
                         /* If we resolved the address let's update the */
                         /* Bluetooth address stored for the remote     */
                         /* device.                                     */
                         /* * NOTE * We are doing this so we don't have */
                         /*          to re-resolve the remote device    */
                         /*          address for future connections.    */
                         /*          However, if the resolvable address */
                         /*          changes we will need to resolve it */
                         /*          again.                             */
                         DeviceInfo->RemoteAddress     = RemoteAddress;
                         DeviceInfo->RemoteAddressType = QAPI_BLE_LAT_RANDOM_E;

                         /* Inform the user we resolved the address.    */
                         QCLI_Printf(ble_group, "\n");
                         QCLI_Printf(ble_group, "Resolved Address (");
                         BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
                         QCLI_Printf(ble_group, "%s", BoardStr);
                         QCLI_Printf(ble_group, ")\n");
                         QCLI_Printf(ble_group, "   Identity Address:       ");
                         BD_ADDRToStr(DeviceInfo->IdentityAddressBD_ADDR, BoardStr);
                         QCLI_Printf(ble_group, "%s\n", BoardStr);
                         QCLI_Printf(ble_group, "   Identity Address Type:  %s\n", ((DeviceInfo->IdentityAddressType == QAPI_BLE_LAT_PUBLIC_IDENTITY_E) ? "Public Identity" : "Random Identity"));

                         /* Set the remote device information pointer to*/
                         /* the return value and break since we are     */
                         /* done.                                       */
                         ret_val = DeviceInfo;
                         break;
                      }
                   }
                }
            }
         }

         DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
      }
   }

   return(ret_val);
}

   /* The following function searches the specified List for the        */
   /* specified GATT Connection ID.  This function returns NULL if      */
   /* either the List Head is invalid, the Connection ID is invalid, or */
   /* the Connection ID was NOT found.                                  */
static DeviceInfo_t *SearchDeviceInfoEntryByConnectionID(DeviceInfo_t **ListHead, unsigned int ConnectionID)
{
   return(qapi_BLE_BSC_SearchGenericListEntry(QAPI_BLE_EK_UNSIGNED_INTEGER_E, (void *)(&ConnectionID), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, ConnectionID), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, NextDeviceInfoInfoPtr), (void **)(ListHead)));
}

   /* The following function searches the specified Key Info List for   */
   /* the specified BD_ADDR and removes it from the List.  This function*/
   /* returns NULL if either the List Head is invalid, the BD_ADDR is   */
   /* invalid, or the specified Entry was NOT present in the list.  The */
   /* entry returned will have the Next Entry field set to NULL, and    */
   /* the caller is responsible for deleting the memory associated with */
   /* this entry by calling the FreeKeyEntryMemory() function.          */
static DeviceInfo_t *DeleteDeviceInfoEntry(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress)
{
   return(qapi_BLE_BSC_DeleteGenericListEntry(QAPI_BLE_EK_BD_ADDR_T_E, (void *)(&RemoteAddress), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, RemoteAddress), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, NextDeviceInfoInfoPtr), (void **)(ListHead)));
}

   /* This function frees the specified Key Info Information member     */
   /* memory.                                                           */
static void FreeDeviceInfoEntryMemory(DeviceInfo_t *EntryToFree)
{
   unsigned int InstanceID;

   /* Loop through all HIDS instance.                                   */
   for(InstanceID = 0; InstanceID < MAX_SUPPORTED_HID_INSTANCES; InstanceID++)
   {
      /* Free the report map.                                           */
      if(EntryToFree->HIDSClientInfo[InstanceID].ReportMap)
         free(EntryToFree->HIDSClientInfo[InstanceID].ReportMap);
   }

   qapi_BLE_BSC_FreeGenericListEntryMemory((void *)(EntryToFree));
}

   /* The following function deletes (and frees all memory) every       */
   /* element of the specified Key Info List. Upon return of this       */
   /* function, the Head Pointer is set to NULL.                        */
static void FreeDeviceInfoList(DeviceInfo_t **ListHead)
{
   DeviceInfo_t *DeviceInfo;
   unsigned int  InstanceID;

   DeviceInfo = *ListHead;

   while(DeviceInfo)
   {
      /* Loop through all HIDS instance.                                */
      for(InstanceID = 0; InstanceID < MAX_SUPPORTED_HID_INSTANCES; InstanceID++)
      {
         /* Free the report map.                                        */
         if(DeviceInfo->HIDSClientInfo[InstanceID].ReportMap)
            free(DeviceInfo->HIDSClientInfo[InstanceID].ReportMap);
      }

      DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
   }

   qapi_BLE_BSC_FreeGenericListEntryList((void **)(ListHead), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, NextDeviceInfoInfoPtr));
}

   /* The following function is responsible for converting data of type */
   /* BD_ADDR to a string.  The first parameter of this function is the */
   /* BD_ADDR to be converted to a string.  The second parameter of this*/
   /* function is a pointer to the string in which the converted BD_ADDR*/
   /* is to be stored.                                                  */
static void BD_ADDRToStr(qapi_BLE_BD_ADDR_t Board_Address, BoardStr_t BoardStr)
{
   snprintf((char *)BoardStr, (sizeof(BoardStr_t)/sizeof(char)), "0x%02X%02X%02X%02X%02X%02X", Board_Address.BD_ADDR5, Board_Address.BD_ADDR4, Board_Address.BD_ADDR3, Board_Address.BD_ADDR2, Board_Address.BD_ADDR1, Board_Address.BD_ADDR0);
}

   /* The following function is responsible for converting number       */
   /* strings to there unsigned integer equivalent.  This function can  */
   /* handle leading and tailing white space, however it does not handle*/
   /* signed or comma delimited values.  This function takes as its     */
   /* input the string which is to be converted.  The function returns  */
   /* zero if an error occurs otherwise it returns the value parsed from*/
   /* the string passed as the input parameter.                         */
static unsigned int StringToUnsignedInteger(char *StringInteger)
{
   int          IsHex;
   unsigned int Index;
   unsigned int ret_val = 0;

   /* Before proceeding make sure that the parameter that was passed as */
   /* an input appears to be at least semi-valid.                       */
   if((StringInteger) && (strlen(StringInteger)))
   {
      /* Initialize the variable.                                       */
      Index = 0;

      /* Next check to see if this is a hexadecimal number.             */
      if(strlen(StringInteger) > 2)
      {
         if((StringInteger[0] == '0') && ((StringInteger[1] == 'x') || (StringInteger[1] == 'X')))
         {
            IsHex = 1;

            /* Increment the String passed the Hexadecimal prefix.      */
            StringInteger += 2;
         }
         else
            IsHex = 0;
      }
      else
         IsHex = 0;

      /* Process the value differently depending on whether or not a    */
      /* Hexadecimal Number has been specified.                         */
      if(!IsHex)
      {
         /* Decimal Number has been specified.                          */
         while(1)
         {
            /* First check to make sure that this is a valid decimal    */
            /* digit.                                                   */
            if((StringInteger[Index] >= '0') && (StringInteger[Index] <= '9'))
            {
               /* This is a valid digit, add it to the value being      */
               /* built.                                                */
               ret_val += (StringInteger[Index] & 0xF);

               /* Determine if the next digit is valid.                 */
               if(((Index + 1) < strlen(StringInteger)) && (StringInteger[Index+1] >= '0') && (StringInteger[Index+1] <= '9'))
               {
                  /* The next digit is valid so multiply the current    */
                  /* return value by 10.                                */
                  ret_val *= 10;
               }
               else
               {
                  /* The next value is invalid so break out of the loop.*/
                  break;
               }
            }

            Index++;
         }
      }
      else
      {
         /* Hexadecimal Number has been specified.                      */
         while(1)
         {
            /* First check to make sure that this is a valid Hexadecimal*/
            /* digit.                                                   */
            if(((StringInteger[Index] >= '0') && (StringInteger[Index] <= '9')) || ((StringInteger[Index] >= 'a') && (StringInteger[Index] <= 'f')) || ((StringInteger[Index] >= 'A') && (StringInteger[Index] <= 'F')))
            {
               /* This is a valid digit, add it to the value being      */
               /* built.                                                */
               if((StringInteger[Index] >= '0') && (StringInteger[Index] <= '9'))
                  ret_val += (StringInteger[Index] & 0xF);
               else
               {
                  if((StringInteger[Index] >= 'a') && (StringInteger[Index] <= 'f'))
                     ret_val += (StringInteger[Index] - 'a' + 10);
                  else
                     ret_val += (StringInteger[Index] - 'A' + 10);
               }

               /* Determine if the next digit is valid.                 */
               if(((Index + 1) < strlen(StringInteger)) && (((StringInteger[Index+1] >= '0') && (StringInteger[Index+1] <= '9')) || ((StringInteger[Index+1] >= 'a') && (StringInteger[Index+1] <= 'f')) || ((StringInteger[Index+1] >= 'A') && (StringInteger[Index+1] <= 'F'))))
               {
                  /* The next digit is valid so multiply the current    */
                  /* return value by 16.                                */
                  ret_val *= 16;
               }
               else
               {
                  /* The next value is invalid so break out of the loop.*/
                  break;
               }
            }

            Index++;
         }
      }
   }

   return(ret_val);
}

   /* The following function is responsible for opening the SS1         */
   /* Bluetooth Protocol Stack.  This function accepts a pre-populated  */
   /* HCI Driver Information structure that contains the HCI Driver     */
   /* Transport Information.  This function returns zero on successful  */
   /* execution and a negative value on all errors.                     */
static int OpenStack(qapi_BLE_HCI_DriverInformation_t *HCI_DriverInformation)
{
   int                    Result;
   int                    ret_val = 0;
   char                   BluetoothAddress[16];
   int8_t                 TxPowerLevel;
   uint32_t               ServiceID;
   qapi_BLE_HCI_Version_t HCIVersion;
   uint8_t                HC_SCO_Data_Packet_Length;
   uint16_t               HC_Total_Num_SCO_Data_Packets;
   uint16_t               HC_Total_Num_LE_Data_Packets;
   uint16_t               HC_LE_Data_Packet_Length;
   uint8_t                TempData;
   uint8_t                Status;

   /* First check to see if the Stack has already been opened.          */
   if(!BluetoothStackID)
   {
      /* Next, makes sure that the Driver Information passed appears to */
      /* be semi-valid.                                                 */
      if(HCI_DriverInformation)
      {
         QCLI_Printf(ble_group, "\n");

         QCLI_Printf(ble_group, "OpenStack().\n");

         /* Initialize the Stack                                        */
         Result = qapi_BLE_BSC_Initialize(HCI_DriverInformation, 0);

         /* Next, check the return value of the initialization to see if*/
         /* it was successful.                                          */
         if(Result > 0)
         {
            /* The Stack was initialized successfully, inform the user  */
            /* and set the return value of the initialization function  */
            /* to the Bluetooth Stack ID.                               */
            BluetoothStackID = Result;
            QCLI_Printf(ble_group, "Bluetooth Stack ID: %d.\n", BluetoothStackID);

            /* Initialize the Default Pairing Parameters.               */
            LE_Parameters.IOCapability      = DEFAULT_IO_CAPABILITY;
            LE_Parameters.OOBDataPresent    = FALSE;
            LE_Parameters.MITMProtection    = (LE_Parameters.IOCapability != QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E) ? DEFAULT_MITM_PROTECTION : FALSE;
            LE_Parameters.SecureConnections = DEFAULT_SECURE_CONNECTIONS;

            if(!qapi_BLE_HCI_Version_Supported(BluetoothStackID, &HCIVersion))
               QCLI_Printf(ble_group, "Device Chipset: %s.\n", (HCIVersion <= NUM_SUPPORTED_HCI_VERSIONS)?HCIVersionStrings[HCIVersion]:HCIVersionStrings[NUM_SUPPORTED_HCI_VERSIONS]);

            /* Read the LE Buffer Size.                                 */
            Result = qapi_BLE_HCI_LE_Read_Buffer_Size(BluetoothStackID, &Status, &HC_LE_Data_Packet_Length, &TempData);

            /* If HCI_LE_Read_Buffer_Size returned an error OR it returned */
            /* ZERO for the LE Data Packet Buffers we need to call         */
            /* HCI_Read_Buffer_Size to get the Data Packet Buffers (which  */
            /* must be shared between Classic and LE Bluetooth).           */
            if((Result) || (Status != 0) || (!HC_LE_Data_Packet_Length) || (!TempData))
            {
               if((!qapi_BLE_HCI_Read_Buffer_Size(BluetoothStackID, &Status, &HC_LE_Data_Packet_Length, &HC_SCO_Data_Packet_Length, &HC_Total_Num_LE_Data_Packets, &HC_Total_Num_SCO_Data_Packets)) && (!Status))
                  Result = 0;
               else
                  Result = -1;
            }
            else
            {
               HC_Total_Num_LE_Data_Packets = (uint16_t)TempData;
               Result                       = 0;
            }

            NumberACLPackets            = HC_Total_Num_LE_Data_Packets;
            NumberOutstandingACLPackets = 0;
            MaxACLPacketSize            = HC_LE_Data_Packet_Length;

            if(!Result)
               QCLI_Printf(ble_group, "Number ACL Buffers: %d, ACL Buffer Size: %d\n", NumberACLPackets, MaxACLPacketSize);
            else
               QCLI_Printf(ble_group, "Unable to determine ACL Buffer Size.\n");

            RegisterForHCIEvents();
            RegisterForACLData();

            GenerateData2Send(MAXIMUM_TEST_BUFFER, TestBuffer);

            /* Let's output the Bluetooth Device Address so that the    */
            /* user knows what the Device Address is.                   */
            if(!qapi_BLE_GAP_Query_Local_BD_ADDR(BluetoothStackID, &LocalBD_ADDR))
            {
               BD_ADDRToStr(LocalBD_ADDR, BluetoothAddress);

               QCLI_Printf(ble_group, "BD_ADDR: %s\n", BluetoothAddress);
            }

            /* Flag that no connection is currently active.             */
            QAPI_BLE_ASSIGN_BD_ADDR(SelectedRemoteBD_ADDR, 0, 0, 0, 0, 0, 0);
            QAPI_BLE_ASSIGN_BD_ADDR(SecurityRemoteBD_ADDR, 0, 0, 0, 0, 0, 0);

            /* Generate some random values for IR and ER (normally would*/
            /* be in flash).                                            */
            GenerateRandomKeys();

            /* Regenerate IRK and DHK from the constant Identity Root   */
            /* Key.                                                     */
            qapi_BLE_GAP_LE_Diversify_Function(BluetoothStackID, (qapi_BLE_Encryption_Key_t *)(&IR), 1,0, &IRK);
            qapi_BLE_GAP_LE_Diversify_Function(BluetoothStackID, (qapi_BLE_Encryption_Key_t *)(&IR), 3, 0, &DHK);

            /* Flag that we have no Key Information in the Key List.    */
            DeviceInfoList = NULL;

            /* Attempt to initialize our persistent storage context.    */
            /* * NOTE * /spinor/ is default mount point for the flash   */
            /*          file system. Unless a different file system is  */
            /*          being used or the mount point is changed, this  */
            /*          directory should be kept in any modifications.  */
            Result = qapi_Persist_Initialize(&PersistHandle, "/spinor/ble", "ble_data", ".bin", NULL, 0);
            if(Result < 0)
               QCLI_Printf(ble_group, "Persistent Storage Initialization Failed: %d\n", Result);

            /* Initialize the GATT Service.                             */
            if((Result = qapi_BLE_GATT_Initialize(BluetoothStackID, (QAPI_BLE_GATT_INITIALIZATION_FLAGS_SUPPORT_LE | QAPI_BLE_GATT_INITIALIZATION_FLAGS_DISABLE_SERVICE_CHANGED_CHARACTERISTIC), GATT_Connection_Event_Callback, 0)) == 0)
            {
               /* Initialize the DIS Service.                           */
               Result = qapi_BLE_DIS_Initialize_Service(BluetoothStackID, &ServiceID);
               if(Result > 0)
               {
                  /* Save the DIS Instance ID.                          */
                  DISInstanceID = (unsigned int)Result;

                  /* Set the default device information for DIS.        */
                  qapi_BLE_DIS_Set_Manufacturer_Name(BluetoothStackID, DISInstanceID, "Qualcomm Technologies, Inc");
                  qapi_BLE_DIS_Set_Model_Number(BluetoothStackID, DISInstanceID, "4.2.1.1");
                  qapi_BLE_DIS_Set_Software_Revision(BluetoothStackID, DISInstanceID, "4.2");
                  qapi_BLE_DIS_Set_Hardware_Revision(BluetoothStackID, DISInstanceID, "4.2");
                  qapi_BLE_DIS_Set_Firmware_Revision(BluetoothStackID, DISInstanceID, "1.0");
               }
               else
                  DisplayFunctionError("DIS_Initialize_Service()", Result);

               /* Initialize the GAPS Service.                          */
               Result = qapi_BLE_GAPS_Initialize_Service(BluetoothStackID, &ServiceID);
               if(Result > 0)
               {
                  /* Save the Instance ID of the GAP Service.           */
                  GAPSInstanceID = (unsigned int)Result;

                  /* Set the GAP Device Name and Device Appearance.     */
                  qapi_BLE_GAPS_Set_Device_Name(BluetoothStackID, GAPSInstanceID, DEVICE_FRIENDLY_NAME);
                  qapi_BLE_GAPS_Set_Device_Appearance(BluetoothStackID, GAPSInstanceID, QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_COMPUTER);

                  /* Let's enable address resolution in the controller. */
                  /* * NOTE * This function MUST be called to enable the*/
                  /*          use of the resolving list in the          */
                  /*          controller.                               */
                  Result = qapi_BLE_GAP_LE_Set_Address_Resolution_Enable(BluetoothStackID, TRUE);
                  if(!Result)
                  {
                     /* Enable the GAPS Central Device Resolution.      */
                     /* * NOTE * This MUST be enabled since the local   */
                     /*          device supports privacy with address   */
                     /*          resolution.  A remote peripheral MUST  */
                     /*          read the Central Address Resolution    */
                     /*          Characteristic to determine if the     */
                     /*          local device supports privacy with     */
                     /*          address resolution before using direct */
                     /*          advertising, where the initiator       */
                     /*          address is a resolvable private address*/
                     /*          (RPA).                                 */
                     qapi_BLE_GAPS_Set_Central_Address_Resolution(BluetoothStackID, GAPSInstanceID, QAPI_BLE_GAR_ENABLED_E);

                     /* Let's set the Resolvable Private Address (RPA)  */
                     /* Timeout to 60 seconds.                          */
                     /* * NOTE * An new RPA will be generated and used  */
                     /*          for a remote device when the timeout   */
                     /*          occurs.                                */
                     Result = qapi_BLE_GAP_LE_Set_Resolvable_Private_Address_Timeout(BluetoothStackID, 60);
                     if(Result)
                        QCLI_Printf(ble_group, "Error - qapi_BLE_GAP_LE_Set_Resolvable_Private_Address_Timeout() returned %d.\n", Result);
                  }
                  else
                     QCLI_Printf(ble_group, "Error - qapi_BLE_GAP_LE_Set_Address_Resolution_Enable() returned %d.\n", Result);
               }
               else
                  DisplayFunctionError("qapi_BLE_GAPS_Initialize_Service()", Result);

               /* Initialize the TPS Service.                           */
               Result = qapi_BLE_TPS_Initialize_Service(BluetoothStackID, &ServiceID);
               if(Result > 0)
               {
                  /* Save the Instance ID of the TPS Service.           */
                  TPSInstanceID = (unsigned int)Result;

                  /* Attempt to query the default connection Tx Power   */
                  /* Level.                                             */
                  if(QueryTxPowerLevel(TRUE, &TxPowerLevel))
                  {
                     /* Set the connection Tx Power Level.              */
                     qapi_BLE_TPS_Set_Tx_Power_Level(BluetoothStackID, TPSInstanceID, TxPowerLevel);
                  }
               }
               else
                  DisplayFunctionError("qapi_BLE_TPS_Initialize_Service()", Result);

               /* Initialize SLoWP.                                     */
               Result = qapi_BLE_SLoWP_Initialize(BluetoothStackID);
               if(!Result)
               {
                  /* Flag that SLoWP is initialized.                    */
                  SLoWPInitialized = TRUE;

                  QCLI_Printf(ble_group, "Initialized 6LoWPAN layer for BLE.\n");
               }
               else
                  DisplayFunctionError("qapi_BLE_SLoWP_Initialize()", Result);

               /* Return success to the caller.                         */
               ret_val = 0;
            }
            else
            {
               /* The Stack was NOT initialized successfully, inform the*/
               /* user and set the return value of the initialization   */
               /* function to an error.                                 */
               DisplayFunctionError("qapi_BLE_GATT_Initialize()", Result);

               /* Shutdown the stack.                                   */
               qapi_BLE_BSC_Shutdown(BluetoothStackID);

               BluetoothStackID = 0;

               ret_val          = -1;
            }
         }
         else
         {
            /* The Stack was NOT initialized successfully, inform the   */
            /* user and set the return value of the initialization      */
            /* function to an error.                                    */
            DisplayFunctionError("qapi_BLE_BSC_Initialize()", Result);

            BluetoothStackID = 0;

            ret_val          = -1;
         }
      }
      else
      {
         /* One or more of the necessary parameters are invalid.        */
         ret_val = -1;
      }
   }
   else
   {
      /* Stack is already opened.                                       */
      ret_val = 0;
   }


   return(ret_val);
}

   /* The following function is responsible for closing the SS1         */
   /* Bluetooth Protocol Stack.  This function requires that the        */
   /* Bluetooth Protocol stack previously have been initialized via the */
   /* OpenStack() function.  This function returns zero on successful   */
   /* execution and a negative value on all errors.                     */
static int CloseStack(void)
{
   int           ret_val = 0;
   unsigned int  Index;
   DeviceInfo_t *DeviceInfo;

   /* First check to see if the Stack has been opened.                  */
   if(BluetoothStackID)
   {
      /* If there are remote devices connected.                         */
      if(ConnectionCount)
      {
         /* Go ahead and flag that we are no longer connected to any    */
         /* remote devices.                                             */
         ConnectionCount = 0;

         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* We need to loop through the remote device information    */
            /* entries and disconnect any remote devices that are still */
            /* connected.                                               */
            DeviceInfo = DeviceInfoList;
            while(DeviceInfo)
            {
               /* If the GATT Connection ID is valid, then we are       */
               /* connected to the remote device.                       */
               if(DeviceInfo->ConnectionID)
               {
                  /* Flag that the remote device is no longer connected.*/
                  DeviceInfo->ConnectionID = 0;

                  /* Send the disconnection request.                    */
                  qapi_BLE_GAP_LE_Disconnect(BluetoothStackID, DeviceInfo->RemoteAddress);
               }

               DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
            }

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
      }

      /* if scan timer is active stop that.                             */
      if(ScanTimerID)
      {
         /* Stop the timer.                                             */
         qapi_BLE_BSC_StopTimer(BluetoothStackID, ScanTimerID);

         ScanTimerID = 0;
      }

      /* Un-initilize SLoWP if it is initialized.                       */
      if(SLoWPNodeInitialized)
      {
         qapi_BLE_SLoWP_Cleanup_Node(BluetoothStackID);

         SLoWPNodeInitialized = FALSE;
      }

      if(SLoWPInitialized)
      {
         qapi_BLE_SLoWP_Cleanup(BluetoothStackID);

         SLoWPInitialized = FALSE;
      }

      /* Flag that the connection is no longer active.                  */
      SLoWPConnected = FALSE;

      /* Un-registered AIOS.                                            */
      if(AIOSInstanceID)
      {
         qapi_BLE_AIOS_Cleanup_Service(BluetoothStackID, AIOSInstanceID);

         AIOSInstanceID = 0;
      }

      /* Un-register any registered BAS service instances.              */
      for(Index = 0; Index < MAX_SUPPORTED_BATTERY_INSTANCES; Index++)
      {
         /* Check to see if this instance is registered.                */
         if(BASInstanceID[Index])
         {
            qapi_BLE_BAS_Cleanup_Service(BluetoothStackID, BASInstanceID[Index]);

            BASInstanceID[Index] = 0;
         }
      }

      /* Cleanup DIS Service.                                           */
      if(DISInstanceID)
      {
         qapi_BLE_DIS_Cleanup_Service(BluetoothStackID, DISInstanceID);

         DISInstanceID = 0;
      }

      /* Cleanup GAP Service Module.                                    */
      if(GAPSInstanceID)
      {
         qapi_BLE_GAPS_Cleanup_Service(BluetoothStackID, GAPSInstanceID);

         GAPSInstanceID = 0;
      }

      /* Cleanup HID Service.                                           */
      if(HIDSInstanceID)
      {
         qapi_BLE_HIDS_Cleanup_Service(BluetoothStackID, HIDSInstanceID);

         HIDSInstanceID = 0;
      }

      /* Cleanup OTA Service.                                           */
      if(OTAInstanceID)
      {
         BLE_OTA_Cleanup_Service(BluetoothStackID, OTAInstanceID);

         /* Loop through each item and clean up any allocations.        */
         for(Index = 0; Index < sizeof(ManualOTAServerImageData)/sizeof(BLE_OTA_Server_Image_Data_t); Index++)
         {
            if(ManualOTAServerImageData[Index].FileName)
               free(ManualOTAServerImageData[Index].FileName);

            if(ManualOTAImageInfo[Index].FilePath)
               free(ManualOTAImageInfo[Index].FilePath);
         }

         memset(ManualOTAServerImageData, 0, sizeof(ManualOTAServerImageData));
         memset(ManualOTAImageInfo, 0, sizeof(ManualOTAImageInfo));

         OTAInstanceID = 0;
      }

      if(OTAClientInitialized)
      {
         BLE_OTA_Cleanup_Client(BluetoothStackID);
      }

      /* Cleanup the SCPS Service Module.                               */
      if(SCPSInstanceID)
      {
         qapi_BLE_SCPS_Cleanup_Service(BluetoothStackID, SCPSInstanceID);

         SCPSInstanceID = 0;
      }

      /* Un-registered SPP LE Service.                                  */
      if(SPPLEServiceID)
      {
         qapi_BLE_GATT_Un_Register_Service(BluetoothStackID, SPPLEServiceID);

         SPPLEServiceID = 0;
      }

      /* Cleanup the TPS Service Module.                                */
      if(TPSInstanceID)
      {
         qapi_BLE_TPS_Cleanup_Service(BluetoothStackID, TPSInstanceID);

         TPSInstanceID = 0;
      }

      /* Release the storage instance.                                  */
      qapi_Persist_Cleanup(PersistHandle);
      PersistHandle = NULL;

      /* Cleanup GATT Module.                                           */
      qapi_BLE_GATT_Cleanup(BluetoothStackID);

      /* Simply close the Stack                                         */
      qapi_BLE_BSC_Shutdown(BluetoothStackID);

      /* Inform the user that the stack has been shut down.             */
      QCLI_Printf(ble_group, "Stack Shutdown.\n");

      /* Free all remote device information entries.                    */
      FreeDeviceInfoList(&DeviceInfoList);
      DeviceInfoList   = NULL;

      /* Flag that the Stack is no longer initialized.                  */
      BluetoothStackID = 0;
      RemoteOOBValid   = FALSE;
      LocalOOBValid    = FALSE;

      /* Flag success to the caller.                                    */
      ret_val          = 0;
   }
   else
   {
      /* A valid Stack ID does not exist, inform to user.               */
      ret_val = -1;
   }

   return(ret_val);
}

/******************************************************************************/
/**  RegisterForHCIEvents(void)                                              **/
/******************************************************************************/
/**  Register for HCI Events.                                                **/
/******************************************************************************/
static int RegisterForHCIEvents(void)
{
   int Result;

   if(BluetoothStackID)
   {
      Result = qapi_BLE_HCI_Register_Event_Callback(BluetoothStackID, EventCallback, 1);

      if(Result)
         QCLI_Printf(ble_group, "HCI Event Registration Successful.\n");
      else
         QCLI_Printf(ble_group, "HCI Event Registration Failed.\n");
   }
   else
      QCLI_Printf(ble_group, "Stack ID Invalid.\n");

   return(0);
}

/******************************************************************************/
/**  RegisterForACLData(void)                                                **/
/******************************************************************************/
/**  Register for ACL Data.                                                  **/
/******************************************************************************/
static int RegisterForACLData(void)
{
   int Result;

   if(BluetoothStackID)
   {
      Result = qapi_BLE_HCI_Register_ACL_Data_Callback(BluetoothStackID, ACLDataCallback, 1);

      if(Result)
         QCLI_Printf(ble_group, "ACL Data Callback Registration Successful.\n");
      else
         QCLI_Printf(ble_group, "ACL Data Callback Registration Failed.\n");
   }
   else
      QCLI_Printf(ble_group, "Stack ID Invalid.\n");

   return(0);
}

   /* The following function is used to generate a pattern of data to   */
   /* send to the remote device.                                        */
static void GenerateData2Send(unsigned int Length,  uint8_t *Data)
{
   unsigned int         Index;
   static unsigned char Cntr = '0';

   /* Make sure the input parameters are valid.                         */
   if((Length) && (Data))
   {
      for(Index = 0; Index < Length; Index++)
      {
         Data[Index] = Cntr++;

         if((Cntr > '9') && (Cntr < 'A'))
            Cntr = 'A';
         else
         {
            if(Cntr > 'F')
               Cntr = '0';
         }
      }
   }
}

   /* The following callback is the period timer callback that is       */
   /* started for periodically transmitting data.                       */
static void Period_Tx_Callback(uint32_t data)
{
   qapi_Status_t         Result;
   unsigned long         Temp;
   static unsigned long  DataIndex = 0;
   qapi_TIMER_set_attr_t Set_Timer_Attr;

   /* Verify that the stack is opened.                                  */
   if(BluetoothStackID != 0)
   {
      /* Verify that a LE Connection Oriented Channel is open for data  */
      /* transfer.                                                      */
      if(CurrentTest == CURRENT_TEST_PERIODIC)
      {
         Temp = MAXIMUM_TEST_BUFFER - DataIndex;

         if(PacketLength <= Temp)
            Temp = PacketLength;

         /* Send the data.                                              */
         SendACLData(Temp, &(TestBuffer[DataIndex]));

         DataIndex += Temp;

         if(DataIndex >= MAXIMUM_TEST_BUFFER)
            DataIndex = 0;
      }
   }

   /* Restart the timer if necessary.                                   */
   if(CurrentTest == CURRENT_TEST_PERIODIC)
   {
      /* Timer restart necessary, so configure according to the saved   */
      /* parameters.                                                    */
      Set_Timer_Attr.time                   = (uint64_t)TransmitPeriod;
      Set_Timer_Attr.reload                 = true;
      Set_Timer_Attr.max_deferrable_timeout = (uint64_t)TransmitPeriod;
      Set_Timer_Attr.unit                   = QAPI_TIMER_UNIT_MSEC;

      Result = qapi_Timer_Set(PeriodicSendTimer, &Set_Timer_Attr);
      if(Result != QAPI_OK)
         Display_Function_Error(ble_group, "qapi_Timer_Set", Result);
   }
   else
      DataIndex = 0;
}

/******************************************************************************/
/**  SendACLData(char *)                                                     **/
/******************************************************************************/
/**  Send ACL Data.                                                          **/
/******************************************************************************/
static int SendACLData(unsigned int Length, unsigned char *Data)
{
   int           Result;
   int           ret_val = 0;
   unsigned long Pass;

   if(BluetoothStackID)
   {
      if((Data) && (Length <= MAXIMUM_TEST_BUFFER))
      {
         if(CurrentTest == CURRENT_TEST_TX_ACL)
            Pass = 0xFFFFFFFF;
         else
            Pass = 1;

         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            while((Pass--) && (!ret_val))
            {
               if(NumberOutstandingACLPackets < NumberACLPackets)
               {
                  Result = qapi_BLE_HCI_Send_ACL_Data(BluetoothStackID,
                                             ConnectionHandle,
                                             QAPI_BLE_HCI_ACL_FLAGS_PACKET_BOUNDARY_FIRST_PACKET_NON_FLUSHABLE,
                                             (uint16_t)Length,
                                             Data);

                  if(!Result)
                  {
                     NumberOutstandingACLPackets++;

                     NumberBytes += Length;
                     ret_val      = 0;
                  }
                  else
                  {
                     QCLI_Printf(ble_group, "   Error - Function Returned %d.\n", Result);

                     ret_val = -4;
                  }
               }
               else
                  ret_val = -3;
            }

            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
      }
      else
         ret_val = -2;
   }
   else
   {
      QCLI_Printf(ble_group, "Stack ID Invalid.\n");

      ret_val = -1;
   }

   return(ret_val);
}

static QCLI_Command_Status_t StartTXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint16_t              _ConnectionHandle;
   qapi_BLE_BD_ADDR_t    BD_ADDR;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      if((Parameter_Count > 0) && (Parameter_List) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
      {
         /* Convert the parameter to a Bluetooth Device Address.        */
         StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

         PacketLength = 0;

         if((Parameter_Count > 1) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= MaxACLPacketSize) && (Parameter_List[1].Integer_Value <= MAXIMUM_TEST_BUFFER))
            PacketLength = (uint32_t)Parameter_List[1].Integer_Value;
         else
         {
            if(Parameter_Count == 1)
               PacketLength = (uint32_t)27;
         }

         if((PacketLength) && (PacketLength <= MaxACLPacketSize))
         {
            if(CurrentTest == CURRENT_TEST_NONE)
            {
               if(!qapi_BLE_GAP_LE_Query_Connection_Handle(BluetoothStackID, BD_ADDR, &_ConnectionHandle))
               {
                  CurrentTest                 = CURRENT_TEST_TX_ACL;
                  StartTime                   = qurt_timer_get_ticks();
                  NumberBytes                 = 0;
                  NumberOutstandingACLPackets = 0;
                  ConnectionHandle            = _ConnectionHandle;

                  QCLI_Printf(ble_group, "Starting ACL TX Test with packet size: %u.\n", PacketLength);

                  SendACLData(PacketLength, TestBuffer);
               }
               else
                  QCLI_Printf(ble_group, "Device is not currently connected.\n");
            }
            else
               QCLI_Printf(ble_group, "Test already in progress.\n");

            /* Flag success to the caller.                              */
            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            QCLI_Printf(ble_group, "Data Packet Size must be between 1 and  %u.\n", MaxACLPacketSize);

            /* One or more of the necessary parameters is/are invalid.  */
            ret_val = QCLI_STATUS_USAGE_E;
         }
      }
      else
      {
         /* One or more of the necessary parameters is/are invalid.     */
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

static QCLI_Command_Status_t StartRXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint16_t              _ConnectionHandle;
   qapi_BLE_BD_ADDR_t    BD_ADDR;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      if(CurrentTest == CURRENT_TEST_NONE)
      {
         _ConnectionHandle = QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE;

         /* Note we will treat the RX Test BD_ADDR as optional - we will*/
         /* not display statistics though.                              */
         if((Parameter_Count > 0) && (Parameter_List) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
         {
            /* Convert the parameter to a Bluetooth Device Address.        */
            StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

            qapi_BLE_GAP_LE_Query_Connection_Handle(BluetoothStackID, BD_ADDR, &_ConnectionHandle);
         }

         StartTime        = 0;
         NumberBytes      = 0;
         CurrentTest      = CURRENT_TEST_RX_ACL;
         ConnectionHandle = _ConnectionHandle;

         ret_val          = QCLI_STATUS_SUCCESS_E;

         QCLI_Printf(ble_group, "Waiting to Receive ACL Data.\n");
      }
      else
      {
         QCLI_Printf(ble_group, "Test already in progress.\n");
         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

static QCLI_Command_Status_t StopTXRXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint32_t              ElapsedTime;
   uint32_t              Bandwidth;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      if(CurrentTest != CURRENT_TEST_NONE)
      {
         /* Do not display statistics if an RX Test was specified (with */
         /* no BD_ADDR specified).                                      */
         if(ConnectionHandle != QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE)
         {
            EndTime      = qurt_timer_get_ticks();

            ElapsedTime  = qurt_timer_convert_ticks_to_time(EndTime - StartTime, QURT_TIME_MSEC) / 1000;

            if(ElapsedTime)
            {
               Bandwidth    = NumberBytes/ElapsedTime;

               QCLI_Printf(ble_group, "Test Time    : %u\n", ElapsedTime);
               QCLI_Printf(ble_group, "Number Bytes : %u\n", NumberBytes);
               QCLI_Printf(ble_group, "Bytes/Second : %u\n", Bandwidth);
               QCLI_Printf(ble_group, "KBytes/Second: %u\n", Bandwidth/1024);
               QCLI_Printf(ble_group, "KBits/Second : %u\n", (Bandwidth*8)/1024);
            }
         }

         QCLI_Printf(ble_group, "Test Complete.\n");

         ConnectionHandle            = QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE;
         CurrentTest                 = CURRENT_TEST_NONE;
         NumberOutstandingACLPackets = 0;
      }
      else
         QCLI_Printf(ble_group, "No Test in progress.\n");

      /* Flag success to the caller.                                    */
      ret_val = QCLI_STATUS_SUCCESS_E;
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* Generic Access Profile (GAPLE) QCLI command functions.            */

   /* The following function is responsible for setting the             */
   /* Discoverability Mode of the local device.  This function returns  */
   /* zero on successful execution and a negative value on all errors.  */
static QCLI_Command_Status_t SetDiscoverabilityMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t               ret_val;
   qapi_BLE_GAP_Discoverability_Mode_t DiscoverabilityMode;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Make sure that all of the parameters required for this function*/
      /* appear to be at least semi-valid.                              */
      if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 2))
      {
         /* Parameters appear to be valid, map the specified parameters */
         /* into the API specific parameters.                           */
         if(Parameter_List[0].Integer_Value == 1)
            DiscoverabilityMode = QAPI_BLE_DM_LIMITED_DISCOVERABLE_MODE_E;
         else
         {
            if(Parameter_List[0].Integer_Value == 2)
               DiscoverabilityMode = QAPI_BLE_DM_GENERAL_DISCOVERABLE_MODE_E;
            else
               DiscoverabilityMode = QAPI_BLE_DM_NON_DISCOVERABLE_MODE_E;
         }

         /* Set the LE Discoveryability Mode.                           */
         LE_Parameters.DiscoverabilityMode = DiscoverabilityMode;

         /* The Mode was changed successfully.                          */
         QCLI_Printf(ble_group, "Discoverability: %s.\n", (DiscoverabilityMode == QAPI_BLE_DM_NON_DISCOVERABLE_MODE_E)?"Non":((DiscoverabilityMode == QAPI_BLE_DM_GENERAL_DISCOVERABLE_MODE_E)?"General":"Limited"));

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         /* One or more of the necessary parameters is/are invalid.     */
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the             */
   /* Connectability Mode of the local device.  This function returns   */
   /* zero on successful execution and a negative value on all errors.  */
static QCLI_Command_Status_t SetConnectabilityMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Make sure that all of the parameters required for this function*/
      /* appear to be at least semi-valid.                              */
      if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= QAPI_BLE_LCM_NON_CONNECTABLE_E) && (Parameter_List[0].Integer_Value <= QAPI_BLE_LCM_DIRECT_CONNECTABLE_E))
      {
         /* Parameters appear to be valid, map the specified parameters */
         /* into the API specific parameters.                           */
         /* * NOTE * The Connectability Mode in LE is only applicable   */
         /*          when advertising, if a device is not advertising   */
         /*          it is not connectable.                             */
         if(Parameter_List[0].Integer_Value == QAPI_BLE_LCM_DIRECT_CONNECTABLE_E)
         {
            /* We CANNOT use Direct Connectable high duty cycle since   */
            /* advertising will stop after 1.28 ms and it is meant for  */
            /* fast connections.  Instead we will use low duty cycle to */
            /* allow the remote device more time to connect.            */
            LE_Parameters.ConnectableMode = QAPI_BLE_LCM_LOW_DUTY_CYCLE_DIRECT_CONNECTABLE_E;
         }
         else
            LE_Parameters.ConnectableMode = (qapi_BLE_GAP_LE_Connectability_Mode_t)Parameter_List[0].Integer_Value;

         /* The Mode was changed successfully.                          */
         switch(LE_Parameters.ConnectableMode)
         {
            case QAPI_BLE_LCM_NON_CONNECTABLE_E:
               QCLI_Printf(ble_group, "Connectability Mode: Non-Connectable.\n");
               break;
            case QAPI_BLE_LCM_CONNECTABLE_E:
               QCLI_Printf(ble_group, "Connectability Mode: Connectable.\n");
               break;
            case QAPI_BLE_LCM_DIRECT_CONNECTABLE_E:
               QCLI_Printf(ble_group, "Connectability Mode: Direct Connectable (High Duty Cycle).\n");
               break;
            case QAPI_BLE_LCM_LOW_DUTY_CYCLE_DIRECT_CONNECTABLE_E:
               QCLI_Printf(ble_group, "Connectability Mode: Direct Connectable (Low Duty Cycle).\n");
               break;
            default:
               QCLI_Printf(ble_group, "Connectability Mode: Invalid.\n");
               break;

         }

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         /* One or more of the necessary parameters is/are invalid.     */
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the Pairability */
   /* Mode of the local device.  This function returns zero on          */
   /* successful execution and a negative value on all errors.          */
static QCLI_Command_Status_t SetPairabilityMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                 Result;
   char                               *Mode;
   QCLI_Command_Status_t               ret_val;
   qapi_BLE_GAP_LE_Pairability_Mode_t  PairabilityMode;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Make sure that all of the parameters required for this function*/
      /* appear to be at least semi-valid.                              */
      if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 2))
      {
         /* Parameters appear to be valid, map the specified parameters */
         /* into the API specific parameters.                           */
         if(Parameter_List[0].Integer_Value == 0)
         {
            PairabilityMode = QAPI_BLE_LPM_NON_PAIRABLEMODE_E;
            Mode            = "QAPI_BLE_LPM_NON_PAIRABLEMODE_E";
         }
         else
         {
            if(Parameter_List[0].Integer_Value == 1)
            {
               PairabilityMode = QAPI_BLE_LPM_PAIRABLE_MODE_E;
               Mode            = "QAPI_BLE_LPM_PAIRABLE_MODE_E";
            }
            else
            {
               PairabilityMode = QAPI_BLE_LPM_PAIRABLE_MODE_ENABLE_EXTENDED_EVENTS_E;
               Mode            = "QAPI_BLE_LPM_PAIRABLE_MODE_ENABLE_EXTENDED_EVENTS_E";
            }
         }

         /* Parameters mapped, now set the Pairability Mode.            */
         Result = qapi_BLE_GAP_LE_Set_Pairability_Mode(BluetoothStackID, PairabilityMode);

         /* Next, check the return value to see if the command was      */
         /* issued successfully.                                        */
         if(Result >= 0)
         {
            /* The Mode was changed successfully.                       */
            QCLI_Printf(ble_group, "Pairability Mode Changed to %s.\n", Mode);

            /* If Secure Simple Pairing has been enabled, inform the    */
            /* user of the current Secure Simple Pairing parameters.    */
            if(PairabilityMode == QAPI_BLE_LPM_PAIRABLE_MODE_E)
               DisplayIOCapabilities();

            /* Flag success to the caller.                              */
            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            /* There was an error setting the Mode.                     */
            DisplayFunctionError("GAP_Set_Pairability_Mode", Result);

            /* Flag that an error occurred while submitting the command.*/
            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         /* One or more of the necessary parameters is/are invalid.     */
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}


   /* The following function is responsible for changing the Secure     */
   /* Simple Pairing Parameters that are exchanged during the Pairing   */
   /* procedure when Secure Simple Pairing (Security Level 4) is used.  */
   /* This function returns zero on successful execution and a negative */
   /* value on all errors.                                              */
static QCLI_Command_Status_t ChangePairingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Make sure that all of the parameters required for this function*/
      /* appear to be at least semi-valid.                              */
      if((Parameter_Count >= 3) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 4))
      {
         /* Parameters appear to be valid, map the specified parameters */
         /* into the API specific parameters.                           */
         if(Parameter_List[0].Integer_Value == 0)
            LE_Parameters.IOCapability = QAPI_BLE_LIC_DISPLAY_ONLY_E;
         else
         {
            if(Parameter_List[0].Integer_Value == 1)
               LE_Parameters.IOCapability = QAPI_BLE_LIC_DISPLAY_YES_NO_E;
            else
            {
               if(Parameter_List[0].Integer_Value == 2)
                  LE_Parameters.IOCapability = QAPI_BLE_LIC_KEYBOARD_ONLY_E;
               else
               {
                  if(Parameter_List[0].Integer_Value == 3)
                     LE_Parameters.IOCapability = QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E;
                  else
                     LE_Parameters.IOCapability = QAPI_BLE_LIC_KEYBOARD_DISPLAY_E;
               }
            }
         }

         /* Finally map the Man in the Middle (MITM) Protection valid.  */
         LE_Parameters.MITMProtection    = (boolean_t)(Parameter_List[1].Integer_Value ? TRUE : FALSE);

         /* Also, map the secure connections.                           */
         LE_Parameters.SecureConnections = (boolean_t)(Parameter_List[2].Integer_Value ? TRUE : FALSE);

         /* Inform the user of the New I/O Capabilities.                */
         DisplayIOCapabilities();

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         /* One or more of the necessary parameters is/are invalid.     */
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for issuing a GAP           */
   /* Authentication Response with a Pass Key value specified via the   */
   /* input parameter.  This function returns zero on successful        */
   /* execution and a negative value on all errors.                     */
static QCLI_Command_Status_t LEPassKeyResponse(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                                   Result;
   QCLI_Command_Status_t                                 ret_val;
   qapi_BLE_GAP_LE_Authentication_Response_Information_t GAP_LE_Authentication_Response_Information;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* First, check to see if there is an on-going Pairing operation  */
      /* active.                                                        */
      if(!QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
      {
         /* Make sure that all of the parameters required for this      */
         /* function appear to be at least semi-valid.                  */
         if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].String_Value) && (strlen((char *)(Parameter_List[0].String_Value)) <= QAPI_BLE_GAP_LE_PASSKEY_MAXIMUM_NUMBER_OF_DIGITS))
         {
            /* Parameters appear to be valid, go ahead and populate the */
            /* response structure.                                      */
            GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type  = QAPI_BLE_LAR_PASSKEY_E;
            GAP_LE_Authentication_Response_Information.Authentication_Data_Length  = (uint8_t)(sizeof(uint32_t));
            GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = (uint32_t)(Parameter_List[0].Integer_Value);

            /* Submit the Authentication Response.                      */
            Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, SecurityRemoteBD_ADDR, &GAP_LE_Authentication_Response_Information);

            /* Check the return value for the submitted command for     */
            /* success.                                                 */
            if(!Result)
            {
               /* Operation was successful, inform the user.            */
               QCLI_Printf(ble_group, "Passkey Response success.\n");

               /* Flag success to the caller.                           */
               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               /* Inform the user that the Authentication Response was  */
               /* not successful.                                       */
               DisplayFunctionError("GAP_LE_Authentication_Response", Result);

               ret_val = QCLI_STATUS_ERROR_E;
            }

            /* Flag that there is no longer a current Authentication    */
            /* procedure in progress.                                   */
            QAPI_BLE_ASSIGN_BD_ADDR(SecurityRemoteBD_ADDR, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
         }
         else
         {
            /* One or more of the necessary parameters is/are invalid.  */
            ret_val = QCLI_STATUS_USAGE_E;
         }
      }
      else
      {
         /* There is not currently an on-going authentication operation,*/
         /* inform the user of this error condition.                    */
         QCLI_Printf(ble_group, "Pass Key Authentication Response: Authentication not in progress.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for querying the Encryption */
   /* Mode for an LE Connection.  This function returns zero on         */
   /* successful execution and a negative value on all errors.          */
static QCLI_Command_Status_t LEQueryEncryption(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                            Result;
   QCLI_Command_Status_t          ret_val;
   qapi_BLE_GAP_Encryption_Mode_t GAP_Encryption_Mode;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* First, check to see if there is an on-going Pairing operation  */
      /* active.                                                        */
      if(!QAPI_BLE_COMPARE_NULL_BD_ADDR(SelectedRemoteBD_ADDR))
      {
         /* Query the current Encryption Mode for this Connection.      */
         Result = qapi_BLE_GAP_LE_Query_Encryption_Mode(BluetoothStackID, SelectedRemoteBD_ADDR, &GAP_Encryption_Mode);
         if(!Result)
         {
            QCLI_Printf(ble_group, "Current Encryption Mode: %s.\n", (GAP_Encryption_Mode == QAPI_BLE_EM_ENABLED_E)?"Enabled":"Disabled");

            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            QCLI_Printf(ble_group, "Error - GAP_LE_Query_Encryption_Mode returned %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         /* There is not currently an on-going authentication operation,*/
         /* inform the user of this error condition.                    */
         QCLI_Printf(ble_group, "Not Connected.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for querying the Encryption */
   /* Mode for an LE Connection.  This function returns zero on         */
   /* successful execution and a negative value on all errors.          */
static QCLI_Command_Status_t LESetPasskey(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   uint32_t              Passkey;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Make sure that all of the parameters required for this         */
      /* function appear to be at least semi-valid.                     */
      if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) &&  ((Parameter_List[0].Integer_Value == 0) || (Parameter_List[0].Integer_Value == 1)))
      {
         /* Check to see if we are setting or clearing the LE Fixed     */
         /* Passkey.                                                    */
         if(Parameter_List[0].Integer_Value == 1)
         {
            /* We are setting the passkey so make sure it is valid.     */
            if((Parameter_Count >= 2) && (Parameter_List[1].String_Value) && (strlen((char *)(Parameter_List[1].String_Value)) <= QAPI_BLE_GAP_LE_PASSKEY_MAXIMUM_NUMBER_OF_DIGITS))
            {
               /* Store the passkey.                                    */
               Passkey = (uint32_t)(Parameter_List[1].String_Value);

               /* Attempt to set the fixed passkey.                     */
               Result  = qapi_BLE_GAP_LE_Set_Fixed_Passkey(BluetoothStackID, &Passkey);
               if(!Result)
               {
                  QCLI_Printf(ble_group, "Fixed Passkey set to %06u.\n", (unsigned int)Passkey);

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(ble_group, "Error - GAP_LE_Set_Fixed_Passkey returned %d.\n", Result);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(ble_group, "Error - Invalid Passkey.\n");

               ret_val = QCLI_STATUS_USAGE_E;
            }
         }
         else
         {
            /* Un-set the fixed passkey that we previously configured.  */
            Result = qapi_BLE_GAP_LE_Set_Fixed_Passkey(BluetoothStackID, NULL);
            if(!Result)
            {
               QCLI_Printf(ble_group, "Fixed Passkey no longer configured.\n");

               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               QCLI_Printf(ble_group, "Error - GAP_LE_Set_Fixed_Passkey returned %d.\n", Result);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
      }
      else
      {
         /* One or more of the necessary parameters is/are invalid.     */
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for querying the Bluetooth  */
   /* Device Address of the local Bluetooth Device.  This function      */
   /* returns zero on successful execution and a negative value on all  */
   /* errors.                                                           */
static QCLI_Command_Status_t GetLocalAddress(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   BoardStr_t            BoardStr;
   qapi_BLE_BD_ADDR_t    BD_ADDR;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Attempt to submit the command.                                 */
      Result = qapi_BLE_GAP_Query_Local_BD_ADDR(BluetoothStackID, &BD_ADDR);

      /* Check the return value of the submitted command for success.   */
      if(!Result)
      {
         BD_ADDRToStr(BD_ADDR, BoardStr);

         QCLI_Printf(ble_group, "BD_ADDR of Local Device is: %s.\n", BoardStr);

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         /* Display a message indicating that an error occurred while   */
         /* attempting to query the Local Device Address.               */
         QCLI_Printf(ble_group, "GAP_Query_Local_BD_ADDR() Failure: %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for enabling LE             */
   /* Advertisements.  This function returns zero on successful         */
   /* execution and a negative value on all errors.                     */
   /* * NOTE * If SPPLE is registered by the local device, then the     */
   /*          local device name (GAPS Device Name), should be set to a */
   /*          shorter length than the default name.  Otherwise, the    */
   /*          128-bit UUID for SPPLE CANNOT fit in the scan response   */
   /*          data.                                                    */
static QCLI_Command_Status_t AdvertiseLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                         Result;
   int                                         Index;
   QCLI_Command_Status_t                       ret_val;
   qapi_BLE_BD_ADDR_t                          BD_ADDR;
   DeviceInfo_t                               *RemoteDevice;
   unsigned int                                Length;
   unsigned int                                UUIDIndex;
   char                                        Name[QAPI_BLE_GAP_MAXIMUM_DEVICE_NAME_LENGTH+1];
   unsigned int                                NameLength;
   uint16_t                                    DeviceAppearance;
   qapi_BLE_GAP_LE_Connectability_Parameters_t ConnectabilityParameters;
   int8_t                                      TransmitPowerLevel;
   union
   {
      qapi_BLE_Advertising_Data_t              AdvertisingData;
      qapi_BLE_Scan_Response_Data_t            ScanResponseData;
   } Advertisement_Data_Buffer;
   enum
   {
      AET_DISABLE_E,
      AET_ENABLE_ALL_E,
      AET_ENABLE_CHANNEL_37_E,
      AET_ENABLE_CHANNEL_38_E,
      AET_ENABLE_CHANNEL_39_E
   };

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Make sure that all of the parameters required for this function*/
      /* appear to be at least semi-valid.                              */
#ifndef V1
      if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= AET_DISABLE_E) && (Parameter_List[0].Integer_Value <= AET_ENABLE_CHANNEL_39_E))
#else
      if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 1))
#endif
         {
         /* Determine whether to enable or disable Advertising.         */
#ifndef V1
         if(Parameter_List[0].Integer_Value == 0)
#else
         if(Parameter_List[0].Integer_Value == AET_DISABLE_E)
#endif
         {
            /* Disable Advertising.                                     */
            Result = qapi_BLE_GAP_LE_Advertising_Disable(BluetoothStackID);
            if(!Result)
            {
               QCLI_Printf(ble_group, "   GAP_LE_Advertising_Disable success.\n");

               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               QCLI_Printf(ble_group, "   GAP_LE_Advertising_Disable returned %d.\n", Result);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            /* Set the Advertising Data.                                */
            memset(&(Advertisement_Data_Buffer.AdvertisingData), 0, sizeof(qapi_BLE_Advertising_Data_t));

            /* Reset the length to zero.                                */
            Length = 0;

            /* Set the Flags A/D Field (1 byte type and 1 byte Flags.   */
            Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length]   = 2;
            Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_FLAGS;
            Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length+2] = 0;

            /* Configure the flags field based on the Discoverability   */
            /* Mode.                                                    */
            if(LE_Parameters.DiscoverabilityMode == QAPI_BLE_DM_GENERAL_DISCOVERABLE_MODE_E)
               Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length+2]    = QAPI_BLE_HCI_LE_ADVERTISING_FLAGS_GENERAL_DISCOVERABLE_MODE_FLAGS_BIT_MASK;
            else
            {
               if(LE_Parameters.DiscoverabilityMode == QAPI_BLE_DM_LIMITED_DISCOVERABLE_MODE_E)
                  Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length+2] = QAPI_BLE_HCI_LE_ADVERTISING_FLAGS_LIMITED_DISCOVERABLE_MODE_FLAGS_BIT_MASK;
            }

            Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length + 2] |= QAPI_BLE_HCI_LE_ADVERTISING_FLAGS_BR_EDR_NOT_SUPPORTED_FLAGS_BIT_MASK;

            /* Update the current length of the advertising data.       */
            /* * NOTE * We MUST add one to account for the length field,*/
            /*          which does not include itself.                  */
            Length += (Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length] + 1);

            /* Include the GAPS Device Appearance.                      */
            if((Result = qapi_BLE_GAPS_Query_Device_Appearance(BluetoothStackID, (uint32_t)GAPSInstanceID, &DeviceAppearance)) == 0)
            {
               /* Make sure we do not exceed the bounds of the buffer.  */
               if((Length + (unsigned int)QAPI_BLE_NON_ALIGNED_WORD_SIZE + 2) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
               {
                  ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]   = 3;
                  ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_APPEARANCE;
                  ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+2]), DeviceAppearance);

                  /* Update the current length of the advertising data. */
                  /* * NOTE * We MUST add one to account for the length */
                  /*          field, which does not include itself.     */
                  Length += (((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1);
               }
               else
                  QCLI_Printf(ble_group, "   The device appearance CANNOT fit in the advertising data.\n", Result);
            }
            else
               QCLI_Printf(ble_group, "   qapi_BLE_GAPS_Query_Device_Appearance(dtAdvertising) returned %d.\n", Result);

            /* Include the Transmit Power Level.                        */
            if((Result = QueryTxPowerLevel(FALSE, &TransmitPowerLevel)) == 0)
            {
               /* Make sure we do not exceed the bounds of the buffer.  */
               if((Length + (unsigned int)QAPI_BLE_NON_ALIGNED_BYTE_SIZE + 2) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
               {
                  ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]   = 2;
                  ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_TX_POWER_LEVEL;
                  ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+2] = TransmitPowerLevel;

                  /* Update the current length of the advertising data. */
                  /* * NOTE * We MUST add one to account for the length */
                  /*          field, which does not include itself.     */
                  Length += (((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1);
               }
               else
                  QCLI_Printf(ble_group, "   The transmit power CANNOT fit in the advertising data.\n");
            }
            else
               QCLI_Printf(ble_group, "   QueryTxPowerLevel() returned %d.\n", Result);


            /* Include the 16-bit service UUIDs if the service is       */
            /* registered.                                              */
            /* * NOTE * SPPLE is excluded since it has a 128 bit UUID.  */

            /* Make sure we have room in the buffer.                    */
            /* * NOTE * We will make sure we have room for at least one */
            /*          16-bit UUID.                                    */
            if((Length + (unsigned int)QAPI_BLE_UUID_16_SIZE + 2) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
            {
               ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]   = 1;
               ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_COMPLETE;

               /* Store the UUID Index location.                        */
               /* * NOTE * We will do this to make the code more        */
               /*          readable.                                    */
               UUIDIndex = (Length + 2);

               /* If AIOS is registered.                                */
               if(AIOSInstanceID)
               {
                  /* Make sure we do not exceed the bounds of the       */
                  /* buffer.                                            */
                  /* * NOTE * We MUST add one to account for the length */
                  /*          field, which does not include itself.     */
                  if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                  {
                     /* Assign the AIOS Service UUID.                   */
                     QAPI_BLE_AIOS_ASSIGN_AIOS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                     /* Update the UUID Index.                          */
                     UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                     /* Update the advertising report data entry length */
                     /* since we have added another UUID.               */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] += QAPI_BLE_UUID_16_SIZE;
                  }
                  else
                  {
                     /* Flag that we could not include all the service  */
                     /* UUIDs.                                          */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                  }
               }

               /* If BAS is registered.                                 */
               for(Index = 0; Index < MAX_SUPPORTED_BATTERY_INSTANCES; Index ++)
               {
                  if(BASInstanceID[Index])
                  {
                     break;
                  }
               }

               if(Index < MAX_SUPPORTED_BATTERY_INSTANCES)
               {
                  /* Make sure we do not exceed the bounds of the       */
                  /* buffer.                                            */
                  /* * NOTE * We MUST add one to account for the length */
                  /*          field, which does not include itself.     */
                  if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                  {
                     /* Assign the BAS Service UUID.                    */
                     QAPI_BLE_BAS_ASSIGN_BAS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                     /* Update the UUID Index.                          */
                     UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                     /* Update the advertising report data entry length */
                     /* since we have added another UUID.               */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]  += QAPI_BLE_UUID_16_SIZE;
                  }
                  else
                  {
                     /* Flag that we could not include all the service  */
                     /* UUIDs.                                          */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                  }
               }

               /* If DIS is registered.                                 */
               if(DISInstanceID)
               {
                  /* Make sure we do not exceed the bounds of the       */
                  /* buffer.                                            */
                  /* * NOTE * We MUST add one to account for the length */
                  /*          field, which does not include itself.     */
                  if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                  {
                     /* Assign the DIS Service UUID.                    */
                     QAPI_BLE_DIS_ASSIGN_DIS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                     /* Update the UUID Index.                          */
                     UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                     /* Update the advertising report data entry length */
                     /* since we have added another UUID.               */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] += QAPI_BLE_UUID_16_SIZE;
                  }
                  else
                  {
                     /* Flag that we could not include all the service  */
                     /* UUIDs.                                          */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length + 1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                  }
               }

               /* If HOGP is registered.                                */
               if(HIDSInstanceID)
               {
                  /* Make sure we do not exceed the bounds of the       */
                  /* buffer.                                            */
                  /* * NOTE * We MUST add one to account for the length */
                  /*          field, which does not include itself.     */
                  if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                  {
                     /* Assign the HOGP Service UUID.                   */
                     QAPI_BLE_HIDS_ASSIGN_HIDS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                     /* Update the UUID Index.                          */
                     UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                     /* Update the advertising report data entry length */
                     /* since we have added another UUID.               */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]  += QAPI_BLE_UUID_16_SIZE;
                  }
                  else
                  {
                     /* Flag that we could not include all the service  */
                     /* UUIDs.                                          */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                  }
               }

               /* If SCPS is registered.                                */
               if(SCPSInstanceID)
               {
                  /* Make sure we do not exceed the bounds of the       */
                  /* buffer.                                            */
                  /* * NOTE * We MUST add one to account for the length */
                  /*          field, which does not include itself.     */
                  if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                  {
                     /* Assign the SCPS Service UUID.                   */
                     QAPI_BLE_SCPS_ASSIGN_SCPS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                     /* Update the UUID Index.                          */
                     UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                     /* Update the advertising report data entry length */
                     /* since we have added another UUID.               */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]  += QAPI_BLE_UUID_16_SIZE;
                  }
                  else
                  {
                     /* Flag that we could not include all the service  */
                     /* UUIDs.                                          */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                  }
               }

               /* If the local device is initialized for the SLoWP Node */
               /* role.                                                 */
               if(SLoWPNodeInitialized)
               {
                  /* Make sure we do not exceed the bounds of the       */
                  /* buffer.                                            */
                  /* * NOTE * We MUST add one to account for the length */
                  /*          field, which does not include itself.     */
                  if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                  {
                     /* Assign the IPSS Service UUID.                   */
                     QAPI_BLE_IPSS_ASSIGN_IPSS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                     /* Update the UUID Index.                          */
                     UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                     /* Update the advertising report data entry length */
                     /* since we have added another UUID.               */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]  += QAPI_BLE_UUID_16_SIZE;
                  }
                  else
                  {
                     /* Flag that we could not include all the service  */
                     /* UUIDs.                                          */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                  }
               }

               /* If TPS is registered.                                 */
               if(TPSInstanceID)
               {
                  /* Make sure we do not exceed the bounds of the       */
                  /* buffer.                                            */
                  /* * NOTE * We MUST add one to account for the length */
                  /*          field, which does not include itself.     */
                  if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                  {
                     /* Assign the TPS Service UUID.                    */
                     QAPI_BLE_TPS_ASSIGN_TPS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                     /* Update the UUID Index.                          */
                     UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                     /* Update the advertising report data entry length */
                     /* since we have added another UUID.               */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]  += QAPI_BLE_UUID_16_SIZE;
                  }
                  else
                  {
                     /* Flag that we could not include all the service  */
                     /* UUIDs.                                          */
                     ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                  }
               }

               /* Update the current length of the advertising data.    */
               /* * NOTE * We MUST add one to account for the length    */
               /*          field, which does not include itself.        */
               Length += (((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1);
            }
            else
               QCLI_Printf(ble_group, "   The 16-bit service UUID's CANNOT fit in the advertising data.\n");

            /* Write the advertising data to the chip.                  */
            Result = qapi_BLE_GAP_LE_Set_Advertising_Data(BluetoothStackID, Length, &(Advertisement_Data_Buffer.AdvertisingData));
            if(!Result)
            {
               /* Initialize the scan response data.                    */
               memset(&(Advertisement_Data_Buffer.ScanResponseData), 0, sizeof(qapi_BLE_Scan_Response_Data_t));

               /* Reset the length to zero.                             */
               Length = 0;

               /* First include the local device name.                  */
               if((Result = qapi_BLE_GAPS_Query_Device_Name(BluetoothStackID, (uint32_t)GAPSInstanceID, Name)) == 0)
               {
                  /* Get the name length.                               */
                  NameLength = strlen(Name);

                  /* Determine if we need to truncate the device name.  */
                  if(NameLength < ((unsigned int)QAPI_BLE_SCAN_RESPONSE_DATA_MAXIMUM_SIZE - 2))
                  {
                     /* Format the complete device name into the scan   */
                     /* response data.                                  */
                     ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] = (uint8_t)(1 + NameLength);
                     ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length + 1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_LOCAL_NAME_COMPLETE;
                  }
                  else
                  {
                     /* Format the truncated device name into the scan  */
                     /* response data.                                  */
                     NameLength = ((unsigned int)QAPI_BLE_SCAN_RESPONSE_DATA_MAXIMUM_SIZE - 2);
                     ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] = (uint8_t)(1 + NameLength);
                     ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length + 1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_LOCAL_NAME_SHORTENED;
                  }

                  /* Make sure we can fit the device name into the scan */
                  /* response data.                                     */
                  if((Length + NameLength + 2) <= (unsigned int)(QAPI_BLE_SCAN_RESPONSE_DATA_MAXIMUM_SIZE - 2))
                  {
                     /* Simply copy the name into the scan response     */
                     /* data.                                           */
                     memcpy(&(((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length + 2]), Name, NameLength);

                     /* Update the current length of the scan response  */
                     /* data.                                           */
                     /* * NOTE * We MUST add one to account for the     */
                     /*          length field, which does not include   */
                     /*          itself.                                */
                     Length += (((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] + 1);
                  }
                  else
                     QCLI_Printf(ble_group, "   The device name CANNOT fit in the scan response data.\n", Result);
               }
               else
                  QCLI_Printf(ble_group, "   qapi_BLE_GAPS_Query_Device_Name(dtAdvertising) returned %d.\n", Result);

               /* Include the 128-bit service UUIDs if the service is   */
               /* registered.                                           */
               /* * NOTE * SPPLE is the only 128-bit UUID supported by  */
               /*          this demo.                                   */

               /* If SPPLE is registered.                               */
               if(SPPLEServiceID)
               {
                  /* Make sure we have room in the buffer.              */
                  if((Length + (unsigned int)QAPI_BLE_UUID_128_SIZE + 2) <= (unsigned int)QAPI_BLE_SCAN_RESPONSE_DATA_MAXIMUM_SIZE)
                  {
                     ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length]   = 1;
                     ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_128_BIT_SERVICE_UUID_COMPLETE;

                     /* Assign the SPPLE Service UUID.                  */
                     SPPLE_ASSIGN_SPPLE_SERVICE_UUID_128(&(((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length+2]));

                     /* Update the UUID Index.                          */
                     UUIDIndex += QAPI_BLE_UUID_128_SIZE;

                     /* Update the advertising report data entry length */
                     /* since we have added another UUID.               */
                     ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] += QAPI_BLE_UUID_128_SIZE;

                     /* Update the current length of the advertising    */
                     /* data.                                           */
                     /* * NOTE * We MUST add one to account for the     */
                     /*          length field, which does not include   */
                     /*          itself.                                */
                     Length += (((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] + 1);
                  }
                  else
                     QCLI_Printf(ble_group, "   The 128-bit SPPLE Service UUID CANNOT fit in the scan response data.\n");
               }

               Result = qapi_BLE_GAP_LE_Set_Scan_Response_Data(BluetoothStackID, Length, &(Advertisement_Data_Buffer.ScanResponseData));
               if(!Result)
               {
                  /* Configure the advertising channel map for the      */
                  /* default advertising parameters.                    */
#ifndef V1
                  BLEParameters.AdvertisingParameters.Advertising_Channel_Map = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_DEFAULT;
#else
                  switch(Parameter_List[0].Integer_Value)
                  {
                     case AET_ENABLE_ALL_E:
                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = (QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_37 | QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_38);
                        break;
                     case AET_ENABLE_CHANNEL_37_E:
                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_37;
                        break;
                     case AET_ENABLE_CHANNEL_38_E:
                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_38;
                        break;
                     case AET_ENABLE_CHANNEL_39_E:
                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_39;
                        break;
                     default:
                        /* Enable all channels if the user specified and*/
                        /* invalid enumeration.                         */
                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = (QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_37 | QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_38);
                        break;
                  }
#endif

                  /* Set up the default advertising parameters if they  */
                  /* have not been configured at the CLI.               */
                  if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID))
                  {
                     /* Configure the remaining default advertising     */
                     /* parameters.                                     */
                     BLEParameters.AdvertisingParameters.Scan_Request_Filter       = QAPI_BLE_FP_NO_FILTER_E;
                     BLEParameters.AdvertisingParameters.Connect_Request_Filter    = QAPI_BLE_FP_NO_FILTER_E;
                     BLEParameters.AdvertisingParameters.Advertising_Interval_Min  = 100;
                     BLEParameters.AdvertisingParameters.Advertising_Interval_Max  = 200;

                     /* Flag that the parameters are valid so we don't  */
                     /* set them unnecessarily.                         */
                     BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID;
                  }

                  /* Configure the Connectability Parameters.           */
                  /* * NOTE * We will ALWAYS advertise                  */
                  ConnectabilityParameters.Connectability_Mode = LE_Parameters.ConnectableMode;
                  ConnectabilityParameters.Own_Address_Type    = QAPI_BLE_LAT_PUBLIC_E;

                  /* If the connectable mode is set for direct          */
                  /* connectable.                                       */
                  if((ConnectabilityParameters.Connectability_Mode == QAPI_BLE_LCM_LOW_DUTY_CYCLE_DIRECT_CONNECTABLE_E) || (ConnectabilityParameters.Connectability_Mode == QAPI_BLE_LCM_DIRECT_CONNECTABLE_E))
                  {
                     /* We will set our own address type to resolvable  */
                     /* fallback public.                                */
                     ConnectabilityParameters.Own_Address_Type = QAPI_BLE_LAT_RESOLVABLE_FALLBACK_PUBLIC_E;
                  }

                  /* Initialize the direct address to zero and the type */
                  /* to public.                                         */
                  /* * NOTE * If the ConnectableMode is set to one of   */
                  /*          the Direct Connectable types, then the    */
                  /*          direct address and type MUST be specified.*/
                  /*          If they are NOT specified, then           */
                  /*          qapi_BLE_GAP_LE_Advertising_Enable() will */
                  /*          fail.                                     */
                  ConnectabilityParameters.Direct_Address_Type   = QAPI_BLE_LAT_PUBLIC_E;
                  QAPI_BLE_ASSIGN_BD_ADDR(ConnectabilityParameters.Direct_Address, 0, 0, 0, 0, 0, 0);

                  /* If the user has supplied the direct address and    */
                  /* direct address type we will store them.            */
                  if((Parameter_Count >= 2) && (strlen((char *)(Parameter_List[1].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
                  {
                     /* Convert the parameter to a Bluetooth Device     */
                     /* Address.                                        */
                     StrToBD_ADDR((char *)(Parameter_List[1].String_Value), &BD_ADDR);

                     /* We will assume that the user has supplied the   */
                     /* public address of the remote device for direct  */
                     /* advertising.                                    */
                     ConnectabilityParameters.Direct_Address_Type = QAPI_BLE_LAT_PUBLIC_E;
                     ConnectabilityParameters.Direct_Address      = BD_ADDR;

                     /* Lock the Bluetooth stack.                       */
                     if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
                     {
                        /* Let's attempt to find the remote device      */
                        /* information for the user specified remote    */
                        /* device address.                              */
                        /* * NOTE * We can only use the resolving list  */
                        /*          in the controller to generate an RPA*/
                        /*          if we have the identity address     */
                        /*          information and the IRK that was    */
                        /*          exchanged during pairing.  This     */
                        /*          information was used to add the     */
                        /*          remote device to the resolving list */
                        /*          so we need to make sure that it is  */
                        /*          valid                               */
                        if((RemoteDevice = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
                        {
                           /* Make sure the remote device was added to  */
                           /* the resolving list.                       */
                           /* * NOTE * If this is set, then the IRK and */
                           /*          identity information are also    */
                           /*          valid.                           */
                           if(RemoteDevice->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST)
                           {
                              /* Store the direct address and type.     */
                              /* * NOTE * The controller will search the*/
                              /*          resolving list for an entry   */
                              /*          matching the identity address */
                              /*          and identity address type.  If*/
                              /*          an entry is found, the IRK    */
                              /*          will be used to generate an   */
                              /*          RPA that will be used as the  */
                              /*          direct advertising address.   */
                              ConnectabilityParameters.Direct_Address_Type = RemoteDevice->IdentityAddressType;
                              ConnectabilityParameters.Direct_Address      = RemoteDevice->IdentityAddressBD_ADDR;
                           }
                        }

                        /* Un-lock the Bluetooth Stack.                 */
                        qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
                     }
                  }
                  else
                  {
                     /* If the user did NOT supply the direct address,  */
                     /* then we need to make sure we are NOT in the a   */
                     /* direct connectable mode.                        */
                     if((ConnectabilityParameters.Connectability_Mode == QAPI_BLE_LCM_LOW_DUTY_CYCLE_DIRECT_CONNECTABLE_E) || (ConnectabilityParameters.Connectability_Mode == QAPI_BLE_LCM_DIRECT_CONNECTABLE_E))
                     {
                        /* Override the local device's connectable mode.*/
                        /* * NOTE * If this is NOT done, then           */
                        /*          qapi_BLE_GAP_LE_Advertising_Enable()*/
                        /*          will fail.                          */
                        ConnectabilityParameters.Own_Address_Type    = QAPI_BLE_LAT_PUBLIC_E;
                        ConnectabilityParameters.Connectability_Mode = QAPI_BLE_LCM_CONNECTABLE_E;

                        /* Inform the user.                             */
                        QCLI_Printf(ble_group, "Using connectable un-directed advertising with public address.\n");
                     }
                  }

                     /* Now enable advertising.                         */
                  Result = qapi_BLE_GAP_LE_Advertising_Enable(BluetoothStackID, TRUE, &(BLEParameters.AdvertisingParameters), &(ConnectabilityParameters), GAP_LE_Event_Callback, 0);
                  if(!Result)
                  {
                     QCLI_Printf(ble_group, "   GAP_LE_Advertising_Enable success, Advertising Interval Range: %u - %u.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Min, (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Max);

                     ret_val = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                  {
                     QCLI_Printf(ble_group, "   GAP_LE_Advertising_Enable returned %d.\n", Result);

                     ret_val = QCLI_STATUS_ERROR_E;
                  }
               }
               else
               {
                  QCLI_Printf(ble_group, "   qapi_BLE_GAP_LE_Set_Advertising_Data(dtScanResponse) returned %d.\n", Result);

                  ret_val = QCLI_STATUS_ERROR_E;
               }

            }
            else
            {
               QCLI_Printf(ble_group, "   qapi_BLE_GAP_LE_Set_Advertising_Data(dtAdvertising) returned %d.\n", Result);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
      }
      else
      {
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for starting an LE scan     */
   /* procedure.  This function returns zero if successful and a        */
   /* negative value if an error occurred.                              */
static QCLI_Command_Status_t ScanLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   unsigned int                    Duration;
   QCLI_Command_Status_t           ret_val;
   qapi_BLE_GAP_LE_Filter_Policy_t FilterPolicy;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Verify the command line parameters.                            */
      if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && ((Parameter_List[0].Integer_Value == 0) || (Parameter_List[0].Integer_Value == 1)))
      {
         /* Check to see if we are enabling or disabling scanning.      */
         if(Parameter_List[0].Integer_Value == 0)
         {
            /* Check to see if we are in fact in the process of         */
            /* scanning.                                                */
            if(ScanInProgress)
            {
               /* Simply stop scanning.                                 */
               if(!StopScan(BluetoothStackID))
               {
                  /* Flag that scanning is not in progess.              */
                  ScanInProgress = FALSE;

                  /* Return success to the caller.                      */
                  ret_val        = QCLI_STATUS_SUCCESS_E;
               }
               else
                  ret_val = QCLI_STATUS_ERROR_E;
            }
            else
            {
               QCLI_Printf(ble_group, "Scanning is not in progress.\n");

               ret_val = QCLI_STATUS_SUCCESS_E;
            }
         }
         else
         {
            /* Check to see if scanning is in progress.                 */
            if(!ScanInProgress)
            {
               /* Determine if the optional filter policy is specified. */
               if((Parameter_Count >= 2) && (Parameter_List) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= QAPI_BLE_FP_NO_FILTER_E) && (Parameter_List[1].Integer_Value <= QAPI_BLE_FP_WHITE_LIST_DIRECTED_RPA_E))
               {
                  /* Store the user specified filter policy.            */
                  FilterPolicy = (qapi_BLE_GAP_LE_Filter_Policy_t)Parameter_List[1].Integer_Value;
               }
               else
               {
                  /* Otherwise we will use no filter.                   */
                  FilterPolicy = QAPI_BLE_FP_NO_FILTER_E;
               }

               /* Check to see if an optional duration is specified.    */
               if((Parameter_Count >= 3) && (Parameter_List) && (Parameter_List[2].Integer_Is_Valid))
                  Duration = Parameter_List[2].Integer_Value;
               else
                  Duration = 0;

               /* Simply start scanning.                                */
               if(!StartScan(BluetoothStackID, FilterPolicy, Duration))
               {
                  /* Flag that scanning is in progess.                  */
                  ScanInProgress = TRUE;

                  /* Return success to the caller.                      */
                  ret_val        = QCLI_STATUS_SUCCESS_E;
               }
               else
                  ret_val = QCLI_STATUS_ERROR_E;
            }
            else
            {
               QCLI_Printf(ble_group, "Scan already in progress.\n");

               ret_val = QCLI_STATUS_SUCCESS_E;
            }
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for connecting to a remote  */
   /* LE device.  This function returns zero if successful and a        */
   /* negative value if an error occurred.                              */
static QCLI_Command_Status_t ConnectLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   qapi_BLE_BD_ADDR_t    BD_ADDR;
   QCLI_Command_Status_t ret_val;
   boolean_t             UseWhiteList;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Next, make sure that a valid device address exists.            */
      if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 1))
      {
         /* Store if the user has requested to use the White List in the*/
         /* controller.                                                 */
         if(Parameter_List[0].Integer_Value == 1)
            UseWhiteList = TRUE;
         else
            UseWhiteList = FALSE;

         /* Check to see if scanning is in progress, if so cancel it.   */
         if(ScanInProgress)
         {
            /* Attempt to stop scanning.                                */
            if(!StopScan(BluetoothStackID))
               ScanInProgress = FALSE;

            QCLI_Printf(ble_group, "Scan stopped before making LE Connection\n");
         }

         /* If we are NOT using the White List in the controller, then  */
         /* the local device will send a connection request when a      */
         /* connectable advertisement is received from a remote device  */
         /* in the White List.                                          */
         /* * NOTE * A remote device and address type MUST have         */
         /*          previously been added to the White List in the     */
         /*          controller.                                        */
         if(UseWhiteList)
         {
            /* Attempt to connect using the White List in the           */
            /* controller.                                              */
            /* * NOTE * The remote address and address type are NOT     */
            /*          used.                                           */
            if(!ConnectLEDevice(BluetoothStackID, UseWhiteList, NULL, 0))
               ret_val = QCLI_STATUS_SUCCESS_E;
            else
               ret_val = QCLI_STATUS_ERROR_E;
         }
         else
         {
            /* Make sure the remote address and address type have been  */
            /* specified.                                               */
            if((Parameter_Count >= 3) && (Parameter_List[1].String_Value) && (strlen((char *)(Parameter_List[1].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= QAPI_BLE_LAT_PUBLIC_E) && (Parameter_List[2].Integer_Value <= QAPI_BLE_LAT_RANDOM_IDENTITY_E))
            {
               /* Convert the parameter to a Bluetooth Device Address.  */
               StrToBD_ADDR((char *)(Parameter_List[1].String_Value), &BD_ADDR);

               /* Attempt to connect to the specified remote address and*/
               /* address type.                                         */
               if(!ConnectLEDevice(BluetoothStackID, UseWhiteList, &BD_ADDR, (qapi_BLE_GAP_LE_Address_Type_t)Parameter_List[2].Integer_Value))
                  ret_val = QCLI_STATUS_SUCCESS_E;
               else
                  ret_val = QCLI_STATUS_ERROR_E;
            }
            else
               ret_val = QCLI_STATUS_USAGE_E;
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for disconnecting to an LE  */
   /* device.  This function returns zero if successful and a negative  */
   /* value if an error occurred.                                       */
static QCLI_Command_Status_t DisconnectLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Next, check to make sure we are currently connected.           */
      /* * NOTE * If we are connected, then the a remote device MUST be */
      /*          selected.                                             */
      if(ConnectionCount)
      {
         /* Disconnect the selected remote device.                      */
         ret_val = qapi_BLE_GAP_LE_Disconnect(BluetoothStackID, SelectedRemoteBD_ADDR);
         if(!ret_val)
            QCLI_Printf(ble_group, "Disconnect Request successful.\n");

         else
            QCLI_Printf(ble_group, "Unable to disconnect device: %d.\n", ret_val);

         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         QCLI_Printf(ble_group, "Device is not connected.\n");

         ret_val = QCLI_STATUS_SUCCESS_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for canceling an active LE  */
   /* connection process to an LE device.  This function returns zero if*/
   /* successful and a negative value if an error occurred.             */
static QCLI_Command_Status_t CancelConnectLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Attempt to cancel the connection process.                      */
      Result = qapi_BLE_GAP_LE_Cancel_Create_Connection(BluetoothStackID);
      if(!Result)
         ret_val = QCLI_STATUS_SUCCESS_E;
      else
      {
         QCLI_Printf(ble_group, "Unable to cancel LE connection process: %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is provided to allow a mechanism of        */
   /* Pairing (or requesting security if a slave) to the connected      */
   /* device.                                                           */
static QCLI_Command_Status_t PairLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Next, check to make sure we are currently connected.           */
      /* * NOTE * If we are connected, then the a remote device MUST be */
      /*          selected.                                             */
      if(ConnectionCount)
      {
         /* Make sure we are not pairing/re-establishing security with  */
         /* another remote device.                                      */
         if(QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
         {
            /* Attempt to send the pairing request.                     */
            if(!SendPairingRequest(SelectedRemoteBD_ADDR, LocalDeviceIsMaster))
               ret_val = QCLI_STATUS_SUCCESS_E;
            else
               ret_val = QCLI_STATUS_ERROR_E;
         }
         else
         {
            /* Inform the user that we cannot pair/re-establish security*/
            /* at this time.                                            */
            QCLI_Printf(ble_group, "\nSecurity is already in progress with another remote device.\n");
            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(ble_group, "Device is not connected.\n");

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is provided to allow a mechanism of        */
   /* Un-Pairing a remote device device.                                */
   /* * NOTE * It is the caller's responsibility to make sure that the  */
   /*          remote device has been removed from the white            */
   /*          list/resolving list. Otherwise the remote device         */
   /*          information will be deleted when the remote device       */
   /*          disconnects (and it has not re-paired). The information  */
   /*          needed to remove the remote device from the lists is     */
   /*          contained in the remote device information.              */
static QCLI_Command_Status_t UnPairRemoteDevice(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int           ret_val;
   DeviceInfo_t *DeviceInfo;
   BoardStr_t    BoardStr;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Next, check to make sure we are currently connected.           */
      /* * NOTE * If we are connected, then the a remote device MUST be */
      /*          selected.                                             */
      if(ConnectionCount)
      {
         /* Verify that the input parameters are semi-valid.            */
         if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value > 0))
         {
            /* Lock the Bluetooth stack.                                */
            if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
            {
               /* Get the device info for the remote device.            */
               if((DeviceInfo = SearchDeviceInfoEntryByConnectionID(&DeviceInfoList, (unsigned int)(Parameter_List[0].Integer_Value))) != NULL)
               {
                  /* We will simply flag that the LTK key is no longer  */
                  /* valid. This will cause the remote device           */
                  /* information to be deleted when a remote device     */
                  /* disconnects.                                       */
                  DeviceInfo->Flags &= ~((uint8_t)DEVICE_INFO_FLAGS_LTK_VALID);

                  /* Inform the user.                                   */
                  QCLI_Printf(ble_group, "\nUnpaired Remote Device:\n");
                  BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
                  QCLI_Printf(ble_group, "   Address:  %s\n", BoardStr);
                  QCLI_Printf(ble_group, "   ID:       %u\n", DeviceInfo->ConnectionID);

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(ble_group, "No device info for the specified GATT Connection ID.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }

               /* Un-lock the Bluetooth Stack.                          */
               qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
            }
            else
            {
               QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
      else
      {
         QCLI_Printf(ble_group, "No Connection Established.\n");

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is respoinsible for selecting a remote     */
   /* device.  This is necessary if multiple remote devices are         */
   /* connected.                                                        */
   /* * NOTE * The selected remote device may be changed during a       */
   /*          pairing/security re-establishment process since the      */
   /*          SecurityRemoteBD_ADDR is used to store the remote device */
   /*          address during this process.                             */
static QCLI_Command_Status_t SelectRemoteDevice(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int           ret_val;
   DeviceInfo_t *DeviceInfo;
   BoardStr_t    BoardStr;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Next, check to make sure we are currently connected.           */
      /* * NOTE * If we are connected, then the a remote device MUST be */
      /*          selected.                                             */
      if(ConnectionCount)
      {
         /* Verify that the input parameters are semi-valid.            */
         if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value > 0))
         {
            /* Lock the Bluetooth stack.                                */
            if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
            {
               /* Get the device info for the remote device.            */
               if((DeviceInfo = SearchDeviceInfoEntryByConnectionID(&DeviceInfoList, (unsigned int)(Parameter_List[0].Integer_Value))) != NULL)
               {
                  /* Simply update the address of the selected remote   */
                  /* device.                                            */
                  SelectedRemoteBD_ADDR = DeviceInfo->RemoteAddress;

                  /* Inform the user of the selected remote device.     */
                  QCLI_Printf(ble_group, "\nSelected Remote Device:\n");
                  BD_ADDRToStr(SelectedRemoteBD_ADDR, BoardStr);
                  QCLI_Printf(ble_group, "   Address:  %s\n", BoardStr);
                  QCLI_Printf(ble_group, "   ID:       %u\n", DeviceInfo->ConnectionID);

                  ret_val               = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(ble_group, "No device info for the specified GATT Connection ID.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }

               /* Un-lock the Bluetooth Stack.                          */
               qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
            }
            else
            {
               QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
      else
      {
         QCLI_Printf(ble_group, "No Connection Established.\n");

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for displaying all remote   */
   /* device information that is stored by the local device.            */
   /* * NOTE * A remote device information entry may exist for a remote */
   /*          device even if we are NOT connected.  This will occur if */
   /*          we have previously paired with the remote device.  In    */
   /*          this case, the remote device information entry will NOT  */
   /*          be deleted when the remote device is disconnected.  If   */
   /*          the remote device is NOT connected, then the GATT        */
   /*          Connection ID will be zero.                              */
static QCLI_Command_Status_t DisplayRemoteDevices(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   BoardStr_t             BoardStr;
   unsigned int           Index;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val;

   /* Lock the Bluetooth stack.                                         */
   if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
   {
      /* Loop through the device information list.                      */
      DeviceInfo = DeviceInfoList;
      Index      = 0;
      while(DeviceInfo)
      {
         /* Display the information for the remote device.              */
         QCLI_Printf(ble_group, "\nDevice Information Entry (%u):\n", Index++);
         QCLI_Printf(ble_group, "   Selected:   %s\n", ((QAPI_BLE_COMPARE_BD_ADDR(SelectedRemoteBD_ADDR, DeviceInfo->RemoteAddress)) ? "Yes" : "No"));
         BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
         QCLI_Printf(ble_group, "   Address:    %s\n", BoardStr);
         QCLI_Printf(ble_group, "   Type:       ");
         switch(DeviceInfo->RemoteAddressType)
         {
            case QAPI_BLE_LAT_PUBLIC_E:
               QCLI_Printf(ble_group, "QAPI_BLE_LAT_PUBLIC_E\n");
               break;
            case QAPI_BLE_LAT_RANDOM_E:
               QCLI_Printf(ble_group, "QAPI_BLE_LAT_RANDOM_E\n");
               break;
            case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
               QCLI_Printf(ble_group, "QAPI_BLE_LAT_PUBLIC_IDENTITY_E\n");
               break;
            case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
               QCLI_Printf(ble_group, "QAPI_BLE_LAT_RANDOM_IDENTITY_E\n");
               break;
            default:
               QCLI_Printf(ble_group, "Invalid\n");
               break;
         }
         QCLI_Printf(ble_group, "   Connected:  %s\n", (DeviceInfo->ConnectionID) ? "Yes" : "No");
         QCLI_Printf(ble_group, "   ID:         %u\n", DeviceInfo->ConnectionID);
         QCLI_Printf(ble_group, "   LTK:        %s\n", (DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_LTK_VALID) ? "Yes" : "No");

         if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_LTK_VALID)
         {
            QCLI_Printf(ble_group, "   LTK:        0x%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n", DeviceInfo->LTK.Long_Term_Key0,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key1,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key2,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key3,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key4,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key5,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key6,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key7,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key8,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key9,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key10,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key11,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key12,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key13,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key14,
                                                                                                                          DeviceInfo->LTK.Long_Term_Key15);


         }

         QCLI_Printf(ble_group, "   IRK:        %s\n", (DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_IRK_VALID) ? "Yes" : "No");

         if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_IRK_VALID)
         {
            BD_ADDRToStr(DeviceInfo->IdentityAddressBD_ADDR, BoardStr);
            QCLI_Printf(ble_group, "   Identity Address:      %s\n", BoardStr);

            switch(DeviceInfo->IdentityAddressType)
            {
               case QAPI_BLE_LAT_PUBLIC_E:
                  QCLI_Printf(ble_group, "   Identity Address Type: %s\n", "Public");
                  break;
               case QAPI_BLE_LAT_RANDOM_E:
                  QCLI_Printf(ble_group, "   Identity Address Type: %s\n", "Random");
                  break;
               case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                  QCLI_Printf(ble_group, "   Identity Address Type: %s\n", "Public Identity");
                  break;
               case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                  QCLI_Printf(ble_group, "   Identity Address Type: %s\n", "Random Identity");
                  break;
               default:
                  QCLI_Printf(ble_group, "   Identity Address Type: %s\n", "Default");
                  break;
            }
         }

         DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
      }

      /* Un-lock the Bluetooth Stack.                                   */
      qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);

      /* Return success to the caller.                                  */
      ret_val = QCLI_STATUS_SUCCESS_E;
   }
   else
   {
      QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for adding a remote device  */
   /* to the white list in the controller.  This function returns zero  */
   /* if successful and a negative value if an error occurred.          */
   /* * NOTE * If a remote device has been successfully added to the    */
   /*          white list in the controller, then the white list may be */
   /*          used when scanning or connecting to the remote device.   */
static QCLI_Command_Status_t AddDeviceToWhiteList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint32_t                            AddedDeviceCount;
   DeviceInfo_t                       *DeviceInfo;
   qapi_BLE_BD_ADDR_t                  BD_ADDR;
   QCLI_Command_Status_t               ret_val;
   qapi_BLE_GAP_LE_Address_Type_t      AddressType;
   qapi_BLE_GAP_LE_White_List_Entry_t  WhiteListEntry;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_Count >= 2) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[1].Integer_Is_Valid) && ((Parameter_List[1].Integer_Value == 255) || ((Parameter_List[1].Integer_Value >= (int32_t)QAPI_BLE_LAT_PUBLIC_E) && (Parameter_List[1].Integer_Value <= (int32_t)QAPI_BLE_LAT_RANDOM_IDENTITY_E))))
      {
         /* Convert the parameter to a Bluetooth Device Address.        */
         StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

         /* Convert the address type.                                   */
         if(Parameter_List[1].Integer_Value == 255)
            AddressType = QAPI_BLE_LAT_ANONYMOUS_E;
         else
            AddressType = (qapi_BLE_GAP_LE_Address_Type_t)Parameter_List[1].Integer_Value;

         /* Initialize the Device Info Pointer.                         */
         DeviceInfo  = NULL;

         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Check to see if we are adding anonymous device entry.    */
            if(AddressType != QAPI_BLE_LAT_ANONYMOUS_E)
            {
               /* Get the device info for the remote device.            */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
               {
                  /* Make sure the remote device is NOT already in the  */
                  /* white list.                                        */
                  if(!(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST))
                  {
                     /* Format the white list entry.                    */
                     if((DeviceInfo->Flags & (DEVICE_INFO_FLAGS_IRK_VALID | DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST)) == (DEVICE_INFO_FLAGS_IRK_VALID | DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST))
                     {
                        DeviceInfo->WhiteListEntry.Address      = DeviceInfo->IdentityAddressBD_ADDR;
                        DeviceInfo->WhiteListEntry.Address_Type = DeviceInfo->IdentityAddressType;
                     }
                     else
                     {
                        DeviceInfo->WhiteListEntry.Address      = BD_ADDR;
                        DeviceInfo->WhiteListEntry.Address_Type = AddressType;
                     }

   #ifdef V2

                     /* Configure as wakeup source.                     */
                     DeviceInfo->WhiteListEntry.WakeOnBLESource = TRUE;

   #endif

                     /* Indicate we have been successful so far.        */
                     WhiteListEntry = DeviceInfo->WhiteListEntry;

                     ret_val        = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                  {
                     QCLI_Printf(ble_group, "Device already in the white list.\n");

                     ret_val = QCLI_STATUS_ERROR_E;
                  }
               }
               else
               {
                  QCLI_Printf(ble_group, "No Device Info.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               /* Initialize the entry.                                 */
               WhiteListEntry.Address_Type    = QAPI_BLE_LAT_ANONYMOUS_E;
               QAPI_BLE_ASSIGN_BD_ADDR(WhiteListEntry.Address, 0, 0, 0, 0, 0, 0);

#ifdef V2
               WhiteListEntry.WakeOnBLESource = FALSE;
#endif

               /* Indicate we are ready to send the command.            */
               ret_val                        = QCLI_STATUS_SUCCESS_E;
            }

            /* Continue only if no error occurred.                      */
            if(ret_val == QCLI_STATUS_SUCCESS_E)
            {
               /* Let's add the device to the white list in the         */
               /* controller.                                           */
               /* * NOTE * We will only add one device, however we could*/
               /*          add more with this function.                 */
               ret_val = qapi_BLE_GAP_LE_Add_Device_To_White_List(BluetoothStackID, 1, &WhiteListEntry, &AddedDeviceCount);
               if(!ret_val)
               {
                  QCLI_Printf(ble_group, "qapi_BLE_GAP_LE_Add_Device_To_White_List() success.\n");
                  QCLI_Printf(ble_group, "   Added devices:  %u.\n", (unsigned int)AddedDeviceCount);

                  /* Flag that the remote device has been added to the  */
                  /* white list.                                        */
                  if(DeviceInfo != NULL)
                     DeviceInfo->Flags |= (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST;

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(ble_group, "Error - qapi_BLE_GAP_LE_Add_Device_To_White_List() returned %d.\n", ret_val);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
         {
            QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for removing a remote device*/
   /* from the white list in the controller.  This function returns zero*/
   /* if successful and a negative value if an error occurred.          */
static QCLI_Command_Status_t RemoveDeviceFromWhiteList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint32_t                            RemovedDeviceCount;
   DeviceInfo_t                       *DeviceInfo;
   qapi_BLE_BD_ADDR_t                  BD_ADDR;
   QCLI_Command_Status_t               ret_val;
   qapi_BLE_GAP_LE_White_List_Entry_t  WhiteListEntry;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_Count >= 1) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
      {
         /* Convert the parameter to a Bluetooth Device Address.        */
         StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

         /* Initialize the local variables.                             */
         DeviceInfo = NULL;

         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Check to see if we are removing the anonymous device.    */
            if(!QAPI_BLE_COMPARE_NULL_BD_ADDR(BD_ADDR))
            {
               /* Get the device info for the remote device.            */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
               {
                  /* Make sure the remote device has been added to the  */
                  /* white list.                                        */
                  if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST)
                  {
                     /* Use local white list entry structure.           */
                     WhiteListEntry = DeviceInfo->WhiteListEntry;

                     /* Indicate we may send the command now.           */
                     ret_val        = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                  {
                     QCLI_Printf(ble_group, "Device not in the white list.\n");

                     ret_val = QCLI_STATUS_ERROR_E;
                  }
               }
               else
               {
                  QCLI_Printf(ble_group, "No Device Info.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               /* Initialize the entry.                                 */
               WhiteListEntry.Address_Type    = QAPI_BLE_LAT_ANONYMOUS_E;
               QAPI_BLE_ASSIGN_BD_ADDR(WhiteListEntry.Address, 0, 0, 0, 0, 0, 0);

#ifdef V2
               WhiteListEntry.WakeOnBLESource = FALSE;
#endif

               /* Indicate we are ready to send the command.            */
               ret_val                        = QCLI_STATUS_SUCCESS_E;
            }

            /* Continue only if no error occurred.                      */
            if(ret_val == QCLI_STATUS_SUCCESS_E)
            {
               /* Let's remove the device from the white list in the    */
               /* controller.                                           */
               /* * NOTE * We will only remove one device, however we   */
               /*          could remove more with this function.        */
               ret_val = qapi_BLE_GAP_LE_Remove_Device_From_White_List(BluetoothStackID, 1, &WhiteListEntry, &RemovedDeviceCount);
               if(!ret_val)
               {
                  QCLI_Printf(ble_group, "qapi_BLE_GAP_LE_Remove_Device_From_White_List() success.\n");
                  QCLI_Printf(ble_group, "   Removed devices:  %u.\n", (unsigned int)RemovedDeviceCount);

                  /* Flag that the remote device has been removed from  */
                  /* the white list.                                    */
                  if(DeviceInfo != NULL)
                     DeviceInfo->Flags &= ~((uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST);

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(ble_group, "Error - qapi_BLE_GAP_LE_Remove_Device_From_White_List() returned %d.\n", ret_val);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
         {
            QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for adding a remote device  */
   /* to the resolving list in the controller.  This function returns   */
   /* zero if successful and a negative value if an error occurred.     */
   /* * NOTE * In order to add a device to the resolving list, the local*/
   /*          device MUST have exchanged the IRK and identity          */
   /*          information during a pairing procedure.                  */
   /* * NOTE * If a remote device has been successfully added to the    */
   /*          resolving list in the controller, then the resolving list*/
   /*          may be used when advertising, scanning, or connecting to */
   /*          the remote device.                                       */
static QCLI_Command_Status_t AddDeviceToResolvingList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint32_t              AddedDeviceCount;
   DeviceInfo_t         *DeviceInfo;
   qapi_BLE_BD_ADDR_t    BD_ADDR;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_Count >= 1) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
      {
         /* Convert the parameter to a Bluetooth Device Address.        */
         StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the remote device.               */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
            {
               /* Make sure the remote device is NOT already in the     */
               /* resolving list.                                       */
               if(!(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST))
               {
                  /* Make sure the remote device has the IRK, which was */
                  /* exchanged during pairing.                          */
                  /* * NOTE * If we have the IRK for the remote device, */
                  /*          then we also have the Identity            */
                  /*          Information.                              */
                  if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_IRK_VALID)
                  {
                     /* Let's add the device to the resolving list in   */
                     /* the controller.                                 */
                     /* * NOTE * We will only add one device, however we*/
                     /*          could add more with this function.     */
                     ret_val = qapi_BLE_GAP_LE_Add_Device_To_Resolving_List(BluetoothStackID, 1, &(DeviceInfo->ResolvingListEntry), &AddedDeviceCount);
                     if(!ret_val)
                     {
                        QCLI_Printf(ble_group, "qapi_BLE_GAP_LE_Add_Device_To_Resolving_List() success.\n");
                        QCLI_Printf(ble_group, "   Added devices:  %u.\n", (unsigned int)AddedDeviceCount);

                        /* Flag that the remote device has been added to*/
                        /* the resolving list.                          */
                        DeviceInfo->Flags |= (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST;

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                     {
                        QCLI_Printf(ble_group, "Error - qapi_BLE_GAP_LE_Add_Device_To_Resolving_List() returned %d.\n", ret_val);

                        ret_val = QCLI_STATUS_ERROR_E;
                     }
                  }
                  else
                     ret_val = QCLI_STATUS_ERROR_E;
               }
               else
               {
                  QCLI_Printf(ble_group, "Device already in the resolving list.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(ble_group, "No Device Info.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
         {
            QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for removing a remote device*/
   /* from the white list in the controller.  This function returns zero*/
   /* if successful and a negative value if an error occurred.          */
static QCLI_Command_Status_t RemoveDeviceFromResolvingList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;
   DeviceInfo_t         *DeviceInfo;
   qapi_BLE_BD_ADDR_t    BD_ADDR;
   uint32_t              RemovedDeviceCount;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_Count >= 1) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
      {
         /* Convert the parameter to a Bluetooth Device Address.        */
         StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the remote device.               */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
            {
               /* Make sure the remote device has been added to the     */
               /* resolving list.                                       */
               if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST)
               {
                  /* Let's remove the device from the resolving list in */
                  /* the controller.                                    */
                  /* * NOTE * We will only remove one device, however we*/
                  /*          could remove more with this function.     */
                  ret_val = qapi_BLE_GAP_LE_Remove_Device_From_Resolving_List(BluetoothStackID, 1, &(DeviceInfo->ResolvingListEntry), &RemovedDeviceCount);
                  if(!ret_val)
                  {
                     QCLI_Printf(ble_group, "qapi_BLE_GAP_LE_Remove_Device_From_Resolving_List() success.\n");
                     QCLI_Printf(ble_group, "   Removed devices:  %u.\n", (unsigned int)RemovedDeviceCount);

                     /* Flag that the remote device has been removed    */
                     /* from the resolving list.                        */
                     DeviceInfo->Flags &= ~((uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST);

                     ret_val = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                  {
                     QCLI_Printf(ble_group, "Error - qapi_BLE_GAP_LE_Remove_Device_From_Resolving_List() returned %d.\n", ret_val);

                     ret_val = QCLI_STATUS_ERROR_E;
                  }
               }
               else
               {
                  QCLI_Printf(ble_group, "Device not in the resolving list.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(ble_group, "No Device Info.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
         {
            QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for setting the             */
   /* authenticated payload timeout.  This function will return zero on */
   /* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t SetAuthenticatedPayloadTimeout(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;
   qapi_BLE_BD_ADDR_t    BD_ADDR;
   uint16_t              Timeout;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Make sure we are connected.                                    */
      if(ConnectionCount)
      {
         /* Verify that the input parameters are semi-valid.            */
         if((Parameter_Count >= 2) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1))
         {
            /* Convert the parameter to a Bluetooth Device Address.     */
            StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

            /* Store the Timeout.                                       */
            Timeout = (uint16_t)Parameter_List[1].Integer_Value;

            /* Let's set the Authenticated Payload Timeout for the      */
            /* specified remote device.                                 */
            ret_val = qapi_BLE_GAP_LE_Set_Authenticated_Payload_Timeout(BluetoothStackID, BD_ADDR, Timeout);
            if(!ret_val)
            {
               QCLI_Printf(ble_group, "qapi_BLE_GAP_LE_Set_Authenticated_Payload_Timeout() success.\n");

               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               QCLI_Printf(ble_group, "Error - qapi_BLE_GAP_LE_Set_Authenticated_Payload_Timeout() returned %d.\n", ret_val);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
      else
      {
         QCLI_Printf(ble_group, "No Connection Established.\n");

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is provided to get the parameters used when*/
   /* performing a BLE Scan Procedure (or outgoing connection).  This   */
   /* function returns QCLI_STATUS_SUCCESS_E on success or an error     */
   /* enumeration if an error occurs.                                   */
static QCLI_Command_Status_t GetScanParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if(BluetoothStackID)
   {
      /* Check to see if the scan parameters are valid.                 */
      if(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID)
      {
         /* Print the new parameters.                                   */
         QCLI_Printf(ble_group, "Scan Window:   %u ms.\n", (unsigned int)BLEParameters.ScanParameters.ScanWindow);
         QCLI_Printf(ble_group, "Scan Interval: %u ms.\n", (unsigned int)BLEParameters.ScanParameters.ScanInterval);
      }
      else
      {
         QCLI_Printf(ble_group, "Scan Parameters have not been configured.\n");
      }

      /* Flag that the function was successful.                         */
      ret_val = QCLI_STATUS_SUCCESS_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is provided to set the parameters used when*/
   /* performing a BLE Scan Procedure (or outgoing connection).  This   */
   /* function returns QCLI_STATUS_SUCCESS_E on success or an error     */
   /* enumeration if an error occurs.                                   */
static QCLI_Command_Status_t SetScanParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint16_t              ScanInterval;
   uint16_t              ScanWindow;
   QCLI_Command_Status_t ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if(BluetoothStackID)
   {
      /* Next check to see if the parameters required for the execution */
      /* of this function appear to be semi-valid.                      */
      if((Parameter_Count >= 2) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid))
      {
         /* Assign the parameters into temporary variables.             */
         ScanInterval = (uint16_t)Parameter_List[0].Integer_Value;
         ScanWindow   = (uint16_t)Parameter_List[1].Integer_Value;

         /* Next make sure that the Scan Window is less than the Scan   */
         /* Interval.                                                   */
         if(ScanWindow <= ScanInterval)
         {
            /* Next verify the Scan Window against the min and max in   */
            /* the specification.                                       */
            if((ScanWindow >= QAPI_BLE_MINIMUM_LE_SCAN_WINDOW) && (ScanWindow <= QAPI_BLE_MAXIMUM_LE_SCAN_WINDOW))
            {
               /* Next verify the Scan Interval against the min and max */
               /* in the specification.                                 */
               if((ScanInterval >= QAPI_BLE_MINIMUM_LE_SCAN_INTERVAL) && (ScanInterval <= QAPI_BLE_MAXIMUM_LE_SCAN_INTERVAL))
               {
                  /* Parameters are valid so store them.                */
                  BLEParameters.ScanParameters.ScanWindow   = ScanWindow;
                  BLEParameters.ScanParameters.ScanInterval = ScanInterval;

                  /* Flag that the parameters are valid.                */
                  BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID;

                  /* Print the new parameters.                          */
                  QCLI_Printf(ble_group, "Scan Window:   %u ms.\n", (unsigned int)BLEParameters.ScanParameters.ScanWindow);
                  QCLI_Printf(ble_group, "Scan Interval: %u ms.\n", (unsigned int)BLEParameters.ScanParameters.ScanInterval);

                  /* Flag that the function was successful.             */
                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(ble_group, "Scan Interval (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)ScanInterval, (unsigned int)QAPI_BLE_MINIMUM_LE_SCAN_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_LE_SCAN_INTERVAL);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(ble_group, "Scan Window (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)ScanWindow, (unsigned int)QAPI_BLE_MINIMUM_LE_SCAN_WINDOW, (unsigned int)QAPI_BLE_MAXIMUM_LE_SCAN_WINDOW);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(ble_group, "Scan Window (%u ms) MUST be less than or equal to Scan Interval (%u ms).\n", (unsigned int)ScanWindow, (unsigned int)ScanInterval);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is provided to query the parameters used   */
   /* when performing a BLE Advertising Procedure.  This function       */
   /* returns QCLI_STATUS_SUCCESS_E on success or an error enumeration  */
   /* if an error occurs.                                               */
static QCLI_Command_Status_t GetAdvertisingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if(BluetoothStackID)
   {
      /* Check to see if the scan parameters are valid.                 */
      if(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID)
      {
         /* Print the new parameters.                                   */
         QCLI_Printf(ble_group, "Minimum Advertising Interval: %u ms.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Min);
         QCLI_Printf(ble_group, "Maximum Advertising Interval: %u ms.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Max);
      }
      else
      {
         QCLI_Printf(ble_group, "Advertising Parameters have not been configured.\n");
      }

      /* Flag that the function was successful.                         */
      ret_val = QCLI_STATUS_SUCCESS_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is provided to set the parameters used when*/
   /* performing a BLE Advertising Procedure.  This function returns    */
   /* QCLI_STATUS_SUCCESS_E on success or an error enumeration if an    */
   /* error occurs.                                                     */
static QCLI_Command_Status_t SetAdvertisingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint16_t              AdvIntervalMin;
   uint16_t              AdvIntervalMax;
   QCLI_Command_Status_t ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if(BluetoothStackID)
   {
      /* Next check to see if the parameters required for the execution */
      /* of this function appear to be semi-valid.                      */
      if((Parameter_Count >= 2) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid))
      {
         /* Assign the parameters into temporary variables.             */
         AdvIntervalMin = (uint16_t)Parameter_List[0].Integer_Value;
         AdvIntervalMax = (uint16_t)Parameter_List[1].Integer_Value;

         /* Next make sure that the Min is less than the Max.           */
         if(AdvIntervalMin <= AdvIntervalMax)
         {
            /* Next verify the Minimum Advertising Interval against the */
            /* min and max in the specification.                        */
            if((AdvIntervalMin >= QAPI_BLE_MINIMUM_ADVERTISING_INTERVAL) && (AdvIntervalMin <= QAPI_BLE_MAXIMUM_ADVERTISING_INTERVAL))
            {
               /* Next verify the Maximum Advertising Interval against  */
               /* the min and max in the specification.                 */
               if((AdvIntervalMax >= QAPI_BLE_MINIMUM_ADVERTISING_INTERVAL) && (AdvIntervalMax <= QAPI_BLE_MAXIMUM_ADVERTISING_INTERVAL))
               {
                  /* Configure the advertising parameters.              */
#ifndef V1
                  BLEParameters.AdvertisingParameters.Advertising_Channel_Map   = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_DEFAULT;
#else
                  BLEParameters.AdvertisingParameters.Advertising_Channel_Map   = (QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_37 | QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_38);
#endif
                  BLEParameters.AdvertisingParameters.Scan_Request_Filter       = QAPI_BLE_FP_NO_FILTER_E;
                  BLEParameters.AdvertisingParameters.Connect_Request_Filter    = QAPI_BLE_FP_NO_FILTER_E;
                  BLEParameters.AdvertisingParameters.Advertising_Interval_Min  = AdvIntervalMin;
                  BLEParameters.AdvertisingParameters.Advertising_Interval_Max  = AdvIntervalMax;

                  /* Flag that the parameters are valid.                */
                  BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID;

                  /* Print the new parameters.                          */
                  QCLI_Printf(ble_group, "Minimum Advertising Interval: %u ms.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Min);
                  QCLI_Printf(ble_group, "Maximum Advertising Interval: %u ms.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Max);

                  /* Flag that the function was successful.             */
                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(ble_group, "Advertising Interval Max (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)AdvIntervalMax, (unsigned int)QAPI_BLE_MINIMUM_ADVERTISING_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_ADVERTISING_INTERVAL);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(ble_group, "Advertising Interval Min (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)AdvIntervalMin, (unsigned int)QAPI_BLE_MINIMUM_ADVERTISING_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_ADVERTISING_INTERVAL);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(ble_group, "Minimum Advertising Interval (%u ms) MUST be less than or equal to the Maximum Advertising Interval (%u ms).\n", (unsigned int)AdvIntervalMin, (unsigned int)AdvIntervalMax);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is provided to query the parameters used   */
   /* when performing a BLE Connection Procedure.  This function returns*/
   /* QCLI_STATUS_SUCCESS_E on success or an error enumeration if an    */
   /* error occurs.                                                     */
static QCLI_Command_Status_t GetConnectionParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if(BluetoothStackID)
   {
      /* Check to see if the scan parameters are valid.                 */
      if(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID)
      {
         /* Print the new parameters.                                   */
         QCLI_Printf(ble_group, "Minimum Connection Interval: %u ms.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Min);
         QCLI_Printf(ble_group, "Maximum Connection Interval: %u ms.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Max);
         QCLI_Printf(ble_group, "Slave Latency:               %u connection events.\n", (unsigned int)BLEParameters.ConnectionParameters.Slave_Latency);
      }
      else
      {
         QCLI_Printf(ble_group, "Connection Parameters have not been configured.\n");
      }

      /* Flag that the function was successful.                         */
      ret_val = QCLI_STATUS_SUCCESS_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is provided to set the parameters used when*/
   /* performing a BLE Connection Procedure.  This function returns     */
   /* QCLI_STATUS_SUCCESS_E on success or an error enumeration if an    */
   /* error occurs.                                                     */
static QCLI_Command_Status_t SetConnectionParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint16_t              ConnIntervalMin;
   uint16_t              ConnIntervalMax;
   uint16_t              SlaveLatency;
   QCLI_Command_Status_t ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if(BluetoothStackID)
   {
      /* Next check to see if the parameters required for the execution */
      /* of this function appear to be semi-valid.                      */
      if((Parameter_Count >= 3) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid))
      {
         /* Assign the parameters into temporary variables.             */
         ConnIntervalMin = (uint16_t)Parameter_List[0].Integer_Value;
         ConnIntervalMax = (uint16_t)Parameter_List[1].Integer_Value;
         SlaveLatency    = (uint16_t)Parameter_List[2].Integer_Value;

         /* Next make sure that the Min is less than the Max.           */
         if(ConnIntervalMin <= ConnIntervalMax)
         {
            /* Next verify the Minimum Connection Interval against the  */
            /* min and max in the specification.                        */
            if((ConnIntervalMin >= QAPI_BLE_MINIMUM_MINIMUM_CONNECTION_INTERVAL) && (ConnIntervalMin <= QAPI_BLE_MAXIMUM_MINIMUM_CONNECTION_INTERVAL))
            {
               /* Next verify the Maximum Connection Interval against   */
               /* the min and max in the specification.                 */
               if((ConnIntervalMax >= QAPI_BLE_MINIMUM_MAXIMUM_CONNECTION_INTERVAL) && (ConnIntervalMax <= QAPI_BLE_MAXIMUM_MAXIMUM_CONNECTION_INTERVAL))
               {
                  /* Finally verify that the Slave Latency value is     */
                  /* valid.                                             */
                  if(SlaveLatency <= QAPI_BLE_MAXIMUM_SLAVE_LATENCY)
                  {
                     /* Configure the Connection parameters.            */
                     BLEParameters.ConnectionParameters.Connection_Interval_Min    = ConnIntervalMin;
                     BLEParameters.ConnectionParameters.Connection_Interval_Max    = ConnIntervalMax;
                     BLEParameters.ConnectionParameters.Minimum_Connection_Length  = 0;
                     BLEParameters.ConnectionParameters.Maximum_Connection_Length  = 10000;
                     BLEParameters.ConnectionParameters.Slave_Latency              = SlaveLatency;
                     BLEParameters.ConnectionParameters.Supervision_Timeout        = 20000;

                     /* Flag that the parameters are valid.             */
                     BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID;

                     /* Print the new parameters.                       */
                     QCLI_Printf(ble_group, "Minimum Connection Interval: %u ms.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Min);
                     QCLI_Printf(ble_group, "Maximum Connection Interval: %u ms.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Max);
                     QCLI_Printf(ble_group, "Slave Latency:               %u connection events.\n", (unsigned int)BLEParameters.ConnectionParameters.Slave_Latency);

                     /* Flag that the function was successful.          */
                     ret_val = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                  {
                     QCLI_Printf(ble_group, "Slave Latency (%u connection events) MUST be in range [%u, %u] connection events.\n", (unsigned int)SlaveLatency, (unsigned int)QAPI_BLE_MINIMUM_SLAVE_LATENCY, (unsigned int)QAPI_BLE_MAXIMUM_SLAVE_LATENCY);

                     ret_val = QCLI_STATUS_ERROR_E;
                  }
               }
               else
               {
                  QCLI_Printf(ble_group, "Connection Interval Max (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)ConnIntervalMax, (unsigned int)QAPI_BLE_MINIMUM_MAXIMUM_CONNECTION_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_MAXIMUM_CONNECTION_INTERVAL);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(ble_group, "Connection Interval Min (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)ConnIntervalMin, (unsigned int)QAPI_BLE_MINIMUM_MINIMUM_CONNECTION_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_MINIMUM_CONNECTION_INTERVAL);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(ble_group, "Minimum Connection Interval (%u ms) MUST be less than or equal to the Maximum Connection Interval (%u ms).\n", (unsigned int)ConnIntervalMin, (unsigned int)ConnIntervalMax);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is provided to enable a wakeup period to   */
   /* wakeup for data transfer.  This function returns                  */
   /* QCLI_STATUS_SUCCESS_E on success or an error enumeration if an    */
   /* error occurs.                                                     */
static QCLI_Command_Status_t SetTestDataPeriod(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint16_t                 _ConnectionHandle;
   qapi_Status_t            Result;
   qapi_BLE_BD_ADDR_t       BD_ADDR;
   QCLI_Command_Status_t    ret_val;
   qapi_TIMER_set_attr_t    Set_Timer_Attr;
   qapi_TIMER_define_attr_t Create_Timer_Attr;

   /* Next check to see if the parameters required for the execution of */
   /* this function appear to be semi-valid.                            */
   if((Parameter_Count >= 2) && (Parameter_List) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[1].Integer_Is_Valid))
   {
      /* Convert the parameter to a Bluetooth Device Address.           */
      StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

      if((Parameter_Count == 2) || ((Parameter_Count >= 3) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= 1) && (Parameter_List[2].Integer_Value <= MaxACLPacketSize)))
      {
         if(Parameter_Count == 2)
            PacketLength = 27;
         else
            PacketLength = Parameter_List[2].Integer_Value;

         if(!qapi_BLE_GAP_LE_Query_Connection_Handle(BluetoothStackID, BD_ADDR, &_ConnectionHandle))
         {
            /* Check to see if we are starting or stopping the timer.   */
            if(Parameter_List[1].Integer_Value == 0)
            {
               /* See if the timer is started.                          */
               if(TransmitPeriod != 0)
               {
                  /* Stop the timer.                                    */
                  qapi_Timer_Stop(PeriodicSendTimer);

                  /* Clean up the timer.                                */
                  qapi_Timer_Undef(PeriodicSendTimer);

                  TransmitPeriod = 0;

                  QCLI_Printf(ble_group, "Timer stopped.\n");
               }
               else
                  QCLI_Printf(ble_group, "Timer already stopped.\n");

               CurrentTest      = CURRENT_TEST_NONE;
               ConnectionHandle = QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE;

               ret_val          = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               /* Verify that the timer isn't already started.          */
               if((TransmitPeriod == 0) && (CurrentTest == CURRENT_TEST_NONE))
               {
                  /* Create the timer.                                  */
                  Create_Timer_Attr.deferrable     = false;
                  Create_Timer_Attr.cb_type        = QAPI_TIMER_FUNC1_CB_TYPE;
                  Create_Timer_Attr.sigs_func_ptr  = (void *)Period_Tx_Callback;
                  Create_Timer_Attr.sigs_mask_data = 0;
                  Result = qapi_Timer_Def(&(PeriodicSendTimer), &Create_Timer_Attr);

                  /* Verify that the timer was started successfully.    */
                  if(Result == QAPI_OK)
                  {
                     /* Start the timer for periodic transmissions.     */
                     Set_Timer_Attr.time                   = (uint64_t)Parameter_List[1].Integer_Value;
                     Set_Timer_Attr.reload                 = true;
                     Set_Timer_Attr.max_deferrable_timeout = (uint64_t)Parameter_List[1].Integer_Value;
                     Set_Timer_Attr.unit                   = QAPI_TIMER_UNIT_MSEC;
                     Result = qapi_Timer_Set(PeriodicSendTimer, &Set_Timer_Attr);

                     /* Start the timer.                                */
                     if(Result == QAPI_OK)
                     {
                        /* Set the timer period.                        */
                        TransmitPeriod = Parameter_List[1].Integer_Value;

                        CurrentTest                 = CURRENT_TEST_PERIODIC;
                        StartTime                   = qurt_timer_get_ticks();
                        NumberBytes                 = 0;
                        NumberOutstandingACLPackets = 0;

                        /* Note the connection Handle.                  */
                        ConnectionHandle            = _ConnectionHandle;

                        QCLI_Printf(ble_group, "Timer started with period %u.\n", (unsigned int)TransmitPeriod);

                        QCLI_Printf(ble_group, "Starting ACL Periodic TX Test, packet size: %u.\n", PacketLength);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                     {
                        /* Clean up the timer.                          */
                        qapi_Timer_Undef(PeriodicSendTimer);

                        Display_Function_Error(ble_group, "qapi_Timer_Set", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                     }
                  }
                  else
                  {
                     Display_Function_Error(ble_group, "qapi_Timer_Def", Result);

                     ret_val = QCLI_STATUS_ERROR_E;
                  }
               }
               else
               {
                  if(TransmitPeriod != 0)
                     QCLI_Printf(ble_group, "Timer already started with period %u.\n", (unsigned int)TransmitPeriod);
                  else
                     QCLI_Printf(ble_group, "Test already in progress.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
         }
         else
         {
            QCLI_Printf(ble_group, "Device is not currently connected.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(ble_group, "Data Packet Size must be between 1 and  %u.\n", MaxACLPacketSize);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is provided to set the suggested Tx Packet */
   /* Size for an LE connection.  This function returns                 */
   /* QCLI_STATUS_SUCCESS_E on success or an error enumeration if an    */
   /* error occurs.                                                     */
static QCLI_Command_Status_t SetDataLength(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Next, check to make sure we are currently connected.           */
      /* * NOTE * If we are connected, then the a remote device MUST be */
      /*          selected.                                             */
      if(ConnectionCount)
      {
         /* Next check to see if the parameters required for the        */
         /* execution of this function appear to be semi-valid.         */
         if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
         {
            Result = qapi_BLE_GAP_LE_Set_Data_Length(BluetoothStackID, SelectedRemoteBD_ADDR, (uint16_t)(Parameter_List[0].Integer_Value), (uint16_t)((8 + 2 + Parameter_List[0].Integer_Value + 4) * 8));
            if(!Result)
            {
               QCLI_Printf(ble_group, "Suggest Tx Packet Size     : %u.\n", (unsigned int)Parameter_List[0].Integer_Value);
               QCLI_Printf(ble_group, "Suggest Tx Packet Time (us): %u.\n", (unsigned int)((8 + 2 + Parameter_List[0].Integer_Value + 4) * 8));

               /* Flag that the function was successful.                */
               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               QCLI_Printf(ble_group, "Error - qapi_BLE_GAP_LE_Set_Data_Length() returned %d.\n", Result);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
      else
      {
         QCLI_Printf(ble_group, "Device is not connected.\n");

         ret_val = QCLI_STATUS_SUCCESS_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

static QCLI_Command_Status_t StorePersistentData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint8_t                NumberDevices;
   uint8_t                Index;
   DeviceInfo_t          *DeviceInfo;
   qapi_Status_t          Result;
   PersistentData_t      *PersistentData;
   QCLI_Command_Status_t  ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Now make sure the storage handle is initialized.               */
      if(PersistHandle)
      {
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            DeviceInfo    = DeviceInfoList;
            NumberDevices = 0;

            while(DeviceInfo)
            {
               ++NumberDevices;
               DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
            }

            if((PersistentData = (PersistentData_t *)malloc(PERSISTENT_DATA_SIZE(NumberDevices))) != NULL)
            {
               memset(PersistentData, 0, PERSISTENT_DATA_SIZE(NumberDevices));

               PersistentData->LocalAddress        = LocalBD_ADDR;
               PersistentData->NumberRemoteDevices = NumberDevices;

               DeviceInfo = DeviceInfoList;
               Index      = 0;

               while(DeviceInfo)
               {
                  PersistentData->RemoteDevices[Index].LastAddress     = DeviceInfo->RemoteAddress;
                  PersistentData->RemoteDevices[Index].LastAddressType = DeviceInfo->RemoteAddressType;

                  if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                  {
                     PersistentData->RemoteDevices[Index].Flags             |= PERSISTENT_REMOTE_DEVICE_DATA_FLAG_LTK_VALID;
                     PersistentData->RemoteDevices[Index].EncryptionKeySize  = DeviceInfo->EncryptionKeySize;
                     PersistentData->RemoteDevices[Index].LTK                = DeviceInfo->LTK;
                  }

                  if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_IRK_VALID)
                  {
                     PersistentData->RemoteDevices[Index].Flags               |= PERSISTENT_REMOTE_DEVICE_DATA_FLAG_IDENTITY_VALID;
                     PersistentData->RemoteDevices[Index].IdentityAddress      = DeviceInfo->IdentityAddressBD_ADDR;
                     PersistentData->RemoteDevices[Index].IdentityAddressType  = DeviceInfo->IdentityAddressType;
                     PersistentData->RemoteDevices[Index].IRK                  = DeviceInfo->IRK;
                  }

                  ++Index;
                  DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
               }

               Result = qapi_Persist_Put(PersistHandle, PERSISTENT_DATA_SIZE(NumberDevices), (uint8_t *)PersistentData);

               if(Result == QAPI_OK)
               {
                  QCLI_Printf(ble_group, "qapi_Persist_Put_Data() Success.\n");

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(ble_group, "qapi_Persist_Put_Data() Failure: %d.\n", Result);

                  ret_val = QCLI_STATUS_ERROR_E;
               }

               free(PersistentData);
            }
            else
            {
               QCLI_Printf(ble_group, "Unable to allocate memory\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }

            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
         {
            QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(ble_group, "Persistent Storage Not Initialized\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

static QCLI_Command_Status_t LoadPersistentData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint8_t                Index;
   uint32_t               DataSize;
   DeviceInfo_t          *DeviceInfo;
   qapi_Status_t          Result;
   PersistentData_t      *PersistentData;
   QCLI_Command_Status_t  ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Now make sure the storage handle is initialized.               */
      if(PersistHandle)
      {
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Don't proceed if there are devices in the list unless a  */
            /* "force" was specified"                                   */
            if(((Parameter_Count >= 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value)) || (!DeviceInfoList))
            {
               /* Attempt to read the data.                             */
               Result = qapi_Persist_Get(PersistHandle, &DataSize, (uint8_t **)&PersistentData);

               if(Result == QAPI_OK)
               {
                  QCLI_Printf(ble_group, "qapi_Persist_Get() Success. Number devices: %u\n", PersistentData->NumberRemoteDevices);
                  /* Verify the data and length seem valid.             */
                  if((PersistentData) && (DataSize >= PERSISTENT_DATA_SIZE(0)) && (DataSize >= PERSISTENT_DATA_SIZE(PersistentData->NumberRemoteDevices)))
                  {
                     /* Verify the the local BD_ADDRs match.            */
                     if(QAPI_BLE_COMPARE_BD_ADDR(LocalBD_ADDR, PersistentData->LocalAddress))
                     {
                        /* Clear the list if it is not empty (user      */
                        /* specified "force").                          */
                        if(DeviceInfoList)
                        {
                           QCLI_Printf(ble_group, "Warning: Device List is not empty. It will be cleared.\n");
                           FreeDeviceInfoList(&DeviceInfoList);
                           DeviceInfoList = NULL;
                        }

                        /* Data all seems valid, so build the device    */
                        /* list.                                        */
                        for(Index=0;Index<PersistentData->NumberRemoteDevices;Index++)
                        {
                           /* Attempt to create a new list entry for the*/
                           /* device.                                   */
                           if((DeviceInfo = CreateNewDeviceInfoEntry(&DeviceInfoList, PersistentData->RemoteDevices[Index].LastAddress)) != NULL)
                           {
                              /* Note the address type of the address   */
                              /* used to create the entry.              */
                              DeviceInfo->RemoteAddressType = PersistentData->RemoteDevices[Index].LastAddressType;

                              /* Note any encryption information if     */
                              /* valid.                                 */
                              if(PersistentData->RemoteDevices[Index].Flags & PERSISTENT_REMOTE_DEVICE_DATA_FLAG_LTK_VALID)
                              {
                                 DeviceInfo->Flags             |= DEVICE_INFO_FLAGS_LTK_VALID;
                                 DeviceInfo->EncryptionKeySize  = PersistentData->RemoteDevices[Index].EncryptionKeySize;
                                 DeviceInfo->LTK                = PersistentData->RemoteDevices[Index].LTK;
                              }

                              /* Note any identity information if valid.*/
                              if(PersistentData->RemoteDevices[Index].Flags & PERSISTENT_REMOTE_DEVICE_DATA_FLAG_IDENTITY_VALID)
                              {
                                 DeviceInfo->Flags                  |= DEVICE_INFO_FLAGS_IRK_VALID;
                                 DeviceInfo->IdentityAddressBD_ADDR  = PersistentData->RemoteDevices[Index].IdentityAddress;
                                 DeviceInfo->IdentityAddressType     = PersistentData->RemoteDevices[Index].IdentityAddressType;
                                 DeviceInfo->IRK                     = PersistentData->RemoteDevices[Index].IRK;

                                 /* We also need to set up the resolving*/
                                 /* list entry, since this is done in   */
                                 /* the GAP LE Auth callback.           */
                                 DeviceInfo->ResolvingListEntry.Peer_Identity_Address      = DeviceInfo->IdentityAddressBD_ADDR;
                                 DeviceInfo->ResolvingListEntry.Peer_Identity_Address_Type = DeviceInfo->IdentityAddressType;
                                 DeviceInfo->ResolvingListEntry.Peer_IRK                   = DeviceInfo->IRK;
                                 DeviceInfo->ResolvingListEntry.Local_IRK                  = IRK;
                              }
                           }
                           else
                           {
                              QCLI_Printf(ble_group, "Failed to create device entry\n");
                           }
                        }

                        QCLI_Printf(ble_group, "Persistent data loaded\n");

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                     {
                        QCLI_Printf(ble_group, "Local BD_ADDR does not match persistent data. The persistent data is invalid.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                     }
                  }
                  else
                  {
                     QCLI_Printf(ble_group, "Persistent data is invalid\n");

                     ret_val = QCLI_STATUS_ERROR_E;
                  }

                  qapi_Persist_Free(PersistHandle, (uint8_t *)PersistentData);
               }
               else
               {
                  QCLI_Printf(ble_group, "qapi_Persist_Get() Failure: %d\n", Result);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(ble_group, "Device List is not empty.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }

            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
         {
            QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(ble_group, "Persistent Storage Not Initialized\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

static QCLI_Command_Status_t DeletePersistentData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t  ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Now make sure the storage handle is initialized.               */
      if(PersistHandle)
      {
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Simply delete the storage.                               */
            qapi_Persist_Delete(PersistHandle);

            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(ble_group, "Persistent Storage Not Initialized\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function configures how much data to report during  */
   /* advertising.                                                      */
static QCLI_Command_Status_t ConfigureAdvReportDisplay(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* Verify the CLI parameters.                                        */
   if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
   {
      if(Parameter_List[0].Integer_Value)
         DisplayAdvertisingEventData = TRUE;
      else
         DisplayAdvertisingEventData = FALSE;

      QCLI_Printf(ble_group, "Advertising Display: %s\n", (DisplayAdvertisingEventData ? "Verbose" : "Limited"));

      ret_val = QCLI_STATUS_SUCCESS_E;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* Converts a string to a binary blob.  String must be large enough  */
   /* to satisfy binary blob length (each byte is 2 binary characters). */
   /* This is internal function so no check is done on input parameters.*/
static void StringToBinaryBlob(unsigned int BinaryLength, uint8_t *BinaryBlob, char *HexString)
{
   char         Buffer[5];
   unsigned int Index;
   unsigned int StringIndex;

   Buffer[0] = '0';
   Buffer[1] = 'x';
   Buffer[4] = '\0';

   for(Index=0,StringIndex=0;Index<BinaryLength;Index++,StringIndex+=2)
   {
      Buffer[2]         = HexString[StringIndex];
      Buffer[3]         = HexString[StringIndex+1];
      BinaryBlob[Index] = (uint8_t)StringToUnsignedInteger(Buffer);
   }
}

   /* Prints a binary blob to the console.  This is internal function so*/
   /* no check is done on input parameters.                             */
static void PrintBinaryBlob(unsigned int BinaryLength, uint8_t *BinaryBlob)
{
   unsigned int Index;

   for(Index=0;Index<BinaryLength;Index++)
      QCLI_Printf(ble_group, "%02X", BinaryBlob[Index]);
}

   /* The following function queries the local OOB data to send to a    */
   /* remote device (sending out of band).                              */
static QCLI_Command_Status_t QueryLocalOOBData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      Result = qapi_BLE_GAP_LE_Query_Local_Secure_Connections_OOB_Data(BluetoothStackID, &LocalOOBRandomizer, &LocalOOBConfirmation);
      if(!Result)
      {
         QCLI_Printf(ble_group, "Confirmation     : 0x");
         PrintBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Confirmation_t), (uint8_t *)&LocalOOBConfirmation);
         QCLI_Printf(ble_group, "\n");

         QCLI_Printf(ble_group, "Randomizer       : 0x");
         PrintBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Randomizer_t), (uint8_t *)&LocalOOBRandomizer);
         QCLI_Printf(ble_group, "\n");

         LocalOOBValid = TRUE;

         /* Flag that the function was successful.                */
         ret_val       = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         QCLI_Printf(ble_group, "Error - qapi_BLE_GAP_LE_Query_Local_Secure_Connections_OOB_Data() returned %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function sets the remote OOB data received from a   */
   /* remote device (received out of band).                             */
static QCLI_Command_Status_t SetRemoteOOOBData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* Verify the CLI parameters.                                        */
   if((Parameter_Count >= 2) && (Parameter_List) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_Secure_Connections_Confirmation_t) * 2)) && (strlen((char *)(Parameter_List[1].String_Value)) == (sizeof(qapi_BLE_Secure_Connections_Randomizer_t) * 2)))
   {
      /* Convert the values.                                            */
      StringToBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Confirmation_t), (uint8_t *)&RemoteOOBConfirmation, Parameter_List[0].String_Value);
      StringToBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Randomizer_t), (uint8_t *)&RemoteOOBRandomizer, Parameter_List[1].String_Value);
      RemoteOOBValid = TRUE;

      /* Print converted values.                                        */
      QCLI_Printf(ble_group, "Remote Confirmation     : 0x");
      PrintBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Confirmation_t), (uint8_t *)&RemoteOOBConfirmation);
      QCLI_Printf(ble_group, "\n");

      QCLI_Printf(ble_group, "Remote Randomizer       : 0x");
      PrintBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Randomizer_t), (uint8_t *)&RemoteOOBRandomizer);
      QCLI_Printf(ble_group, "\n");

      /* Flag that the function was successful.                         */
      ret_val = QCLI_STATUS_SUCCESS_E;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

#ifndef V1

static QCLI_Command_Status_t LowPowerTransmitOverride(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;
   boolean_t             Enable;
   uint16_t              FEM_Ctrl_0_1;
   uint16_t              FEM_Ctrl_2_3;
   uint8_t               Tx_Power;
   int                   Result;

   if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
   {
      if(Parameter_List[0].Integer_Value)
         Enable = TRUE;
      else
         Enable = FALSE;

      if(!(Enable) || ((Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= -128) && (Parameter_List[1].Integer_Value <= 127) && (Parameter_List[2].Integer_Is_Valid)))
      {
         if(Enable)
         {
            Tx_Power = (uint8_t)Parameter_List[1].Integer_Value;

            if(Parameter_List[2].Integer_Value)
            {
               /* Rx Mode Settings.                                     */
               FEM_Ctrl_0_1 = 0x0000;
               FEM_Ctrl_2_3 = 0x0000;
            }
            else
            {
               /* Shutdown Mode Settings.                               */
               FEM_Ctrl_0_1 = 0x00FF;
               FEM_Ctrl_2_3 = 0xFF00;
            }
         }
         else
         {
            Tx_Power     = QAPI_BLE_BSC_TX_POWER_REVERT_TO_DEFAULT;
            FEM_Ctrl_0_1 = 0x0000;
            FEM_Ctrl_2_3 = 0x0000;
         }

         if((Result = qapi_BLE_BSC_SetTxPower(BluetoothStackID, TRUE, Tx_Power)) == QAPI_OK)
         {
            if((Result = qapi_BLE_BSC_Set_FEM_Control_Override(BluetoothStackID, Enable, FEM_Ctrl_0_1, FEM_Ctrl_2_3)) == QAPI_OK)
            {
               QCLI_Printf(ble_group, "Success\n");
               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               QCLI_Printf(ble_group, "qapi_BLE_BSC_Set_FEM_Control_Override returned %d\n", Result);

               /* FEM Control override failed, reset Tx power to don't  */
               /* care.                                                 */
               qapi_BLE_BSC_SetTxPower(BluetoothStackID, TRUE, 127);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(ble_group, "qapi_BLE_BSC_SetTxPower returned %d\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

#endif

   /* Generic Access Profile (GAPLE) helper functions.                  */

   /* The following function is responsible for placing the Local       */
   /* Bluetooth Device into General Discoverablity Mode.  Once in this  */
   /* mode the Device will respond to Inquiry Scans from other Bluetooth*/
   /* Devices.  This function requires that a valid Bluetooth Stack ID  */
   /* exists before running.  This function returns zero on successful  */
   /* execution and a negative value if an error occurred.              */
static int SetDisc(void)
{
   int ret_val = 0;

   /* First, check that a valid Bluetooth Stack ID exists.              */
   if(BluetoothStackID)
   {
      /* * NOTE * Discoverability is only applicable when we are        */
      /*          advertising so save the default Discoverability Mode  */
      /*          for later.                                            */
      LE_Parameters.DiscoverabilityMode = QAPI_BLE_DM_GENERAL_DISCOVERABLE_MODE_E;
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for placing the Local       */
   /* Bluetooth Device into Connectable Mode.  Once in this mode the    */
   /* Device will respond to Page Scans from other Bluetooth Devices.   */
   /* This function requires that a valid Bluetooth Stack ID exists     */
   /* before running.  This function returns zero on success and a      */
   /* negative value if an error occurred.                              */
static int SetConnect(void)
{
   int ret_val = 0;

   /* First, check that a valid Bluetooth Stack ID exists.              */
   if(BluetoothStackID)
   {
      /* * NOTE * Connectability is only an applicable when advertising */
      /*          so we will just save the default connectability for   */
      /*          the next time we enable advertising.                  */
      LE_Parameters.ConnectableMode = QAPI_BLE_LCM_CONNECTABLE_E;
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for placing the local       */
   /* Bluetooth device into Pairable mode.  Once in this mode the device*/
   /* will response to pairing requests from other Bluetooth devices.   */
   /* This function returns zero on successful execution and a negative */
   /* value on all errors.                                              */
static int SetPairable(void)
{
   int Result;
   int ret_val = 0;

   /* First, check that a valid Bluetooth Stack ID exists.              */
   if(BluetoothStackID)
   {
      /* Attempt to set the attached device to be pairable.             */
      Result = qapi_BLE_GAP_LE_Set_Pairability_Mode(BluetoothStackID, QAPI_BLE_LPM_PAIRABLE_MODE_ENABLE_EXTENDED_EVENTS_E);

      /* Next, check the return value of the GAP Set Pairability mode   */
      /* command for successful execution.                              */
      if(!Result)
      {
         /* The device has been set to pairable mode, now register an   */
         /* Authentication Callback to handle the Authentication events */
         /* if required.                                                */
         Result = qapi_BLE_GAP_LE_Register_Remote_Authentication(BluetoothStackID, GAP_LE_Event_Callback, (unsigned long)0);

         /* Next, check the return value of the GAP Register Remote     */
         /* Authentication command for successful execution.            */
         if(Result)
         {
            /* An error occurred while trying to execute this function. */
            DisplayFunctionError("GAP_LE_Register_Remote_Authentication", Result);

            ret_val = Result;
         }
      }
      else
      {
         /* An error occurred while trying to make the device pairable. */
         DisplayFunctionError("GAP_LE_Set_Pairability_Mode", Result);

         ret_val = Result;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for starting a scan.        */
static int StartScan(uint32_t BluetoothStackID, qapi_BLE_GAP_LE_Filter_Policy_t FilterPolicy, unsigned int ScanDuration)
{
   int Result;

   /* First, determine if the input parameters appear to be semi-valid. */
   if(BluetoothStackID)
   {
      /* Check to see if we need to configure the default Scan          */
      /* Parameters.                                                    */
      if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID))
      {
         /* Configure the default Scan Window and Scan Interval.        */
         BLEParameters.ScanParameters.ScanWindow   = 50;
         BLEParameters.ScanParameters.ScanInterval = 100;

         /* Flag that the scan parameters are valid so that we do not   */
         /* re-configure the defaults un-necessarily.                   */
         BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID;
      }

      /* See if we should start a timer for this scan.                  */
      if(ScanDuration)
      {
         /* Start a timer for this operation.                           */
         Result = qapi_BLE_BSC_StartTimer(BluetoothStackID, (ScanDuration * 1000), BSC_Timer_Callback, ScanDuration);
         if(Result > 0)
         {
            /* Save the scan timer ID.                                  */
            ScanTimerID = (unsigned int)Result;

            Result      = 0;
         }
      }
      else
         Result = 0;

      /* Continue if no error occurred.                                 */
      if(!Result)
      {
         /* Not currently scanning, go ahead and attempt to perform the */
         /* scan.                                                       */
         Result = qapi_BLE_GAP_LE_Perform_Scan(BluetoothStackID, QAPI_BLE_ST_ACTIVE_E, BLEParameters.ScanParameters.ScanInterval, BLEParameters.ScanParameters.ScanWindow, QAPI_BLE_LAT_PUBLIC_E, FilterPolicy, TRUE, GAP_LE_Event_Callback, 0);
         if(!Result)
            QCLI_Printf(ble_group, "Scan started successfully. Scan Window: %u, Scan Interval: %u.\n", (unsigned int)BLEParameters.ScanParameters.ScanWindow, (unsigned int)BLEParameters.ScanParameters.ScanInterval);
         else
            QCLI_Printf(ble_group, "Unable to perform scan: %d\n", Result);
      }
      else
         QCLI_Printf(ble_group, "Unable to start scan timer: %d\n", Result);
   }
   else
      Result = -1;

   return(Result);
}

   /* The following function is responsible for stopping on on-going    */
   /* scan.                                                             */
static int StopScan(uint32_t BluetoothStackID)
{
   int Result;

   /* First, determine if the input parameters appear to be semi-valid. */
   if(BluetoothStackID)
   {
      /* if scan timer is active stop that.                             */
      if(ScanTimerID)
      {
         /* Stop the timer.                                             */
         qapi_BLE_BSC_StopTimer(BluetoothStackID, ScanTimerID);

         ScanTimerID = 0;
      }

      /* Stop the scan.                                                 */
      Result = qapi_BLE_GAP_LE_Cancel_Scan(BluetoothStackID);
      if(!Result)
      {
         QCLI_Printf(ble_group, "Scan stopped successfully.\n");

         /* Flag that scanning is not in progess.                       */
         ScanInProgress = FALSE;
      }
      else
         QCLI_Printf(ble_group, "Unable to stop scan: %d\n", Result);
   }
   else
      Result = -1;

   return(Result);
}

   /* The following function is responsible for creating an LE          */
   /* connection to the specified Remote Device.                        */
   /* * NOTE * If UseWhiteList is TRUE, then the BD_ADDR may be excluded*/
   /*          (NULL), and the address type will be ignored.  Otherwise,*/
   /*          they MUST be specified.  A remote device address and     */
   /*          address type MUST have been added to the White List in   */
   /*          the controller to use this functionality.                */
   /* * NOTE * If UseWhiteList is FALSE, then this function will perform*/
   /*          no checks on the remote addresss or address type.        */
   /* * NOTE * If Address Resolution has been enabled in the controller */
   /*          and the remote device's identity information has been    */
   /*          added to the Resolving List in the controller, then the  */
   /*          local controller will generate a resolvable private      */
   /*          address (RPA) to send in the connection request.         */
   /* * NOTE * If the user wishes to use the White List and the         */
   /*          Resolving List in the controller, then the remote device */
   /*          address and address type specified for the added White   */
   /*          List entry MUST correspond to the identity address and   */
   /*          identity address type for the remote device.             */
   /* * NOTE * If the user wishes to ONLY use the Resolving List in the */
   /*          controller (Not White List), then the remote device      */
   /*          address and address type specified to this function MUST */
   /*          correspond to the identity address and identity address  */
   /*          type for the remote device.                              */
static int ConnectLEDevice(uint32_t BluetoothStackID, boolean_t UseWhiteList, qapi_BLE_BD_ADDR_t *BD_ADDR, qapi_BLE_GAP_LE_Address_Type_t AddressType)
{
   int Result;

   /* First, determine if the input parameters appear to be semi-valid. */
   if(BluetoothStackID)
   {
      /* Check to see if we need to configure the default Scan          */
      /* Parameters.                                                    */
      if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID))
      {
         /* Configure the default Scan Window and Scan Interval.        */
         BLEParameters.ScanParameters.ScanWindow   = 50;
         BLEParameters.ScanParameters.ScanInterval = 100;

         /* Flag that the scan parameters are valid so that we do not   */
         /* re-configure the defaults un-necessarily.                   */
         BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID;
      }

      /* Check to see if we need to configure the default Connection    */
      /* Parameters.                                                    */
      if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID))
      {
         /* Initialize the default connection parameters.               */
         BLEParameters.ConnectionParameters.Connection_Interval_Min    = 50;
         BLEParameters.ConnectionParameters.Connection_Interval_Max    = 200;
         BLEParameters.ConnectionParameters.Minimum_Connection_Length  = 0;
         BLEParameters.ConnectionParameters.Maximum_Connection_Length  = 10000;
         BLEParameters.ConnectionParameters.Slave_Latency              = 0;
         BLEParameters.ConnectionParameters.Supervision_Timeout        = 20000;

         /* Flag that the connection parameters are valid so that we do */
         /* not re-configure the defaults un-necessarily.               */
         BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID;
      }

      /* Everything appears correct, go ahead and attempt to make the   */
      /* connection.                                                    */
      /* * NOTE * Our local address type will ALWAYS be resolvable      */
      /*          fallback public, in case the Resolving List in the    */
      /*          controller is used for connecting.  It is worth noting*/
      /*          that this demo uses its local/public address as the   */
      /*          public identity address for simplicity.               */
      Result = qapi_BLE_GAP_LE_Create_Connection(BluetoothStackID, BLEParameters.ScanParameters.ScanInterval, BLEParameters.ScanParameters.ScanWindow, (UseWhiteList ? QAPI_BLE_FP_WHITE_LIST_E : QAPI_BLE_FP_NO_FILTER_E), AddressType, BD_ADDR, QAPI_BLE_LAT_RESOLVABLE_FALLBACK_PUBLIC_E, &(BLEParameters.ConnectionParameters), GAP_LE_Event_Callback, 0);
      if(!Result)
      {
         QCLI_Printf(ble_group, "Connection Request successful.\n");
         QCLI_Printf(ble_group, "Scan Parameters:       Window %u, Interval %u.\n", (unsigned int)BLEParameters.ScanParameters.ScanWindow,
                                                                                     (unsigned int)BLEParameters.ScanParameters.ScanInterval);
         QCLI_Printf(ble_group, "Connection Parameters: Interval Range %u - %u, Slave Latency %u.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Min,
                                                                                                       (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Max,
                                                                                                       (unsigned int)BLEParameters.ConnectionParameters.Slave_Latency);
         QCLI_Printf(ble_group, "Using White List:      %s.\n", (UseWhiteList ? "Yes" : "No"));
      }
      else
      {
         /* Unable to create connection.                                */
         QCLI_Printf(ble_group, "Unable to create connection: %d.\n", Result);
      }
   }
   else
      Result = -1;

   return(Result);
}

   /* The following function provides a mechanism to configure a        */
   /* Pairing Capabilities structure with the application's pairing     */
   /* parameters.                                                       */
static void ConfigureCapabilities(qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t *Capabilities)
{
   /* Make sure the Capabilities pointer is semi-valid.                 */
   if(Capabilities)
   {
      /* Initialize the capabilities.                                   */
      memset(Capabilities, 0, QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_SIZE);

      /* Configure the Pairing Capabilities structure.                  */
      Capabilities->Bonding_Type                    = QAPI_BLE_LBT_BONDING_E;
      Capabilities->IO_Capability                   = LE_Parameters.IOCapability;
      Capabilities->Flags                           = 0;

      if(LE_Parameters.MITMProtection)
         Capabilities->Flags |= QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_MITM_REQUESTED;

      if(LE_Parameters.SecureConnections)
         Capabilities->Flags |= QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_SECURE_CONNECTIONS;

      if(RemoteOOBValid)
         Capabilities->Flags |= QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_OOB_DATA_PRESENT;

      if(LocalOOBValid)
      {
         Capabilities->Flags                     |= QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_LOCAL_OOB_DATA_VALID;
         Capabilities->LocalOOBData.Flags         = 0;
         Capabilities->LocalOOBData.Confirmation  = LocalOOBConfirmation;
         Capabilities->LocalOOBData.Randomizer    = LocalOOBRandomizer;
      }

      /* ** NOTE ** This application always requests that we use the    */
      /*            maximum encryption because this feature is not a    */
      /*            very good one, if we set less than the maximum we   */
      /*            will internally in GAP generate a key of the        */
      /*            maximum size (we have to do it this way) and then   */
      /*            we will zero out how ever many of the MSBs          */
      /*            necessary to get the maximum size.  Also as a slave */
      /*            we will have to use Non-Volatile Memory (per device */
      /*            we are paired to) to store the negotiated Key Size. */
      /*            By requesting the maximum (and by not storing the   */
      /*            negotiated key size if less than the maximum) we    */
      /*            allow the slave to power cycle and regenerate the   */
      /*            LTK for each device it is paired to WITHOUT storing */
      /*            any information on the individual devices we are    */
      /*            paired to.                                          */
      Capabilities->Maximum_Encryption_Key_Size        = QAPI_BLE_GAP_LE_MAXIMUM_ENCRYPTION_KEY_SIZE;

      /* This application only demonstrates using the Long Term Key's   */
      /* (LTK) for encryption of a LE Link and the Identity Resolving   */
      /* Key (IRK) for resolving resovable private addresses (RPA's),   */
      /* however we could request and send all possible keys here if we */
      /* wanted to.                                                     */
      Capabilities->Receiving_Keys.Encryption_Key     = TRUE;
      Capabilities->Receiving_Keys.Identification_Key = TRUE;
      Capabilities->Receiving_Keys.Signing_Key        = FALSE;
      Capabilities->Receiving_Keys.Link_Key           = FALSE;

      Capabilities->Sending_Keys.Encryption_Key       = TRUE;
      Capabilities->Sending_Keys.Identification_Key   = TRUE;
      Capabilities->Sending_Keys.Signing_Key          = FALSE;
      Capabilities->Sending_Keys.Link_Key             = FALSE;
   }
}

   /* The following function provides a mechanism for sending a pairing */
   /* request to a device that is connected on an LE Link.              */
static int SendPairingRequest(qapi_BLE_BD_ADDR_t BD_ADDR, boolean_t ConnectionMaster)
{
   int                                             ret_val;
   BoardStr_t                                      BoardStr;
   qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t ExtendedCapabilities;

   /* Make sure a Bluetooth Stack is open.                              */
   if(BluetoothStackID)
   {
      /* Configure the application pairing parameters.                  */
      ConfigureCapabilities(&ExtendedCapabilities);

      /* Inform the user we are attempting to pair to the remote device.*/
      BD_ADDRToStr(BD_ADDR, BoardStr);
      QCLI_Printf(ble_group, "Attempting to Pair to %s.\n", BoardStr);

      DisplayPairingInformation(&ExtendedCapabilities);

      /* Attempt to pair to the remote device.                          */
      if(ConnectionMaster)
      {
         /* Go ahead and store the address of the remote device that we */
         /* are going to attempt to pair.                               */
         /* * NOTE * If this function is called by the                  */
         /*          GAP_LE_Event_Callback() then this will already be  */
         /*          set, however if it is called by PairLE(), then it  */
         /*          will NOT be set.  We MUST only set this if we are  */
         /*          the master of the connection since the master sends*/
         /*          the pairing request.  The slave will set this when */
         /*          the pairing request has been received.             */
         SecurityRemoteBD_ADDR = BD_ADDR;

         /* Start the pairing process.                                  */
         if((ret_val = qapi_BLE_GAP_LE_Extended_Pair_Remote_Device(BluetoothStackID, SecurityRemoteBD_ADDR, &ExtendedCapabilities, GAP_LE_Event_Callback, 0)) == QAPI_BLE_BTPS_ERROR_SECURE_CONNECTIONS_NOT_SUPPORTED)
         {
            /* Since Secure Connections isn't supported go ahead and    */
            /* disable our request for Secure Connections and re-submit */
            /* our request.                                             */
            QCLI_Printf(ble_group, "Secure Connections not supported, disabling Secure Connections.\n");

            ExtendedCapabilities.Flags &= ~QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_SECURE_CONNECTIONS;

            /* Try this again.                                          */
            ret_val = qapi_BLE_GAP_LE_Extended_Pair_Remote_Device(BluetoothStackID, SecurityRemoteBD_ADDR, &ExtendedCapabilities, GAP_LE_Event_Callback, 0);
         }

         QCLI_Printf(ble_group, "     GAP_LE_Extended_Pair_Remote_Device returned %d.\n", ret_val);
      }
      else
      {
         /* As a slave we can only request that the Master start the    */
         /* pairing process.                                            */
         ret_val = qapi_BLE_GAP_LE_Extended_Request_Security(BluetoothStackID, BD_ADDR, &ExtendedCapabilities, GAP_LE_Event_Callback, 0);

         QCLI_Printf(ble_group, "     GAP_LE_Request_Security returned %d.\n", ret_val);
      }
   }
   else
   {
      QCLI_Printf(ble_group, "Stack ID Invalid.\n");

      ret_val = -1;
   }

   return(ret_val);
}

   /* The following function provides a mechanism of sending a Slave    */
   /* Pairing Response to a Master's Pairing Request.                   */
static int SlavePairingRequestResponse(qapi_BLE_BD_ADDR_t BD_ADDR)
{
   int                                                   ret_val;
   BoardStr_t                                            BoardStr;
   qapi_BLE_GAP_LE_Authentication_Response_Information_t AuthenticationResponseData;

   /* Make sure a Bluetooth Stack is open.                              */
   if(BluetoothStackID)
   {
      BD_ADDRToStr(BD_ADDR, BoardStr);
      QCLI_Printf(ble_group, "Sending Pairing Response to %s.\n", BoardStr);

      /* We must be the slave if we have received a Pairing Request     */
      /* thus we will respond with our capabilities.                    */
      AuthenticationResponseData.GAP_LE_Authentication_Type = QAPI_BLE_LAR_PAIRING_CAPABILITIES_E;
      AuthenticationResponseData.Authentication_Data_Length = QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_SIZE;

      /* Configure the Application Pairing Parameters.                  */
      ConfigureCapabilities(&(AuthenticationResponseData.Authentication_Data.Extended_Pairing_Capabilities));

      /* Attempt to pair to the remote device.                          */
      if((ret_val = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, BD_ADDR, &AuthenticationResponseData)) == QAPI_BLE_BTPS_ERROR_SECURE_CONNECTIONS_NOT_SUPPORTED)
      {
         /* Since Secure Connections isn't supported go ahead and       */
         /* disable our request for Secure Connections and re-submit our*/
         /* request.                                                    */
         QCLI_Printf(ble_group, "Secure Connections not supported, disabling Secure Connections.\n");

         AuthenticationResponseData.Authentication_Data.Extended_Pairing_Capabilities.Flags &= ~QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_SECURE_CONNECTIONS;

         /* Try this again.                                             */
         ret_val = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, BD_ADDR, &AuthenticationResponseData);
      }

      QCLI_Printf(ble_group, "GAP_LE_Authentication_Response returned %d.\n", ret_val);
   }
   else
   {
      QCLI_Printf(ble_group, "Stack ID Invalid.\n");

      ret_val = -1;
   }

   return(ret_val);
}

   /* The following function is provided to allow a mechanism of        */
   /* responding to a request for Encryption Information to send to a   */
   /* remote device.                                                    */
static int EncryptionInformationRequestResponse(qapi_BLE_BD_ADDR_t BD_ADDR, uint8_t KeySize, qapi_BLE_GAP_LE_Authentication_Response_Information_t *GAP_LE_Authentication_Response_Information)
{
   int      ret_val;
   uint16_t LocalDiv;

   /* Make sure a Bluetooth Stack is open.                              */
   if(BluetoothStackID)
   {
      /* Make sure the input parameters are semi-valid.                 */
      if((!QAPI_BLE_COMPARE_NULL_BD_ADDR(BD_ADDR)) && (GAP_LE_Authentication_Response_Information))
      {
         QCLI_Printf(ble_group, "   Calling GAP_LE_Generate_Long_Term_Key.\n");

         /* Generate a new LTK, EDIV and Rand tuple.                    */
         ret_val = qapi_BLE_GAP_LE_Generate_Long_Term_Key(BluetoothStackID, (qapi_BLE_Encryption_Key_t *)(&DHK), (qapi_BLE_Encryption_Key_t *)(&ER), &(GAP_LE_Authentication_Response_Information->Authentication_Data.Encryption_Information.LTK), &LocalDiv, &(GAP_LE_Authentication_Response_Information->Authentication_Data.Encryption_Information.EDIV), &(GAP_LE_Authentication_Response_Information->Authentication_Data.Encryption_Information.Rand));
         if(!ret_val)
         {
            QCLI_Printf(ble_group, "   Encryption Information Request Response.\n");

            /* Response to the request with the LTK, EDIV and Rand      */
            /* values.                                                  */
            GAP_LE_Authentication_Response_Information->GAP_LE_Authentication_Type                                     = QAPI_BLE_LAR_ENCRYPTION_INFORMATION_E;
            GAP_LE_Authentication_Response_Information->Authentication_Data_Length                                     = QAPI_BLE_GAP_LE_ENCRYPTION_INFORMATION_DATA_SIZE;
            GAP_LE_Authentication_Response_Information->Authentication_Data.Encryption_Information.Encryption_Key_Size = KeySize;

            ret_val = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, BD_ADDR, GAP_LE_Authentication_Response_Information);
            if(!ret_val)
            {
               QCLI_Printf(ble_group, "   qapi_BLE_GAP_LE_Authentication_Response (larEncryptionInformation) success.\n");
            }
            else
            {
               QCLI_Printf(ble_group, "   Error - SM_Generate_Long_Term_Key returned %d.\n", ret_val);
            }
         }
         else
         {
            QCLI_Printf(ble_group, "   Error - SM_Generate_Long_Term_Key returned %d.\n", ret_val);
         }
      }
      else
      {
         QCLI_Printf(ble_group, "Invalid Parameters.\n");

         ret_val = -1;
      }
   }
   else
   {
      QCLI_Printf(ble_group, "Stack ID Invalid.\n");

      ret_val = -1;
   }

   return(ret_val);
}

   /* Displays the current I/O Capabilities.                            */
static void DisplayIOCapabilities(void)
{
   QCLI_Printf(ble_group, "I/O Capabilities: %s, MITM: %s. Secure Connections: %s.\n", IOCapabilitiesStrings[(unsigned int)(LE_Parameters.IOCapability - QAPI_BLE_LIC_DISPLAY_ONLY_E)], LE_Parameters.MITMProtection?"TRUE":"FALSE", LE_Parameters.SecureConnections?"TRUE":"FALSE");
}

   /* The following function displays the pairing capabilities that is  */
   /* passed into this function.                                        */
static void DisplayPairingInformation(qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t *Pairing_Capabilities)
{
   /* Display the IO Capability.                                        */
   switch(Pairing_Capabilities->IO_Capability)
   {
      case QAPI_BLE_LIC_DISPLAY_ONLY_E:
         QCLI_Printf(ble_group, "   IO Capability:       Display Only.\n");
         break;
      case QAPI_BLE_LIC_DISPLAY_YES_NO_E:
         QCLI_Printf(ble_group, "   IO Capability:       Display Yes/No.\n");
         break;
      case QAPI_BLE_LIC_KEYBOARD_ONLY_E:
         QCLI_Printf(ble_group, "   IO Capability:       Keyboard Only.\n");
         break;
      case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
         QCLI_Printf(ble_group, "   IO Capability:       No Input No Output.\n");
         break;
      case QAPI_BLE_LIC_KEYBOARD_DISPLAY_E:
         QCLI_Printf(ble_group, "   IO Capability:       Keyboard/Display.\n");
         break;
   }

   QCLI_Printf(ble_group, "   Bonding Type:        %s.\n", (Pairing_Capabilities->Bonding_Type == QAPI_BLE_LBT_BONDING_E)?"Bonding":"No Bonding");
   QCLI_Printf(ble_group, "   MITM:                %s.\n", (Pairing_Capabilities->Flags & QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_MITM_REQUESTED)?"TRUE":"FALSE");
   QCLI_Printf(ble_group, "   Secure Connections:  %s.\n", (Pairing_Capabilities->Flags & QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_SECURE_CONNECTIONS)?"TRUE":"FALSE");
   QCLI_Printf(ble_group, "   OOB:                 %s.\n", (Pairing_Capabilities->Flags & QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_OOB_DATA_PRESENT)?"OOB":"OOB Not Present");
   QCLI_Printf(ble_group, "   Encryption Key Size: %d.\n", Pairing_Capabilities->Maximum_Encryption_Key_Size);
   QCLI_Printf(ble_group, "   Sending Keys: \n");
   QCLI_Printf(ble_group, "      LTK:              %s.\n", ((Pairing_Capabilities->Sending_Keys.Encryption_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      IRK:              %s.\n", ((Pairing_Capabilities->Sending_Keys.Identification_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      CSRK:             %s.\n", ((Pairing_Capabilities->Sending_Keys.Signing_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      Link Key:         %s.\n", ((Pairing_Capabilities->Sending_Keys.Link_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "   Receiving Keys: \n");
   QCLI_Printf(ble_group, "      LTK:              %s.\n", ((Pairing_Capabilities->Receiving_Keys.Encryption_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      IRK:              %s.\n", ((Pairing_Capabilities->Receiving_Keys.Identification_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      CSRK:             %s.\n", ((Pairing_Capabilities->Receiving_Keys.Signing_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      Link Key:         %s.\n", ((Pairing_Capabilities->Receiving_Keys.Link_Key)?"YES":"NO"));
}

   /* The following function displays the pairing capabilities that is  */
   /* passed into this function.                                        */
static void DisplayLegacyPairingInformation(qapi_BLE_GAP_LE_Pairing_Capabilities_t *Pairing_Capabilities)
{
   /* Display the IO Capability.                                        */
   switch(Pairing_Capabilities->IO_Capability)
   {
      case QAPI_BLE_LIC_DISPLAY_ONLY_E:
         QCLI_Printf(ble_group, "   IO Capability:       Display Only.\n");
         break;
      case QAPI_BLE_LIC_DISPLAY_YES_NO_E:
         QCLI_Printf(ble_group, "   IO Capability:       Display Yes/No.\n");
         break;
      case QAPI_BLE_LIC_KEYBOARD_ONLY_E:
         QCLI_Printf(ble_group, "   IO Capability:       Keyboard Only.\n");
         break;
      case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
         QCLI_Printf(ble_group, "   IO Capability:       No Input No Output.\n");
         break;
      case QAPI_BLE_LIC_KEYBOARD_DISPLAY_E:
         QCLI_Printf(ble_group, "   IO Capability:       Keyboard/Display.\n");
         break;
   }

   QCLI_Printf(ble_group, "   MITM:                %s.\n", (Pairing_Capabilities->MITM)?"TRUE":"FALSE");
   QCLI_Printf(ble_group, "   Bonding Type:        %s.\n", (Pairing_Capabilities->Bonding_Type == QAPI_BLE_LBT_BONDING_E)?"Bonding":"No Bonding");
   QCLI_Printf(ble_group, "   OOB:                 %s.\n", (Pairing_Capabilities->OOB_Present)?"OOB":"OOB Not Present");
   QCLI_Printf(ble_group, "   Encryption Key Size: %d.\n", Pairing_Capabilities->Maximum_Encryption_Key_Size);
   QCLI_Printf(ble_group, "   Sending Keys: \n");
   QCLI_Printf(ble_group, "      LTK:              %s.\n", ((Pairing_Capabilities->Sending_Keys.Encryption_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      IRK:              %s.\n", ((Pairing_Capabilities->Sending_Keys.Identification_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      CSRK:             %s.\n", ((Pairing_Capabilities->Sending_Keys.Signing_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "   Receiving Keys: \n");
   QCLI_Printf(ble_group, "      LTK:              %s.\n", ((Pairing_Capabilities->Receiving_Keys.Encryption_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      IRK:              %s.\n", ((Pairing_Capabilities->Receiving_Keys.Identification_Key)?"YES":"NO"));
   QCLI_Printf(ble_group, "      CSRK:             %s.\n", ((Pairing_Capabilities->Receiving_Keys.Signing_Key)?"YES":"NO"));
}

   /* The following function is provided to properly print a UUID.      */
static void DisplayUUID(qapi_BLE_GATT_UUID_t *UUID)
{
   if(UUID)
   {
      if(UUID->UUID_Type == QAPI_BLE_GU_UUID_16_E)
         QCLI_Printf(ble_group, "%02X%02X\n", UUID->UUID.UUID_16.UUID_Byte1, UUID->UUID.UUID_16.UUID_Byte0);
      else
      {
         if(UUID->UUID_Type == QAPI_BLE_GU_UUID_128_E)
         {
            QCLI_Printf(ble_group, "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n", UUID->UUID.UUID_128.UUID_Byte15, UUID->UUID.UUID_128.UUID_Byte14, UUID->UUID.UUID_128.UUID_Byte13,
                                                                                                    UUID->UUID.UUID_128.UUID_Byte12, UUID->UUID.UUID_128.UUID_Byte11, UUID->UUID.UUID_128.UUID_Byte10,
                                                                                                    UUID->UUID.UUID_128.UUID_Byte9,  UUID->UUID.UUID_128.UUID_Byte8,  UUID->UUID.UUID_128.UUID_Byte7,
                                                                                                    UUID->UUID.UUID_128.UUID_Byte6,  UUID->UUID.UUID_128.UUID_Byte5,  UUID->UUID.UUID_128.UUID_Byte4,
                                                                                                    UUID->UUID.UUID_128.UUID_Byte3,  UUID->UUID.UUID_128.UUID_Byte2,  UUID->UUID.UUID_128.UUID_Byte1,
                                                                                                    UUID->UUID.UUID_128.UUID_Byte0);
         }
      }
   }
}

   /* Displays a function error message.                                */
static void DisplayFunctionError(char *Function, int Status)
{
   QCLI_Printf(ble_group, "%s Failed: %d.\n", Function, Status);
}

   /* The following function is a utility function which is used to     */
   /* generate random values for the ER and the IR.                     */
static void GenerateRandomKeys(void)
{
   uint8_t                  Status;
   unsigned int             MaxSize;
   qapi_BLE_Random_Number_t RandomNumber;

   /* Initialize the max size.                                          */
   MaxSize = (sizeof(qapi_BLE_Random_Number_t) > (sizeof(qapi_BLE_Encryption_Key_t) / 2)) ? (sizeof(qapi_BLE_Encryption_Key_t) / 2) : sizeof(qapi_BLE_Random_Number_t);

   /* Initialize the ER and IR to random values.                        */
   if((!qapi_BLE_HCI_LE_Rand(BluetoothStackID,  &Status,  &RandomNumber)) && (!Status))
      memcpy(&ER, &RandomNumber, MaxSize);

   if((!qapi_BLE_HCI_LE_Rand(BluetoothStackID,  &Status,  &RandomNumber)) && (!Status))
      memcpy(&(((uint8_t *)&ER)[sizeof(qapi_BLE_Encryption_Key_t) / 2]), &RandomNumber, MaxSize);

   if((!qapi_BLE_HCI_LE_Rand(BluetoothStackID,  &Status,  &RandomNumber)) && (!Status))
      memcpy(&IR, &RandomNumber, MaxSize);

   if((!qapi_BLE_HCI_LE_Rand(BluetoothStackID,  &Status,  &RandomNumber)) && (!Status))
      memcpy(&(((uint8_t *)&IR)[sizeof(qapi_BLE_Encryption_Key_t) / 2]), &RandomNumber, MaxSize);
}

   /* Hardware Controller Interface (HCI) QCLI command functions.       */

#ifdef V2

   /* The PHY to string mapping table.                                  */
char *PHYMapping[] =
{
   "LE 1M PHY",
   "LE 2M PHY",
   "LE Coded PHY",
   "Unknown PHY"
};

   /* The following function converts the PHY to a string for printing. */
char *PHYToString(qapi_BLE_GAP_LE_PHY_Type_t PHY)
{
   if((PHY >= QAPI_BLE_LPT_PHY_LE_1M_E) && (PHY <= QAPI_BLE_LPT_PHY_LE_CODED_E))
      return(PHYMapping[PHY - QAPI_BLE_LPT_PHY_LE_1M_E]);
   else
      return(PHYMapping[3]);
}

   /* The following function is responsible for reading the PHY for an  */
   /* existing connection. This function will return zero on successful */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ReadPHY(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                        Result;
   BoardStr_t                 BoardStr;
   QCLI_Command_Status_t      ret_val = QCLI_STATUS_SUCCESS_E;
   qapi_BLE_GAP_LE_PHY_Type_t TX_PHY_Result;
   qapi_BLE_GAP_LE_PHY_Type_t RX_PHY_Result;

   /* Verify that there is a connection that is established.            */
   if(ConnectionCount)
   {
      /* Query the connection PHY.                                      */
      Result = qapi_BLE_GAP_LE_Query_Connection_PHY(BluetoothStackID, SelectedRemoteBD_ADDR, &TX_PHY_Result, &RX_PHY_Result);
      if(!Result)
      {
         BD_ADDRToStr(SelectedRemoteBD_ADDR, BoardStr);
         QCLI_Printf(ble_group, "Remote Device:  %s\n",  BoardStr);
         QCLI_Printf(bt5_group, "TX PHY:         %s.\n", PHYToString(TX_PHY_Result));
         QCLI_Printf(bt5_group, "RX PHY:         %s.\n", PHYToString(RX_PHY_Result));
      }
      else
      {
         QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Query_Connection_PHY() returned error: %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(ble_group, "No connection currently connected.\n");

      /* Flag success to the caller.                                    */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the PHY for an  */
   /* existing connection. This function will return zero on successful */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t SetPHY(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   uint32_t              TX_PHYS;
   uint32_t              RX_PHYS;
   QCLI_Command_Status_t ret_val = QCLI_STATUS_SUCCESS_E;

   /* Make sure the mandatory parameters are semi-valid.                */
   if((Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid))
   {
      /* Store the parameters.                                          */
      TX_PHYS = (uint32_t)Parameter_List[1].Integer_Value;
      RX_PHYS = (uint32_t)Parameter_List[2].Integer_Value;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   /* If an error has not occured.                                      */
   if(!ret_val)
   {
      /* Verify that there is a connection that is established.         */
      if(ConnectionCount)
      {
         /* Simply call the GAP function.                               */
         Result = qapi_BLE_GAP_LE_Set_Connection_PHY(BluetoothStackID, SelectedRemoteBD_ADDR, TX_PHYS, RX_PHYS);
         if(!Result)
         {
            QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Set_Connection_PHY() success.\n");
         }
         else
         {
            QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Set_Connection_PHY() error: %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(ble_group, "No connection currently connected.\n");

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_ERROR_E;
      }
   }

   return(ret_val);
}

   /* The following function is responsible for setting the extended    */
   /* advertising parameters. This function will return zero on         */
   /* successful execution and a negative value on errors.              */
   /* * NOTE * This function currently only allows one advertising set  */
   /*          to be configure.                                         */
   /* * NOTE * This function does NOT allow direct advertising.         */
static QCLI_Command_Status_t SetExtendedAdvertisingParams(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                               Result;
   int8_t                                            SelectedTxPowerResult;
   uint8_t                                           AdvertisingHandle;
   QCLI_Command_Status_t                             ret_val = QCLI_STATUS_SUCCESS_E;
   qapi_BLE_GAP_LE_Extended_Advertising_Parameters_t ExtAdvParameters;

   /* Make sure the mandatory AdvertisingHandle and                     */
   /* AdvertisingEventProperties parameters are semi-valid.             */
   if((Parameter_Count >= 3) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 1) &&
                                (Parameter_List[1].Integer_Is_Valid) &&
                                (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= -127) && (Parameter_List[2].Integer_Value <= 127))
   {
      /* Store the parameters.                                          */
      AdvertisingHandle                             = (uint8_t)Parameter_List[0].Integer_Value;
      ExtAdvParameters.Advertising_Event_Properties = (uint16_t)Parameter_List[1].Integer_Value;
      ExtAdvParameters.Advertising_Tx_Power         = (int8_t)Parameter_List[2].Integer_Value;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   /* If an error has not occured.                                      */
   if(!ret_val)
   {
      /* Set the remaining extended advertising parameters.             */
      /* * NOTE * The PeerAddrType and PeerAddr are set so that direct  */
      /*          advertising CANNOT be used.                           */
      ExtAdvParameters.Primary_Advertising_Interval_Min  = (uint32_t)(100);
      ExtAdvParameters.Primary_Advertising_Interval_Max  = (uint32_t)(200);
      ExtAdvParameters.Primary_Advertising_Channel_Map   = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_DEFAULT;
      ExtAdvParameters.Own_Address_Type                  = QAPI_BLE_LAT_PUBLIC_E;
      ExtAdvParameters.Peer_Address_Type                 = QAPI_BLE_LAT_PUBLIC_E;
      QAPI_BLE_ASSIGN_BD_ADDR(ExtAdvParameters.Peer_Address,  0, 0, 0, 0, 0, 0);
      ExtAdvParameters.Scan_Request_Filter               = QAPI_BLE_FP_NO_FILTER_E;
      ExtAdvParameters.Connect_Request_Filter            = QAPI_BLE_FP_NO_FILTER_E;
      ExtAdvParameters.Primary_Advertising_PHY           = QAPI_BLE_LPT_PHY_LE_1M_E;
      ExtAdvParameters.Secondary_Advertising_Max_Skip    = 0x00;
      ExtAdvParameters.Secondary_Advertising_PHY         = QAPI_BLE_LPT_PHY_LE_1M_E;
      ExtAdvParameters.Advertising_SID                   = 0x00;
      ExtAdvParameters.Scan_Request_Notifications_Enable = TRUE;

      /* Call the GAP function to set the extended advertising          */
      /* parameters.                                                    */
      Result = qapi_BLE_GAP_LE_Set_Extended_Advertising_Parameters(BluetoothStackID, AdvertisingHandle, &ExtAdvParameters, &SelectedTxPowerResult);
      if(!Result)
      {
         QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Set_Extended_Advertising_Parameters() returned success.\n");
         QCLI_Printf(bt5_group, "      Selected Tx Power Result: %d.\n", (int)SelectedTxPowerResult);
      }
      else
      {
         QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Set_Extended_Advertising_Parameters() returned error: %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }

   return(ret_val);
}

   /* The following function is responsible for enabling extended       */
   /* advertising. This function will return zero on successful         */
   /* execution and a negative value on errors.                         */
   /* * NOTE * This function currently only allows one advertising set  */
   /*          to be enabled.                                           */
static QCLI_Command_Status_t EnableExtendedAdvertising(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   uint8_t               NumberOfSets;
   uint8_t               AdvertisingHandle;
   uint8_t               MaxExtAdvertisingEvents = 0;
   uint32_t              Duration                = 0;
   boolean_t             Enable;
   QCLI_Command_Status_t ret_val                 = QCLI_STATUS_SUCCESS_E;

   /* Make sure the mandatory Enable and NumberOfSets parameters are    */
   /* semi-valid.                                                       */
   if((Parameter_Count >= 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 1))
   {
      /* Store the parameters.                                          */
      Enable = (boolean_t)Parameter_List[0].Integer_Value;

      /* If an advertising set is going to be enabled.                  */
      if(Enable)
      {
         /* Make sure the NumberOfSets and AdvertisingHandle parameter  */
         /* is semi-valid.                                              */
         /* * NOTE * NumberOfSets MUST be 1 for this function.          */
         if((Parameter_Count >= 3) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value == 1) &&
                                      (Parameter_List[2].Integer_Is_Valid))
         {
            /* Store the parameters.                                    */
            NumberOfSets      = (uint8_t)Parameter_List[1].Integer_Value;
            AdvertisingHandle = (uint8_t)Parameter_List[2].Integer_Value;

            /* Check if the optional Duration and MaxExtAdvertisingEvent*/
            /* parameters are specified.                                */
            if((Parameter_Count == 5) && (Parameter_List[3].Integer_Is_Valid) && (Parameter_List[4].Integer_Is_Valid))
            {
               /* Store the optional parameters.                        */
               Duration                = (uint32_t)Parameter_List[3].Integer_Value;
               MaxExtAdvertisingEvents = (uint8_t)Parameter_List[4].Integer_Value;
            }
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
      else
      {
         /* Make sure the NumberOfSets parameter is semi-valid.         */
         if((Parameter_Count >= 2) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= 1))
         {
            /* Store the parameters.                                    */
            NumberOfSets = (uint8_t)Parameter_List[1].Integer_Value;

            /* If we are NOT disabling all sets (NumberOfSets = 0), then*/
            /* the advertising handle MUST be valid.                    */
            if(NumberOfSets)
            {
               /* Make sure the AdvertisingHandle parameter is valid.   */
               if((Parameter_Count == 3) && (Parameter_List[2].Integer_Is_Valid))
               {
                  /* Store the parameter.                               */
                  AdvertisingHandle = (uint8_t)Parameter_List[2].Integer_Value;
               }
               else
                  ret_val = QCLI_STATUS_USAGE_E;
            }
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   /* If an error has not occured.                                      */
   if(!ret_val)
   {
      /* Simply call the GAP function.                                  */
      Result = qapi_BLE_GAP_LE_Enable_Extended_Advertising(BluetoothStackID, Enable, NumberOfSets, &AdvertisingHandle, &Duration, &MaxExtAdvertisingEvents, GAP_LE_Event_Callback, 0);
      if(!Result)
         QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Enable_Extended_Advertising() returned success.\n");
      else
      {
         QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Enable_Extended_Advertising() returned error: %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }

   return(ret_val);
}

   /* The following function is responsible for setting the extended    */
   /* scanning parameters. This function will return zero on successful */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t SetExtendedScanParams(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                                Result;
   uint16_t                                           ScanInterval;
   uint16_t                                           ScanWindow;
   boolean_t                                          FilterWhiteList;
   QCLI_Command_Status_t                              ret_val = QCLI_STATUS_SUCCESS_E;
   qapi_BLE_GAP_LE_Address_Type_t                     OwnAddrType;
   qapi_BLE_GAP_LE_Filter_Policy_t                    ScanningFilterPolicy;
   qapi_BLE_GAP_LE_Extended_Scanning_PHY_Parameters_t ScanParameter;

   /* Make sure the mandatory parameters are semi-valid.                */
   if((Parameter_Count >= 3) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid))
   {
      /* Store the parameters.                                          */
      ScanInterval    = (uint16_t)Parameter_List[0].Integer_Value;
      ScanWindow      = (uint16_t)Parameter_List[1].Integer_Value;
      FilterWhiteList = (boolean_t)Parameter_List[2].Integer_Value;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   /* If an error has not occured.                                      */
   if(!ret_val)
   {
      /* Store the default options.                                     */
      ScanParameter.Scan_PHY      = QAPI_BLE_LPT_PHY_LE_1M_E;
      ScanParameter.Scan_Type     = QAPI_BLE_ST_ACTIVE_E;
      ScanParameter.Scan_Interval = ScanInterval;
      ScanParameter.Scan_Window   = ScanWindow;
      OwnAddrType                 = QAPI_BLE_LAT_PUBLIC_E;

      if(FilterWhiteList)
         ScanningFilterPolicy     = QAPI_BLE_FP_WHITE_LIST_E;
      else
         ScanningFilterPolicy     = QAPI_BLE_FP_NO_FILTER_E;

      Result = qapi_BLE_GAP_LE_Set_Extended_Scan_Parameters(BluetoothStackID, OwnAddrType, ScanningFilterPolicy, 1, &ScanParameter);
      if(!Result)
         QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Set_Extended_Scan_Parameters() returned success.\n");
      else
      {
         QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Set_Extended_Scan_Parameters() returned error: %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }

   return(ret_val);
}

   /* The following function is responsible for enabling/disabling      */
   /* extended scanning. This function will return zero on successful   */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t EnableExtendedScan(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                                    Result;
   uint32_t                                               Duration;
   uint32_t                                               Period;
   boolean_t                                              Enable;
   QCLI_Command_Status_t                                  ret_val = QCLI_STATUS_SUCCESS_E;
   qapi_BLE_GAP_LE_Extended_Scan_Filter_Duplicates_Type_t FilterDuplicates;

   /* Make sure the mandatory parameters are semi-valid.                */
   if((Parameter_Count >= 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 1))
   {
      /* Store the parameters.                                          */
      Enable           = (boolean_t)Parameter_List[0].Integer_Value;
      FilterDuplicates = QAPI_BLE_FD_DISABLED_E;
      Duration         = 0;
      Period           = 0;

      /* If an advertising set is going to be enabled.                  */
      if(Enable)
      {
         /* Make sure the remaining parameters are valid.               */
         if((Parameter_Count == 3) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid))
         {
            /* Store the parameter.                                     */
            FilterDuplicates = QAPI_BLE_FD_ENABLED_E;
            Duration         = (uint32_t)Parameter_List[1].Integer_Value;
            Period           = (uint32_t)Parameter_List[2].Integer_Value;
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   /* If an error has not occured.                                      */
   if(!ret_val)
   {
      /* Enable extended scanning.                                      */
      Result = qapi_BLE_GAP_LE_Enable_Extended_Scan(BluetoothStackID, Enable, FilterDuplicates, Duration, Period, GAP_LE_Event_Callback, 0);
      if(!Result)
         QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Enable_Extended_Scan() returned success.\n");
      else
      {
         QCLI_Printf(bt5_group, "   qapi_BLE_GAP_LE_Enable_Extended_Scan() returned error: %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }

   return(ret_val);
}

   /* The following function is responsible for sending an extended     */
   /* connection request to a specified remote device. This function    */
   /* will return zero on successful execution and a negative value on  */
   /* errors.                                                           */
static QCLI_Command_Status_t ExtendedConnect(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                              Result;
   qapi_BLE_BD_ADDR_t                               PeerAddr;
   QCLI_Command_Status_t                            ret_val = QCLI_STATUS_SUCCESS_E;
   qapi_BLE_GAP_LE_Address_Type_t                   OwnAddrType;
   qapi_BLE_GAP_LE_Address_Type_t                   PeerAddrType;
   qapi_BLE_GAP_LE_Filter_Policy_t                  FilterPolicy;
   qapi_BLE_GAP_LE_Extended_Connection_Parameters_t ConnParameters;

   /* Make sure the remote address and address type have been specified.*/
   if((Parameter_Count == 2) && (Parameter_List[0].String_Value) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= QAPI_BLE_LAT_PUBLIC_E) && (Parameter_List[1].Integer_Value <= QAPI_BLE_LAT_RANDOM_IDENTITY_E))
   {
      /* Store the mandatory parameters.                                */
      StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &PeerAddr);
      PeerAddrType = (uint8_t)Parameter_List[1].Integer_Value;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   /* If an error has not occured.                                      */
   if(!ret_val)
   {
      /* Check to see if we need to configure the default Scan          */
      /* Parameters.                                                    */
      if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID))
      {
         /* Configure the default Scan Window and Scan Interval.        */
         BLEParameters.ScanParameters.ScanWindow   = 50;
         BLEParameters.ScanParameters.ScanInterval = 100;

         /* Flag that the scan parameters are valid so that we do not   */
         /* re-configure the defaults un-necessarily.                   */
         BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID;
      }

      /* Check to see if we need to configure the default Connection    */
      /* Parameters.                                                    */
      if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID))
      {
         /* Initialize the default connection parameters.               */
         BLEParameters.ConnectionParameters.Connection_Interval_Min    = 50;
         BLEParameters.ConnectionParameters.Connection_Interval_Max    = 200;
         BLEParameters.ConnectionParameters.Minimum_Connection_Length  = 0;
         BLEParameters.ConnectionParameters.Maximum_Connection_Length  = 10000;
         BLEParameters.ConnectionParameters.Slave_Latency              = 0;
         BLEParameters.ConnectionParameters.Supervision_Timeout        = 20000;

         /* Flag that the connection parameters are valid so that we do */
         /* not re-configure the defaults un-necessarily.               */
         BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID;
      }

      /* Format the connection parameters.                              */
      ConnParameters.Initiating_PHY            = QAPI_BLE_LPT_PHY_LE_1M_E;
      ConnParameters.Scan_Interval             = BLEParameters.ScanParameters.ScanInterval;
      ConnParameters.Scan_Window               = BLEParameters.ScanParameters.ScanWindow;
      ConnParameters.Connection_Interval_Min   = BLEParameters.ConnectionParameters.Connection_Interval_Min;
      ConnParameters.Connection_Interval_Max   = BLEParameters.ConnectionParameters.Connection_Interval_Max;
      ConnParameters.Slave_Latency             = BLEParameters.ConnectionParameters.Slave_Latency;
      ConnParameters.Supervision_Timeout       = BLEParameters.ConnectionParameters.Supervision_Timeout;
      ConnParameters.Minimum_Connection_Length = BLEParameters.ConnectionParameters.Minimum_Connection_Length;
      ConnParameters.Maximum_Connection_Length = BLEParameters.ConnectionParameters.Maximum_Connection_Length;

      /* Set the default options.                                       */
      FilterPolicy = QAPI_BLE_FP_NO_FILTER_E;
      OwnAddrType  = QAPI_BLE_LAT_PUBLIC_E;

      /* Simply call the GAP function.                                  */
      Result = qapi_BLE_GAP_LE_Extended_Create_Connection(BluetoothStackID, FilterPolicy, PeerAddrType, &PeerAddr, OwnAddrType, 1, &ConnParameters, GAP_LE_Event_Callback, 0);
      if(!Result)
         QCLI_Printf(bt5_group, "   qapi_BLE_HCI_LE_Extended_Create_Connection returned success.\n");
      else
      {
         QCLI_Printf(bt5_group, "   qapi_BLE_HCI_LE_Extended_Create_Connection returned error: %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }

   return(ret_val);
}

#endif

   /* Generic Attribute Profile (GATT) QCLI command functions.          */

   /* The following function is responsible for performing a GATT       */
   /* Service Discovery Operation.  This function will return zero on   */
   /* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t DiscoverServices(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                     Result;
   DeviceInfo_t                           *DeviceInfo;
   QCLI_Command_Status_t                   ret_val;
   qapi_BLE_GATT_Attribute_Handle_Group_t  DiscoveryHandleRange;

   /* Verify that there is a connection that is established.            */
   if(ConnectionCount)
   {
      /* Lock the Bluetooth stack.                                      */
      if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
      {
         /* Get the device info for the connection device.              */
         if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
         {
            /* Verify that no service discovery is outstanding for this */
            /* device.                                                  */
            if(!(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING))
            {
               /* Start the service discovery process.                  */
               if((Parameter_Count >= 2) && (Parameter_List[0].Integer_Value) && (Parameter_List[1].Integer_Value) && (Parameter_List[0].Integer_Value <= Parameter_List[1].Integer_Value))
               {
                  memset(&DiscoveryHandleRange, 0, sizeof(DiscoveryHandleRange));
                  DiscoveryHandleRange.Starting_Handle = Parameter_List[0].Integer_Value;
                  DiscoveryHandleRange.Ending_Handle   = Parameter_List[1].Integer_Value;

                  Result = qapi_BLE_GATT_Start_Service_Discovery_Handle_Range(BluetoothStackID, DeviceInfo->ConnectionID, &DiscoveryHandleRange, 0, NULL, GATT_Service_Discovery_Event_Callback, 0);
               }
               else
                  Result = qapi_BLE_GATT_Start_Service_Discovery(BluetoothStackID, DeviceInfo->ConnectionID, 0, NULL, GATT_Service_Discovery_Event_Callback, 0);

               if(!Result)
               {
                  /* Display success message.                           */
                  QCLI_Printf(ble_group, "qapi_BLE_GATT_Service_Discovery_Start() success.\n");

                  /* Flag that a Service Discovery Operation is         */
                  /* outstanding.                                       */
                  DeviceInfo->Flags |= DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING;

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  /* An error occur so just clean-up.                   */
                  QCLI_Printf(ble_group, "Error - GATT_Service_Discovery_Start returned %d.\n", Result);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(ble_group, "Service Discovery Operation Outstanding for Device.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(ble_group, "No Device Info.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }

         /* Un-lock the Bluetooth Stack.                                */
         qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
      }
      else
      {
         QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(ble_group, "No Connection Established\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for querying the GATT MTU.  */
   /* This function returns zero if successful and a negative value if  */
   /* an error occurred.                                                */
static QCLI_Command_Status_t GetGATTMTU(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   uint16_t              MTU;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Simply query the Maximum Supported MTU from the GATT layer.    */
      if((Result = qapi_BLE_GATT_Query_Maximum_Supported_MTU(BluetoothStackID, &MTU)) == 0)
      {
         QCLI_Printf(ble_group, "Maximum GATT MTU: %u.\n", (unsigned int)MTU);

         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         QCLI_Printf(ble_group, "Error - qapi_BLE_GATT_Query_Maximum_Supported_MTU() %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the GATT MTU.   */
   /* This function returns zero if successful and a negative value if  */
   /* an error occurred.                                                */
static QCLI_Command_Status_t SetGATTMTU(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Bluetooth Stack is initialized, go ahead and check to see if   */
      /* the parameters are valid.                                      */
      if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= QAPI_BLE_ATT_PROTOCOL_MTU_MINIMUM_LE) && (Parameter_List[0].Integer_Value <= QAPI_BLE_ATT_PROTOCOL_MTU_MAXIMUM))
      {
         /* Simply set the Maximum Supported MTU to the GATT layer.     */
         if((Result = qapi_BLE_GATT_Change_Maximum_Supported_MTU(BluetoothStackID, (uint16_t)Parameter_List[0].Integer_Value)) == 0)
         {
            QCLI_Printf(ble_group, "qapi_BLE_GATT_Change_Maximum_Supported_MTU() success, new GATT Maximum Supported MTU: %u.\n", (unsigned int)Parameter_List[0].Integer_Value);

            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            QCLI_Printf(ble_group, "Error - qapi_BLE_GATT_Change_Maximum_Supported_MTU() %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         /* Flag that an error occurred while submitting the command.   */
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* Generic Attribute Profile (GATT) helper functions.                */

   /* The following function is used to enable/disable notifications on */
   /* a specified handle.  This function returns the positive non-zero  */
   /* Transaction ID of the Write Request or a negative error code.     */
static int EnableDisableNotificationsIndications(uint16_t ClientConfigurationHandle, uint16_t ClientConfigurationValue, unsigned int ConnectionID, qapi_BLE_GATT_Client_Event_Callback_t ClientEventCallback)
{
   int                       ret_val;
   qapi_BLE_NonAlignedWord_t Buffer;

   /* Verify the input parameters.                                      */
   if((BluetoothStackID) && (ConnectionID) && (ClientConfigurationHandle))
   {
      ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(&Buffer, ClientConfigurationValue);

      ret_val = qapi_BLE_GATT_Write_Request(BluetoothStackID, ConnectionID, ClientConfigurationHandle, sizeof(Buffer), &Buffer, ClientEventCallback, 0);
   }
   else
      ret_val = QAPI_BLE_BTPS_ERROR_INVALID_PARAMETER;

   return(ret_val);
}

   /* Automation IO Service (AIOS) QCLI command functions.              */

   /* The following function is responsible for registering AIOS.  This */
   /* function will return zero on successful execution and a negative  */
   /* value on errors.                                                  */
static QCLI_Command_Status_t RegisterAIOS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t                          ret_val = QCLI_STATUS_SUCCESS_E;
   int                                            Result;
   uint32_t                                       ServiceID;
   qapi_BLE_AIOS_Initialize_Data_t                InitializeData;
   unsigned int                                   Index;
   unsigned int                                   Index2;
   qapi_BLE_AIOS_Characteristic_Type_t            Type;
   AIOP_Server_Characteristic_Data_t             *CharacteristicDataPtr;
   AIOP_Server_Instance_Data_t                   *InstanceDataPtr;
   qapi_BLE_AIOS_Characteristic_Entry_t          *CharacteristicEntryPtr;
   qapi_BLE_AIOS_Characteristic_Instance_Entry_t *InstanceEntryPtr;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Register for the service is one is not already registered.     */
      if(!AIOSInstanceID)
      {
         /* Configure the AIOS Server.                                  */
         /* * NOTE * This function will initialize all default          */
         /*          Characteristic properties, descriptors, and        */
         /*          descriptor properties.  This function will set     */
         /*          default data values for Characteristics and        */
         /*          descriptors.                                       */
         ConfigureAIOSServer();

         /* Initialize the AIOS InitializeData structure so we do not   */
         /* have any unexpected behaviour.                              */
         memset(&InitializeData, 0, QAPI_BLE_AIOS_INITIALIZE_DATA_SIZE);

         /* Set the InitializeData fields based on the AIOS Server      */
         /* information that we initialized previously.                 */
         /* * NOTE * This demo does not support the Aggregate           */
         /*          Characteristic.                                    */
         InitializeData.Number_Of_Entries        = (uint8_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS;
         InitializeData.Aggregate_Supported      = FALSE;
         InitializeData.Aggregate_Property_Flags = 0;

         /* We need to allocate memory for the Entries field.           */
         if((InitializeData.Entries = (qapi_BLE_AIOS_Characteristic_Entry_t *)malloc(QAPI_BLE_AIOS_CHARACTERISTIC_ENTRY_SIZE * InitializeData.Number_Of_Entries)) != NULL)
         {
            /* We will loop through each AIOS Characteristic Entry.     */
            for(Index = 0; Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS; Index++)
            {
               /* The Index will be used to indicate the AIOS           */
               /* Characteristic type.                                  */
               Type = (qapi_BLE_AIOS_Characteristic_Type_t)Index;

               /* Store a pointer to the Characteristic Entry           */
               /* information in InitializeData.                        */
               CharacteristicEntryPtr = &(InitializeData.Entries[Type]);

               /* Store a pointer to the Characteristic information on  */
               /* the AIOS Server.                                      */
               CharacteristicDataPtr = &(AIOSServerInfo.Characteristic[Type]);

               /* Simply copy the Characteristic Entry information we   */
               /* initialized earlier in the AIOS Server information.   */
               /* * NOTE * The Instances field has not be set since each*/
               /*          instance on the AIOS Server will hold its    */
               /*          Characteristic Instance Entry information.   */
               /*          Whereas the                                  */
               /*          qapi_BLE_AIOS_Characteristic_Entry_t has this*/
               /*          information stored contiguously.             */
               *CharacteristicEntryPtr = CharacteristicDataPtr->Characteristic_Entry;

               /* We need to allocate memory of the Instances field     */
               /* since it has not been set.                            */
               if((CharacteristicEntryPtr->Instances = (qapi_BLE_AIOS_Characteristic_Instance_Entry_t *)malloc(QAPI_BLE_AIOS_CHARACTERISTIC_ENTRY_SIZE * CharacteristicEntryPtr->Number_Of_Instances)) != NULL)
               {
                  /* We will loop through each AIOS Characteristic      */
                  /* Instance Entry.                                    */
                  for(Index2 = 0; Index2 < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES; Index2++)
                  {
                     /* Store a pointer to the Characteristic Instance  */
                     /* Entry information in InitializeData, in the     */
                     /* Entries field based on the AIOS Characteristic  */
                     /* type.                                           */
                     InstanceEntryPtr = &(CharacteristicEntryPtr->Instances[Index2]);

                     /* Store a pointer to the Characteristic instance  */
                     /* information.                                    */
                     /* * NOTE * The Index2 will be used to identify the*/
                     /*          AIOS Characteristic instance.  This    */
                     /*          also directly corresponds to the ID    */
                     /*          field that the service will use for the*/
                     /*          qapi_BLE_AIOS_Characteristic_Info_t    */
                     /*          structure.                             */
                     InstanceDataPtr = &(CharacteristicDataPtr->Instances[Index2]);

                     /* Simply copy the Characteristic Instance Entry   */
                     /* information we configured earlier in the AIOS   */
                     /* Server information.                             */
                     *InstanceEntryPtr = InstanceDataPtr->Instance_Entry;
                  }
               }
               else
               {
                  QCLI_Printf(aios_group, "Unable to allocate memory for the AIOS Characteristic instances.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
         }
         else
         {
            QCLI_Printf(aios_group, "Unable to allocate memory for the AIOS Characteristics.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }

         /* If an error has not occured.                                */
         if(!ret_val)
         {
            /* Register AIOS with GATT.                                 */
            Result = qapi_BLE_AIOS_Initialize_Service(BluetoothStackID, QAPI_BLE_AIOS_SERVICE_FLAGS_LE, &InitializeData, AIOS_EventCallback, 0, &ServiceID);
            if((Result > 0) && (ServiceID > 0))
            {
               /* Display success message.                              */
               QCLI_Printf(aios_group, "Successfully registered AIOS Service, InstanceID = %u.\n", Result);

               /* Save the instance ID of the registered service.       */
               AIOSInstanceID = (unsigned int)Result;
            }
            else
            {
               DisplayFunctionError("qapi_BLE_AIOS_Initialize_Service", Result);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }

         /* Free the memory for the InitializeData structure if it was  */
         /* allocated.                                                  */
         /* * NOTE * The AIOS Server retains a copy of this information */
         /*          for future use.                                    */
         for(Index = 0; Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS; Index++)
         {
            if((InitializeData.Entries[Index].Number_Of_Instances) && (InitializeData.Entries[Index].Instances))
            {
               /* Free the Characteristic instance entries.             */
               free(InitializeData.Entries[Index].Instances);
               InitializeData.Entries[Index].Instances           = NULL;
               InitializeData.Entries[Index].Number_Of_Instances = 0;
            }
         }

         /* Free the Characteristic entries.                            */
         if((InitializeData.Number_Of_Entries) && (InitializeData.Entries))
         {
            free(InitializeData.Entries);
            InitializeData.Entries           = NULL;
            InitializeData.Number_Of_Entries = 0;
         }
      }
      else
      {
         QCLI_Printf(aios_group, "AIOS is already registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(aios_group, "Connection currently active.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for unregistering AIOS.     */
   /* This function will return zero on successful execution and a      */
   /* negative value on errors.                                         */
static QCLI_Command_Status_t UnregisterAIOS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;
   int                   Result;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that a service is registered.                           */
      if(AIOSInstanceID)
      {
         /* Unregister the AIOS Service with GATT.                      */
         Result = qapi_BLE_AIOS_Cleanup_Service(BluetoothStackID, AIOSInstanceID);
         if(Result == 0)
         {
            /* Display success message.                                 */
            QCLI_Printf(aios_group, "Successfully unregistered AIOS: InstanceID %u.\n", AIOSInstanceID);

            /* Clear the instance ID.                                   */
            AIOSInstanceID = 0;

            /* Return success to the caller.                            */
            ret_val        = QCLI_STATUS_SUCCESS_E;
         }
         else
            DisplayFunctionError("qapi_BLE_AIOS_Cleanup_Service", Result);
      }
      else
         QCLI_Printf(aios_group, "AIOS is not registered.\n");
   }
   else
      QCLI_Printf(aios_group, "Connection currently active.\n");

   return(ret_val);
}

   /* The following function is responsible for allowing an AIOS Client */
   /* to configure an AIOS Digital or Analog Client Characteristic      */
   /* Configuration Descriptor (CCCD) on the AIOS Server for            */
   /* notifications.  This function will return zero on successful      */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ConfigureRemoteAIOS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t               ret_val = QCLI_STATUS_ERROR_E;
   int                                 Result;
   DeviceInfo_t                       *DeviceInfo;
   qapi_BLE_AIOS_Characteristic_Type_t Type;
   uint16_t                            ID;
   AIOP_Client_Instance_Info_t        *InstanceInfoPtr;

   /* Verify that we are connected to a remote device.                  */
   if(ConnectionCount)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[2].Integer_Is_Valid))
      {
         /* Store the parameters.                                       */
         Type = (qapi_BLE_AIOS_Characteristic_Type_t)Parameter_List[0].Integer_Value;
         ID   = (uint16_t)Parameter_List[1].Integer_Value;

         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the selected remote device.      */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               QCLI_Printf(aios_group, "Attempting to configure CCCDs...\n");

               /* Get a pointer to the instance information that has    */
               /* been specified by the user.                           */
               InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[Type].Instances[ID]);

               /* Make sure the characteristic instance has been        */
               /* discovered.                                           */
               if(InstanceInfoPtr->Valid)
               {
                  /* Make sure the AIOS Client has discovered the CCCD. */
                  if(InstanceInfoPtr->CCCD_Handle)
                  {
                     Result = EnableDisableNotificationsIndications(InstanceInfoPtr->CCCD_Handle, (Parameter_List[2].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_AIOS);
                     if(Result > 0)
                     {
                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                  }
                  else
                     QCLI_Printf(aios_group, "   Error - AIOS characteristic CC not found on this device.\n");
               }
               else
                  QCLI_Printf(aios_group, "Characteristic instance has not been discovered.\n");
            }
            else
               QCLI_Printf(aios_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(aios_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      QCLI_Printf(aios_group, "No Connection Established.\n");

   return(ret_val);
}

   /* The following function is responsible for allowing an AIOS Client */
   /* to read an AIOS Digital or Analog Characteristic Value on the AIOS*/
   /* Server.  This function will return zero on successful execution   */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t ReadAIOSCharacteristic(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t               ret_val = QCLI_STATUS_ERROR_E;
   int                                 Result;
   DeviceInfo_t                       *DeviceInfo;
   qapi_BLE_AIOS_Characteristic_Type_t Type;
   uint16_t                            ID;
   AIOP_Client_Instance_Info_t        *InstanceInfoPtr;
   uint16_t                            AttributeHandle;

   /* Verify that we are connected to a remote device.                  */
   if(ConnectionCount)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_List) && (Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES))
      {
         /* Store the parameters.                                       */
         Type = (qapi_BLE_AIOS_Characteristic_Type_t)Parameter_List[0].Integer_Value;
         ID   = (uint16_t)Parameter_List[1].Integer_Value;

         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the selected remote device.      */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Get a pointer to the instance information that has    */
               /* been specified by the user.                           */
               InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[Type].Instances[ID]);

               /* Make sure the characteristic instance has been        */
               /* discovered.                                           */
               if(InstanceInfoPtr->Valid)
               {
                  /* Determine the attribute handle based on the        */
                  /* specified AIOS Characteristic type.                */
                  if(Type == QAPI_BLE_ACT_DIGITAL_E)
                     AttributeHandle = InstanceInfoPtr->Digital_Characteristic_Handle;
                  else
                     AttributeHandle = InstanceInfoPtr->Analog_Charactersitic_Handle;

                  /* Make sure the AIOS Client has discovered the       */
                  /* Characteristic.                                    */
                  if(AttributeHandle)
                  {
                     /* Store the request information so we can handle  */
                     /* the response.                                   */
                     DeviceInfo->AIOPClientInfo.Client_Request_Info.AttributeHandleType = ahtCharacteristic;
                     DeviceInfo->AIOPClientInfo.Client_Request_Info.Type                = Type;
                     DeviceInfo->AIOPClientInfo.Client_Request_Info.ID                  = ID;

                     /* Finally, submit a read request to the server    */
                     if((Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, AttributeHandle, GATT_ClientEventCallback_AIOS, AttributeHandle)) > 0)
                     {
                        QCLI_Printf(aios_group, "AIOS Characteristic Request sent, Transaction ID = %u", Result);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                        DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                  }
                  else
                     QCLI_Printf(aios_group, "   Error - AIOS Characteristic not found on this device.\n");
               }
               else
                  QCLI_Printf(aios_group, "Characteristic instance has not been discovered.\n");
            }
            else
               QCLI_Printf(aios_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(aios_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      QCLI_Printf(aios_group, "No Connection Established.\n");

   return(ret_val);
}

   /* The following function is responsible for allowing an AIOS Client */
   /* or AIOS Server to write an AIOS Digital Output Characteristic.    */
   /* This function will return zero on successful execution and a      */
   /* negative value on errors.                                         */
static QCLI_Command_Status_t WriteAIOSDigitalOutput(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t        ret_val = QCLI_STATUS_ERROR_E;
   int                          Result;
   DeviceInfo_t                *DeviceInfo;
   uint16_t                     ID;
   AIOP_Server_Instance_Data_t *InstanceDataPtr;
   AIOP_Client_Instance_Info_t *InstanceInfoPtr;
   uint8_t                      DigitalValue[2];

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid))
   {
      /* Store the parameters.                                          */
      ID              = (uint16_t)Parameter_List[0].Integer_Value;
      DigitalValue[0] = (uint8_t)Parameter_List[1].Integer_Value;
      DigitalValue[1] = (uint8_t)Parameter_List[2].Integer_Value;

      /* If this is the AIOS Server, then we will update the digital    */
      /* output value.  Otherwise, we will send a GATT Write request to */
      /* update the digital output value on the AIOS Server.            */
      if(AIOSInstanceID)
      {
         /* Get a pointer to the instance data that has been specified  */
         /* by the user.                                                */
         InstanceDataPtr = &(AIOSServerInfo.Characteristic[QAPI_BLE_ACT_DIGITAL_E].Instances[ID]);

         /* Make sure the Digital Characteristic is an output.          */
         if(InstanceDataPtr->Instance_Entry.IO_Type == QAPI_BLE_IO_OUTOUT_E)
         {
            /* Update the value.                                        */
            InstanceDataPtr->Data.Digital[0] = DigitalValue[0];
            InstanceDataPtr->Data.Digital[1] = DigitalValue[1];
         }
         else
            QCLI_Printf(aios_group, "   Error - AIOS Digital Input Characteristic CANNOT be written.\n");
      }
      else
      {
         /* Verify that we are connected to a remote device.            */
         if(ConnectionCount)
         {
            /* Lock the Bluetooth stack.                                */
            if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
            {
               /* Get the device info for the selected remote device.   */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
               {
                  /* Get a pointer to the instance information that has */
                  /* been specified by the user.                        */
                  InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_DIGITAL_E].Instances[ID]);

                  /* Make sure the characteristic instance has been     */
                  /* discovered.                                        */
                  if(InstanceInfoPtr->Valid)
                  {
                     /* Make sure the AIOS Client has discovered the    */
                     /* Digital Characteristic.                         */
                     if(InstanceInfoPtr->Digital_Characteristic_Handle)
                     {
                        /* Make sure the Digital Characteristic is an   */
                        /* output.                                      */
                        if(InstanceInfoPtr->IOType == QAPI_BLE_IO_OUTOUT_E)
                        {
                           /* Finally, submit a read request to the     */
                           /* server                                    */
                           if((Result = qapi_BLE_GATT_Write_Request(BluetoothStackID, DeviceInfo->ConnectionID, InstanceInfoPtr->Digital_Characteristic_Handle, 2, DigitalValue, GATT_ClientEventCallback_AIOS, InstanceInfoPtr->Digital_Characteristic_Handle)) > 0)
                           {
                              QCLI_Printf(aios_group, "AIOS Digital Characteristic Request sent, Transaction ID = %u", Result);

                              ret_val = QCLI_STATUS_SUCCESS_E;
                           }
                           else
                              DisplayFunctionError("qapi_BLE_GATT_Write_Request", Result);
                        }
                        else
                           QCLI_Printf(aios_group, "   Error - AIOS Digital Input Characteristic CANNOT be written.\n");
                     }
                     else
                        QCLI_Printf(aios_group, "   Error - AIOS Digital Characteristic not found on this device.\n");
                  }
                  else
                     QCLI_Printf(aios_group, "Characteristic instance has not been discovered.\n");
               }
               else
                  QCLI_Printf(aios_group, "No Device Info.\n");

               /* Un-lock the Bluetooth Stack.                          */
               qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
            }
            else
               QCLI_Printf(aios_group, "Unable to acquire Bluetooth Stack Lock.\n");
         }
         else
            QCLI_Printf(aios_group, "No Connection Established.\n");
      }
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for allowing an AIOS Client */
   /* or AIOS Server to write an AIOS Analog Output Characteristic.     */
   /* This function will return zero on successful execution and a      */
   /* negative value on errors.                                         */
static QCLI_Command_Status_t WriteAIOSAnalogOutput(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t        ret_val = QCLI_STATUS_ERROR_E;
   int                          Result;
   DeviceInfo_t                *DeviceInfo;
   uint16_t                     ID;
   AIOP_Server_Instance_Data_t *InstanceDataPtr;
   AIOP_Client_Instance_Info_t *InstanceInfoPtr;
   uint16_t                     AnalogValue;
   qapi_BLE_NonAlignedWord_t    Buffer;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[1].Integer_Is_Valid))
   {
      /* Store the parameters.                                          */
      ID          = (uint16_t)Parameter_List[0].Integer_Value;
      AnalogValue = (uint16_t)Parameter_List[1].Integer_Value;

      /* If this is the AIOS Server, then we will update the digital    */
      /* output value.  Otherwise, we will send a GATT Write request to */
      /* update the digital output value on the AIOS Server.            */
      if(AIOSInstanceID)
      {
         /* Get a pointer to the instance data that has been specified  */
         /* by the user.                                                */
         InstanceDataPtr = &(AIOSServerInfo.Characteristic[QAPI_BLE_ACT_ANALOG_E].Instances[ID]);

         /* Make sure the Digital Characteristic is an output.          */
         if(InstanceDataPtr->Instance_Entry.IO_Type == QAPI_BLE_IO_OUTOUT_E)
         {
            /* Update the value.                                        */
            InstanceDataPtr->Data.Analog = AnalogValue;
         }
         else
            QCLI_Printf(aios_group, "   Error - AIOS Analog Input Characteristic CANNOT be written.\n");
      }
      else
      {
         /* Verify that we are connected to a remote device.            */
         if(ConnectionCount)
         {
            /* Lock the Bluetooth stack.                                */
            if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
            {
               /* Get the device info for the selected remote device.   */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
               {
                  /* Get a pointer to the instance information that has */
                  /* been specified by the user.                        */
                  InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_ANALOG_E].Instances[ID]);

                  /* Make sure the characteristic instance has been     */
                  /* discovered.                                        */
                  if(InstanceInfoPtr->Valid)
                  {
                     /* Make sure the AIOS Client has discovered the    */
                     /* Analog Characteristic.                          */
                     if(InstanceInfoPtr->Analog_Charactersitic_Handle)
                     {
                        /* Make sure the Analog Characteristic is an    */
                        /* output.                                      */
                        if(InstanceInfoPtr->IOType == QAPI_BLE_IO_OUTOUT_E)
                        {
                           /* Format the buffer.                        */
                           ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(&Buffer, AnalogValue);

                           /* Finally, submit a read request to the     */
                           /* server                                    */
                           if((Result = qapi_BLE_GATT_Write_Request(BluetoothStackID, DeviceInfo->ConnectionID, InstanceInfoPtr->Analog_Charactersitic_Handle, 2, &Buffer, GATT_ClientEventCallback_AIOS, InstanceInfoPtr->Analog_Charactersitic_Handle)) > 0)
                           {
                              QCLI_Printf(aios_group, "AIOS Analog Characteristic Request sent, Transaction ID = %u", Result);

                              ret_val = QCLI_STATUS_SUCCESS_E;
                           }
                           else
                              DisplayFunctionError("qapi_BLE_GATT_Write_Request", Result);
                        }
                        else
                           QCLI_Printf(aios_group, "   Error - AIOS Analog Input Characteristic CANNOT be written.\n");
                     }
                     else
                        QCLI_Printf(aios_group, "   Error - AIOS Analog Characteristic not found on this device.\n");
                  }
                  else
                     QCLI_Printf(aios_group, "Characteristic instance has not been discovered.\n");
               }
               else
                  QCLI_Printf(aios_group, "No Device Info.\n");

               /* Un-lock the Bluetooth Stack.                          */
               qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
            }
            else
               QCLI_Printf(aios_group, "Unable to acquire Bluetooth Stack Lock.\n");
         }
         else
            QCLI_Printf(aios_group, "No Connection Established.\n");
      }
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for allowing an AIOS Client */
   /* to read an AIOS Digital or Analog Presentation Format Descriptor  */
   /* on the AIOS Server.  This function will return zero on successful */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ReadAIOSPresentationFormat(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t               ret_val = QCLI_STATUS_ERROR_E;
   int                                 Result;
   DeviceInfo_t                       *DeviceInfo;
   qapi_BLE_AIOS_Characteristic_Type_t Type;
   uint16_t                            ID;
   AIOP_Client_Instance_Info_t        *InstanceInfoPtr;

   /* Verify that we are connected to a remote device.                  */
   if(ConnectionCount)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_List) && (Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES))
      {
         /* Store the parameters.                                       */
         Type = (qapi_BLE_AIOS_Characteristic_Type_t)Parameter_List[0].Integer_Value;
         ID   = (uint16_t)Parameter_List[1].Integer_Value;

         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the selected remote device.      */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Get a pointer to the instance information that has    */
               /* been specified by the user.                           */
               InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[Type].Instances[ID]);

               /* Make sure the characteristic instance has been        */
               /* discovered.                                           */
               if(InstanceInfoPtr->Valid)
               {
                  /* Make sure the AIOS Client has discovered the       */
                  /* Presentation Format Descriptor.                    */
                  if(InstanceInfoPtr->Presentation_Format_Handle)
                  {
                     /* Store the request information so we can handle  */
                     /* the response.                                   */
                     DeviceInfo->AIOPClientInfo.Client_Request_Info.AttributeHandleType = ahtPresentationFormat;
                     DeviceInfo->AIOPClientInfo.Client_Request_Info.Type                = Type;
                     DeviceInfo->AIOPClientInfo.Client_Request_Info.ID                  = ID;

                     /* Finally, submit a read request to the server    */
                     if((Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, InstanceInfoPtr->Presentation_Format_Handle, GATT_ClientEventCallback_AIOS, InstanceInfoPtr->Presentation_Format_Handle)) > 0)
                     {
                        QCLI_Printf(aios_group, "AIOS Presentation Format Descriptor Request sent, Transaction ID = %u", Result);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                        DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                  }
                  else
                     QCLI_Printf(aios_group, "   Error - AIOS Presentation Format Descriptor not found on this device.\n");
               }
               else
                  QCLI_Printf(aios_group, "Characteristic instance has not been discovered.\n");
            }
            else
               QCLI_Printf(aios_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(aios_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      QCLI_Printf(aios_group, "No Connection Established.\n");

   return(ret_val);
}

   /* The following function is responsible for allowing an AIOS Client */
   /* to read an AIOS Digital Characteristic's Number of Digitals       */
   /* descriptor on the AIOS Server.  This function will return zero on */
   /* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t ReadAIOSNumberOfDigitals(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t        ret_val = QCLI_STATUS_ERROR_E;
   int                          Result;
   DeviceInfo_t                *DeviceInfo;
   uint16_t                     ID;
   AIOP_Client_Instance_Info_t *InstanceInfoPtr;

   /* Verify that we are connected to a remote device.                  */
   if(ConnectionCount)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_List) && (Parameter_Count >= 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES))
      {
         /* Store the parameters.                                       */
         ID = (uint16_t)Parameter_List[0].Integer_Value;

         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the selected remote device.      */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Get a pointer to the instance information that has    */
               /* been specified by the user.                           */
               InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_DIGITAL_E].Instances[ID]);

               /* Make sure the characteristic instance has been        */
               /* discovered.                                           */
               if(InstanceInfoPtr->Valid)
               {
                  /* Make sure the AIOS Client has discovered the Number*/
                  /* Of Digitals Descriptor.                            */
                  if(InstanceInfoPtr->Number_Of_Digitals_Handle)
                  {
                     /* Store the request information so we can handle  */
                     /* the response.                                   */
                     DeviceInfo->AIOPClientInfo.Client_Request_Info.AttributeHandleType = ahtNumberOfDigitals;
                     DeviceInfo->AIOPClientInfo.Client_Request_Info.Type                = QAPI_BLE_ACT_DIGITAL_E;
                     DeviceInfo->AIOPClientInfo.Client_Request_Info.ID                  = ID;

                     /* Finally, submit a read request to the server    */
                     if((Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, InstanceInfoPtr->Number_Of_Digitals_Handle, GATT_ClientEventCallback_AIOS, InstanceInfoPtr->Number_Of_Digitals_Handle)) > 0)
                     {
                        QCLI_Printf(aios_group, "AIOS Number Of Digitals Descriptor Request sent, Transaction ID = %u", Result);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                        DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                  }
                  else
                     QCLI_Printf(aios_group, "   Error - AIOS Number Of Digitals Descriptor not found on this device.\n");
               }
               else
                  QCLI_Printf(aios_group, "Characteristic instance has not been discovered.\n");
            }
            else
               QCLI_Printf(aios_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(aios_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      QCLI_Printf(aios_group, "No Connection Established.\n");

   return(ret_val);
}

   /* The following function is responsible for allowing an AIOS Server */
   /* to set an AIOS Digital Input Characteristic.  This function will  */
   /* return zero on successful execution and a negative value on       */
   /* errors.                                                           */
static QCLI_Command_Status_t SetAIOSDigitalInput(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t        ret_val = QCLI_STATUS_ERROR_E;
   uint16_t                     ID;
   AIOP_Server_Instance_Data_t *InstanceDataPtr;
   uint8_t                      DigitalValue[2];

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid))
   {
      /* Store the parameters.                                          */
      ID              = (uint16_t)Parameter_List[0].Integer_Value;
      DigitalValue[0] = (uint8_t)Parameter_List[1].Integer_Value;
      DigitalValue[1] = (uint8_t)Parameter_List[2].Integer_Value;

      /* If this is the AIOS Server, then we will update the digital    */
      /* output value.  Otherwise, we will send a GATT Write request to */
      /* update the digital output value on the AIOS Server.            */
      if(AIOSInstanceID)
      {
         /* Get a pointer to the instance data that has been specified  */
         /* by the user.                                                */
         InstanceDataPtr = &(AIOSServerInfo.Characteristic[QAPI_BLE_ACT_DIGITAL_E].Instances[ID]);

         /* Make sure the Digital Characteristic is an output.          */
         if(InstanceDataPtr->Instance_Entry.IO_Type == QAPI_BLE_IO_INPUT_E)
         {
            /* Update the value.                                        */
            InstanceDataPtr->Data.Digital[0] = DigitalValue[0];
            InstanceDataPtr->Data.Digital[1] = DigitalValue[1];

            /* Set return value to success.                             */
            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
            QCLI_Printf(aios_group, "   Error - AIOS Digital Output Characteristic CANNOT be set.\n");
      }
      else
         QCLI_Printf(aios_group, "   Error - Only the AIOS Server may set the Digital Input Characteristic.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for allowing an AIOS Server */
   /* to set an AIOS Analog Input Characteristic.  This function will   */
   /* return zero on successful execution and a negative value on       */
   /* errors.                                                           */
static QCLI_Command_Status_t SetAIOSAnalogInput(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t        ret_val = QCLI_STATUS_ERROR_E;
   uint16_t                     ID;
   AIOP_Server_Instance_Data_t *InstanceDataPtr;
   uint16_t                     AnalogValue;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[1].Integer_Is_Valid))
   {
      /* Store the parameters.                                          */
      ID          = (uint16_t)Parameter_List[0].Integer_Value;
      AnalogValue = (uint16_t)Parameter_List[1].Integer_Value;

      /* Make sure we are the AIOS Server.                              */
      if(AIOSInstanceID)
      {
         /* Get a pointer to the instance data that has been specified  */
         /* by the user.                                                */
         InstanceDataPtr = &(AIOSServerInfo.Characteristic[QAPI_BLE_ACT_ANALOG_E].Instances[ID]);

         /* Make sure the Digital Characteristic is an output.          */
         if(InstanceDataPtr->Instance_Entry.IO_Type == QAPI_BLE_IO_INPUT_E)
         {
            /* Update the value.                                        */
            InstanceDataPtr->Data.Analog = AnalogValue;

            /* Set return value to success.                             */
            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
            QCLI_Printf(aios_group, "   Error - AIOS Analog Output Characteristic CANNOT be set.\n");
      }
      else
         QCLI_Printf(aios_group, "   Error - Only the AIOS Server may set the Analog Input Characteristic.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for allowing an AIOS Server */
   /* to notify the specify AIOS Characteristic to a remote AIOS Client.*/
   /* This function will return zero on successful execution and a      */
   /* negative value on errors.                                         */
static QCLI_Command_Status_t NotifyAIOSCharacteristic(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t                ret_val = QCLI_STATUS_ERROR_E;
   int                                  Result;
   DeviceInfo_t                        *DeviceInfo;
   qapi_BLE_AIOS_Characteristic_Type_t  Type;
   uint16_t                             ID;
   AIOP_Server_Instance_Data_t         *InstanceDataPtr;
   qapi_BLE_AIOS_Characteristic_Info_t  Info;
   qapi_BLE_AIOS_Characteristic_Data_t  Data;

   /* Verify that we are connected to a remote device.                  */
   if(ConnectionCount)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_List) && (Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES))
      {
         /* Store the parameters.                                       */
         Type = (qapi_BLE_AIOS_Characteristic_Type_t)Parameter_List[0].Integer_Value;
         ID   = (uint16_t)Parameter_List[1].Integer_Value;

         /* Make sure we are the AIOS Server.                           */
         if(AIOSInstanceID)
         {
            /* Lock the Bluetooth stack.                                */
            if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
            {
               /* Get the device info for the selected remote device.   */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
               {
                  /* Get a pointer to the instance data that has been   */
                  /* specified by the user.                             */
                  InstanceDataPtr = &(AIOSServerInfo.Characteristic[Type].Instances[ID]);

                  /* Make sure the AIOS Client has configured the       */
                  /* specified characteristic for notifications.        */
                  if(DeviceInfo->AIOPServerConfiguration == QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                  {
                     /* Determine the attribute handle based on the     */
                     /* specified AIOS Characteristic type.             */
                     if(Type == QAPI_BLE_ACT_DIGITAL_E)
                     {
                        /* Format the characteristic information.       */
                        Info.ID     = ID;
                        Info.Type   = Type;
                        Info.IOType = InstanceDataPtr->Instance_Entry.IO_Type;

                        /* Format the notification.                     */
                        Data.Digital.Buffer = InstanceDataPtr->Data.Digital;
                        Data.Digital.Length = 2;

                        /* Finally, send the notification.              */
                        if((Result = qapi_BLE_AIOS_Notify_Characteristic(BluetoothStackID, AIOSInstanceID, DeviceInfo->ConnectionID, &Info, &Data)) > 0)
                        {
                           QCLI_Printf(aios_group, "AIOS Characteristic Notification sent, Length = %u", Result);

                           ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                           DisplayFunctionError("qapi_BLE_AIOS_Notify_Characteristic", Result);
                     }
                     else
                     {
                        /* Format the characteristic information.       */
                        Info.ID     = ID;
                        Info.Type   = Type;
                        Info.IOType = InstanceDataPtr->Instance_Entry.IO_Type;

                        /* Format the notification.                     */
                        Data.Digital.Buffer = (uint8_t *)&(InstanceDataPtr->Data.Analog);
                        Data.Digital.Length = 2;

                        /* Finally, send the notification.              */
                        if((Result = qapi_BLE_AIOS_Notify_Characteristic(BluetoothStackID, AIOSInstanceID, DeviceInfo->ConnectionID, &Info, &Data)) > 0)
                        {
                           QCLI_Printf(aios_group, "AIOS Characteristic Notification sent, Length = %u", Result);

                           ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                           DisplayFunctionError("qapi_BLE_AIOS_Notify_Characteristic", Result);
                     }
                  }
                  else
                     QCLI_Printf(aios_group, "   Error - The AIOS Client has not configured the CCCD for notifications.\n");
               }
               else
                  QCLI_Printf(aios_group, "No Device Info.\n");

               /* Un-lock the Bluetooth Stack.                          */
               qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
            }
            else
               QCLI_Printf(aios_group, "Unable to acquire Bluetooth Stack Lock.\n");
         }
         else
            QCLI_Printf(aios_group, "   Error - Only the AIOS Server may send a notification.\n");
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      QCLI_Printf(aios_group, "No Connection Established.\n");

   return(ret_val);
}

   /* The following function will configure the AIOS Server before it is*/
   /* initialized by a call to qapi_BLE_AIOS_Initialize_Service().      */
static void ConfigureAIOSServer(void)
{
   unsigned int                         Index;
   unsigned int                         Index2;
   qapi_BLE_AIOS_Characteristic_Type_t  Type;
   AIOP_Server_Characteristic_Data_t   *CharacteristicDataPtr;
   AIOP_Server_Instance_Data_t         *InstanceDataPtr;

   /* Initialize the AIOS Server information.                           */
   memset(&AIOSServerInfo, 0, AIOP_SERVER_INFORMATION_DATA_SIZE);

   /* Loop to initialize the AIOS Characteristic's information that will*/
   /* be used for all AIOS Characteristic instances.                    */
   for(Index = 0; Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS; Index++)
   {
      /* The Index will be used to indicate the AIOS Characteristic     */
      /* type.                                                          */
      Type = (qapi_BLE_AIOS_Characteristic_Type_t)Index;

      /* Store a pointer to the Characteristic information.             */
      CharacteristicDataPtr = &(AIOSServerInfo.Characteristic[Type]);

      /* Let's go ahead and initialize the Characteristic's information.*/
      /* * NOTE * We will not set the Instances field since it will not */
      /*          be used for the AIOS Server.  It will be set for the  */
      /*          qapi_BLE_AIOS_Initialize_Data_t structure we when copy*/
      /*          this information to it.                               */
      CharacteristicDataPtr->Characteristic_Entry.Type                = (qapi_BLE_AIOS_Characteristic_Type_t)Index;
      CharacteristicDataPtr->Characteristic_Entry.Number_Of_Instances = (uint16_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES;
      CharacteristicDataPtr->Characteristic_Entry.Instances           = NULL;

      /* Loop to initialize all AIOS Characteristic instance's          */
      /* information for this Characteristic type.                      */
      for(Index2 = 0; Index2 < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES; Index2++)
      {
         /* Store a pointer to the Characteristic instance information. */
         /* * NOTE * The Index2 will be used to identify the AIOS       */
         /*          Characteristic instance.  This also directly       */
         /*          corresponds to the ID field that the service will  */
         /*          use for the AIOS_Characteristic_Info_t structure.  */
         InstanceDataPtr = &(CharacteristicDataPtr->Instances[Index2]);

         /* Let's go ahead and initialize the instances IO Type.        */
         /* * NOTE * We will make even indexes inputs and odd indexes   */
         /*          outputs.                                           */
         InstanceDataPtr->Instance_Entry.IO_Type = (Index2 % 2 == 0) ? QAPI_BLE_IO_INPUT_E : QAPI_BLE_IO_OUTOUT_E;

         /* We will go ahead and initiailze the fields that depend on   */
         /* the IOType.                                                 */
         switch(InstanceDataPtr->Instance_Entry.IO_Type)
         {
            case QAPI_BLE_IO_INPUT_E:
               InstanceDataPtr->Instance_Entry.Characteristic_Property_Flags = (uint8_t)AIOP_DEFAULT_INPUT_CHARACTERISTIC_PROPERTY_FLAGS;

               /* ** NOTE ** Inputs will automatically be given the read*/
               /*            property since it is mandatory.  However,  */
               /*            since we are going to retain the           */
               /*            Instance_Entry on AIOS Server we will go   */
               /*            ahead and flag this property.              */
               /*            qapi_BLE_AIOS_Initialize_Service() will NOT*/
               /*            FAIL if this flag is set (even though it is*/
               /*            not required for inputs), since it is a    */
               /*            valid property for inputs.  This will also */
               /*            allow the AIOS Server to not have to check */
               /*            if the AIOS Characteristic is an input or  */
               /*            it has the read property.  We can simply   */
               /*            check if it has the read property.         */
               InstanceDataPtr->Instance_Entry.Characteristic_Property_Flags |= (uint8_t)QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ;
               break;
            case QAPI_BLE_IO_OUTOUT_E:
               InstanceDataPtr->Instance_Entry.Characteristic_Property_Flags = (uint8_t)AIOP_DEFAULT_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS;
               break;
            default:
               /* Prevent compiler warnings.                            */
               break;
         }

         /* We will use a custom trigger by default.  This means that we*/
         /* do NOT support the Value Trigger or Time Trigger            */
         /* Characteristic Descriptors.  See qapi_ble_aios.h for more   */
         /* information.                                                */
         InstanceDataPtr->Instance_Entry.Use_Custom_Trigger = TRUE;

         /* Now they we have set up the instance entry that will be     */
         /* needed to initialize the Characteristic instance with a call*/
         /* to qapi_BLE_AIOS_Initialize_Service(), we will setup initial*/
         /* values for the instance's data.                             */
         /* * NOTE * If we do not initialize a field below, then it     */
         /*          already has been initialized to zero.              */

         /* Initialize the Presentation Format data.                    */
         /* * NOTE * The Description field use to identify the AIOS     */
         /*          Characteristic instance is always 1 greater than   */
         /*          the ID (Index2) that we use to identify it.        */
         if(Type == QAPI_BLE_ACT_DIGITAL_E)
            InstanceDataPtr->Presentation_Format.Format   = (uint8_t)QAPI_BLE_AIOS_DIGITAL_PRESENTATION_FORMAT_STRUCT;
         else
            InstanceDataPtr->Presentation_Format.Format   = (uint8_t)QAPI_BLE_AIOS_ANALOG_PRESENTATION_FORMAT_UINT16;
         InstanceDataPtr->Presentation_Format.Exponent    = 0;
         InstanceDataPtr->Presentation_Format.Unit        = 0;
         InstanceDataPtr->Presentation_Format.NameSpace   = (uint8_t)QAPI_BLE_AIOS_PRESENTATION_FORMAT_NAMESPACE_BT_SIG;
         InstanceDataPtr->Presentation_Format.Description = (uint16_t)(Index2 + 1);

         /* Initialize the Number Of Digitals descriptor.               */
         /* * NOTE * This demo supports 8 digital signals for each      */
         /*          Digital Characteristic instance.                   */
         InstanceDataPtr->Number_Of_Digitals = 8;
      }
   }
}

   /* The following function is responsible for getting a pointer to the*/
   /* AIOS Server Characteristic instance information based on the      */
   /* CharacteristicInfo parameter.  If this function is successful a   */
   /* pointer to the instance will be returned.  Otherwise NULL will be */
   /* returned.                                                         */
   /* * NOTE * This function should NOT be used for the Aggregate       */
   /*          Characteristic.                                          */
static AIOP_Server_Instance_Data_t *GetAIOSServerInstanceInfoPtr(qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo)
{
   AIOP_Server_Instance_Data_t *ret_val = NULL;

   /* Make sure the parameters are semi-valid.                          */
   if(CharacteristicInfo)
   {
      /* Make sure the Characteristic type is valid.                    */
      if((CharacteristicInfo->Type >= QAPI_BLE_ACT_DIGITAL_E) && (CharacteristicInfo->Type <= QAPI_BLE_ACT_ANALOG_E))
      {
         /* Make sure the ID is less than the number of supported       */
         /* instances.                                                  */
         /* * NOTE * This demo only supports two instances for each AIOS*/
         /*          Characteristic.                                    */
         if(CharacteristicInfo->ID < (uint32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES)
         {
            /* Since we have the type and instance identifier we can use*/
            /* these values to index the AIOS Server Characteristic     */
            /* instance information.                                    */
            ret_val = &(AIOSServerInfo.Characteristic[CharacteristicInfo->Type].Instances[CharacteristicInfo->ID]);
         }
         else
            QCLI_Printf(aios_group, "\nWarning - Invalid Characteristic instance ID.\n");
      }
      else
         QCLI_Printf(aios_group, "\nWarning - Invalid Characteristic type.\n");
   }
   else
      QCLI_Printf(aios_group, "\nWarning - Characteristic information invalid.\n");

   return (ret_val);
}

   /* The following function is responsible for getting a pointer to the*/
   /* AIOSS Client Characteristic instance's information based on the   */
   /* DeviceInfo parameter.  If this function is successful a pointer to*/
   /* the AIOS Client's instance information will be returned.          */
   /* Otherwise NULL will be returned.                                  */
   /* * NOTE * This function should NOT be used for the Aggregate       */
   /*          Characteristic.                                          */
static AIOP_Client_Instance_Info_t *GetAIOSClientInstanceInfoPtr(AIOP_Client_Information_t *ClientInfo)
{
   AIOP_Client_Instance_Info_t         *ret_val = NULL;
   qapi_BLE_AIOS_Characteristic_Type_t  Type;
   unsigned int                         ID;

   /* Make sure the parameters are semi-valid.                          */
   if(ClientInfo)
   {
      /* Store the Type and ID to make the code more readable.          */
      Type = ClientInfo->Client_Request_Info.Type;
      ID   = ClientInfo->Client_Request_Info.ID;

      /* Make sure the type is valid.                                   */
      if((Type >= QAPI_BLE_ACT_DIGITAL_E) && (Type <= QAPI_BLE_ACT_ANALOG_E))
      {
         /* Make sure the ID is less than the number of attribute handle*/
         /* information entries.                                        */
         /* * NOTE * This should directly correspond to the number of   */
         /*          instances of an AIOS Characteristic Type we        */
         /*          discovered.                                        */
         if(ID < (uint16_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES)
         {
            /* Since we have the type and instance identifier we can use*/
            /* these values to index the AIOS Client Attribute Handle   */
            /* information and get the correct instance.                */
            ret_val = &(ClientInfo->Characteristics[Type].Instances[ID]);
         }
         else
            QCLI_Printf(aios_group, "\nWarning - Invalid Characteristic instance ID.\n");
      }
      else
         QCLI_Printf(aios_group, "\nWarning - Invalid Characteristic type.\n");
   }
   else
      QCLI_Printf(aios_group, "\nWarning - Device information invalid.\n");

   return (ret_val);
}

   /* The following function is a utility function that provides a      */
   /* mechanism of populating a AIOS Client Information structure with  */
   /* the information discovered from a AIOS Discovery operation.       */
   /* * NOTE * We will only store characteristc attribute handles that  */
   /*          are supported by this demo.                              */
static void AIOSPopulateHandles(AIOP_Client_Information_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
   unsigned int                                           Index;
   unsigned int                                           Index2;
   qapi_BLE_GATT_Characteristic_Information_t            *CharacteristicInfoPtr;
   AIOP_Client_Instance_Info_t                           *InstanceInfoPtr;

   /* Verify that the input parameters are semi-valid.                  */
   if((ClientInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_AIOS_COMPARE_AIOS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
   {
     /* Loop through all characteristics discovered in the service and  */
     /* populate the correct entry.                                     */
     CharacteristicInfoPtr = ServiceDiscoveryData->CharacteristicInformationList;
     if(CharacteristicInfoPtr)
     {
        /* Let's loop through the AIOS Characteristic and store their   */
        /* information.                                                 */
        for(Index = 0; Index < ServiceDiscoveryData->NumberOfCharacteristics; Index++)
        {
           /* All AIOS UUIDs are defined to be 16 bit UUIDs.            */
           if(CharacteristicInfoPtr[Index].Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
           {
              /* If this is a Digital Characteristic.                   */
              if(QAPI_BLE_AIOS_COMPARE_DIGITAL_CHARACTERISTIC_UUID_TO_UUID_16(CharacteristicInfoPtr[Index].Characteristic_UUID.UUID.UUID_16))
              {
                 /* Find an empty AIOP Client Instance Information      */
                 /* structure to store this attribute handle            */
                 /* information.                                        */
                 for(Index2 = 0; Index2 < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES; Index2++)
                 {
                    /* Store a pointer to the Attribute Handle instance */
                    /* to aid in readability.                           */
                    InstanceInfoPtr = &(ClientInfo->Characteristics[QAPI_BLE_ACT_DIGITAL_E].Instances[Index2]);

                    /* Make sure this is an instance that has not been  */
                    /* used yet.                                        */
                    /* * NOTE * This demo will only store               */
                    /*          AIOP_NUMBER_OF_SUPPORTED_INSTANCES.     */
                    if(InstanceInfoPtr->Valid == FALSE)
                    {
                       /* Flag that the instance information is valid.  */
                       InstanceInfoPtr->Valid = TRUE;

                       /* Store the properties.                         */
                       InstanceInfoPtr->Properties = CharacteristicInfoPtr[Index].Characteristic_Properties;

                       /* Check the Digital Characteristic properties to*/
                       /* determine information that needs to be stored.*/
                       if((InstanceInfoPtr->Properties & (QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE | QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE_WITHOUT_RESPONSE)))
                       {
                          /* Store the IO Type.                         */
                          InstanceInfoPtr->IOType = QAPI_BLE_IO_OUTOUT_E;
                       }
                       else
                       {
                          /* * NOTE * It is impossible to determine if  */
                          /*          this is an error, but we will     */
                          /*          assume that since Write or Write  */
                          /*          without response is not supported */
                          /*          this MUST be an input             */
                          /*          Characteristic.                   */

                          /* This MUST be a Digital Characteristic input*/
                          /* so lets check for Mandatory read property. */
                          if(InstanceInfoPtr->Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ)
                          {
                             //* Store the IO Type.                                */
                             InstanceInfoPtr->IOType = QAPI_BLE_IO_INPUT_E;
                          }
                          else
                             QCLI_Printf(ble_group, "Warning - Invalid properties for the Digital Characteristic instance!\n");
                       }

                       /* Store the attribute handle information for    */
                       /* this Digital Characteristic.                  */
                       InstanceInfoPtr->Digital_Characteristic_Handle = CharacteristicInfoPtr[Index].Characteristic_Handle;

                       /* Call the helper function to populate the      */
                       /* descriptor handles for this attribute handle  */
                       /* entry.                                        */
                       StoreDescriptorHandles(InstanceInfoPtr, &(CharacteristicInfoPtr[Index]));

                       /* We do not want to populate another instance so*/
                       /* we are done.                                  */
                       break;
                    }
                 }

                 /* Continue since we found the AIOS Characteristic     */
                 /* type.                                               */
                 continue;
              }

              /* If this is a Analog Characteristic.                    */
              if(QAPI_BLE_AIOS_COMPARE_ANALOG_CHARACTERISTIC_UUID_TO_UUID_16(CharacteristicInfoPtr[Index].Characteristic_UUID.UUID.UUID_16))
              {
                 /* Find an empty AIOP Client Instance Information      */
                 /* structure to store this attribute handle            */
                 /* information.                                        */
                 for(Index2 = 0; Index2 < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES; Index2++)
                 {
                    /* Store a pointer to the Attribute Handle instance */
                    /* to aid in readability.                           */
                    InstanceInfoPtr = &(ClientInfo->Characteristics[QAPI_BLE_ACT_ANALOG_E].Instances[Index2]);

                    /* Make sure this is an instance that has not been  */
                    /* used yet.                                        */
                    /* * NOTE * This demo will only store               */
                    /*          AIOP_NUMBER_OF_SUPPORTED_INSTANCES.     */
                    if(InstanceInfoPtr->Valid == FALSE)
                    {
                       /* Flag that the instance information is valid.  */
                       InstanceInfoPtr->Valid = TRUE;

                       /* Store the properties.                         */
                       InstanceInfoPtr->Properties = CharacteristicInfoPtr[Index].Characteristic_Properties;

                       /* Check the Analog Characteristic properties to */
                       /* determine information that needs to be stored.*/
                       if((InstanceInfoPtr->Properties & (QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE | QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE_WITHOUT_RESPONSE)))
                       {
                          /* Store the IO Type.                         */
                          InstanceInfoPtr->IOType = QAPI_BLE_IO_OUTOUT_E;
                       }
                       else
                       {
                          /* * NOTE * It is impossible to determine if  */
                          /*          this is an error, but we will     */
                          /*          assume that since Write or Write  */
                          /*          without response is not supported */
                          /*          this MUST be an input             */
                          /*          Characteristic.                   */

                          /* This MUST be a Analog Characteristic input */
                          /* so lets check for Mandatory read property. */
                          if(InstanceInfoPtr->Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ)
                          {
                             //* Store the IO Type.                     */
                             InstanceInfoPtr->IOType = QAPI_BLE_IO_INPUT_E;
                          }
                          else
                             QCLI_Printf(ble_group, "Warning - Invalid properties for the Analog Characteristic instance!\n");
                       }

                       /* Store the attribute handle information for    */
                       /* this Analog Characteristic.                   */
                       InstanceInfoPtr->Analog_Charactersitic_Handle = CharacteristicInfoPtr[Index].Characteristic_Handle;

                       /* Call the helper function to populate the      */
                       /* descriptor handles for this attribute handle  */
                       /* entry.                                        */
                       StoreDescriptorHandles(InstanceInfoPtr, &(CharacteristicInfoPtr[Index]));

                       /* We do not want to populate another instance so*/
                       /* we are done.                                  */
                       break;
                    }
                 }

                 /* Continue since we found the AIOS Characteristic     */
                 /* type.                                               */
                 continue;
              }

              /* Always print warnings for unknown characteristics.     */
              QCLI_Printf(ble_group, "\nUnknown Characteristic:\n");
              QCLI_Printf(ble_group, "   Handle:        0x%04X\n", CharacteristicInfoPtr[Index].Characteristic_Handle);
              QCLI_Printf(ble_group, "   Properties:    0x%02X\n", CharacteristicInfoPtr[Index].Characteristic_Properties);
              QCLI_Printf(ble_group, "   UUID:          0x");
              DisplayUUID(&(CharacteristicInfoPtr[Index].Characteristic_UUID));
           }
           else
              QCLI_Printf(ble_group, "\nWarning - UUID not 16-bit.\n");
        }
     }
   }
}

   /* The following function is a helper function for                   */
   /* StoreAttributeHandles() to populate the descriptor handles for an */
   /* AIOS Characteristic instance.                                     */
   /* * NOTE * We will only store descriptor attribute handles that are */
   /*          supported by this demo.                                  */
static void StoreDescriptorHandles(AIOP_Client_Instance_Info_t *InstanceInfoPtr, qapi_BLE_GATT_Characteristic_Information_t *CharacteristicInfoPtr)
{
   unsigned int                                           Index;
   qapi_BLE_GATT_Characteristic_Descriptor_Information_t *DescriptorInfoPtr;

   /* Store a pointer to the Descriptor information.                    */
   DescriptorInfoPtr = CharacteristicInfoPtr->DescriptorList;

   /* Loop through the descriptor information and store the descriptor  */
   /* handles.                                                          */
   for(Index = 0; Index < CharacteristicInfoPtr->NumberOfDescriptors; Index++)
   {
      /* Make sure the Descriptor UUID is 16-bit.                       */
      if(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
      {
         /* Check for the CCCD.                                         */
         if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID.UUID.UUID_16))
         {
            /* Store the handle.                                        */
            InstanceInfoPtr->CCCD_Handle = DescriptorInfoPtr[Index].Characteristic_Descriptor_Handle;
            continue;
         }

         /* Check for the Presentation Format descriptor.               */
         if(QAPI_BLE_GATT_COMPARE_CHARACTERISTIC_PRESENTATION_FORMAT_ATTRIBUTE_TYPE_TO_UUID_16(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID.UUID.UUID_16))
         {
            /* Store the handle.                                        */
            InstanceInfoPtr->Presentation_Format_Handle = DescriptorInfoPtr[Index].Characteristic_Descriptor_Handle;
            continue;
         }

         /* Check for the Number Of Digitals descriptor.                */
         /* * NOTE * This should ONLY be received for Digital           */
         /*          Characteristics, however we will not check this    */
         /*          here.                                              */
         if(QAPI_BLE_AIOS_COMPARE_NUMBER_OF_DIGITALS_CD_UUID_TO_UUID_16(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID.UUID.UUID_16))
         {
            /* Store the handle.                                        */
            InstanceInfoPtr->Number_Of_Digitals_Handle = DescriptorInfoPtr[Index].Characteristic_Descriptor_Handle;
            continue;
         }
      }

      /* Always print warnings for unknown characteristic descriptors.  */
      QCLI_Printf(ble_group, "\nUnknown Descriptor:\n");
      QCLI_Printf(ble_group, "   Handle:  0x%04X\n", DescriptorInfoPtr[Index].Characteristic_Descriptor_Handle);
      QCLI_Printf(ble_group, "   UUID:    0x");
      DisplayUUID(&(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID));
   }
}

   /* The following function is responsible for displaying the          */
   /* characteristic info in AIOS Events.                               */
static void DisplayAIOSCharacteristicInfo(qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo)
{
   /* Make sure the parameters are semi-valid.                          */
   if(CharacteristicInfo)
   {
      QCLI_Printf(aios_group, "   Characteristic Info:\n");
      QCLI_Printf(aios_group, "      Type:              ");
      switch(CharacteristicInfo->Type)
      {
         case QAPI_BLE_ACT_DIGITAL_E:
            QCLI_Printf(aios_group, "Digital.\n");
            break;
         case QAPI_BLE_ACT_ANALOG_E:
            QCLI_Printf(aios_group, "Analog.\n");
            break;
         default:
            QCLI_Printf(aios_group, "Invalid(%u).\n", CharacteristicInfo->Type);
      }
      QCLI_Printf(aios_group, "      IOType:            ");
      switch(CharacteristicInfo->IOType)
      {
         case QAPI_BLE_IO_INPUT_E:
            QCLI_Printf(aios_group, "Input.\n");
            break;
         case QAPI_BLE_IO_OUTOUT_E:
            QCLI_Printf(aios_group, "Output.\n");
            break;
         default:
            QCLI_Printf(aios_group, "Invalid(%u).\n", CharacteristicInfo->Type);
      }
      QCLI_Printf(aios_group, "      ID:                %u\n", CharacteristicInfo->ID);
   }
}

   /* The following function is responsible for displaying a Digital    */
   /* Characteristic.                                                   */
static void DisplayDigitalCharacteristic(qapi_BLE_AIOS_Digital_Characteristic_Data_t *DigitalData, uint32_t ID)
{
   unsigned int Index;
   unsigned int Index2;
   uint8_t      DigitalPosition;
   uint8_t      DigitalByte;
   uint8_t      DigitalCtr = 0;

   /* Make sure the parameter is semi-valid.                            */
   if(DigitalData)
   {
      /* Display the Characteristic type.                               */
      QCLI_Printf(aios_group, "\nDigital Characteristic (ID = %u):\n", ID);

      for(Index = 0; Index < (unsigned int)(DigitalData->Length); Index++)
      {
         /* Only 4 digital signals in a byte.  We will update the       */
         /* digital position after each iteration.                      */
         /* * NOTE * We start the digital at 0x03 or the lowest two bits*/
         /*          positions.  Shift left by two each iteration for   */
         /*          the next two bits.                                 */
         for(Index2 = 0, DigitalPosition = 0x03; Index2 < 4; Index2++, DigitalPosition <<= 2)
         {
            /* Print the digital signal number.                         */
            QCLI_Printf(aios_group, "   (%u). Digital: ", DigitalCtr++);

            /* Store a copy of the byte so we don't modify it.          */
            DigitalByte       = DigitalData->Buffer[Index];

            /* Get the state for the digital by using the position.     */
            DigitalByte      &= DigitalPosition;

            /* Shift the digital signal value to the two lowest bits.   */
            /* The number of right shifts will be (Index2*2).  This may */
            /* be zero for the first digital signal, which should       */
            /* already be at the lowest two bits.  This must be done so */
            /* we can print the value correctly.                        */
            DigitalByte     >>= (Index2*2);

            /* Print the digital byte.                                  */
            DisplayDigitalByte(DigitalByte);
         }
      }
   }
}

   /* Display the digital signal.  This is included so we don't have to */
   /* print this statement multiple times in the above function.        */
static void DisplayDigitalByte(uint8_t DigitalByte)
{
   /* Simply print the state in string format.                          */
   switch(DigitalByte)
   {
      case QAPI_BLE_AIOS_DIGITAL_CHARACTERISTIC_STATE_INACTIVE:
         QCLI_Printf(aios_group, "Inactive State.\n");
         break;
      case QAPI_BLE_AIOS_DIGITAL_CHARACTERISTIC_STATE_ACTIVE:
         QCLI_Printf(aios_group, "Active State.\n");
         break;
      case QAPI_BLE_AIOS_DIGITAL_CHARACTERISTIC_STATE_TRI_STATE:
         QCLI_Printf(aios_group, "Tri State.\n");
         break;
      case QAPI_BLE_AIOS_DIGITAL_CHARACTERISTIC_STATE_UNKNOWN:
         QCLI_Printf(aios_group, "Unknown State.\n");
         break;
      default:
         /* Can't occur, but here for compiler warnings.                */
         break;
   }
}

   /* The following function is responsible for displaying an Analog    */
   /* Characteristic.                                                   */
static void DisplayAnalogCharacteristic(uint16_t AnalogData, uint32_t ID)
{
   /* Display the Analog Characteristic.                                */
   QCLI_Printf(aios_group, "\nAnalog Characteristic (ID = %u):\n", ID);
   QCLI_Printf(aios_group, "   Value:   0x%04X\n", AnalogData);
}

   /* The following function is responsible for displaying the          */
   /* presentation format data received in a GATT Read response.        */
static void DisplayAIOSPresentationFormatData(qapi_BLE_AIOS_Presentation_Format_Data_t *PresentationFormatData)
{
   /* Make sure the data is semi-valid.                                 */
   if(PresentationFormatData)
   {
      QCLI_Printf(aios_group, "\nPresentation Format Data:\n");
      QCLI_Printf(aios_group, "   Format:       0x%02X\n", PresentationFormatData->Format);
      QCLI_Printf(aios_group, "   Exponent:     0x%02X\n", PresentationFormatData->Exponent);
      QCLI_Printf(aios_group, "   Unit:         0x%04X\n", PresentationFormatData->Unit);
      QCLI_Printf(aios_group, "   NameSpace:    0x%02X\n", PresentationFormatData->NameSpace);
      QCLI_Printf(aios_group, "   Description:  0x%04X\n", PresentationFormatData->Description);
   }
}

   /* The following function displays received digtal characteristic    */
   /* data.                                                             */
static void DecodeDisplayDigitalCharacteristic(uint16_t ValueLength, uint8_t *Value, uint32_t ID)
{
   qapi_BLE_AIOS_Digital_Characteristic_Data_t DigitalData;

   DigitalData.Length = ValueLength;
   DigitalData.Buffer = Value;

   /* Display the Digital Characteristic.                               */
   DisplayDigitalCharacteristic(&DigitalData, ID);
}

   /* The following function displays the received analog characteristic*/
   /* data.                                                             */
static void DecodeDisplayAnalogCharacteristic(uint16_t ValueLength, uint8_t *Value, uint32_t ID)
{
   uint16_t AnalogData;

   /* Verify the length.                                                */
   if(ValueLength >= (uint16_t)QAPI_BLE_NON_ALIGNED_WORD_SIZE)
   {
      AnalogData = READ_UNALIGNED_WORD_LITTLE_ENDIAN(Value);

      /* Display the Analog Characteristic.                             */
      DisplayAnalogCharacteristic(AnalogData, ID);
   }
   else
      QCLI_Printf(aios_group, "\nAnalog Characteristic has an invalid length.\n");
}

   /* Battery Alert Service (BAS) QCLI command functions.               */

   /* The following function is responsible for registering a BAS       */
   /* Service.  This function will return zero on successful execution  */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t RegisterBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                     Index;
   int                                     Result;
   uint32_t                                ServiceID;
   QCLI_Command_Status_t                   ret_val = QCLI_STATUS_SUCCESS_E;
   qapi_BLE_BAS_Presentation_Format_Data_t BatteryLevelPresentationFormat;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that the Service is not already registered.             */
      for(Index = 0; ((Index < MAX_SUPPORTED_BATTERY_INSTANCES) && (BASInstanceID[Index])); Index++)
         ;

      /* Register for the service is one is not already registered.     */
      if(Index != MAX_SUPPORTED_BATTERY_INSTANCES)
      {
         /* Register the BAS Service with GATT.                         */
         Result = qapi_BLE_BAS_Initialize_Service(BluetoothStackID, BAS_EventCallback, 0, &ServiceID);
         if((Result > 0) && (ServiceID > 0))
         {
            /* Display success message.                                 */
            QCLI_Printf(bas_group, "Successfully registered BAS Service, InstanceID = %u.\n", Result);

            /* Save the ServiceID of the registered service.            */
            BASInstanceID[Index]                       = (unsigned int)Result;

            /* Initialize internal BAS variables                        */
            BatteryLevelPresentationFormat.Format      = 0;
            BatteryLevelPresentationFormat.Exponent    = 0;
            BatteryLevelPresentationFormat.Unit        = 0;
            BatteryLevelPresentationFormat.NameSpace   = 1;
            BatteryLevelPresentationFormat.Description = (uint16_t)(Result);

            qapi_BLE_BAS_Set_Characteristic_Presentation_Format(BluetoothStackID, BASInstanceID[Index], &BatteryLevelPresentationFormat);
         }
         else
         {
            DisplayFunctionError("qapi_BLE_BAS_Initialize_Service", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(bas_group, "Maximum number of BAS instances have been registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(bas_group, "Connection currently active.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for unregistering a BAS     */
   /* Service.  This function will return zero on successful execution  */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t UnregisterBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Index;
   int                   Result;
   QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that a service is registered.                           */
      for(Index = MAX_SUPPORTED_BATTERY_INSTANCES - 1; ((Index >= 0) && (!BASInstanceID[Index])); Index--)
         ;

      if(Index >= 0)
      {
         /* Unregister the BAS Service with GATT.                       */
         Result = qapi_BLE_BAS_Cleanup_Service(BluetoothStackID, BASInstanceID[Index]);
         if(Result == 0)
         {
            /* Display success message.                                 */
            QCLI_Printf(bas_group, "Successfully unregistered BAS Service InstanceID %u.\n", BASInstanceID[Index]);

            /* Clear the ServiceID of the registered service.           */
            BASInstanceID[Index] = 0;

            /* Return success to the caller.                            */
            ret_val              = QCLI_STATUS_SUCCESS_E;
         }
         else
            DisplayFunctionError("qapi_BLE_BAS_Cleanup_Service", Result);
      }
      else
         QCLI_Printf(bas_group, "BAS Service not registered.\n");
   }
   else
      QCLI_Printf(bas_group, "Connection currently active.\n");

   return(ret_val);
}

   /* The following function is responsible for configure a BAS Service */
   /* on a remote device.  This function will return zero on successful */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ConfigureRemoteBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   unsigned int           InstanceID;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

   if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
      InstanceID = (Parameter_List[1].Integer_Value - 1);
   else
      ret_val = QCLI_STATUS_USAGE_E;

#else

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid))
      InstanceID = 0;
   else
      ret_val = QCLI_STATUS_USAGE_E;

#endif

   if(ret_val != QCLI_STATUS_USAGE_E)
   {
      /* Verify that we are not configured as a server                  */
      if(!BASInstanceID[0])
      {
         /* Verify that there is a connection that is established.      */
         if(ConnectionCount)
         {
            /* Lock the Bluetooth stack.                                */
            if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
            {
               /* Get the device info for the connection device.        */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
               {
                  QCLI_Printf(bas_group, "Attempting to configure CCCDs...\n");

                  /* Determine if Battery Level Client Configuration is */
                  /* supported (mandatory).                             */
                  if(DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Client_Configuration)
                     Result = EnableDisableNotificationsIndications(DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Client_Configuration, (Parameter_List[0].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_BAS);
                  else
                  {
                     QCLI_Printf(bas_group, "   Error - Battery Level Client Configuration not found on this device.\n");

                     Result = 0;
                  }

                  /* Check for CC Configuration success                 */
                  if(Result > 0)
                  {
                     QCLI_Printf(bas_group, "CCCD Configuration Success.\n");

                     ret_val = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                  {
                     /* CC Configuration failed, check to see if it was */
                     /* from a call to SetNotification                  */
                     if(Result < 0)
                        DisplayFunctionError("SetNotification", ret_val);

                     ret_val = QCLI_STATUS_ERROR_E;
                  }
               }
               else
                  QCLI_Printf(bas_group, "No Device Info.\n");

               /* Un-lock the Bluetooth Stack.                          */
               qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
            }
            else
               QCLI_Printf(bas_group, "Unable to acquire Bluetooth Stack Lock.\n");
         }
         else
            QCLI_Printf(bas_group, "No Connection Established.\n");
      }
      else
         QCLI_Printf(bas_group, "Cannot configure remote BAS Services when registered as a service.\n");
   }

   return(ret_val);
}

   /* The following function is responsible for reading the battery     */
   /* level. It can be executed by a server or a client with an open    */
   /* connection to a remote server.  If executed as a client, a GATT   */
   /* read request will be generated, and the results will be returned  */
   /* as a response in the GATT client event callback.  This function   */
   /* will return zero on successful execution and a negative value on  */
   /* errors.                                                           */
static QCLI_Command_Status_t GetBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int           Result;
   int           ret_val = QCLI_STATUS_ERROR_E;
   unsigned int  InstanceID;
   DeviceInfo_t *DeviceInfo;

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
      InstanceID = Parameter_List[0].Integer_Value - 1;
   else
      ret_val = QCLI_STATUS_USAGE_E;

#else

   InstanceID = 0;

#endif

   if(ret_val != QCLI_STATUS_USAGE_E)
   {
      /* Lock the Bluetooth stack.                                      */
      if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
      {
         /* First check for a registered BAS Server                     */
         if(BASInstanceID[0])
         {
            /* Verify that this server instance has been initialized.   */
            if(BASInstanceID[InstanceID])
            {
               QCLI_Printf(bas_group, "Battery Level: %u%%.\n", (uint16_t)BatteryLevel[InstanceID]);

               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
               ret_val = QCLI_STATUS_ERROR_E;
         }
         else
         {
            /* Check to see if we are configured as a client with an    */
            /* active connection                                        */
            if(ConnectionCount)
            {
               /* Get the device info for the connection device.        */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
               {
                  /* Verify that the client has received a valid Battery*/
                  /* Level Attribute Handle.                            */
                  if(DeviceInfo->BASClientInfo[InstanceID].Battery_Level != 0)
                  {
                     /* Finally, submit a read request to the server    */
                     if((Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->BASClientInfo[InstanceID].Battery_Level, GATT_ClientEventCallback_BAS, DeviceInfo->BASClientInfo[InstanceID].Battery_Level)) > 0)
                     {
                        QCLI_Printf(bas_group, "GetBatteryLevel Request sent, Transaction ID = %u", Result);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                        DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                  }
                  else
                     QCLI_Printf(bas_group, "Battery Level not supported on remote service.\n");
               }
               else
                  QCLI_Printf(bas_group, "No Device Info.\n");
            }
            else
               QCLI_Printf(bas_group, "Either a BAS server must be registered or a BAS client must be connected.\n");
         }

         /* Un-lock the Bluetooth Stack.                                */
         qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
      }
      else
         QCLI_Printf(bas_group, "Unable to acquire Bluetooth Stack Lock.\n");
   }

   return(ret_val);
}

   /* The following function is responsible for writing the battery     */
   /* level.  It can be executed by a server only.  This function will  */
   /* return zero on successful execution and a negative value on       */
   /* errors.                                                           */
static QCLI_Command_Status_t SetBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint8_t               Level;
   unsigned int          InstanceID;
   QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

   if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (QAPI_BLE_BAS_VALID_BATTERY_LEVEL(Parameter_List[0].Integer_Value)) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
   {
      InstanceID = Parameter_List[1].Integer_Value - 1;
      Level      = (uint8_t)Parameter_List[0].Integer_Value;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

#else

   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid) && (QAPI_BLE_BAS_VALID_BATTERY_LEVEL(Parameter_List[0].Integer_Value)))
   {
      InstanceID = 0;
      Level      = (uint8_t)Parameter_List[0].Integer_Value;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

#endif

   if(ret_val != QCLI_STATUS_USAGE_E)
   {
      /* First check for a registered BAS Server                        */
      if(BASInstanceID[0])
      {
         /* Verify that this server instance has been initialized.      */
         if(BASInstanceID[InstanceID])
         {
            BatteryLevel[InstanceID] = Level;
            ret_val                  = QCLI_STATUS_SUCCESS_E;

            QCLI_Printf(bas_group, "Battery Level set.\n");
         }
      }
      else
      {
         if(ConnectionCount)
            QCLI_Printf(bas_group, "Error - Only a server can set battery level.\n");
         else
            QCLI_Printf(bas_group, "Error - BAS server not registered\n");
      }
   }

   return(ret_val);
}

   /* The following function is responsible for notifying a battery     */
   /* level to a connected remote device. This function will return     */
   /* zero on successful execution and a negative value on errors.      */
static QCLI_Command_Status_t NotifyBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   uint8_t                Level;
   unsigned int           InstanceID;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)
   if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (QAPI_BLE_BAS_VALID_BATTERY_LEVEL(Parameter_List[0].Integer_Value)) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
   {
      InstanceID = Parameter_List[1].Integer_Value - 1;
      Level      = (uint8_t)Parameter_List[0].Integer_Value;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

#else

   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid) && (QAPI_BLE_BAS_VALID_BATTERY_LEVEL(Parameter_List[0].Integer_Value)))
   {
      InstanceID = 0;
      Level      = (uint8_t)Parameter_List[0].Integer_Value;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

#endif

   if(ret_val != QCLI_STATUS_USAGE_E)
   {
      /* First, check that valid Bluetooth Stack ID exists.             */
      if(BluetoothStackID)
      {
         /* Verify that we have an open server and a connection.        */
         if(BASInstanceID[InstanceID])
         {
            if(ConnectionCount)
            {
               /* Lock the Bluetooth stack.                             */
               if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
               {
                  if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                  {
                     if(DeviceInfo->BASServerInfo[InstanceID].Battery_Level_Client_Configuration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                     {
                        /* Go ahead and send the Battery Level          */
                        /* Notification                                 */
                        if((Result = qapi_BLE_BAS_Notify_Battery_Level(BluetoothStackID, BASInstanceID[InstanceID], DeviceInfo->ConnectionID, Level)) == 0)
                        {
                           QCLI_Printf(bas_group, "Battery Level Notification success.\n");

                           BatteryLevel[InstanceID] = Level;

                           ret_val                  = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                           DisplayFunctionError("qapi_BLE_BAS_Notify_Battery_Level", Result);
                     }
                     else
                     {
                        QCLI_Printf(bas_group, "Client has not registered for Battery Level notifications.\n");

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                  }
                  else
                     QCLI_Printf(bas_group, "Error - Unknown Client.\n");

                  /* Un-lock the Bluetooth Stack.                       */
                  qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
               }
               else
                  QCLI_Printf(bas_group, "Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
               QCLI_Printf(bas_group, "Connection not established.\n");
         }
         else
         {
            if(ConnectionCount)
               QCLI_Printf(bas_group, "Error - Only a server can notify.\n");
            else
               QCLI_Printf(bas_group, "Error - BAS server not registered\n");
         }
      }
   }

   return(ret_val);
}

   /* The following function is responsible for reading the battery     */
   /* level presentation format. It can be executed by a server or a    */
   /* client with an open connection to a remote server.  If executed   */
   /* as a client, a GATT read request will be generated, and the       */
   /* results will be returned as a response in the GATT client event   */
   /* callback.  This function will return zero on successful execution */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t GetBatteryLevelPresentationFormat(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                      Result;
   DeviceInfo_t                            *DeviceInfo;
   unsigned int                             InstanceID;
   QCLI_Command_Status_t                    ret_val = QCLI_STATUS_ERROR_E;
   qapi_BLE_BAS_Presentation_Format_Data_t  BatteryLevelFormat;

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
      InstanceID = (Parameter_List[0].Integer_Value - 1);
   else
      ret_val = QCLI_STATUS_USAGE_E;

#else

   InstanceID = 0;

#endif

   if(ret_val != QCLI_STATUS_USAGE_E)
   {
      /* First check for a registered BAS Server                        */
      if(BASInstanceID[0])
      {
         /* Verify that this server instance has been initialized.      */
         if(BASInstanceID[InstanceID])
         {
            Result = qapi_BLE_BAS_Query_Characteristic_Presentation_Format(BluetoothStackID, BASInstanceID[InstanceID], &BatteryLevelFormat);
            if(Result == 0)
            {
               QCLI_Printf(bas_group, "\nBattery Level Presentation Format\n");
               QCLI_Printf(bas_group, "\n   NameSpace:   0x%02X\n", BatteryLevelFormat.NameSpace);
               QCLI_Printf(bas_group, "\n   Description: 0x%04X\n", BatteryLevelFormat.Description);

               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               DisplayFunctionError("qapi_BLE_BAS_Query_Characteristic_Presentation_Format", Result);

               if(Result == QAPI_BLE_BTPS_ERROR_FEATURE_NOT_AVAILABLE)
                  QCLI_Printf(bas_group, "Command Not Supported.\n");
            }
         }
      }
      else
      {
         /* Check to see if we are configured as a client with an active*/
         /* connection                                                  */
         if(ConnectionCount)
         {
            /* Lock the Bluetooth stack.                                */
            if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
            {
               /* Get the device info for the connection device.        */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
               {
                  /* Verify that the client has received a valid Battery*/
                  /* Level Presentation Format Attribute Handle.        */
                  if(DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Presentation_Format != 0)
                  {
                     /* Finally, submit a read request to the server    */
                     if((Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Presentation_Format, GATT_ClientEventCallback_BAS, DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Presentation_Format)) > 0)
                     {
                        QCLI_Printf(bas_group, "Battery_Level_Presentation_Format Request sent, Transaction ID = %u", Result);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                        DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                  }
                  else
                     QCLI_Printf(bas_group, "Battery Level presentation format not supported on remote service.\n");
               }
               else
                  QCLI_Printf(bas_group, "No Device Info.\n");

               /* Un-lock the Bluetooth Stack.                          */
               qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
            }
            else
               QCLI_Printf(bas_group, "Unable to acquire Bluetooth Stack Lock.\n");
         }
         else
            QCLI_Printf(bas_group, "Either a BAS server must be registered or a BAS client must be connected.\n");
      }
   }

   return(ret_val);
}

   /* The following function is responsible for writing the battery     */
   /* level presentation format descriptor. It can be executed only     */
   /* by a server. This function will return zero on successful         */
   /* execution and a negative value on  errors.                        */
static QCLI_Command_Status_t SetBatteryLevelPresentationFormat(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                     Result;
   uint8_t                                 Namespace;
   uint16_t                                Description;
   unsigned int                            InstanceID;
   QCLI_Command_Status_t                   ret_val = QCLI_STATUS_ERROR_E;
   qapi_BLE_BAS_Presentation_Format_Data_t BatteryLevelFormat;

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

   if((Parameter_List) && (Parameter_Count > 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= 1) && (Parameter_List[2].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
   {
      Namespace   = (uint8_t)Parameter_List[0].Integer_Value;
      Description = (uint16_t)Parameter_List[1].Integer_Value;
      InstanceID  = Parameter_List[2].Integer_Value - 1;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

#else

   if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid))
   {
      Namespace   = Parameter_List[0].Integer_Value;
      Description = Parameter_List[1].Integer_Value;
      InstanceID  = 0;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

#endif

   /* Verify that no usage error occurred.                              */
   if(ret_val != QCLI_STATUS_USAGE_E)
   {
      /* Verify that the selected instance is registered.               */
      if(BASInstanceID[InstanceID])
      {
         /* As per the spec, only Namespace/description need to be      */
         /* configured in presentation format descriptor.  Any 16bit    */
         /* unsigned number will be a valid description for battery     */
         /* level presentation format                                   */
         BatteryLevelFormat.Format      = 0;
         BatteryLevelFormat.Exponent    = 0;
         BatteryLevelFormat.Unit        = 0;
         BatteryLevelFormat.NameSpace   = Namespace;
         BatteryLevelFormat.Description = Description;

         /* Set the presentation format.                                */
         if((Result = qapi_BLE_BAS_Set_Characteristic_Presentation_Format(BluetoothStackID, BASInstanceID[InstanceID], &BatteryLevelFormat)) == 0)
         {
            QCLI_Printf(bas_group, "Description of Battery Level Presentation Format successfully set.\n");

            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            DisplayFunctionError("qapi_BLE_BAS_Set_Characteristic_Presentation_Format", Result);
            if(Result == QAPI_BLE_BTPS_ERROR_FEATURE_NOT_AVAILABLE)
               QCLI_Printf(bas_group, "Command Not Supported.\n");
         }
      }
      else
      {
         if(ConnectionCount)
            QCLI_Printf(bas_group, "Cannot write to battery level presentation format as a client.\n");
         else
            QCLI_Printf(bas_group, "BAS server not registered\n");
      }
   }

   return(ret_val);
}

   /* Battery Alert Service (BAS) helper functions.                     */

   /* The following function is a utility function that provides a      */
   /* mechanism of populating a BAS Client Information structure with   */
   /* the information discovered from a GDIS Discovery operation.       */
static void BASPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
   unsigned int                                           Index1;
   unsigned int                                           Index2;
   qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
   qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

   /* Verify that the input parameters are semi-valid.                  */
   if((DeviceInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_BAS_COMPARE_BAS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
   {
      /* Loop through all characteristics discovered in the service     */
      /* and populate the correct entry.                                */
      CurrentCharacteristic = ServiceDiscoveryData->CharacteristicInformationList;
      if(CurrentCharacteristic)
      {
         for(Index1 = 0; Index1 < ServiceDiscoveryData->NumberOfCharacteristics; Index1++, CurrentCharacteristic++)
         {
            if(QAPI_BLE_BAS_COMPARE_BATTERY_LEVEL_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
            {
               /* All BAS UUIDs are defined to be 16 bit UUIDs.         */
               if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
               {
                  DeviceInfo->BASClientInfo[BASInstanceIDIndex].Battery_Level = CurrentCharacteristic->Characteristic_Handle;

                  /* Loop through the Descriptor List.                  */
                  CurrentDescriptor = CurrentCharacteristic->DescriptorList;
                  for(Index2 = 0; Index2 < CurrentCharacteristic->NumberOfDescriptors; Index2++)
                  {
                     if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                     {
                        if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_UUID.UUID.UUID_16))
                           DeviceInfo->BASClientInfo[BASInstanceIDIndex].Battery_Level_Client_Configuration = CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_Handle;
                        else
                        {
                           if(QAPI_BLE_GATT_COMPARE_CHARACTERISTIC_PRESENTATION_FORMAT_ATTRIBUTE_TYPE_TO_UUID_16(CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_UUID.UUID.UUID_16))
                              DeviceInfo->BASClientInfo[BASInstanceIDIndex].Battery_Level_Presentation_Format = CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_Handle;
                        }
                     }
                  }
               }
            }
         }

         /* Increment the index to save the handles of other service    */
         /* instances to DeviceInfo->ClientInfo[] array during          */
         /* etGDIS_Service_Discovery_Indication                         */
         ++BASInstanceIDIndex;
         if(BASInstanceIDIndex == MAX_SUPPORTED_BATTERY_INSTANCES)
         {
            /* Reset the index to ZERO once Discovery indication is done*/
            /* for all the service instances                            */
            BASInstanceIDIndex = 0;
         }
      }
   }
}

   /* The following function is a utility function that checks if a     */
   /* given handle is a Handle of Battery Level characteristic. This    */
   /* function returns TRUE if handle matches with Battery Level        */
   /* characteristic of any of the Service Instance else returns FALSE  */
static boolean_t IsBatteryLevelHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo)
{
   boolean_t    ret_val = FALSE;
   unsigned int Index;

   for(Index = 0;((Index < MAX_SUPPORTED_BATTERY_INSTANCES) && (!ret_val)); ++Index)
   {
      if(Handle == DeviceInfo->BASClientInfo[Index].Battery_Level)
         ret_val = TRUE;
   }

   return(ret_val);
}

   /* The following function is a utility function that checks if a     */
   /* given handle is a Handle of Battery Level Presentation Format     */
   /* characteristic. This function returns TRUE if handle matches      */
   /* with Battery Level Presentation Format characteristic of any of   */
   /* the Service Instance else returns FALSE                           */
static boolean_t IsBatteryLevelPresentationFormatHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo)
{
   boolean_t    ret_val = FALSE;
   unsigned int Index;

   for(Index = 0;((Index < MAX_SUPPORTED_BATTERY_INSTANCES) && (!ret_val)); ++Index)
   {
      if(Handle == DeviceInfo->BASClientInfo[Index].Battery_Level_Presentation_Format)
         ret_val = TRUE;
   }

   return(ret_val);
}

   /* The following function is a utility function that checks if a     */
   /* given handle is a Handle of Battery Level Client Configuration    */
   /* characteristic. This function returns TRUE if handle matches with */
   /* Battery Level Client Configuration characteristic of any of the   */
   /* Service Instance else returns FALSE                               */
static boolean_t IsBASClientConfigurationHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo)
{
   boolean_t    ret_val = FALSE;
   unsigned int Index;

   for(Index = 0;((Index < MAX_SUPPORTED_BATTERY_INSTANCES) && (!ret_val)); ++Index)
   {
      if(Handle == DeviceInfo->BASClientInfo[Index].Battery_Level_Client_Configuration)
         ret_val = TRUE;
   }

   return(ret_val);
}

   /* Generic Access Profile Service (GAPS) QCLI command functions.     */

   /* The following function is responsible for reading the current     */
   /* Local Device Name.  This function will return zero on successful  */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ReadLocalName(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   char                  NameBuffer[248+1];
   QCLI_Command_Status_t ret_val;

   /* Verify that the GAP Service is registered.                        */
   if(GAPSInstanceID)
   {
      /* Initialize the Name Buffer to all zeros.                       */
      memset(NameBuffer, 0, sizeof(NameBuffer));

      /* Query the Local Name.                                          */
      Result = qapi_BLE_GAPS_Query_Device_Name(BluetoothStackID, GAPSInstanceID, NameBuffer);
      if(!Result)
      {
         QCLI_Printf(gaps_group, "Device Name: %s.\n", NameBuffer);

         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         QCLI_Printf(gaps_group, "Error - qapi_BLE_GAPS_Query_Device_Name returned %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(gaps_group, "GAP Service not registered.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the current     */
   /* Local Device Name.  This function will return zero on successful  */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t SetLocalName(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].String_Value) && (strlen((char *)(Parameter_List[0].String_Value)) > 0) && (strlen((char *)(Parameter_List[0].String_Value)) <= 248))
   {
      /* Verify that the GAP Service is registered.                     */
      if(GAPSInstanceID)
      {
         /* Query the Local Name.                                       */
         Result = qapi_BLE_GAPS_Set_Device_Name(BluetoothStackID, GAPSInstanceID, (char *)(Parameter_List[0].String_Value));
         if(!Result)
         {
            QCLI_Printf(gaps_group, "qapi_BLE_GAPS_Set_Device_Name success.\n");

            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            QCLI_Printf(gaps_group, "Error - qapi_BLE_GAPS_Query_Device_Name returned %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(gaps_group, "GAP Service not registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      ret_val = QCLI_STATUS_USAGE_E;
   }

   return(ret_val);
}

   /* The following function is responsible for reading the Device Name */
   /* for the currently connected remote device.  This function will    */
   /* return zero on successful execution and a negative value on       */
   /* errors.                                                           */
static QCLI_Command_Status_t ReadRemoteName(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val;

   /* Verify that there is a connection that is established.            */
   if(ConnectionCount)
   {
      /* Lock the Bluetooth stack.                                      */
      if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
      {
         /* Get the device info for the connection device.              */
         if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
         {
            /* Verify that we discovered the Device Name Handle.        */
            if(DeviceInfo->GAPSClientInfo.DeviceNameHandle)
            {
               /* Attempt to read the remote device name.               */
               Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->GAPSClientInfo.DeviceNameHandle, GATT_ClientEventCallback_GAPS, (unsigned long)DeviceInfo->GAPSClientInfo.DeviceNameHandle);
               if(Result > 0)
               {
                  QCLI_Printf(gaps_group, "Attempting to read Remote Device Name.\n");

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(gaps_group, "Error - GATT_Read_Value_Request returned %d.\n", Result);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(gaps_group, "GAP Service Device Name Handle not discovered.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(gaps_group, "No Device Info.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }

         /* Un-lock the Bluetooth Stack.                                */
         qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
      }
      else
      {
         QCLI_Printf(gaps_group, "Unable to acquire Bluetooth Stack Lock.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(gaps_group, "No Connection Established\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for reading the Local Device*/
   /* Appearance value.  This function will return zero on successful   */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ReadLocalAppearance(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   char                  *AppearanceString;
   uint16_t               Appearance;
   QCLI_Command_Status_t  ret_val;

   /* Verify that the GAP Service is registered.                        */
   if(GAPSInstanceID)
   {
      /* Query the Local Name.                                          */
      Result = qapi_BLE_GAPS_Query_Device_Appearance(BluetoothStackID, GAPSInstanceID, &Appearance);
      if(!Result)
      {
         /* Map the Appearance to a String.                             */
         if(AppearanceToString(Appearance, &AppearanceString))
            QCLI_Printf(gaps_group, "Device Appearance: %s(%u).\n", AppearanceString, Appearance);
         else
            QCLI_Printf(gaps_group, "Device Appearance: Unknown(%u).\n", Appearance);

         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         QCLI_Printf(gaps_group, "Error - qapi_BLE_GAPS_Query_Device_Appearance returned %d.\n", Result);

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(gaps_group, "GAP Service not registered.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the Local Device*/
   /* Appearance value.  This function will return zero on successful   */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t SetLocalAppearance(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   uint16_t              Appearance;
   QCLI_Command_Status_t ret_val;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value < NUMBER_OF_APPEARANCE_MAPPINGS))
   {
      /* Verify that the GAP Service is registered.                     */
      if(GAPSInstanceID)
      {
         /* Map the Appearance Index to the GAP Appearance Value.       */
         if(AppearanceIndexToAppearance(Parameter_List[0].Integer_Value, &Appearance))
         {
            /* Set the Local Appearance.                                */
            Result = qapi_BLE_GAPS_Set_Device_Appearance(BluetoothStackID, GAPSInstanceID, Appearance);
            if(!Result)
            {
               QCLI_Printf(gaps_group, "qapi_BLE_GAPS_Set_Device_Appearance success.\n");

               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               QCLI_Printf(gaps_group, "Error - qapi_BLE_GAPS_Set_Device_Appearance returned %d.\n", Result);

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(gaps_group, "Invalid Appearance Index.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(gaps_group, "GAP Service not registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(gaps_group, "Appearance Index = \n");
      DumpAppearanceMappings();

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for reading the Device Name */
   /* for the currently connected remote device.  This function will    */
   /* return zero on successful execution and a negative value on       */
   /* errors.                                                           */
static QCLI_Command_Status_t ReadRemoteAppearance(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val;

   /* Verify that there is a connection that is established.            */
   if(ConnectionCount)
   {
      /* Lock the Bluetooth stack.                                      */
      if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
      {
         /* Get the device info for the connection device.              */
         if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
         {
            /* Verify that we discovered the Device Name Handle.        */
            if(DeviceInfo->GAPSClientInfo.DeviceAppearanceHandle)
            {
               /* Attempt to read the remote device name.               */
               Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->GAPSClientInfo.DeviceAppearanceHandle, GATT_ClientEventCallback_GAPS, (unsigned long)DeviceInfo->GAPSClientInfo.DeviceAppearanceHandle);
               if(Result > 0)
               {
                  QCLI_Printf(gaps_group, "Attempting to read Remote Device Appearance.\n");

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(gaps_group, "Error - GATT_Read_Value_Request returned %d.\n", Result);

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(gaps_group, "GAP Service Device Appearance Handle not discovered.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(gaps_group, "No Device Info.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }

         /* Un-lock the Bluetooth Stack.                                */
         qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
      }
      else
      {
         QCLI_Printf(gaps_group, "Unable to acquire Bluetooth Stack Lock.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(gaps_group, "No Connection Established\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* Generic Access Profile Service (GAPS) helper functions.           */

   /* The following function is a utility function that provides a      */
   /* mechanism of populating discovered GAP Service Handles.           */
static void GAPSPopulateHandles(GAPS_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceInfo)
{
   unsigned int                                Index1;
   qapi_BLE_GATT_Characteristic_Information_t *CurrentCharacteristic;

   /* Verify that the input parameters are semi-valid.                  */
   if((ClientInfo) && (ServiceInfo) && (ServiceInfo->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_GAP_COMPARE_GAP_SERVICE_UUID_TO_UUID_16(ServiceInfo->ServiceInformation.UUID.UUID.UUID_16)))
   {
      /* Loop through all characteristics discovered in the service     */
      /* and populate the correct entry.                                */
      CurrentCharacteristic = ServiceInfo->CharacteristicInformationList;
      if(CurrentCharacteristic)
      {
         for(Index1=0;Index1<ServiceInfo->NumberOfCharacteristics;Index1++,CurrentCharacteristic++)
         {
            /* All GAP Service UUIDs are defined to be 16 bit UUIDs.    */
            if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
            {
               /* Determine which characteristic this is.               */
               if(!QAPI_BLE_GAP_COMPARE_GAP_DEVICE_NAME_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
               {
                  if(!QAPI_BLE_GAP_COMPARE_GAP_DEVICE_APPEARANCE_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                     continue;
                  else
                  {
                     ClientInfo->DeviceAppearanceHandle = CurrentCharacteristic->Characteristic_Handle;
                     continue;
                  }
               }
               else
               {
                  ClientInfo->DeviceNameHandle = CurrentCharacteristic->Characteristic_Handle;
                  continue;
               }
            }
         }
      }
   }
}

   /* The following function is a utility function that is used to dump */
   /* the Appearance to String Mapping Table.                           */
static void DumpAppearanceMappings(void)
{
   unsigned int Index;

   for(Index=0;Index<NUMBER_OF_APPEARANCE_MAPPINGS;++Index)
      QCLI_Printf(ble_group, "   %u = %s.\n", Index, AppearanceMappings[Index].String);
}

   /* The following function is used to map a Appearance Value to it's  */
   /* string representation.  This function returns TRUE on success or  */
   /* FALSE otherwise.                                                  */
static boolean_t AppearanceToString(uint16_t Appearance, char **String)
{
   boolean_t    ret_val;
   unsigned int Index;

   /* Verify that the input parameters are semi-valid.                  */
   if(String)
   {
      for(Index=0,ret_val=FALSE;Index<NUMBER_OF_APPEARANCE_MAPPINGS;++Index)
      {
         if(AppearanceMappings[Index].Appearance == Appearance)
         {
            *String = AppearanceMappings[Index].String;
            ret_val = TRUE;
            break;
         }
      }
   }
   else
      ret_val = FALSE;

   return(ret_val);
}

   /* The following function is used to map an Index into the Appearance*/
   /* Mapping table to it's Appearance Value.  This function returns    */
   /* TRUE on success or FALSE otherwise.                               */
static boolean_t AppearanceIndexToAppearance(unsigned int Index, uint16_t *Appearance)
{
   boolean_t ret_val;

   if((Index < NUMBER_OF_APPEARANCE_MAPPINGS) && (Appearance))
   {
      *Appearance = AppearanceMappings[Index].Appearance;
      ret_val     = TRUE;
   }
   else
      ret_val = FALSE;

   return(ret_val);
}

   /* HID over GATT Service (HIDS) QCLI command functions.              */

   /* The following function is responsible for registering a HIDS      */
   /* Service.  This function will return zero on successful execution  */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t RegisterHIDS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                   Result;
   uint8_t                               ServiceFlags;
   uint32_t                              ServiceID;
   qapi_BLE_GATT_UUID_t                  ReferenceUUID[1];
   QCLI_Command_Status_t                 ret_val;
   qapi_BLE_HIDS_HID_Information_Data_t  HIDInformation;
   qapi_BLE_HIDS_Report_Reference_Data_t ReportReferenceData[3];

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that the Service is not already registered.             */
      if(!HIDSInstanceID)
      {
         /* Configure the HID Information value.                        */
         HIDInformation.CountryCode = QAPI_BLE_HIDS_HID_LOCALIZATION_BYTE_NO_LOCALIZATION;
         HIDInformation.Flags       = QAPI_BLE_HIDS_HID_INFORMATION_FLAGS_NORMALLY_CONNECTABLE;
         HIDInformation.Version     = QAPI_BLE_HIDS_HID_VERSION_NUMBER;

         /* Configure the Report Reference structures.  Note that since */
         /* we have only 1 report of a type (Input,Output,Feature) we   */
         /* do not need to have a unique Reference ID and therefore we  */
         /* use a Report ID of ZERO.                                    */
         ReportReferenceData[0].ReportID   = HID_KEYBOARD_INPUT_REPORT_ID;
         ReportReferenceData[0].ReportType = (QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT | QAPI_BLE_HIDS_REPORT_REFERENCE_SUPPORT_INPUT_WRITE_FEATURE);
         ReportReferenceData[1].ReportID   = HID_KEYBOARD_OUTPUT_REPORT_ID;
         ReportReferenceData[1].ReportType = QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT;
         ReportReferenceData[2].ReportID   = HID_MOUSE_INPUT_REPORT_ID;
         ReportReferenceData[2].ReportType = (QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT | QAPI_BLE_HIDS_REPORT_REFERENCE_SUPPORT_INPUT_WRITE_FEATURE);

         /* Assign the external report reference values.                */
         ReferenceUUID[0].UUID_Type = QAPI_BLE_GU_UUID_16_E;
         QAPI_BLE_ASSIGN_BLUETOOTH_UUID_16(ReferenceUUID[0].UUID.UUID_16, 0x00, 0x00);

         /* Assign the service flags.                                   */
         ServiceFlags = (QAPI_BLE_HIDS_FLAGS_SUPPORT_KEYBOARD | QAPI_BLE_HIDS_FLAGS_SUPPORT_MOUSE | QAPI_BLE_HIDS_FLAGS_BOOT_KEYBOARD_INPUT_REPORT_WRITABLE | QAPI_BLE_HIDS_FLAGS_BOOT_MOUSE_INPUT_REPORT_WRITABLE);

         /* Initialize the HID Service.                                 */
         Result = qapi_BLE_HIDS_Initialize_Service(BluetoothStackID, ServiceFlags, &HIDInformation, 0, NULL, (sizeof(ReferenceUUID)/sizeof(qapi_BLE_GATT_UUID_t)), ReferenceUUID, (sizeof(ReportReferenceData)/sizeof(qapi_BLE_HIDS_Report_Reference_Data_t)), ReportReferenceData, HIDS_Event_Callback, 0, &ServiceID);
         if(Result > 0)
         {
            /* Save the ServiceID of the registered service.            */
            HIDSInstanceID = (unsigned int)Result;

            QCLI_Printf(hids_group, "Successfully registered HIDS Service, InstanceID = %u.\n", Result);

            ret_val        = QCLI_STATUS_ERROR_E;
         }
         else
         {
            DisplayFunctionError("qapi_BLE_HIDS_Initialize_Service", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(hids_group, "HIDS Service already registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(hids_group, "Connection currently active.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for unregistering a HIDS    */
   /* Service.  This function will return zero on successful execution  */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t UnregisterHIDS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;
   int                   Result;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that a service is registered.                           */
      if(HIDSInstanceID)
      {
         /* Unregister the HIDS Service with GATT.                      */
         Result = qapi_BLE_HIDS_Cleanup_Service(BluetoothStackID, HIDSInstanceID);
         if(Result == 0)
         {
            /* Display success message.                                 */
            QCLI_Printf(hids_group, "Successfully unregistered HIDS: InstanceID %u.\n", HIDSInstanceID);

            /* Clear the instance ID.                                   */
            HIDSInstanceID = 0;

            /* Return success to the caller.                            */
            ret_val        = QCLI_STATUS_SUCCESS_E;
         }
         else
            DisplayFunctionError("qapi_BLE_HIDS_Cleanup_Service", Result);
      }
      else
         QCLI_Printf(hids_group, "HIDS is not registered.\n");
   }
   else
      QCLI_Printf(hids_group, "Connection currently active.\n");

   return(ret_val);
}

   /* The following function is responsible for configuring a HID       */
   /* Service on a remote device. This function will return zero on     */
   /* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t ConfigureHIDS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                             Result;
   unsigned int                    Index;
   unsigned int                    InstanceID;
   DeviceInfo_t                   *DeviceInfo;
   QCLI_Command_Status_t           ret_val = QCLI_STATUS_ERROR_E;
   qapi_BLE_GAP_Encryption_Mode_t  GAPEncryptionMode;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
   {
      /* Verify that there is a connection that is established.         */
      if(ConnectionCount)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the connection device.           */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Make sure encryption is enabled.                      */
               if((qapi_BLE_GAP_LE_Query_Encryption_Mode(BluetoothStackID, SelectedRemoteBD_ADDR, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
               {
                  /* Set the Instance ID.                               */
                  InstanceID = (Parameter_List[0].Integer_Value - 1);
                  ret_val    = QCLI_STATUS_SUCCESS_E;

                  QCLI_Printf(hids_group, "Attempting to configure CCCDs...\n");

                  /* Determine if Boot Keyboard Input Report is         */
                  /* supported.                                         */
                  if(DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD)
                  {
                     /* Enable Notifications on the proper              */
                     /* characteristics.                                */
                     Result = EnableDisableNotificationsIndications(DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD, (Parameter_List[1].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_HIDS);

                     /* Check for CC Configuration success              */
                     if(Result > 0)
                        QCLI_Printf(hids_group, "CCCD Configuration Success.\n");
                     else
                     {
                        /* CC Configuration failed, check to see if it  */
                        /* was from a call to                           */
                        /* EnableDisableNotificationsIndications        */
                        if(Result < 0)
                           DisplayFunctionError("EnableDisableNotificationsIndications", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                     }
                  }

                  /* Determine if Boot Mouse Input Report is supported. */
                  if((ret_val == QCLI_STATUS_SUCCESS_E) && (DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD))
                  {
                     /* Enable Notifications on the proper              */
                     /* characteristics.                                */
                     Result = EnableDisableNotificationsIndications(DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD, (Parameter_List[1].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_HIDS);

                     /* Check for CC Configuration success              */
                     if(Result > 0)
                        QCLI_Printf(hids_group, "CCCD Configuration Success.\n");
                     else
                     {
                        /* CC Configuration failed, check to see if it  */
                        /* was from a call to                           */
                        /* EnableDisableNotificationsIndications        */
                        if(Result < 0)
                           DisplayFunctionError("EnableDisableNotificationsIndications", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                     }
                  }

                  for(Index=0;((Index < HIDS_MAXIMUM_NUMBER_REPORTS) && (ret_val == QCLI_STATUS_SUCCESS_E)); Index++)
                  {
                     if(DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle)
                     {
                        /* Enable Notifications on the proper           */
                        /* characteristics.                             */
                        Result = EnableDisableNotificationsIndications(DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle, (Parameter_List[1].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_HIDS);

                        /* Check for CC Configuration success           */
                        if(Result > 0)
                           QCLI_Printf(hids_group, "CCCD Configuration Success.\n");
                        else
                        {
                           /* CC Configuration failed, check to see if  */
                           /* it was from a call to                     */
                           /* EnableDisableNotificationsIndications     */
                           if(Result < 0)
                              DisplayFunctionError("EnableDisableNotificationsIndications", Result);

                           ret_val = QCLI_STATUS_ERROR_E;
                        }
                     }
                  }
               }
               else
                  QCLI_Printf(hids_group, "Must be paired with this device to use HIDS.\n");
            }
            else
               QCLI_Printf(hids_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(hids_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         QCLI_Printf(hids_group, "No Connection Established.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for reading a HID Service   */
   /* configuration on a remote device. This function will return zero  */
   /* on successful execution and a negative value on errors.           */
static QCLI_Command_Status_t ReadHIDSConfiguration(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                             Result;
   DeviceInfo_t                   *DeviceInfo;
   unsigned int                    Index;
   unsigned int                    InstanceID;
   QCLI_Command_Status_t           ret_val = QCLI_STATUS_ERROR_E;
   qapi_BLE_GAP_Encryption_Mode_t  GAPEncryptionMode;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
   {
      /* Verify that there is a connection that is established.         */
      if(ConnectionCount)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the connection device.           */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Make sure encryption is enabled.                      */
               if((qapi_BLE_GAP_LE_Query_Encryption_Mode(BluetoothStackID, SelectedRemoteBD_ADDR, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
               {
                  /* Set the Instance ID.                               */
                  InstanceID = (Parameter_List[0].Integer_Value - 1);
                  ret_val    = QCLI_STATUS_SUCCESS_E;

                  QCLI_Printf(hids_group, "Attempting to read CCCDs...\n");

                  /* Determine if Boot Keyboard Input Report is         */
                  /* supported.                                         */
                  if(DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD)
                  {
                     /* Read the CCD.                                   */
                     Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD, GATT_ClientEventCallback_HIDS, DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD);

                     /* Check for CC Read success                       */
                     if(Result > 0)
                        QCLI_Printf(hids_group, "CCCD Read Success.\n");
                     else
                     {
                        /* CC Read failed, display an error.            */
                        if(Result < 0)
                           DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                     }
                  }

                  /* Determine if Boot Mouse Input Report is supported. */
                  if((ret_val == QCLI_STATUS_SUCCESS_E) && (DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD))
                  {
                     /* Read the CCD.                                   */
                     Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD, GATT_ClientEventCallback_HIDS, DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD);

                     /* Check for CC Read success                       */
                     if(Result > 0)
                        QCLI_Printf(hids_group, "CCCD Read Success.\n");
                     else
                     {
                        /* CC Read failed, display an error.            */
                        if(Result < 0)
                           DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                     }
                  }

                  for(Index=0;((Index < HIDS_MAXIMUM_NUMBER_REPORTS) && (ret_val == QCLI_STATUS_SUCCESS_E)); Index++)
                  {
                     if(DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle)
                     {
                        /* Read the CCD.                                */
                        Result = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle, GATT_ClientEventCallback_HIDS, DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle);

                        /* Check for CC Read success                    */
                        if(Result > 0)
                           QCLI_Printf(hids_group, "CCCD Read Success.\n");
                        else
                        {
                           /* CC Read failed, display an error.         */
                           if(Result < 0)
                              DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);

                           ret_val = QCLI_STATUS_ERROR_E;
                        }
                     }
                  }

               }
               else
                  QCLI_Printf(hids_group, "Must be paired with this device to use HIDS.\n");
            }
            else
               QCLI_Printf(hids_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(hids_group, "Unable to acquire Bluetooth Stack Lock.\n");

      }
      else
         QCLI_Printf(hids_group, "No Connection Established.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for getting a report on a   */
   /* HID service of a remote device. This function will return zero on */
   /* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t GetReport(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   DeviceInfo_t          *DeviceInfo;
   unsigned int           InstanceID;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
   {
      /* Verify that there is a connection that is established.         */
      if(ConnectionCount)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the connection device.           */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Set the Instance ID.                                  */
               InstanceID = (Parameter_List[0].Integer_Value - 1);

               /* Get the HIDS report.                                  */
               if((Result = HIDSGetReport(DeviceInfo->ConnectionID, &(DeviceInfo->HIDSClientInfo[InstanceID]), Parameter_List[1].Integer_Value, Parameter_List[2].Integer_Value)) > 0)
               {
                  QCLI_Printf(hids_group, "HIDSGetReport() Success: Transaction ID = %d.\n", Result);

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
               else
                  DisplayFunctionError("HIDSGetReport", Result);
            }
            else
               QCLI_Printf(hids_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(hids_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         QCLI_Printf(hids_group, "No Connection Established.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for setting a report on a   */
   /* HID service of a remote device. This function will return zero on */
   /* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t SetReport(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   uint8_t               *Report;
   boolean_t              ResponseExpected;
   unsigned int           ReportLength;
   unsigned int           InstanceID;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

   /* Verify that the input parameters are semi-valid.                  */

   if((Parameter_List) && (Parameter_Count >= 5) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[3].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
   {
      /* Verify that there is a connection that is established.         */
      if(ConnectionCount)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the connection device.           */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Set the Instance ID.                                  */
               InstanceID = (Parameter_List[0].Integer_Value - 1);

               /* Attempt to get the Report Data.                       */
               ReportLength = ExtractHexString(Parameter_List[4].String_Value, &Report);
               if((ReportLength) && (Report))
               {
                  ResponseExpected = (boolean_t)Parameter_List[3].Integer_Value;

                  /* Set the HIDS report.                               */
                  if((Result = HIDSSetReport(DeviceInfo->ConnectionID , &(DeviceInfo->HIDSClientInfo[InstanceID]), Parameter_List[1].Integer_Value, Parameter_List[2].Integer_Value, Report, ReportLength, ResponseExpected)) > 0)
                  {
                     QCLI_Printf(hids_group, "HIDSSetReport() Success: %d.\n", Result);

                     ret_val = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                     DisplayFunctionError("HIDSSetReport", Result);

                  /* Free the memory allocated for the buffer.          */
                  free(Report);
               }
               else
                  QCLI_Printf(hids_group, "Failed to parse the report data.\n");
            }
            else
               QCLI_Printf(hids_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(hids_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         QCLI_Printf(hids_group, "No Connection Established.\n");
   }
   else
   {
      /* Due to a QCLI limitation we will display the usage here.       */
      QCLI_Printf(hids_group, "[InstanceID] [ReportType] [ReportID (0 = None] [Response Expected (0 = False, 1 = True)] [Value (Hex String)]\n");
      QCLI_Printf(hids_group, "   Where ReportType is = \n");
      QCLI_Printf(hids_group, " Input                 = 1\n");
      QCLI_Printf(hids_group, " Output                = 2\n");
      QCLI_Printf(hids_group, " Feature               = 3\n");
      QCLI_Printf(hids_group, " Boot Keyboard Input   = 4\n");
      QCLI_Printf(hids_group, " Boot Keyboard Output  = 5\n");
      QCLI_Printf(hids_group, " Boot Mouse Input      = 6\n");
      QCLI_Printf(hids_group, "\nSet specified report data.\n");

      ret_val = QCLI_STATUS_SUCCESS_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the suspend     */
   /* mode of a HID service on a remote device. This function will      */
   /* return zero on successful execution and a negative value on       */
   /* errors.                                                           */
static QCLI_Command_Status_t SetSuspend(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                    Result;
   uint8_t                                Buffer[QAPI_BLE_HIDS_CONTROL_POINT_VALUE_LENGTH];
   DeviceInfo_t                          *DeviceInfo;
   unsigned int                           InstanceID;
   QCLI_Command_Status_t                  ret_val = QCLI_STATUS_ERROR_E;
   qapi_BLE_HIDS_Control_Point_Command_t  Command;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
   {
      /* Verify that there is a connection that is established.         */
      if(ConnectionCount)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the connection device.           */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Set the Instance ID.                                  */
               InstanceID = (Parameter_List[0].Integer_Value - 1);

               /* Determine if Boot Mouse Input Report is supported.    */
               if(DeviceInfo->HIDSClientInfo[InstanceID].ControlPoint)
               {
                  /* Format the Set Suspend Mode command.               */
                  Command = (Parameter_List[1].Integer_Value ? QAPI_BLE_PC_SUSPEND_E : QAPI_BLE_PC_EXIT_SUSPEND_E);

                  if((Result = qapi_BLE_HIDS_Format_Control_Point_Command(Command, sizeof(Buffer), Buffer)) == 0)
                  {
                     /* Perform the Write Without Response.             */
                     Result = qapi_BLE_GATT_Write_Without_Response_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].ControlPoint, sizeof(Buffer), Buffer);

                     /* Check for GATT Write success                    */
                     if(Result > 0)
                     {
                        QCLI_Printf(hids_group, "Set Suspend Mode Success: %s.\n", (Parameter_List[1].Integer_Value ? "Suspend" : "Exit Suspend"));

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                     {
                        /* Set suspend mode failed, check to see if it  */
                        /* was from a call to                           */
                        /* GATT_Write_Without_Response_Request          */
                        if(Result < 0)
                           DisplayFunctionError("qapi_BLE_GATT_Write_Without_Response_Request", Result);
                     }
                  }
                  else
                     DisplayFunctionError("qapi_BLE_HIDS_Format_Control_Point_Command", Result);
               }
               else
                  QCLI_Printf(hids_group, "Control point not supported.\n");
            }
            else
               QCLI_Printf(hids_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(hids_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         QCLI_Printf(hids_group, "No Connection Established.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for setting the protocol    */
   /* mode of a HID service on a remote device. This function will      */
   /* return zero on successful execution and a negative value on       */
   /* errors.                                                           */
static QCLI_Command_Status_t SetProtocolMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                            Result;
   uint8_t                        Buffer[QAPI_BLE_HIDS_PROTOCOL_MODE_VALUE_LENGTH];
   DeviceInfo_t                  *DeviceInfo;
   unsigned int                   InstanceID;
   QCLI_Command_Status_t          ret_val = QCLI_STATUS_ERROR_E;
   qapi_BLE_HIDS_Protocol_Mode_t  ProtocolMode;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
   {
      /* Verify that there is a connection that is established.         */
      if(ConnectionCount)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the connection device.           */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Set the Instance ID.                                  */
               InstanceID = (Parameter_List[0].Integer_Value - 1);

               /* Determine if Boot Mouse Input Report is supported.    */
               if(DeviceInfo->HIDSClientInfo[InstanceID].ProtocolModeHandle)
               {
                  /* Format the Set Protocol Mode command.              */
                  ProtocolMode = (Parameter_List[1].Integer_Value ? QAPI_BLE_PM_REPORT_E : QAPI_BLE_PM_BOOT_E);

                  if((Result = qapi_BLE_HIDS_Format_Protocol_Mode(ProtocolMode, sizeof(Buffer), Buffer)) == 0)
                  {
                     /* Perform the Write Without Response.             */
                     Result = qapi_BLE_GATT_Write_Without_Response_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].ProtocolModeHandle, sizeof(Buffer), Buffer);

                     /* Check for GATT Write success                    */
                     if(Result > 0)
                     {
                        QCLI_Printf(hids_group, "Set Protocol Mode Success: %s Mode.\n", (Parameter_List[1].Integer_Value ? "Report" : "Boot"));

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                     {
                        /* Set protocol mode failed, check to see if it */
                        /* was from a call to                           */
                        /* GATT_Write_Without_Response_Request          */
                        if(Result < 0)
                           DisplayFunctionError("qapi_BLE_GATT_Write_Without_Response_Request", Result);
                     }
                  }
                  else
                     DisplayFunctionError("qapi_BLE_HIDS_Format_Protocol_Mode", Result);
               }
               else
                  QCLI_Printf(hids_group, "Protocol Mode Characteristic not supported.\n");
            }
            else
               QCLI_Printf(hids_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(hids_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         QCLI_Printf(hids_group, "No Connection Established.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsiblfor sending a key button.     */
   /* This includes both a key-down and key-up report.                  */
static QCLI_Command_Status_t SendReport(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                      Result;
   uint8_t                                  InputReport[HID_KEYBOARD_INPUT_REPORT_SIZE];
   DeviceInfo_t                            *DeviceInfo;
   QCLI_Command_Status_t                    ret_val;
   qapi_BLE_HIDS_Report_Type_t              ReportType;
   qapi_BLE_GAP_Encryption_Mode_t           GAPEncryptionMode;
   qapi_BLE_HIDS_Report_Reference_Data_t    ReportReferenceData;
   qapi_BLE_HIDS_Report_Reference_Data_t   *ReportReferenceDataPtr;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 1))
   {
      /* Search for the device info structure for this device.          */
      if(HIDSInstanceID)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Find the device info.                                    */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Check that we are encrypted.                          */
               if((qapi_BLE_GAP_LE_Query_Encryption_Mode(BluetoothStackID, SelectedRemoteBD_ADDR, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
               {
                  /* Make sure the client has subscribed to             */
                  /* notifications for the given report type and current*/
                  /* protocol mode.                                     */
                  if(((Parameter_List[0].Integer_Value == 0) && (((HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) && (DeviceInfo->HIDSServerInfo.BootKeyboardInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)) || ((HIDS_Protocol_Mode == QAPI_BLE_PM_REPORT_E) && (DeviceInfo->HIDSServerInfo.ReportKeyboardInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)))) || ((Parameter_List[0].Integer_Value == 1) && (((HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) && (DeviceInfo->HIDSServerInfo.BootMouseInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)) || ((HIDS_Protocol_Mode == QAPI_BLE_PM_REPORT_E) && (DeviceInfo->HIDSServerInfo.ReportMouseInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)))))
                  {
                     /* Check to see what characteristic should be      */
                     /* notified based on the operating mode.           */
                     if(HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E)
                     {
                        if(Parameter_List[0].Integer_Value == 0)
                           ReportType = QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E;
                        else
                           ReportType = QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT;

                        ReportReferenceDataPtr = NULL;
                     }
                     else
                     {
                        ReportType = QAPI_BLE_PM_REPORT_E;

                        if(Parameter_List[0].Integer_Value == 0)
                           ReportReferenceData.ReportID = HID_KEYBOARD_INPUT_REPORT_ID;
                        else
                           ReportReferenceData.ReportID = HID_MOUSE_INPUT_REPORT_ID;

                        ReportReferenceData.ReportType = QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT;

                        ReportReferenceDataPtr         = &ReportReferenceData;
                     }

                     memset(InputReport, 0, sizeof(InputReport));

                     /* Send the Boot Input Report notification.        */
                     if(Parameter_List[0].Integer_Value == 0)
                     {
                        InputReport[2] = 0x04;

                        Result = qapi_BLE_HIDS_Notify_Input_Report(BluetoothStackID, HIDSInstanceID, DeviceInfo->ConnectionID, ReportType, ReportReferenceDataPtr, HID_KEYBOARD_INPUT_REPORT_SIZE, InputReport);

                        if(Result == HID_KEYBOARD_INPUT_REPORT_SIZE)
                        {
                           InputReport[2] = 0;
                           Result = qapi_BLE_HIDS_Notify_Input_Report(BluetoothStackID, HIDSInstanceID, DeviceInfo->ConnectionID, ReportType, ReportReferenceDataPtr, HID_KEYBOARD_INPUT_REPORT_SIZE, InputReport);
                        }

                        /* Check to see if any error occurred.          */
                        if(Result == HID_KEYBOARD_INPUT_REPORT_SIZE)
                        {
                           QCLI_Printf(hids_group, "Report sent to remote device\n");

                           ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                           QCLI_Printf(hids_group, "Error - qapi_BLE_HIDS_Notify_Input_Report() returned %d for %s mode.\n", Result, (HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) ? "Boot" : "Keyboard");

                           ret_val = QCLI_STATUS_ERROR_E;
                        }
                     }
                     else
                     {
                        Result = qapi_BLE_HIDS_Notify_Input_Report(BluetoothStackID, HIDSInstanceID, DeviceInfo->ConnectionID, ReportType, ReportReferenceDataPtr, HID_MOUSE_INPUT_REPORT_SIZE, InputReport);

                        /* Check to see if any error occurred.          */
                        if(Result == HID_MOUSE_INPUT_REPORT_SIZE)
                        {
                           QCLI_Printf(hids_group, "Report sent to remote device\n");

                           ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                           QCLI_Printf(hids_group, "Error - qapi_BLE_HIDS_Notify_Input_Report() returned %d for %s mode.\n", Result, (HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) ? "Boot" : "Mouse");

                           ret_val = QCLI_STATUS_ERROR_E;
                        }
                     }
                  }
                  else
                  {
                     QCLI_Printf(hids_group, "Client has not registered for HID notifications.\n");

                     ret_val = QCLI_STATUS_ERROR_E;
                  }
               }
               else
               {
                  QCLI_Printf(hids_group, "Error: Connection not encrypted\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(hids_group, "Unable to find device structure.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
         {
            QCLI_Printf(hids_group, "Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_ERROR_E;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for sending a key string to */
   /* a remote device.                                                  */
static QCLI_Command_Status_t SendKeyString(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t                  ret_val;
   int                                    Result;
   unsigned int                           Index;
   unsigned int                           StringLength;
   DeviceInfo_t                          *DeviceInfo;
   uint8_t                                InputReport[HID_KEYBOARD_INPUT_REPORT_SIZE];
   qapi_BLE_HIDS_Report_Type_t            ReportType;
   qapi_BLE_HIDS_Report_Reference_Data_t  ReportReferenceData;
   qapi_BLE_HIDS_Report_Reference_Data_t *ReportReferenceDataPtr;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].String_Value))
   {
      /* Search for the device info structure for this device.          */
      if((HIDSInstanceID) && ((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL))
      {
         /* Check that we are encrypted.                                */
         if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
         {
            /* Make sure the client has subscribed to notifications for */
            /* the given report type and current protocol mode.         */
            if(((HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) && (DeviceInfo->HIDSServerInfo.BootKeyboardInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)) || ((HIDS_Protocol_Mode == QAPI_BLE_PM_REPORT_E) && (DeviceInfo->HIDSServerInfo.ReportKeyboardInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)))
            {
               /* Check to see what characteristic should be notified   */
               /* based on the operating mode.                          */
               if(HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E)
               {
                  ReportType = QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E;

                  ReportReferenceDataPtr = NULL;
               }
               else
               {
                  ReportType                     = QAPI_BLE_RT_REPORT_E;

                  ReportReferenceData.ReportID   = HID_KEYBOARD_INPUT_REPORT_ID;
                  ReportReferenceData.ReportType = QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT;

                  ReportReferenceDataPtr         = &ReportReferenceData;
               }

               memset(InputReport, 0, sizeof(InputReport));

               StringLength = strlen(Parameter_List[0].String_Value);

               ret_val = 0;

               for(Index=0;Index < StringLength && !ret_val;Index++)
               {
                  if((Parameter_List[0].String_Value[Index] == '+') && (Parameter_Count >= 2) && (Parameter_List[1].Integer_Is_Valid))
                     Parameter_List[0].String_Value[Index] = ' ';

                  if(CHECK_ASCII_VALID(Parameter_List[0].String_Value[Index]))
                  {
                     InputReport[0] = KeyTable[Parameter_List[0].String_Value[Index] - ' '].Modifiers;
                     InputReport[2] = KeyTable[Parameter_List[0].String_Value[Index] - ' '].HID;

                     Result = qapi_BLE_HIDS_Notify_Input_Report(BluetoothStackID, HIDSInstanceID, DeviceInfo->ConnectionID, ReportType, ReportReferenceDataPtr, HID_KEYBOARD_INPUT_REPORT_SIZE, InputReport);

                     if(Result == HID_KEYBOARD_INPUT_REPORT_SIZE)
                     {
                        InputReport[2] = 0;
                        Result = qapi_BLE_HIDS_Notify_Input_Report(BluetoothStackID, HIDSInstanceID, DeviceInfo->ConnectionID, ReportType, ReportReferenceDataPtr, HID_KEYBOARD_INPUT_REPORT_SIZE, InputReport);
                     }

                     /* Check to see if any error occurred.             */
                     if(Result != HID_KEYBOARD_INPUT_REPORT_SIZE)
                     {
                        QCLI_Printf(hids_group, "Error - HIDS_Notify_Input_Report() returned %d for %s mode.\n", Result, (HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) ? "Boot" : "Keyboard");

                        ret_val = QCLI_STATUS_ERROR_E;
                     }
                  }
                  else
                  {
                     QCLI_Printf(hids_group, "Unable to convert character '%c' (0x%02X) to HID Usage Code. Skipping.\n", Parameter_List[0].String_Value[Index], Parameter_List[0].String_Value[Index]);
                  }
               }

               if(!ret_val)
               {
                  QCLI_Printf(hids_group, "String successfully sent\n");
               }
            }
            else
            {
               QCLI_Printf(hids_group, "Client has not registered for HID notifications.\n");

               ret_val = 0;
            }
         }
         else
         {
            QCLI_Printf(hids_group, "Error: Connection not encrypted\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
         ret_val = QCLI_STATUS_ERROR_E;
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

#ifdef V2

   /* The following function is responsible for enabling or disabling   */
   /* the BBIF interface for BLE.  This function returns                */
   /* QCLI_STATUS_SUCCESS_E on success or an error enumeration if an    */
   /* error occurs.                                                     */
static QCLI_Command_Status_t EnableBBIF(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val;

   /* First, check that valid Bluetooth Stack ID exists.                */
   if(BluetoothStackID)
   {
      /* Make sure that all of the parameters required for this function*/
      /* appear to be at least semi-valid.                              */
      if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
      {
         /* Now attempt to query the version of the Bluetooth           */
         /* Controller.                                                 */
         Result = HCI_VS_EnableBBIF(BluetoothStackID, (boolean_t)(Parameter_List[0].Integer_Value?TRUE:FALSE));
         if(!Result)
            QCLI_Printf(ble_fpga_group, "        Success %s BBIF.\n", Parameter_List[0].Integer_Value?"Enabling":"Disabling");
         else
            QCLI_Printf(ble_fpga_group, "        Error %s BBIF: %d.\n", Parameter_List[0].Integer_Value?"Enabling":"Disabling", Result);

         /* Flag success to the caller.                                 */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         /* One or more of the necessary parameters is/are invalid.     */
         ret_val = QCLI_STATUS_USAGE_E;
      }
   }
   else
   {
      /* No valid Bluetooth Stack ID exists.                            */
      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is used to program the local BD_ADDR into  */
   /* OTP.  This function is only provided for FPGA builds in order to  */
   /* avoid accidental calls consuming OTP space.  Please use the MFG   */
   /* tool to program OTP on ASICs.                                     */
static QCLI_Command_Status_t SetOTPAddress(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   qapi_Status_t          Result;
   QCLI_Command_Status_t  ret_val;
   uint64_t               BD_Addr;
   unsigned int           Length;

   /* Make sure that all of the parameters required for this function   */
   /* appear to be at least semi-valid.                                 */
   if((Parameter_Count > 0) && (Parameter_List) && (Hex_String_To_ULL(Parameter_List[0].String_Value, &BD_Addr)))
   {
      /* Check if the tag has already been written.                     */
      Result = qapi_OTP_TLV_Read(QAPI_OTP_TLV_TAG_BLE_ADDRESS, (uint8_t *)&BD_Addr, sizeof(BD_Addr), &Length);
      if(Result == QAPI_ERR_NO_ENTRY)
      {
         if(BD_Addr <= 0x0000FFFFFFFFFFFFULL)
         {
            Result = qapi_OTP_TLV_Write(QAPI_OTP_TLV_TAG_BLE_ADDRESS, (uint8_t *)&BD_Addr, sizeof(qapi_BLE_BD_ADDR_t));

            if(Result == QAPI_OK)
            {
               Display_Function_Success(ble_fpga_group, "qapi_OTP_TLV_Write");
               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               Display_Function_Error(ble_fpga_group, "qapi_OTP_TLV_Write", Result);
               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
      else
      {
         QCLI_Printf(ble_fpga_group, "Tag already exists.\n");
         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      /* One or more of the necessary parameters is/are invalid.        */
      ret_val = QCLI_STATUS_USAGE_E;
   }

   return(ret_val);
}

#endif

   /* HID over GATT Service (HIDS) helper functions.                    */

   /* The following function is a utility function that provides a      */
   /* mechanism of populating a HIDS Client Information structure with  */
   /* the information discovered from a GATT Discovery operation.       */
static void HIDSPopulateHandles(HIDS_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
   uint16_t                                              *ClientConfigurationHandle;
   uint16_t                                              *ReportReferenceHandle = NULL;
   unsigned int                                           Index1;
   unsigned int                                           Index2;
   unsigned int                                           Index3;
   qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
   qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

   /* Verify that the input parameters are semi-valid.                  */
   if((ClientInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_HIDS_COMPARE_HIDS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
   {
      /* Store the starting and ending attribute handles for HIDS.      */
      ClientInfo->ServiceHandleRange.Starting_Handle = ServiceDiscoveryData->ServiceInformation.Service_Handle;
      ClientInfo->ServiceHandleRange.Ending_Handle   = ServiceDiscoveryData->ServiceInformation.End_Group_Handle;

      /* Clear the NULL UUID used for comparison.                       */
      memset(&NULL_UUID_128,  0,  sizeof(NULL_UUID_128));

      /* Loop through all characteristics discovered in the service and */
      /* populate the correct entry.                                    */
      CurrentCharacteristic = ServiceDiscoveryData->CharacteristicInformationList;
      if(CurrentCharacteristic)
      {
         for(Index1 = 0; Index1 < ServiceDiscoveryData->NumberOfCharacteristics; Index1++, CurrentCharacteristic++)
         {
            /* All HIDS UUIDs are defined to be 16 bit UUIDs.           */
            if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
            {
               /* Clear the client configuration handle.                */
               ClientConfigurationHandle = NULL;

               /* Determine which characteristic this is.               */
               if(!QAPI_BLE_HIDS_COMPARE_HIDS_PROTOCOL_MODE_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
               {
                  if(!QAPI_BLE_HIDS_COMPARE_HIDS_REPORT_MAP_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                  {
                     if(!QAPI_BLE_HIDS_COMPARE_HIDS_REPORT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                     {
                        if(!QAPI_BLE_HIDS_COMPARE_HIDS_BOOT_KEYBOARD_INPUT_REPORT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                        {
                           if(!QAPI_BLE_HIDS_COMPARE_HIDS_BOOT_KEYBOARD_OUTPUT_REPORT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                           {
                              if(!QAPI_BLE_HIDS_COMPARE_HIDS_BOOT_MOUSE_INPUT_REPORT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                              {
                                 if(!QAPI_BLE_HIDS_COMPARE_HIDS_HID_INFORMATION_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                                 {
                                    if(!QAPI_BLE_HIDS_COMPARE_HIDS_HID_CONTROL_POINT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                                       continue;
                                    else
                                    {
                                       ClientInfo->ControlPoint = CurrentCharacteristic->Characteristic_Handle;
                                       continue;
                                    }
                                 }
                                 else
                                 {
                                    ClientInfo->HIDSInformationHandle = CurrentCharacteristic->Characteristic_Handle;
                                    continue;
                                 }
                              }
                              else
                              {
                                 ClientInfo->BootMouseInputReport = CurrentCharacteristic->Characteristic_Handle;
                                 ClientConfigurationHandle       = &(ClientInfo->BootMouseInputReport_CCCD);
                              }
                           }
                           else
                           {
                              ClientInfo->BootKeyboardOutputReport = CurrentCharacteristic->Characteristic_Handle;
                              continue;
                           }
                        }
                        else
                        {
                           ClientInfo->BootKeyboardInputReport = CurrentCharacteristic->Characteristic_Handle;
                           ClientConfigurationHandle          = &(ClientInfo->BootKeyboardInputReport_CCCD);
                        }
                     }
                     else
                     {
                        /* Loop through the reports and make sure to    */
                        /* overwrite if the same handle was previously  */
                        /* saved.                                       */
                        for(Index2=0; Index2 < HIDS_MAXIMUM_NUMBER_REPORTS; Index2++)
                        {
                           if((ClientInfo->Reports[Index2].Handle == CurrentCharacteristic->Characteristic_Handle) || (!(ClientInfo->Reports[Index2].Handle)))
                           {
                              ClientInfo->Reports[Index2].Handle = CurrentCharacteristic->Characteristic_Handle;
                              ClientConfigurationHandle          = &(ClientInfo->Reports[Index2].CCCDHandle);
                              ReportReferenceHandle              = &(ClientInfo->Reports[Index2].ReportReferenceHandle);
                              break;
                           }
                        }
                     }
                  }
                  else
                     ClientInfo->ReportMapHandle = CurrentCharacteristic->Characteristic_Handle;
               }
               else
               {
                  ClientInfo->ProtocolModeHandle = CurrentCharacteristic->Characteristic_Handle;
                  continue;
               }

               /* Loop through the Descriptor List.                     */
               CurrentDescriptor = CurrentCharacteristic->DescriptorList;
               if((CurrentDescriptor))
               {
                  for(Index2 = 0; Index2 < CurrentCharacteristic->NumberOfDescriptors; Index2++, CurrentDescriptor++)
                  {
                     if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                     {
                        /* Get the Client Characteristic Configure      */
                        /* Descriptor.                                  */
                        if((ClientConfigurationHandle) && (QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16)))
                           *ClientConfigurationHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                        else
                        {
                           /* Get the Report Reference Descriptor.      */
                           if((ReportReferenceHandle) && (QAPI_BLE_HIDS_COMPARE_REPORT_REFERENCE_DESCRIPTOR_UUID_TO_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16)))
                              *ReportReferenceHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                           else
                           {
                              /* Get the External Report Reference      */
                              /* Descriptor(s).                         */
                              if(QAPI_BLE_HIDS_COMPARE_EXTERNAL_REPORT_REFERENCE_DESCRIPTOR_UUID_TO_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16))
                              {
                                 /* Loop through the external report    */
                                 /* reference list.                     */
                                 for(Index3=0; Index3 < HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES; Index3++)
                                 {
                                    /* Make sure to overwrite if this   */
                                    /* handle was previously discovered */
                                    /* and its value found.             */
                                    if((!(ClientInfo->ExternalReportReferences[Index3].ExternalReportReferenceHandle)) || ((ClientInfo->ExternalReportReferences[Index3].ExternalReportReferenceHandle) && (!(QAPI_BLE_COMPARE_UUID_128(NULL_UUID_128, ClientInfo->ExternalReportReferences[Index3].ExternalReportReference.UUID.UUID_128)))))
                                    {
                                       ClientInfo->ExternalReportReferences[Index3].ExternalReportReferenceHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                                       break;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }

         /* Increment the index to save the handles of other service    */
         /* instances to DeviceInfo->ClientInfo[] array during          */
         /* etGDIS_Service_Discovery_Indication                         */
         ++HIDSInstanceIDIndex;
         if(HIDSInstanceIDIndex == MAX_SUPPORTED_HID_INSTANCES)
         {
            /* Reset the index to ZERO once Discovery indication is     */
            /* done for all the service instances                       */
            HIDSInstanceIDIndex = 0;
         }
      }
   }
}

   /* The following function is responsible for reading the values of a */
   /* remote HID service. This function will return zero on successful  */
   /* execution and a negative value on errors.                         */
static void ReadHIDSInfo(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo)
{
   int           ret_val;
   unsigned int  Index;

   /* Read the protocol mode if it exists.                              */
   if(ClientInfo->ProtocolModeHandle)
   {
      ret_val = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, ConnectionID, ClientInfo->ProtocolModeHandle, GATT_ClientEventCallback_HIDS, ClientInfo->ProtocolModeHandle);
      if(ret_val < 0)
      {
         /* Reading the protocol mode failed.                           */
         DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
      }
   }

   /* Read the HID information if it exists.                            */
   if(ClientInfo->HIDSInformationHandle)
   {
      ret_val = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, ConnectionID, ClientInfo->HIDSInformationHandle, GATT_ClientEventCallback_HIDS, ClientInfo->HIDSInformationHandle);
      if(ret_val < 0)
      {
         /* Reading the HID information failed.                         */
         DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
      }
   }
   else
      QCLI_Printf(hids_group, "Error - HID Information handle not found on this device.\n");

   for(Index=0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
   {
      if((ClientInfo->Reports[Index].Handle) && (ClientInfo->Reports[Index].ReportReferenceHandle))
      {
         ret_val = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, ConnectionID, ClientInfo->Reports[Index].ReportReferenceHandle, GATT_ClientEventCallback_HIDS, ClientInfo->Reports[Index].ReportReferenceHandle);
         if(ret_val < 0)
         {
            /* Reading the HID report information failed.               */
            DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
         }
      }
      else
         break;
   }

   for(Index=0; Index < HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES; Index++)
   {
      if(ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle)
      {
         ret_val = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, ConnectionID, ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle, GATT_ClientEventCallback_HIDS, ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle);
         if(ret_val < 0)
         {
            /* Reading the HID external report reference information    */
            /* failed.                                                  */
            DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
         }
      }
      else
         break;
   }

   /* Read the report map if it exists.                                 */
   if(ClientInfo->ReportMapHandle)
   {
      ret_val = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, ConnectionID, ClientInfo->ReportMapHandle, GATT_ClientEventCallback_HIDS, ClientInfo->ReportMapHandle);
      if(ret_val < 0)
      {
         /* Reading the report map failed.                              */
         DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
      }
   }
   else
      QCLI_Printf(hids_group, "Error - Report Map handle not found on this device.\n");
}

   /* This function performs a GET_REPORT request for a specific Report */
   /* Type and ID.                                                      */
static int HIDSGetReport(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo, uint8_t ReportType, uint8_t ReportID)
{
   int          ret_val;
   uint16_t     Handle;
   unsigned int Index;

   /* Check the input parameters.                                       */
   if(ClientInfo)
   {
      /* Initialize the handle to 0.                                    */
      Handle = 0;

      /* Switch through by report type.                                 */
      switch(ReportType)
      {
         case hrtHIDSInputReport:
            /* Get the Input Report Handle.                             */
            for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
            {
               if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT))
               {
                  Handle = ClientInfo->Reports[Index].Handle;
                  break;
               }
            }
            break;
         case hrtHIDSOutputReport:
            /* Get the Output Report Handle.                            */
            for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
            {
               if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT))
               {
                  Handle = ClientInfo->Reports[Index].Handle;
                  break;
               }
            }
            break;
         case hrtHIDSFeatureReport:
            /* Get the Feature Report Handle.                           */
            for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
            {
               if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_FEATURE_REPORT))
               {
                  Handle = ClientInfo->Reports[Index].Handle;
                  break;
               }
            }
            break;
         case hrtHIDSBootKeyboardInputReport:
            /* Get the Boot Keyboard Input Handle.                      */
            if(ClientInfo->BootKeyboardInputReport)
               Handle = ClientInfo->BootKeyboardInputReport;
            break;
         case hrtHIDSBootKeyboardOuputReport:
            /* Get the Boot Keyboard Output Handle.                     */
            if(ClientInfo->BootKeyboardOutputReport)
               Handle = ClientInfo->BootKeyboardOutputReport;
            break;
         case hrtHIDSBootMouseInputReport:
            /* Get the Boot Mouse Input Handle.                         */
            if(ClientInfo->BootMouseInputReport)
               Handle = ClientInfo->BootMouseInputReport;
            break;
         default:
            break;
      }

      /* Make sure the handle was found.                                */
      if(Handle)
      {
         /* Perform the GATT Read.                                      */
         ret_val = qapi_BLE_GATT_Read_Value_Request(BluetoothStackID, ConnectionID, Handle, GATT_ClientEventCallback_HIDS, Handle);

         /* Check for GATT Read success                                 */
         if(ret_val > 0)
            QCLI_Printf(hids_group, "Get Report Success.\n");
         else
         {
            /* Get report failed, check to see if it was from a call to */
            /* GATT_Read_Value_Request                                  */
            if(ret_val <= 0)
               DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
         }
      }
      else
         ret_val = QAPI_BLE_BTPS_ERROR_INVALID_PARAMETER;
   }

   return(ret_val);
}

   /* This function performs a GET_REPORT request for a specific Report */
   /* Type and ID.                                                      */
static int HIDSSetReport(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo, uint8_t ReportType, uint8_t ReportID, uint8_t *Value, unsigned int ValueLength, boolean_t ResponseExpected)
{
   int          ret_val;
   uint16_t     Handle;
   unsigned int Index;

   /* Check the input parameters.                                       */
   if((ClientInfo) && (Value))
   {
      /* Initialize the handle to 0.                                    */
      Handle = 0;

      /* Switch through by report type.                                 */
      switch(ReportType)
      {
         case hrtHIDSInputReport:
            /* Get the Input Report Handle.                             */
            for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
            {
               if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT))
               {
                  Handle = ClientInfo->Reports[Index].Handle;
                  break;
               }
            }
            break;
         case hrtHIDSOutputReport:
            /* Get the Output Report Handle.                            */
            for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
            {
               if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT))
               {
                  Handle = ClientInfo->Reports[Index].Handle;
                  break;
               }
            }
            break;
         case hrtHIDSFeatureReport:
            /* Get the Feature Report Handle.                           */
            for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
            {
               if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_FEATURE_REPORT))
               {
                  Handle = ClientInfo->Reports[Index].Handle;
                  break;
               }
            }
            break;
         case hrtHIDSBootKeyboardInputReport:
            /* Get the Boot Keyboard Input Handle.                      */
            if(ClientInfo->BootKeyboardInputReport)
               Handle = ClientInfo->BootKeyboardInputReport;
            break;
         case hrtHIDSBootKeyboardOuputReport:
            /* Get the Boot Keyboard Output Handle.                     */
            if(ClientInfo->BootKeyboardOutputReport)
               Handle = ClientInfo->BootKeyboardOutputReport;
            break;
         case hrtHIDSBootMouseInputReport:
            /* Get the Boot Mouse Input Handle.                         */
            if(ClientInfo->BootMouseInputReport)
               Handle = ClientInfo->BootMouseInputReport;
            break;
         default:
            break;
      }

      /* Make sure the handle was found.                                */
      if(Handle)
      {
         /* Send the appropriate GATT Write Request.                    */
         if(ResponseExpected)
            ret_val = qapi_BLE_GATT_Write_Request(BluetoothStackID, ConnectionID, Handle, ValueLength, Value, GATT_ClientEventCallback_HIDS, Handle);
         else
            ret_val = qapi_BLE_GATT_Write_Without_Response_Request(BluetoothStackID, ConnectionID, Handle, ValueLength, Value);
      }
      else
         ret_val = QAPI_BLE_BTPS_ERROR_INVALID_PARAMETER;
   }

   return(ret_val);
}

   /* The following function is provided to allow a mechanism of        */
   /* parsing a hex string.  The second parameter will be pointed to an */
   /* allocated buffer that holds the parsed data (which the caller     */
   /* MUST free when finished) and the return value will hold the       */
   /* number of bytes that were parsed into the Buffer.                 */
static unsigned int ExtractHexString(char *String, uint8_t **Buffer)
{
   char          ch;
   char         *BufPtr;
   char         *ParseBuffer;
   unsigned int  StringLength;
   unsigned int  ret_val = 0;

   /* Verify that the input parameters are valid.                       */
   if((String) && (Buffer))
   {
      *Buffer      = NULL;
      StringLength = strlen(String);
      if((ParseBuffer = malloc(StringLength)) != NULL)
      {
         /* Set the return pointer to the start of the parse buffer.    */
         *Buffer = (uint8_t *)ParseBuffer;

         /* Parse the string until the parse buffer while their are     */
         /* characters remaining.                                       */
         BufPtr = String;

         /* Advance past the leading " if necessary.                    */
         if(*BufPtr == '"')
         {
            (void)*(BufPtr++);
            --StringLength;
         }

         while(StringLength--)
         {
            ch = *(BufPtr++);
            if(ch == '"')
               break;

            /* Check to see if \x or 0x are specified.                  */
            if(((ch == '\\') || (ch == '0')) && ((char)(*BufPtr | ' ')  == 'x'))
            {
               if(StringLength >= 3)
               {
                  ch            = (char)((ToInt(BufPtr[1]) << 4) + ToInt(BufPtr[2]));
                  StringLength -= 3;
                  BufPtr       += 3;
               }
               else
                  break;
            }
            else
            {
               if(StringLength >= 1)
               {
                  ch            = (char)((ToInt(ch) << 4) + ToInt(BufPtr[0]));
                  StringLength -= 1;
                  BufPtr       += 1;
               }
               else
                  break;
            }

            *(ParseBuffer++) = ch;
            ++ret_val;
         }

         /* If we were unable to parse any bytes into the parse buffer  */
         /* we will free the allocated memory.                          */
         if(!ret_val)
         {
            free(*Buffer);
            *Buffer = NULL;
         }
      }
   }

   return(ret_val);
}


   /* Heart Rate Service (HRS) QCLI command functions.                  */

   /* The following function is responsible for configuring an HRS      */
   /* Service on a remote device. This function will return zero on     */
   /* successful execution and a negative value on errors.              */
   /* * NOTE * This function will NOT check if we are an HRS Server,    */
   /*          since this demo does NOT support running as the HRS      */
   /*          Server.                                                  */
static QCLI_Command_Status_t ConfigureRemoteHRS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid))
   {
      /* Verify that there is a connection that is established.         */
      if(ConnectionCount)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Get the device info for the connection device.           */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               QCLI_Printf(hrs_group, "Attempting to configure CCCDs...\n");

               /* Initialize the result to 0.                           */
               Result = 0;

               /* Determine if HRS Measurement CC is supported (only if */
               /* HRS Measurement characteristic is supported(optional))*/
               if(DeviceInfo->HRSClientInfo.Heart_Rate_Measurement)
               {
                  /* Make sure a CCCD has been discovered for the remote*/
                  /* device's HRS Measurement Characteristic.           */
                  if(DeviceInfo->HRSClientInfo.Heart_Rate_Measurement_Client_Configuration)
                  {
                     Result = EnableDisableNotificationsIndications(DeviceInfo->HRSClientInfo.Heart_Rate_Measurement_Client_Configuration, (Parameter_List[0].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_HRS);

                     /* Check for CC Configuration success              */
                     if(Result > 0)
                     {
                        QCLI_Printf(hrs_group, "CCCD Configuration Success.\n");

                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                     {
                        /* CC Configuration failed, check to see if it  */
                        /* was from a call to                           */
                        /* EnableDisableNotificationsIndications        */
                        if(Result < 0)
                           DisplayFunctionError("EnableDisableNotificationsIndications", Result);
                     }
                  }
                  else
                     QCLI_Printf(hrs_group, "   Error - HRS Measurement CC not found on this device.\n");
               }
               else
                  QCLI_Printf(hrs_group, "   Error - HRS Measurement Characteristics not supported.\n");
            }
            else
               QCLI_Printf(hrs_group, "No Device Info.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(ble_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         QCLI_Printf(hrs_group, "No Connection Established.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* Heart Rate Service (HRS) helper functions.                        */

   /* The following function is a utility function that provides a      */
   /* mechanism of populating a HRS Client Information structure with   */
   /* the information discovered from a GATT Discovery operation.       */
static void HRSPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
   uint16_t                                              *ClientConfigurationHandle;
   unsigned int                                           Index1;
   unsigned int                                           Index2;
   qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
   qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

   /* Verify that the input parameters are semi-valid.                  */
   if((DeviceInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_HRS_COMPARE_HRS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
   {
      /* Loop through all characteristics discovered in the service     */
      /* and populate the correct entry.                                */
      CurrentCharacteristic = ServiceDiscoveryData->CharacteristicInformationList;
      if(CurrentCharacteristic)
      {
         for(Index1 = 0; Index1 < ServiceDiscoveryData->NumberOfCharacteristics; Index1++, CurrentCharacteristic++)
         {
            /* All HRS UUIDs are defined to be 16 bit UUIDs.            */
            if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
            {
               ClientConfigurationHandle = NULL;

               /* Determine which characteristic this is.               */
               if(!QAPI_BLE_HRS_COMPARE_HRS_HEART_RATE_MEASUREMENT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
               {
                  if(!QAPI_BLE_HRS_COMPARE_HRS_BODY_SENSOR_LOCATION_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                  {
                     if(!QAPI_BLE_HRS_COMPARE_HRS_HEART_RATE_CONTROL_POINT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                     {
                        continue;
                     }
                     else
                     {
                        DeviceInfo->HRSClientInfo.Heart_Rate_Control_Point = CurrentCharacteristic->Characteristic_Handle;

                        /* Verify that write is supported.              */
                        if(!(CurrentCharacteristic->Characteristic_Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE))
                           QCLI_Printf(hrs_group, "Warning - Mandatory write property of Heart Rate Control Point characteristic not supported!\n");

                        continue;
                     }
                  }
                  else
                  {
                     DeviceInfo->HRSClientInfo.Body_Sensor_Location = CurrentCharacteristic->Characteristic_Handle;

                     /* Verify that read is supported.                  */
                     if(!(CurrentCharacteristic->Characteristic_Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ))
                        QCLI_Printf(hrs_group, "Warning - Mandatory read property of Body Sensor Location characteristic not supported!\n");

                     continue;
                  }
               }
               else
               {
                  DeviceInfo->HRSClientInfo.Heart_Rate_Measurement = CurrentCharacteristic->Characteristic_Handle;
                  ClientConfigurationHandle     = &(DeviceInfo->HRSClientInfo.Heart_Rate_Measurement_Client_Configuration);

                  /* Verify that notify is supported.                   */
                  if(!(CurrentCharacteristic->Characteristic_Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_NOTIFY))
                     QCLI_Printf(hrs_group, "Warning - Mandatory notify property of Heart Rate Measurement characteristic not supported!\n");
               }

               /* Loop through the Descriptor List.                     */
               CurrentDescriptor = CurrentCharacteristic->DescriptorList;
               if((CurrentDescriptor) && (ClientConfigurationHandle))
               {
                  for(Index2 = 0; Index2 < CurrentCharacteristic->NumberOfDescriptors; Index2++, CurrentDescriptor++)
                  {
                     if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                     {
                        if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16))
                        {
                           *ClientConfigurationHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                           break;
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

   /* The following function is used to decode and display a Heart Rate */
   /* measurement from a notification event.  The first parameter       */
   /* provides the buffer length of the data to be decoded, the second  */
   /* parameter provides the data packet to be decoded, and the final   */
   /* parameter is a boolean value that determines whether the decoded  */
   /* data will be printed to the terminal.  This function returns a    */
   /* pointer to a an allocated Heart Rate measurement structure with   */
   /* the decoded data on success and NULL on failure.  If this function*/
   /* succeeds, the allocated buffer will need to be freed when it is   */
   /* done being used.                                                  */
static qapi_BLE_HRS_Heart_Rate_Measurement_Data_t *DecodeDisplayHeartRate(unsigned int ValueLength, uint8_t *Value, boolean_t PrintData)
{
   qapi_BLE_HRS_Heart_Rate_Measurement_Data_t *ret_val = NULL;
   qapi_BLE_HRS_Heart_Rate_Measurement_Data_t  Heart_Rate_Measurement;
   uint16_t                                    Index;
   int                                         Result;

   /* Verify that the input parameters seem semi-valid.                 */
   if((ValueLength) && (Value))
   {
      /* Initialize the Heart Rate Structure.                           */
      memset(&Heart_Rate_Measurement, 0, sizeof(qapi_BLE_HRS_Heart_Rate_Measurement_Data_t));

      /* Decode the Heart Rate Measurement.                             */
      Result = qapi_BLE_HRS_Decode_Heart_Rate_Measurement(ValueLength, Value, &Heart_Rate_Measurement);
      if(!Result)
      {
         /* Print out the information parsed from the Heart Rate        */
         /* Measurement.                                                */
         if(PrintData)
         {
            QCLI_Printf(hrs_group, "      \nFlags:             0x%02X\n", Heart_Rate_Measurement.Flags);
            QCLI_Printf(hrs_group, "      Heart Rate:        %u\n", Heart_Rate_Measurement.Heart_Rate);

            if(Heart_Rate_Measurement.Flags & QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_FLAGS_ENERGY_EXPENDED_PRESENT)
               QCLI_Printf(hrs_group, "      Energy Expended:   %u\n", Heart_Rate_Measurement.Energy_Expended);

            QCLI_Printf(hrs_group, "      Sensor Contact:    ");

            if(Heart_Rate_Measurement.Flags & QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_FLAGS_SENSOR_CONTACT_STATUS_SUPPORTED)
            {
               if(Heart_Rate_Measurement.Flags & QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_FLAGS_SENSOR_CONTACT_STATUS_DETECTED)
                  QCLI_Printf(hrs_group, "Detected");
               else
                  QCLI_Printf(hrs_group, "Not Detected");
            }
            else
               QCLI_Printf(hrs_group, "Not Supported");

            QCLI_Printf(hrs_group, "\n");
         }

         /* Allocate the required memory for the RR Intervals.          */
         if((ret_val = (qapi_BLE_HRS_Heart_Rate_Measurement_Data_t *)malloc(QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_DATA_SIZE(Heart_Rate_Measurement.Number_Of_RR_Intervals))) != NULL)
         {
            /* If there are RR Intervals, then allocate memory to hold  */
            /* them and parse them out of the notification.             */
            if(Heart_Rate_Measurement.Number_Of_RR_Intervals)
            {
               ret_val->Number_Of_RR_Intervals = Heart_Rate_Measurement.Number_Of_RR_Intervals;

               /* Decode the Heart Rate Measurement.                    */
               Result = qapi_BLE_HRS_Decode_Heart_Rate_Measurement(ValueLength, Value, ret_val);
               if(!Result)
               {
                  if(PrintData)
                  {
                     if(ret_val->Flags & QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_FLAGS_RR_INTERVAL_PRESENT)
                     {
                        QCLI_Printf(hrs_group, "      Num. RR Intervals: %u\n", ret_val->Number_Of_RR_Intervals);

                        if(ret_val->Number_Of_RR_Intervals != 0)
                        {
                           QCLI_Printf(hrs_group, "      RR Intervals:      { ");

                           for(Index = 0; Index < (ret_val->Number_Of_RR_Intervals - 1); Index++)
                              QCLI_Printf(hrs_group, "%d, ", ret_val->RR_Intervals[Index]);

                           QCLI_Printf(hrs_group, "%d }\n", ret_val->RR_Intervals[Index]);
                        }
                     }
                  }
               }
               else
                  DisplayFunctionError("HRS_Decode_Heart_Rate_Measurement", Result);
            }
            else
            {
               /* Just copy over the data                               */
               memcpy(ret_val, &Heart_Rate_Measurement, QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_DATA_SIZE(Heart_Rate_Measurement.Number_Of_RR_Intervals));
            }

            free(ret_val);
            ret_val = NULL;
         }
      }
      else
         DisplayFunctionError("qapi_BLE_HRS_Decode_Heart_Rate_Measurement", Result);
   }

   return(ret_val);
}

   /* Over the Air service QCLI command functions.                      */

   /* Registers an OTA service. The first parameter is optional and     */
   /* specifies if images should automatically be registered with the   */
   /* service or not.                                                   */
static QCLI_Command_Status_t RegisterOTA(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_Count == 0) || ((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid)))
   {
      /* Verify that we are not configured as a server                  */
      if(!OTAInstanceID)
      {
         /* Register the service with or without the image data.        */
         if((Parameter_Count) && (Parameter_List[0].Integer_Value == 0))
         {
            /* Clear the internal image data defaults.                  */
            memset(ManualOTAServerImageData, 0, sizeof(ManualOTAServerImageData));
            memset(ManualOTAImageInfo, 0, sizeof(ManualOTAImageInfo));

            UseOTADefaultImages = FALSE;

            Result = BLE_OTA_Initialize_Service(BluetoothStackID, 0, NULL, 0, OTA_EventCallback, NULL, &OTAInstanceID);

            if(Result == BLE_OTA_STATUS_SUCCESS)
            {
               QCLI_Printf(ota_group, "OTA service registered successfully.\n");
               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
               QCLI_Printf(ota_group, "OTA service register failed, %d.\n", Result);
         }
         else
         {
            /* Get the image lengths from the flash file system.        */
            PopulateDefaultOTAImageSizes();

            UseOTADefaultImages = TRUE;

            Result = BLE_OTA_Initialize_Service(BluetoothStackID, 0, DefaultOTAServerImageData, sizeof(DefaultOTAServerImageData)/sizeof(BLE_OTA_Server_Image_Data_t), OTA_EventCallback, NULL, &OTAInstanceID);

            if(Result == BLE_OTA_STATUS_SUCCESS)
            {
               QCLI_Printf(ota_group, "OTA service registered successfully.\n");
               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
               QCLI_Printf(ota_group, "OTA service register failed, %d.\n", Result);
         }
      }
      else
         QCLI_Printf(ota_group, "Service already registered.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* Unegisters an OTA service.                                        */
static QCLI_Command_Status_t UnregisterOTA(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint8_t               Index;
   QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;

   /* Verify that we are not configured as a server                     */
   if(OTAInstanceID)
   {
      /* Unregister the service                                         */
      BLE_OTA_Cleanup_Service(BluetoothStackID, OTAInstanceID);

      OTAInstanceID = 0;

      /* Loop through each item and clean up any allocations.           */
      for(Index = 0; Index < sizeof(ManualOTAServerImageData)/sizeof(BLE_OTA_Server_Image_Data_t); Index++)
      {
         /* Use the same index for the server image data and image info,*/
         /* the arrays have the same length.                            */
         if(ManualOTAServerImageData[Index].FileName)
            free(ManualOTAServerImageData[Index].FileName);

         if(ManualOTAImageInfo[Index].FilePath)
            free(ManualOTAImageInfo[Index].FilePath);
      }

      memset(ManualOTAServerImageData, 0, sizeof(ManualOTAServerImageData));
      memset(ManualOTAImageInfo, 0, sizeof(ManualOTAImageInfo));

      QCLI_Printf(ota_group, "OTA service unregistered.\n");
   }
   else
      QCLI_Printf(ota_group, "Service not registered.\n");

   return(ret_val);
}

   /* Manually registers an images with the OTA service.                */
static QCLI_Command_Status_t RegisterImage(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                      Result;
   uint8_t                  Index;
   uint8_t                  ImageIndex = 0;
   QCLI_Command_Status_t    ret_val = QCLI_STATUS_ERROR_E;
   struct qapi_fs_stat_type FileStat;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_Count >= 3) && (Parameter_List) && (Parameter_List[2].Integer_Is_Valid) && \
     ((Parameter_Count == 3) || ((Parameter_Count >= 4) && (Parameter_List[3].Integer_Is_Valid))))
   {
      /* Verify that we are registered as a server                      */
      if(OTAInstanceID)
      {
         for(Index = 0; Index < sizeof(ManualOTAServerImageData)/sizeof(BLE_OTA_Server_Image_Data_t); Index++)
         {
            /* Find the first empty entry.                              */
            if(ManualOTAServerImageData[Index].FileName == NULL)
            {
               ImageIndex = Index;

               /* Allocate the file name.                               */
               if((ManualOTAServerImageData[Index].FileName = (char *)malloc(strlen(Parameter_List[0].String_Value)+1)) != NULL)
               {
                  /* Allocate the file path.                            */
                  if((ManualOTAImageInfo[Index].FilePath = (char *)malloc(strlen("/spinor/") + strlen(Parameter_List[0].String_Value)+1)) != NULL)
                  {
                     /* Format the file name and path.                  */
                     strcpy(ManualOTAServerImageData[Index].FileName, (const char *)Parameter_List[0].String_Value);
                     strcpy(ManualOTAImageInfo[Index].FilePath, "/spinor/");
                     strcat(ManualOTAImageInfo[Index].FilePath, (const char *)Parameter_List[0].String_Value);

                     ManualOTAServerImageData[Index].Version = Parameter_List[2].Integer_Value;

                     /* Provide an image ID or let the service assign   */
                     /* one.                                            */
                     if(Parameter_Count >= 4)
                        ManualOTAServerImageData[Index].ImageID = Parameter_List[3].Integer_Value;
                     else
                        ManualOTAServerImageData[Index].ImageID = 0;

                     /* Get the file size.                              */
                     if(qapi_Fs_Stat(ManualOTAImageInfo[Index].FilePath, &FileStat) == QAPI_OK)
                     {
                        ManualOTAServerImageData[Index].ImageLength = FileStat.st_size;
                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                     else
                     {
                        ManualOTAServerImageData[Index].ImageLength = 0;
                        QCLI_Printf(ota_group, "Could not find image '%s' in file system, setting length to 0.\n", Parameter_List[0].String_Value);
                        ret_val = QCLI_STATUS_SUCCESS_E;
                     }
                  }
                  else
                  {
                     free(ManualOTAServerImageData[Index].FileName);
                     ManualOTAServerImageData[Index].FileName = NULL;
                     QCLI_Printf(ota_group, "Error, could not allocate file path buffer.\n");
                  }
               }
               else
                  QCLI_Printf(ota_group, "Error, could not allocate file name buffer.\n");

               break;
            }
         }

         if(ret_val == QCLI_STATUS_SUCCESS_E)
         {
            /* Register the image.                                      */
            Result = BLE_OTA_Register_Image(BluetoothStackID, OTAInstanceID, &ManualOTAServerImageData[ImageIndex]);

            if(Result == BLE_OTA_STATUS_SUCCESS)
               QCLI_Printf(ota_group, "OTA image registered successfully, ImageID %d.\n", ManualOTAServerImageData[ImageIndex].ImageID);
            else
               QCLI_Printf(ota_group, "OTA image register failed, %d.\n", Result);
         }
      }
      else
         QCLI_Printf(ota_group, "Service not registered.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* Manually unregisters an images with the OTA service.              */
static QCLI_Command_Status_t UnregisterImage(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;
   uint8_t               Index;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_Count >= 1) && (Parameter_List[0].Integer_Is_Valid))
   {
      /* Verify that we are registered as a server.                     */
      if(OTAInstanceID)
      {
         /* Unregister the image.                                       */
         Result = BLE_OTA_Unregister_Image(BluetoothStackID, OTAInstanceID, Parameter_List[0].Integer_Value);

         if(Result == BLE_OTA_STATUS_SUCCESS)
         {
            /* If this image was dynamically allocated, then find it    */
            /* and clean up the allocations.                            */
            for(Index = 0; Index < sizeof(ManualOTAServerImageData)/sizeof(BLE_OTA_Server_Image_Data_t); Index++)
            {
               if(ManualOTAServerImageData[Index].ImageID == Parameter_List[0].Integer_Value)
               {
                  if(ManualOTAServerImageData[Index].FileName)
                     free(ManualOTAServerImageData[Index].FileName);

                  if(ManualOTAImageInfo[Index].FilePath)
                     free(ManualOTAImageInfo[Index].FilePath);

                  memset(&ManualOTAServerImageData[Index], 0, sizeof(BLE_OTA_Server_Image_Data_t));
                  memset(&ManualOTAImageInfo[Index], 0, sizeof(BLE_OTA_Demo_Image_Info_t));
               }
            }

            QCLI_Printf(ota_group, "OTA image unregistered successfully, ImageID %d.\n", Parameter_List[0].Integer_Value);
         }
         else
            QCLI_Printf(ota_group, "OTA image unregister failed, %d.\n", Result);
      }
      else
         QCLI_Printf(ota_group, "Service not registered.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

static QCLI_Command_Status_t GetRegisteredImages(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                          Result;
   QCLI_Command_Status_t        ret_val = QCLI_STATUS_ERROR_E;
   uint8_t                      Index;
   uint8_t                      ImageDataCount = BLE_OTA_MAXIMUM_NUMBER_OF_IMAGES;
   BLE_OTA_Server_Image_Data_t *ImageData;

   /* Verify that we are registered as a server.                        */
   if(OTAInstanceID)
   {
      ImageData = (BLE_OTA_Server_Image_Data_t *)malloc(sizeof(BLE_OTA_Server_Image_Data_t)*BLE_OTA_MAXIMUM_NUMBER_OF_IMAGES);

      if(ImageData)
      {
         /* Get the image list.                                         */
         Result = BLE_OTA_Get_Registered_Images(BluetoothStackID, OTAInstanceID, ImageData, &ImageDataCount);

         if(Result == BLE_OTA_STATUS_SUCCESS)
         {
            QCLI_Printf(ota_group, "Get registered OTA images successful:\n");

            if(!ImageDataCount)
               QCLI_Printf(ota_group, "   No images found.\n");

            /* If this image was dynamically allocated, then find it    */
            /* and clean up the allocations.                            */
            for(Index = 0; Index < ImageDataCount; Index++)
            {
               QCLI_Printf(ota_group, "   Image ID %d:\n", ImageData[Index].ImageID);
               QCLI_Printf(ota_group, "     File Name:      %s\n", ImageData[Index].FileName);
               QCLI_Printf(ota_group, "     Version:        %d\n", ImageData[Index].Version);
               QCLI_Printf(ota_group, "     Image Length:   %d\n", ImageData[Index].ImageLength);
            }
         }
         else
            QCLI_Printf(ota_group, "OTA get registered images failed, %d.\n", Result);

         /* Free the image data buffer.                                 */
         free(ImageData);
      }
      else
         QCLI_Printf(ota_group, "Failed to allocate image list.\n");
   }
   else
      QCLI_Printf(ota_group, "Service not registered.\n");

   return(ret_val);
}

   /* Discovers an OTA server on a remote device.                       */
static QCLI_Command_Status_t DiscoverOTA(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   qapi_BLE_BD_ADDR_t     BD_ADDR;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;
   DeviceInfo_t          *DeviceInfo;

   /* Make sure the client is initialized.                              */
   if(!OTAClientInitialized)
   {
      if(BLE_OTA_Initialize_Client(BluetoothStackID) == 0)
         OTAClientInitialized = TRUE;
   }

   if(OTAClientInitialized)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_Count >= 1) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
      {
         /* Convert the parameter to a Bluetooth Device Address.        */
         StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

         /* Get the device info for the connection device.              */
         if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
         {
            /* Discover the OTA service.                                */
            Result = BLE_OTA_Discover_OTA_Service(BluetoothStackID, DeviceInfo->ConnectionID);

            if(Result == BLE_OTA_STATUS_SUCCESS)
               QCLI_Printf(ota_group, "OTA service discovered successfully on device %s.\n", Parameter_List[0].String_Value);
            else
               QCLI_Printf(ota_group, "OTA service discovery failure on device %s, result %d.\n", Parameter_List[0].String_Value, Result);
         }
         else
            QCLI_Printf(ota_group, "Unable to find device info for %d.\n", BD_ADDR);
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      QCLI_Printf(ota_group, "Unable to initialize OTA client.\n");

   return(ret_val);
}

   /* Queries for an updated image on a remote OTA service.             */
static QCLI_Command_Status_t QueryOTAImage(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   qapi_BLE_BD_ADDR_t     BD_ADDR;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;
   uint32_t               ImageLength;
   uint32_t               ImageID;
   uint32_t               Version;
   DeviceInfo_t          *DeviceInfo;

   /* Make sure the client is initialized.                              */
   if(!OTAClientInitialized)
   {
      if(BLE_OTA_Initialize_Client(BluetoothStackID) == 0)
         OTAClientInitialized = TRUE;
   }

   if(OTAClientInitialized)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_Count >= 3) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[2].Integer_Is_Valid))
      {
         /* Convert the parameter to a Bluetooth Device Address.        */
         StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

         if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
         {
            Version = Parameter_List[2].Integer_Value;

            /* Query for a new OTA image.                               */
            Result = BLE_OTA_Query_Image(BluetoothStackID, DeviceInfo->ConnectionID, Parameter_List[1].String_Value, &Version, &ImageLength, &ImageID);

            if(Result == BLE_OTA_STATUS_SUCCESS)
               QCLI_Printf(ota_group, "OTA image queried successfully on device %s, image ID %d, version %d, length %d.\n", Parameter_List[0].String_Value, ImageID, Version, ImageLength);
            else
               QCLI_Printf(ota_group, "OTA image query failure on device %s, result %d.\n", Parameter_List[0].String_Value, Result);
         }
         else
            QCLI_Printf(ota_group, "Device info not found for %s.\n", BD_ADDR);
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      QCLI_Printf(ota_group, "Unable to initialize OTA client.\n");

   return(ret_val);
}

   /* Reads data from an OTA image.                                     */
static QCLI_Command_Status_t ReadOTAImage(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   qapi_BLE_BD_ADDR_t     BD_ADDR;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;
   uint32_t               ImageID;
   uint32_t               DataLength;
   uint32_t               FileOffset;
   uint8_t               *DataBuffer;
   uint32_t               Index;
   DeviceInfo_t          *DeviceInfo;

   /* Make sure the client is initialized.                              */
   if(!OTAClientInitialized)
   {
      if(BLE_OTA_Initialize_Client(BluetoothStackID) == 0)
         OTAClientInitialized = TRUE;
   }

   if(OTAClientInitialized)
   {
      /* Verify that the input parameters are semi-valid.               */
      if((Parameter_Count >= 4) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && \
        (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[3].Integer_Is_Valid))
      {
         /* Convert the parameter to a Bluetooth Device Address.        */
         StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

         if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
         {
            ImageID    = Parameter_List[1].Integer_Value;
            DataLength = Parameter_List[2].Integer_Value;
            FileOffset = Parameter_List[3].Integer_Value;

            /* Allocate a buffer to hold the data.                      */
            DataBuffer = (uint8_t *)malloc(DataLength);

            if(DataBuffer)
            {
               /* Read the OTA image data.                              */
               Result = BLE_OTA_Read_Image_Data(BluetoothStackID, DeviceInfo->ConnectionID, ImageID, DataBuffer, &DataLength, FileOffset);

               if(Result == BLE_OTA_STATUS_SUCCESS)
               {
                  QCLI_Printf(ota_group, "OTA image read successfully on device %s, read: \n\n", Parameter_List[0].String_Value);
                  for(Index = 0; Index < DataLength; Index++)
                  {
                     QCLI_Printf(ota_group, "%02x ", DataBuffer[Index]);
                  }
               }
               else
                  QCLI_Printf(ota_group, "OTA image read failure on device %s, result %d.\n", Parameter_List[0].String_Value, Result);

               /* Free the buffer.                                      */
               free(DataBuffer);
            }
            else
               QCLI_Printf(ota_group, "Unable to allocate buffer length %d.\n", DataLength);
         }
         else
            QCLI_Printf(ota_group, "Device info not found for %s.\n", BD_ADDR);
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      QCLI_Printf(ota_group, "Unable to initialize OTA client.\n");

   return(ret_val);
}

   /* Gets the size of OTA images from flash and stores them in the     */
   /* OTA image data array.                                             */
static void PopulateDefaultOTAImageSizes(void)
{
   uint8_t                  Index;
   struct qapi_fs_stat_type FileStat;

   for(Index = 0; Index < sizeof(DefaultOTAServerImageData)/sizeof(BLE_OTA_Server_Image_Data_t); Index++)
   {
      /* Get the file size.                                             */
      if(DefaultOTAImageInfo[Index].FilePath)
      {
         if(qapi_Fs_Stat(DefaultOTAImageInfo[Index].FilePath, &FileStat) == QAPI_OK)
         {
            DefaultOTAServerImageData[Index].ImageLength = FileStat.st_size;
         }
         else
         {
            DefaultOTAServerImageData[Index].ImageLength = 0;
            QCLI_Printf(ota_group, "Could not find image '%s' in file system, setting length to 0.\n", DefaultOTAServerImageData[Index].FileName);
         }
      }
      else
      {
         DefaultOTAServerImageData[Index].ImageLength = 0;
         QCLI_Printf(ota_group, "Could not find unnamed image in file system, setting length to 0.\n", DefaultOTAServerImageData[Index].FileName);
      }
   }
}

   /* 6LoWPAN (SLoWP) QCLI command functions.                           */

   /* The following function is responsible for registering the SLoWP   */
   /* Node Role.  This function will return zero on successful execution*/
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t RegisterSLoWPNode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                    Result;
   QCLI_Command_Status_t                  ret_val;
   qapi_BLE_L2CA_Queueing_Parameters_t    QueueingParameters;
   qapi_BLE_L2CA_LE_Channel_Parameters_t  ChannelParameters;
   qapi_BLE_GATT_Attribute_Handle_Group_t HandleRange;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that the Node Role is not already registered.           */
      if(!SLoWPNodeInitialized)
      {
         /* Configure the default channel parameters.                   */
         ChannelParameters.ChannelFlags   = SLoWP_CHANNEL_PARAMETERS_FLAGS;
         ChannelParameters.MaxSDUSize     = SLoWP_CHANNEL_PARAMETERS_MAX_SDU_SIZE;
         ChannelParameters.MaxPDUSize     = SLoWP_CHANNEL_PARAMETERS_MAX_PDU_SIZE;
         ChannelParameters.PDUQueueDepth  = SLoWP_CHANNEL_PARAMETERS_PDU_QUEUE_DEPTH;
         ChannelParameters.MaximumCredits = SLoWP_CHANNEL_PARAMETERS_MAX_CREDITS;

         /* Configure the default queuing parameters.                   */
         QueueingParameters.Flags         = SLoWP_QP_DATA_PACKET_QUEUEING_FLAGS;
         QueueingParameters.QueueLimit    = SLoWP_QP_MAXIMUM_NUMBER_QUEUED_DATA_PACKETS;
         QueueingParameters.LowThreshold  = SLoWP_QP_QUEUED_DATA_PACKETS_THRESHOLD;

         /* Register the SLoWP Node Role.                               */
         Result = qapi_BLE_SLoWP_Initialize_Node(BluetoothStackID, &ChannelParameters, &QueueingParameters, SLoWP_EventCallback, 0, &HandleRange);
         if(!Result)
         {
            /* Display success message.                                 */
            QCLI_Printf(slowp_group, "Successfully registered SLoWP Node Role: Handle Range 0x%04X - 0x%04X.\n", HandleRange.Starting_Handle, HandleRange.Ending_Handle);

            /* Flag that the node role is initialized successfully..    */
            SLoWPNodeInitialized = TRUE;

            /* Return success to the caller.                            */
            ret_val              = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            QCLI_Printf(slowp_group, "Error - qapi_BLE_SLoWP_Initialize_Node() returned %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(slowp_group, "SLoWP Node Role already registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(slowp_group, "BLE connection(s) currently active.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for un-registering the SLoWP*/
   /* Node Role.  This function will return zero on successful execution*/
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t UnregisterSLoWPNode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that the Node Role is already registered.               */
      if(SLoWPNodeInitialized)
      {
         /* Un-Register the SLoWP Node Role.                            */
         qapi_BLE_SLoWP_Cleanup_Node(BluetoothStackID);

         /* Display success message.                                    */
         QCLI_Printf(slowp_group, "Successfully un-registered SLoWP Node Role.\n");

         /* Flag that the node role is not initialized.                 */
         SLoWPNodeInitialized = FALSE;

         /* Return success to the caller.                               */
         ret_val              = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         QCLI_Printf(slowp_group, "SLoWP Node Role is not registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(slowp_group, "BLE connection(s) currently active.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for opening a SLoWP Node.   */
   /* This function will return zero on successful execution and a      */
   /* negative value on errors.                                         */
static QCLI_Command_Status_t ConnectSLoWPNode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t                  ret_val            = QCLI_STATUS_SUCCESS_E;
   int                                    Result;
   qapi_BLE_L2CA_Queueing_Parameters_t    QueueingParameters;
   qapi_BLE_L2CA_LE_Channel_Parameters_t  ChannelParameters;
   DeviceInfo_t                          *DeviceInfo;
   boolean_t                              ManualCreditMode;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_Count == 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 1))
   {
      /* Store the parameter.                                           */
      ManualCreditMode = (boolean_t)Parameter_List[0].Integer_Value;

      /* Verify that there is an ctive connection.                      */
      if(ConnectionCount)
      {
         /* Get the device information.                                 */
         if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
         {
            /* Set the applications channel parameters for the Node.    */
            /* * NOTE * If we want to manually control credits for the  */
            /*          channel then we will flag/unflag it here.       */
            if(!ManualCreditMode)
            {
               ChannelParameters.ChannelFlags = SLoWP_CHANNEL_PARAMETERS_FLAGS;
            }
            else
            {
               ChannelParameters.ChannelFlags = QAPI_BLE_L2CA_LE_CHANNEL_PARAMETER_FLAGS_MANUAL_CREDIT_MODE;
            }

            /* Configure the default channel parameters.                */
            ChannelParameters.MaxSDUSize     = SLoWP_CHANNEL_PARAMETERS_MAX_SDU_SIZE;
            ChannelParameters.MaxPDUSize     = SLoWP_CHANNEL_PARAMETERS_MAX_PDU_SIZE;
            ChannelParameters.PDUQueueDepth  = SLoWP_CHANNEL_PARAMETERS_PDU_QUEUE_DEPTH;
            ChannelParameters.MaximumCredits = SLoWP_CHANNEL_PARAMETERS_MAX_CREDITS;

            /* Configure the default queuing parameters.                */
            QueueingParameters.Flags         = SLoWP_QP_DATA_PACKET_QUEUEING_FLAGS;
            QueueingParameters.QueueLimit    = SLoWP_QP_MAXIMUM_NUMBER_QUEUED_DATA_PACKETS;
            QueueingParameters.LowThreshold  = SLoWP_QP_QUEUED_DATA_PACKETS_THRESHOLD;

            /* Connect to the SLoWP Node.                               */
            /* * NOTE * We can be registered as an SLoWP Node, but if we*/
            /*          call this API will be acting as a SLoWP Router  */
            /*          and connecting to another Node.                 */
            Result = qapi_BLE_SLoWP_Connect_Remote_Node(BluetoothStackID, DeviceInfo->RemoteAddress, &ChannelParameters, &QueueingParameters, SLoWP_EventCallback, BluetoothStackID);
            if(!Result)
            {
               QCLI_Printf(slowp_group, "SLoWP connection request sent.\n");
            }
            else
               DisplayFunctionError("qapi_BLE_SLoWP_Connect_Remote_Node", Result);
         }
         else
            QCLI_Printf(slowp_group, "Unknown device.\n");
      }
      else
         QCLI_Printf(slowp_group, "No Connection Established.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for closing a SLoWP         */
   /* connection.  This function will return zero on successful         */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t DisconnectSLoWPRouter(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val;

   /* Verify that the Node Role is already registered.                  */
   if(SLoWPNodeInitialized)
   {
      /* Verify that we are connected to a router.                      */
      if(SLoWPConnected)
      {
         /* Attempt to close the connection.                            */
         Result = qapi_BLE_SLoWP_Close_Connection(BluetoothStackID, SLoWPRouterAddress);
         if(!Result)
         {
            QCLI_Printf(slowp_group, "SLoWP Connection closed.\n");

            SLoWPConnected = FALSE;

            ret_val        = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            QCLI_Printf(slowp_group, "Error - qapi_BLE_SLoWP_Close_Connection() returned %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(slowp_group, "SLoWP local node not connected to router.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(slowp_group, "SLoWP Node Role is not registered.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the connection  */
   /* mode for a SLoWP connection.                                      */
static QCLI_Command_Status_t SetSLoWPConnectionMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t                ret_val         = QCLI_STATUS_SUCCESS_E;
   int                                  Result;
   qapi_BLE_IPSP_Node_Connection_Mode_t ConnectionMode;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count == 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= QAPI_BLE_CM_AUTOMATIC_ACCEPT_E) && (Parameter_List[0].Integer_Value <= QAPI_BLE_CM_MANUAL_ACCEPT_E))
   {
      ConnectionMode = Parameter_List[0].Integer_Value;

      /* Verify that there is no active connection.                     */
      if(!ConnectionCount)
      {
         /* Verify that the Node Role is already registered.            */
         if(SLoWPNodeInitialized)
         {
            if((Result = qapi_BLE_SLoWP_Set_Node_Connection_Mode(BluetoothStackID, ConnectionMode)) != 0)
               DisplayFunctionError("qapi_BLE_SLoWP_Set_Node_Connection_Mode", Result);
         }
         else
            QCLI_Printf(slowp_group, "SLoWP Node Role is not registered.\n");
      }
      else
         QCLI_Printf(slowp_group, "SLoWP local node connected to router.\n");
   }
   else

      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for querying the connection */
   /* mode for a SLoWP connection.                                      */
static QCLI_Command_Status_t GetSLoWPConnectionMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t                ret_val         = QCLI_STATUS_SUCCESS_E;
   int                                  Result;
   qapi_BLE_IPSP_Node_Connection_Mode_t ConnectionMode;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that the Node Role is already registered.               */
      if(SLoWPNodeInitialized)
      {
         if((Result = qapi_BLE_SLoWP_Get_Node_Connection_Mode(BluetoothStackID, &ConnectionMode)) == 0)
         {
            QCLI_Printf(slowp_group, "The Node's connection mode is: %s.\n", ((ConnectionMode == QAPI_BLE_CM_AUTOMATIC_ACCEPT_E) ? "Automatic accept" : ((ConnectionMode == QAPI_BLE_CM_AUTOMATIC_REJECT_E) ? "Automatic Reject" : "Manual accept")));
         }
         else
            DisplayFunctionError("qapi_BLE_SLoWP_Get_Node_Connection_Mode", Result);
      }
      else
         QCLI_Printf(slowp_group, "SLoWP Node Role is not registered.\n");
   }
   else
      QCLI_Printf(slowp_group, "SLoWP local node connected to router.\n");

   return(ret_val);
}

   /* Scan Parameter Service (SCPS) QCLI command functions.             */

   /* The following function is responsible for registering a SCPS      */
   /* Service.  This function will return zero on successful execution  */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t RegisterSCPS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   uint32_t              ServiceID;
   QCLI_Command_Status_t ret_val;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that the Service is not already registered.             */
      if(!SCPSInstanceID)
      {
         /* Register the SCPS Service with GATT.                        */
         Result = qapi_BLE_SCPS_Initialize_Service(BluetoothStackID, SCPS_EventCallback, 0, &ServiceID);
         if(Result > 0)
         {
            /* Display success message.                                 */
            QCLI_Printf(scps_group, "Successfully registered SCPS Service, InstanceID = %u.\n", Result);

            /* Save the ServiceID of the registered service.            */
            SCPSInstanceID = (unsigned int)Result;

            /* Return success to the caller.                            */
            ret_val        = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            QCLI_Printf(scps_group, "Error - qapi_BLE_SCPS_Initialize_Service() returned %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(scps_group, "SCPS Service already registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(scps_group, "BLE connection(s) currently active.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for unregistering a SCPS    */
   /* Service.  This function will return zero on successful execution  */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t UnregisterSCPS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                   Result;
   QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that a service is registered.                           */
      if(SCPSInstanceID)
      {
         /* Unregister the SCPS Service with GATT.                      */
         Result = qapi_BLE_SCPS_Cleanup_Service(BluetoothStackID, SCPSInstanceID);
         if(Result == 0)
         {
            /* Display success message.                                 */
            QCLI_Printf(scps_group, "Successfully unregistered SCPS Service.\n");

            /* Clear the ServiceID of the registered service.           */
            SCPSInstanceID = 0;

            /* Return success to the caller.                            */
            ret_val        = QCLI_STATUS_SUCCESS_E;
         }
         else
            DisplayFunctionError("qapi_BLE_SCPS_Cleanup_Service", Result);
      }
      else
         QCLI_Printf(scps_group, "SCPS Service not registered.\n");
   }
   else
      QCLI_Printf(scps_group, "BLE connection(s) currently active.\n");

   return(ret_val);
}

   /* The following function is responsible for configure a SCPS Service*/
   /* on a remote device.  This function will return zero on successful */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ConfigureRemoteSCPS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid))
   {
      /* Verify that we are not configured as a server                  */
      if(!SCPSInstanceID)
      {
         /* Verify that there is a connection that is established.      */
         if(ConnectionCount)
         {
            /* Lock the Bluetooth stack.                                */
            if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
            {
               /* Get the device info for the connection device.        */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
               {
                  QCLI_Printf(scps_group, "Attempting to configure CCCDs...\n");

                  /* Initialize the result to 0.                        */
                  Result = 0;

                  /* Determine if Scan Refresh CC is supported (only if */
                  /* Scan Refresh characteristic is supported(optional))*/
                  if(DeviceInfo->SCPSClientInfo.Scan_Refresh)
                  {
                     /* Make sure a CCCD has been discovered for the    */
                     /* remote device's Scan Refresh characteristic.    */
                     if(DeviceInfo->SCPSClientInfo.Scan_Refresh_Client_Configuration)
                        Result = EnableDisableNotificationsIndications(DeviceInfo->SCPSClientInfo.Scan_Refresh_Client_Configuration, (Parameter_List[0].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_SCPS);
                     else
                        QCLI_Printf(scps_group, "   Error - Scan Refresh CC not found on this device.\n");
                  }
                  else
                     QCLI_Printf(scps_group, "   Error - Scan Refresh Characteristics not supported.\n");

                  /* Check for CC Configuration success                 */
                  if(Result > 0)
                  {
                     QCLI_Printf(scps_group, "CCCD Configuration Success.\n");

                     ret_val = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                  {
                     /* CC Configuration failed, check to see if it was */
                     /* from a call to                                  */
                     /* EnableDisableNotificationsIndications           */
                     if(Result < 0)
                        DisplayFunctionError("EnableDisableNotificationsIndications", Result);
                  }
               }
               else
                  QCLI_Printf(scps_group, "No Device Info.\n");

               /* Un-lock the Bluetooth Stack.                          */
               qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
            }
            else
               QCLI_Printf(scps_group, "Unable to acquire Bluetooth Stack Lock.\n");
         }
         else
            QCLI_Printf(scps_group, "No Connection Established.\n");
      }
      else
         QCLI_Printf(scps_group, "Cannot configure remote SCPS Services when registered as a service.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for writing the Scan        */
   /* Interval Window to connected remote device. It can be executed    */
   /* only by a client. This function will return zero on successful    */
   /* execution and a negative value on errors                          */
static QCLI_Command_Status_t SetScanIntervalWindow(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                        Result;
   uint8_t                                    Buffer[QAPI_BLE_SCPS_SCAN_INTERVAL_WINDOW_SIZE];
   DeviceInfo_t                              *DeviceInfo;
   QCLI_Command_Status_t                      ret_val = QCLI_STATUS_ERROR_E;
   qapi_BLE_SCPS_Scan_Interval_Window_Data_t  ScanIntervalWindow;

   /* Verify that the input parameters are semi-valid.                  */
   if((Parameter_List) && (Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid))
   {
      /* Set the scan interval/window.                                  */
      ScanIntervalWindow.LE_Scan_Interval = (uint16_t)Parameter_List[0].Integer_Value;
      ScanIntervalWindow.LE_Scan_Window   = (uint16_t)Parameter_List[1].Integer_Value;

      /* Verify that we are not configured as a server                  */
      if(!SCPSInstanceID)
      {
         /* Verify that there is a valid connection                     */
         if(ConnectionCount)
         {
            /* Lock the Bluetooth stack.                                */
            if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
            {
               /* Get the device info for the connection device.        */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
               {
                  /* Verify that the client has received a valid Scan   */
                  /* Interval Window Attribute Handle.                  */
                  if(DeviceInfo->SCPSClientInfo.Scan_Interval_Window != 0)
                  {
                     /* Format the command                              */
                     if((Result = qapi_BLE_SCPS_Format_Scan_Interval_Window(&ScanIntervalWindow, QAPI_BLE_SCPS_SCAN_INTERVAL_WINDOW_SIZE, Buffer)) == 0)
                     {
                        /* Finally, submit a write without response     */
                        /* request to the server.                       */
                        if((Result = qapi_BLE_GATT_Write_Without_Response_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->SCPSClientInfo.Scan_Interval_Window, QAPI_BLE_SCPS_SCAN_INTERVAL_WINDOW_SIZE, ((void *)Buffer))) > 0)
                        {
                           QCLI_Printf(scps_group, "Number of Bytes written: %d", Result);

                           ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                           DisplayFunctionError("qapi_BLE_GATT_Write_Without_Response_Request", Result);
                     }
                     else
                        DisplayFunctionError("qapi_BLE_SCPS_Format_Scan_Interval_Window", Result);
                  }
                  else
                     QCLI_Printf(scps_group, "Error - Scan Interval Window not supported on remote service!\n");
               }
               else
                  QCLI_Printf(scps_group, "Error getting device info.\n");

               /* Un-lock the Bluetooth Stack.                          */
               qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
            }
            else
               QCLI_Printf(scps_group, "Unable to acquire Bluetooth Stack Lock.\n");
         }
         else
            QCLI_Printf(scps_group, "Connection is not established.\n");
      }
      else
         QCLI_Printf(scps_group, "Cannot Set Scan Interval Window when registered as a service.\n");
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for performing a Scan       */
   /* Refresh Notification to a connected remote device. It can be      */
   /* executed only by a server. This function will return zero on      */
   /* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t NotifyScanRefresh(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                    Result;
   uint8_t                ScanRefreshValue;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

   /* Verify that we have an open server and a connection.              */
   if(SCPSInstanceID)
   {
      /* Verify that there is an active connection.                     */
      if(ConnectionCount)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Find the device information for the selected connected   */
            /* BLE remote device.                                       */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
               /* Verify that the client has registered for             */
               /* notifications.                                        */
               if(DeviceInfo->SCPSServerInfo.Scan_Refresh_Client_Configuration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
               {
                  /* Initialize Scan Refresh Value                      */
                  ScanRefreshValue = QAPI_BLE_SCPS_SCAN_REFRESH_VALUE_SERVER_REQUIRES_REFRESH;

                  /* Go ahead and send the Scan Refresh Value data.     */
                  if((Result = qapi_BLE_SCPS_Notify_Scan_Refresh(BluetoothStackID, SCPSInstanceID, DeviceInfo->ConnectionID, ScanRefreshValue)) == 0)
                  {
                     QCLI_Printf(scps_group, "Scan Refresh Notification success.\n");

                     ret_val = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                     DisplayFunctionError("qapi_BLE_SCPS_Notify_Scan_Refresh", Result);
               }
               else
               {
                  QCLI_Printf(scps_group, "Client has not registered for Scan Refresh notifications.\n");

                  ret_val = QCLI_STATUS_SUCCESS_E;
               }
            }
            else
               QCLI_Printf(scps_group, "Error - Unknown Client.\n");

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
            QCLI_Printf(scps_group, "Unable to acquire Bluetooth Stack Lock.\n");
      }
      else
         QCLI_Printf(scps_group, "Connection not established.\n");
   }
   else
   {
      if(ConnectionCount)
         QCLI_Printf(scps_group, "Error - Only a server can notify.\n");
      else
         QCLI_Printf(scps_group, "Error - SCPS server not registered\n");
   }

   return(ret_val);
}

   /* Scan Parameter Service (SCPS) helper functions.                   */

   /* The following function is a utility function that provides a      */
   /* mechanism of populating a SCPS Client Information structure with  */
   /* the information discovered from a GATT Discovery operation.       */
static void SCPSPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
   unsigned int                                           Index1;
   unsigned int                                           Index2;
   qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
   qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

   /* Verify that the input parameters are semi-valid.                  */
   if((DeviceInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_SCPS_COMPARE_SCPS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
   {
      /* Loop through all characteristics discovered in the service     */
      /* and populate the correct entry.                                */
      CurrentCharacteristic = ServiceDiscoveryData->CharacteristicInformationList;
      if(CurrentCharacteristic)
      {
         for(Index1 = 0; Index1 < ServiceDiscoveryData->NumberOfCharacteristics; Index1++, CurrentCharacteristic++)
         {
            if(QAPI_BLE_SCPS_COMPARE_SCAN_INTERVAL_WINDOW_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
            {
               /* All SCPS UUIDs are defined to be 16 bit UUIDs.        */
               if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                  DeviceInfo->SCPSClientInfo.Scan_Interval_Window = CurrentCharacteristic->Characteristic_Handle;
            }
            else
            {
               if(QAPI_BLE_SCPS_COMPARE_SCAN_REFRESH_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
               {
                  DeviceInfo->SCPSClientInfo.Scan_Refresh = CurrentCharacteristic->Characteristic_Handle;

                  /* Loop through the Descriptor List.                  */
                  CurrentDescriptor = CurrentCharacteristic->DescriptorList;
                  for(Index2 = 0; Index2 < CurrentCharacteristic->NumberOfDescriptors; Index2++)
                  {
                     if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                     {
                        if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_UUID.UUID.UUID_16))
                           DeviceInfo->SCPSClientInfo.Scan_Refresh_Client_Configuration = CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_Handle;
                     }
                  }
               }
            }
         }
      }
   }
}

   /* Serial Port over LE (SPPLE) QCLI command functions.               */

   /* The following function is responsible for registering a SPPLE     */
   /* Service.  This function will return zero on successful execution  */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t RegisterSPPLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   int                                    Result;
   QCLI_Command_Status_t                  ret_val;
   qapi_BLE_GATT_Attribute_Handle_Group_t ServiceHandleGroup;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that the Service is not already registered.             */
      if(!SPPLEServiceID)
      {
         /* Initialize the Service Handle Group to 0 since we do not    */
         /* require a specific location in the service table.           */
         ServiceHandleGroup.Starting_Handle = 0;
         ServiceHandleGroup.Ending_Handle   = 0;

         /* Register the SPPLE Service.                                 */
         Result = qapi_BLE_GATT_Register_Service(BluetoothStackID, SPPLE_SERVICE_FLAGS, SPPLE_SERVICE_ATTRIBUTE_COUNT, (qapi_BLE_GATT_Service_Attribute_Entry_t *)SPPLE_Service, &ServiceHandleGroup, GATT_ServerEventCallback_SPPLE, 0);
         if(Result > 0)
         {
            /* Display success message.                                 */
            QCLI_Printf(spple_group, "Successfully registered SPPLE Service, ServiceID = %u.\n", Result);

            /* Save the ServiceID of the registered service.            */
            SPPLEServiceID = (unsigned int)Result;

            /* Return success to the caller.                            */
            ret_val        = QCLI_STATUS_SUCCESS_E;
         }
         else
         {
            QCLI_Printf(spple_group, "Error - qapi_BLE_GATT_Register_Service() returned %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(spple_group, "SPPLE Service already registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(spple_group, "Connection currently active.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for unregistering a SPPLE   */
   /* Service.  This function will return zero on successful execution  */
   /* and a negative value on errors.                                   */
static QCLI_Command_Status_t UnregisterSPPLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* Verify that there is no active connection.                        */
   if(!ConnectionCount)
   {
      /* Verify that the Service is not already registered.             */
      if(SPPLEServiceID)
      {
         /* Un-registered SPP LE Service.                               */
         qapi_BLE_GATT_Un_Register_Service(BluetoothStackID, SPPLEServiceID);

         /* Display success message.                                    */
         QCLI_Printf(spple_group, "Successfully unregistered SPPLE Service.\n");

         /* Save the ServiceID of the registered service.               */
         SPPLEServiceID = 0;

         /* Return success to the caller.                               */
         ret_val        = QCLI_STATUS_SUCCESS_E;
      }
      else
      {
         QCLI_Printf(spple_group, "SPPLE Service not registered.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(spple_group, "Connection currently active.\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for configure a SPPLE       */
   /* Service on a remote device.  This function will return zero on    */
   /* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t ConfigureSPPLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val;

   /* Verify that there is a connection that is established.            */
   if(ConnectionCount)
   {
      /* Lock the Bluetooth stack.                                      */
      if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
      {
         /* Get the device info for the connection device.              */
         if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
         {
            /* Verify that we are not already acting as a Server.       */
            if(!(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_SERVER))
            {
               /* Determine if a service discovery operation has been   */
               /* previously done.                                      */
               if(SPPLE_CLIENT_INFORMATION_VALID(DeviceInfo->ClientInfo))
               {
                  QCLI_Printf(spple_group, "SPPLE Service found on remote device, attempting to read Transmit Credits, and configured CCCDs.\n");

                  /* Send the Initial Credits to the remote device.     */
                  SendCredits(DeviceInfo, DeviceInfo->ReceiveBuffer.BytesFree);

                  /* Enable Notifications on the proper characteristics.*/
                  EnableDisableNotificationsIndications(DeviceInfo->ClientInfo.Rx_Credit_Client_Configuration_Descriptor, QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE, DeviceInfo->ConnectionID, GATT_ClientEventCallback_SPPLE);
                  EnableDisableNotificationsIndications(DeviceInfo->ClientInfo.Tx_Client_Configuration_Descriptor, QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE, DeviceInfo->ConnectionID, GATT_ClientEventCallback_SPPLE);

                  /* Flag that we are an SPPLE Client.                  */
                  DeviceInfo->Flags |= DEVICE_INFO_FLAGS_SPPLE_CLIENT;

                  ret_val            = QCLI_STATUS_SUCCESS_E;
               }
               else
               {
                  QCLI_Printf(spple_group, "No SPPLE Service discovered on device.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(spple_group, "Already operating as a Server\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(spple_group, "No Device Info.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }

         /* Un-lock the Bluetooth Stack.                                */
         qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
      }
      else
      {
         QCLI_Printf(spple_group, "Unable to acquire Bluetooth Stack Lock.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(spple_group, "No Connection Established\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for sending a number of     */
   /* characters to a remote device to which a connection exists.  The  */
   /* function receives a parameter that indicates the number of byte to*/
   /* be transferred.  This function will return zero on successful     */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t SendDataCommand(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val;

   /* Make sure that all of the parameters required for this function   */
   /* appear to be at least semi-valid.                                 */
   if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value > 0))
   {
      /* Verify that there is a connection that is established.         */
      if(ConnectionCount)
      {
         /* Lock the Bluetooth stack.                                   */
         if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
         {
            /* Check to see if we are sending to another port.          */
            if(!SendInfo.BytesToSend)
            {
               /* Get the device info for the connection device.        */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
               {
                  /* Verify that we are a Client or Server.             */
                  if(DeviceInfo->Flags & (DEVICE_INFO_FLAGS_SPPLE_CLIENT | DEVICE_INFO_FLAGS_SPPLE_SERVER))
                  {
                     /* Get the count of the number of bytes to send.   */
                     SendInfo.BytesToSend  = (uint32_t)Parameter_List[0].Integer_Value;
                     SendInfo.BytesSent    = 0;

                     /* Kick start the send process.                    */
                     SendProcess(DeviceInfo);

                     ret_val = QCLI_STATUS_SUCCESS_E;
                  }
                  else
                  {
                     QCLI_Printf(spple_group, "SPPLE has not been configured\n");

                     ret_val = QCLI_STATUS_ERROR_E;
                  }
               }
               else
               {
                  QCLI_Printf(spple_group, "No Device Info.\n");

                  ret_val = QCLI_STATUS_ERROR_E;
               }
            }
            else
            {
               QCLI_Printf(spple_group, "Send Currently in progress.\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }

            /* Un-lock the Bluetooth Stack.                             */
            qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
         }
         else
         {
            QCLI_Printf(spple_group, "Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }
      }
      else
      {
         QCLI_Printf(spple_group, "No Connection Established\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_USAGE_E;

   return(ret_val);
}

   /* The following function is responsible for reading data sent by a  */
   /* remote device to which a connection exists.  This function will   */
   /* return zero on successful execution and a negative value on       */
   /* errors.                                                           */
static QCLI_Command_Status_t ReadDataCommand(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   uint8_t               *Ptr;
   boolean_t              Done;
   unsigned int           Temp;
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val;

   /* Verify that there is a connection that is established.            */
   if(ConnectionCount)
   {
      /* Lock the Bluetooth stack.                                      */
      if(!qapi_BLE_BSC_LockBluetoothStack(BluetoothStackID))
      {
         /* Get the device info for the connection device.              */
         if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
         {
            /* Verify that we are a Client or Server.                   */
            if(DeviceInfo->Flags & (DEVICE_INFO_FLAGS_SPPLE_CLIENT | DEVICE_INFO_FLAGS_SPPLE_SERVER))
            {
               /* Determine the number of bytes we are going to read.   */
               Temp = DeviceInfo->ReceiveBuffer.BufferSize - DeviceInfo->ReceiveBuffer.BytesFree;

               QCLI_Printf(spple_group, "Read: %u bytes.\n", Temp);
               QCLI_Printf(spple_group, "Read: Data: ");

               /* Loop and read all of the data.                        */
               Done = FALSE;
               while(!Done)
               {
                  /* Read the data.                                     */
                  Temp = ReadData(DeviceInfo, SPPLE_DATA_BUFFER_LENGTH, SPPLEBuffer);
                  if(Temp > 0)
                  {
                     /* Display the data.                               */
                     Ptr = SPPLEBuffer;

                     while(Temp > 0)
                     {
                        QCLI_Printf(spple_group, "0x%02X ", *Ptr);
                        Ptr++;
                        Temp--;
                     }
                  }
                  else
                     Done = TRUE;
               }

               QCLI_Printf(spple_group, "\n");

               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
               QCLI_Printf(spple_group, "SPPLE has not been configured\n");

               ret_val = QCLI_STATUS_ERROR_E;
            }
         }
         else
         {
            QCLI_Printf(spple_group, "No Device Info.\n");

            ret_val = QCLI_STATUS_ERROR_E;
         }

         /* Un-lock the Bluetooth Stack.                                */
         qapi_BLE_BSC_UnLockBluetoothStack(BluetoothStackID);
      }
      else
      {
         QCLI_Printf(spple_group, "Unable to acquire Bluetooth Stack Lock.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
   {
      QCLI_Printf(spple_group, "No Connection Established\n");

      ret_val = QCLI_STATUS_ERROR_E;
   }

   return(ret_val);
}

   /* The following function is responsible for setting the application */
   /* state to support loopback mode.  This function will return zero on*/
   /* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t Loopback(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if(BluetoothStackID)
   {
      /* Next check to see if the parameters required for the execution */
      /* of this function appear to be semi-valid.                      */
      if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
      {
         /* Set the Loopback Active field.                              */
         if(Parameter_List[0].Integer_Value)
            LoopbackActive = TRUE;
         else
            LoopbackActive = FALSE;

         /* Finally output the current Loopback state.                  */
         QCLI_Printf(spple_group, "Current Loopback Mode set to: %s.\n", LoopbackActive?"ACTIVE":"INACTIVE");

         /* Flag success.                                               */
         ret_val = QCLI_STATUS_SUCCESS_E;
      }
      else
         ret_val = QCLI_STATUS_USAGE_E;
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for setting the application */
   /* state to support displaying Raw Data.  This function will return  */
   /* zero on successful execution and a negative value on errors.      */
static QCLI_Command_Status_t DisplayRawModeData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if(BluetoothStackID)
   {
      /* Check to see if Loopback is active.  If it is then we will not */
      /* process this command (and we will inform the user).            */
      if(!LoopbackActive)
      {
         /* Next check to see if the parameters required for the        */
         /* execution of this function appear to be semi-valid.         */
         if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
         {
            /* Set the Display Raw Data flag.                           */
            if(Parameter_List[0].Integer_Value)
               DisplayRawData = TRUE;
            else
               DisplayRawData = FALSE;

            /* Output the current Raw Data Display Mode state.          */
            QCLI_Printf(spple_group, "Current Raw Data Display Mode set to: %s.\n", DisplayRawData?"ACTIVE":"INACTIVE");

            /* Flag that the function was successful.                   */
            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
      else
      {
         QCLI_Printf(spple_group, "Unable to process Raw Mode Display Request when operating in Loopback Mode.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for setting the application */
   /* state to support Automatically reading all data that is received  */
   /* through SPP.  This function will return zero on successful        */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t AutomaticReadMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   QCLI_Command_Status_t ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if(BluetoothStackID)
   {
      /* Check to see if Loopback is active.  If it is then we will not */
      /* process this command (and we will inform the user).            */
      if(!LoopbackActive)
      {
         /* Next check to see if the parameters required for the        */
         /* execution of this function appear to be semi-valid.         */
         if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
         {
            /* Set the Automatic Read Active flag flag.                 */
            if(Parameter_List[0].Integer_Value)
               AutomaticReadActive = TRUE;
            else
               AutomaticReadActive = FALSE;

            /* Output the current Automatic Read Mode state.            */
            QCLI_Printf(spple_group, "Current Automatic Read Mode set to: %s.\n", AutomaticReadActive?"ACTIVE":"INACTIVE");

            /* Flag that the function was successful.                   */
            ret_val = QCLI_STATUS_SUCCESS_E;
         }
         else
            ret_val = QCLI_STATUS_USAGE_E;
      }
      else
      {
         QCLI_Printf(spple_group, "Unable to process Automatic Read Mode Request when operating in Loopback Mode.\n");

         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for setting the application */
   /* state to support Automatically reading all data that is received  */
   /* through SPP.  This function will return zero on successful        */
   /* execution and a negative value on errors.                         */
static QCLI_Command_Status_t SetThroughputMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
   DeviceInfo_t          *DeviceInfo;
   QCLI_Command_Status_t  ret_val;

   /* First check to see if the parameters required for the execution of*/
   /* this function appear to be semi-valid.                            */
   if (BluetoothStackID)
   {
      if (ConnectionCount)
      {
         /* Get the device info for the connection device.              */
         if ((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
         {
            /* Next check to see if the parameters required for the     */
            /* execution of this function appear to be semi-valid.      */
            if ((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
            {
               /* Set the Throughput Mode flag.                         */
               if (Parameter_List[0].Integer_Value)
               {
                  DeviceInfo->ThroughputModeActive = TRUE;

                  /* Clear any previous transfer information.           */
                  memset(&DeviceInfo->XferInfo, 0, sizeof(XferInfo_t));
               }
               else
               {
                  DisplayThroughput(DeviceInfo);
                  DeviceInfo->ThroughputModeActive = FALSE;
               }

               /* Output the current Throughput Mode state.             */
               QCLI_Printf(spple_group, "\nCurrent Throughput Mode set to: %s.\n", DeviceInfo->ThroughputModeActive ? "ACTIVE" : "INACTIVE");

               /* Flag that the function was successful.                */
               ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
               ret_val = QCLI_STATUS_USAGE_E;
         }
         else
         {
            QCLI_Printf(spple_group, "Device info does not exist for selected remote device.\n");
            ret_val = QCLI_STATUS_USAGE_E;
         }
      }
      else
      {
         QCLI_Printf(spple_group, "Connection must exist in order to change Throughput Mode.\n");
         ret_val = QCLI_STATUS_ERROR_E;
      }
   }
   else
      ret_val = QCLI_STATUS_ERROR_E;

   return(ret_val);
}

   /* The following function is responsible for timing the throughput of*/
   /* an SPPLE Service.  This function will return zero on successful   */
   /* execution and a negative value on errors.                         */
static void DisplayThroughput(DeviceInfo_t *DeviceInfo)
{
   char        DiffTime[16];
   uint64_t    Throughput;
   uint64_t    Diff;
   BoardStr_t  BoardStr;
   XferInfo_t *XferInfo;

   if(DeviceInfo->ThroughputModeActive)
   {
      BD_ADDRToStr(SelectedRemoteBD_ADDR, BoardStr);

      XferInfo = &DeviceInfo->XferInfo;

      Diff = XferInfo->LastTime - XferInfo->FirstTime;
      if (Diff)
      {
         /* Get bits per second.                                        */
         Throughput = (XferInfo->RxCount * 8) / Diff;

         /* Convert the difference to a string in HH:MM:SS format.      */
         SecondsToString((Diff), sizeof(DiffTime), DiffTime);
         QCLI_Printf(spple_group, "Remote Device: %s\n", BoardStr);
         QCLI_Printf(spple_group, "   Throughput: %d.", Throughput / 1000);
         QCLI_Printf(spple_group, "%03d Kbps\n", Throughput % 1000);
         QCLI_Printf(spple_group, "     Rx Bytes: %d\n", XferInfo->RxCount);
         QCLI_Printf(spple_group, " Elapsed Time: %s\n", DiffTime);
      }
      else
      {
         QCLI_Printf(spple_group, "Remote Device: %s\n", BoardStr);
         QCLI_Printf(spple_group, "   Throughput: Unknown\n");
         QCLI_Printf(spple_group, "     Rx Bytes: %d\n", XferInfo->RxCount);
         QCLI_Printf(spple_group, "         Diff: None\n");
      }
   }
}

   /* The following function is used to convert seconds into a string of*/
   /* the following formats: HH:MM:SS, MM:SS.                           */
static char *SecondsToString(uint32_t Seconds, uint8_t BufferLength, char *Buffer)
{
   char     *ret_val;
   uint32_t  Hours;
   uint32_t  Minutes;
   uint32_t  Offset;

   if ((BufferLength > 0) && (Buffer != NULL))
   {
      Hours = Seconds / (60 * 60);
      Minutes = (Seconds / 60) % 60;
      Seconds = Seconds % 60;

      /* Initialize the return value to the input buffer. This will be  */
      /* overwritten to NULL if there is an error.                      */
      ret_val = Buffer;

      /* Display the hours only if non-zero.                            */
      if (Hours != 0)
      {
         Offset = snprintf(Buffer, BufferLength, "%d:", (unsigned int)Hours);

         if ((Offset + 1) < BufferLength)
         {
            Buffer += Offset;
            BufferLength -= Offset;
         }
         else
            BufferLength = 0;
      }

      /* Display the minutes.                                           */
      if (BufferLength > 0)
      {
         /* Pad the minutes to two characters if hours are present.     */
         if (Hours != 0)
            Offset = snprintf(Buffer, BufferLength, "%02d:", (unsigned int)Minutes);
         else
            Offset = snprintf(Buffer, BufferLength, "%d:", (unsigned int)Minutes);

         if ((Offset + 1) < BufferLength)
         {
            Buffer += Offset;
            BufferLength -= Offset;

            /* Display the seconds.                                     */
            Offset = snprintf(Buffer, BufferLength, "%02d", (unsigned int)Seconds);

            if ((Offset + 1) >= BufferLength)
               ret_val = "";
         }
         else
            ret_val = "";
      }
      else
         ret_val = "";
   }
   else
      ret_val = "";

   return(ret_val);
}

   /* Serial Port over LE (SPPLE) helper functions.                     */

   /* The following function is a utility function that provides a      */
   /* mechanism of populating a BRSM Client Information structure with  */
   /* the information discovered from a GATT Discovery operation.       */
static void SPPLEPopulateHandles(SPPLE_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceInfo)
{
   uint16_t                                              *ClientConfigurationHandle;
   unsigned int                                           Index1;
   unsigned int                                           Index2;
   qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
   qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

   /* Verify that the input parameters are semi-valid.                  */
   if((ClientInfo) && (ServiceInfo) && (ServiceInfo->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_128_E) && (SPPLE_COMPARE_SPPLE_SERVICE_UUID_TO_UUID_128(ServiceInfo->ServiceInformation.UUID.UUID.UUID_128)))
   {
      /* Loop through all characteristics discovered in the service     */
      /* and populate the correct entry.                                */
      CurrentCharacteristic = ServiceInfo->CharacteristicInformationList;
      if(CurrentCharacteristic)
      {
         for(Index1=0;Index1<ServiceInfo->NumberOfCharacteristics;Index1++,CurrentCharacteristic++)
         {
            /* All SPPLE UUIDs are defined to be 128 bit UUIDs.         */
            if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_128_E)
            {
               ClientConfigurationHandle = NULL;

               /* Determine which characteristic this is.               */
               if(!SPPLE_COMPARE_SPPLE_TX_UUID_TO_UUID_128(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_128))
               {
                  if(!SPPLE_COMPARE_SPPLE_TX_CREDITS_UUID_TO_UUID_128(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_128))
                  {
                     if(!SPPLE_COMPARE_SPPLE_RX_UUID_TO_UUID_128(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_128))
                     {
                        if(!SPPLE_COMPARE_SPPLE_RX_CREDITS_UUID_TO_UUID_128(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_128))
                           continue;
                        else
                        {
                           ClientInfo->Rx_Credit_Characteristic = CurrentCharacteristic->Characteristic_Handle;
                           ClientConfigurationHandle            = &(ClientInfo->Rx_Credit_Client_Configuration_Descriptor);
                        }
                     }
                     else
                     {
                        ClientInfo->Rx_Characteristic = CurrentCharacteristic->Characteristic_Handle;
                        continue;
                     }
                  }
                  else
                  {
                     ClientInfo->Tx_Credit_Characteristic = CurrentCharacteristic->Characteristic_Handle;
                     continue;
                  }
               }
               else
               {
                  ClientInfo->Tx_Characteristic = CurrentCharacteristic->Characteristic_Handle;
                  ClientConfigurationHandle     = &(ClientInfo->Tx_Client_Configuration_Descriptor);
               }

               /* Loop through the Descriptor List.                     */
               CurrentDescriptor = CurrentCharacteristic->DescriptorList;
               if((CurrentDescriptor) && (ClientConfigurationHandle))
               {
                  for(Index2=0;Index2<CurrentCharacteristic->NumberOfDescriptors;Index2++,CurrentDescriptor++)
                  {
                     if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                     {
                        if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16))
                        {
                           *ClientConfigurationHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                           break;
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

   /* The following function is a utility function that is used to add  */
   /* data (using InIndex as the buffer index) from the buffer specified*/
   /* by the DataBuffer parameter.  The second and third parameters     */
   /* specified the length of the data to add and the pointer to the    */
   /* data to add to the buffer.  This function returns the actual      */
   /* number of bytes that were added to the buffer (or 0 if none were  */
   /* added).                                                           */
static unsigned int AddDataToBuffer(SPPLE_Data_Buffer_t *DataBuffer, unsigned int DataLength, uint8_t *Data)
{
   unsigned int BytesAdded = 0;
   unsigned int Count;

   /* Verify that the input parameters are valid.                       */
   if((DataBuffer) && (DataLength) && (Data))
   {
      /* Loop while we have data AND space in the buffer.               */
      while(DataLength)
      {
         /* Get the number of bytes that can be placed in the buffer    */
         /* until it wraps.                                             */
         Count = DataBuffer->BufferSize - DataBuffer->InIndex;

         /* Determine if the number of bytes free is less than the      */
         /* number of bytes till we wrap and choose the smaller of the  */
         /* numbers.                                                    */
         Count = (DataBuffer->BytesFree < Count)?DataBuffer->BytesFree:Count;

         /* Cap the Count that we add to buffer to the length of the    */
         /* data provided by the caller.                                */
         Count = (Count > DataLength)?DataLength:Count;

         if(Count)
         {
            /* Copy the data into the buffer.                           */
            memcpy(&DataBuffer->Buffer[DataBuffer->InIndex], Data, Count);

            /* Update the counts.                                       */
            DataBuffer->InIndex   += Count;
            DataBuffer->BytesFree -= Count;
            DataLength            -= Count;
            BytesAdded            += Count;
            Data                  += Count;

            /* Wrap the InIndex if necessary.                           */
            if(DataBuffer->InIndex >= DataBuffer->BufferSize)
               DataBuffer->InIndex = 0;
         }
         else
            break;
      }
   }

   return(BytesAdded);
}

   /* The following function is a utility function that is used to      */
   /* removed data (using OutIndex as the buffer index) from the buffer */
   /* specified by the DataBuffer parameter The second parameter        */
   /* specifies the length of the Buffer that is pointed to by the third*/
   /* parameter.  This function returns the actual number of bytes that */
   /* were removed from the DataBuffer (or 0 if none were added).       */
   /* * NOTE * Buffer is optional and if not specified up to            */
   /*          BufferLength bytes will be deleted from the Buffer.      */
static unsigned int RemoveDataFromBuffer(SPPLE_Data_Buffer_t *DataBuffer, unsigned int BufferLength, uint8_t *Buffer)
{
   unsigned int Count;
   unsigned int BytesRemoved = 0;
   unsigned int MaxRemove;

   /* Verify that the input parameters are valid.                       */
   if((DataBuffer) && (BufferLength))
   {
      /* Loop while we have data to remove and space in the buffer to   */
      /* place it.                                                      */
      while(BufferLength)
      {
         /* Determine the number of bytes that are present in the       */
         /* buffer.                                                     */
         Count = DataBuffer->BufferSize - DataBuffer->BytesFree;
         if(Count)
         {
            /* Calculate the maximum number of bytes that I can remove  */
            /* from the buffer before it wraps.                         */
            MaxRemove = DataBuffer->BufferSize - DataBuffer->OutIndex;

            /* Cap max we can remove at the BufferLength of the caller's*/
            /* buffer.                                                  */
            MaxRemove = (MaxRemove > BufferLength)?BufferLength:MaxRemove;

            /* Cap the number of bytes I will remove in this iteration  */
            /* at the maximum I can remove or the number of bytes that  */
            /* are in the buffer.                                       */
            Count = (Count > MaxRemove)?MaxRemove:Count;

            /* Copy the data into the caller's buffer (If specified).   */
            if(Buffer)
            {
               memcpy(Buffer, &DataBuffer->Buffer[DataBuffer->OutIndex], Count);
               Buffer += Count;
            }

            /* Update the counts.                                       */
            DataBuffer->OutIndex  += Count;
            DataBuffer->BytesFree += Count;
            BytesRemoved          += Count;
            BufferLength          -= Count;

            /* Wrap the OutIndex if necessary.                          */
            if(DataBuffer->OutIndex >= DataBuffer->BufferSize)
               DataBuffer->OutIndex = 0;
         }
         else
            break;
      }
   }

   return(BytesRemoved);
}

   /* The following function is used to initialize the specified buffer */
   /* to the defaults.                                                  */
static void InitializeBuffer(SPPLE_Data_Buffer_t *DataBuffer)
{
   /* Verify that the input parameters are valid.                       */
   if(DataBuffer)
   {
      DataBuffer->BufferSize = SPPLE_DATA_CREDITS;
      DataBuffer->BytesFree  = SPPLE_DATA_CREDITS;
      DataBuffer->InIndex    = 0;
      DataBuffer->OutIndex   = 0;
   }
}

   /* The following function is a utility function that exists to fill  */
   /* the specified buffer with the DataStr that is used to send data.  */
   /* This function will fill from the CurrentBufferLength up to Max    */
   /* Length in Buffer.  CurrentBufferLength is used to return the total*/
   /* length of the buffer.  The first parameter specifies the          */
   /* DeviceInfo which is used to fill any remainder of the string so   */
   /* that there are no breaks in the pattern.  This function returns   */
   /* the number of bytes added to the transmit buffer of the specified */
   /* device.                                                           */
static unsigned int FillBufferWithString(SPPLE_Data_Buffer_t *DataBuffer, unsigned *CurrentBufferLength, unsigned int MaxLength, uint8_t *Buffer)
{
   unsigned int DataCount;
   unsigned int Length;
   unsigned int Added2Buffer = 0;

   /* Verify that the input parameter is semi-valid.                    */
   if((DataBuffer) && (CurrentBufferLength) && (MaxLength) && (Buffer))
   {
      /* Copy as much of the DataStr into the Transmit buffer as is     */
      /* possible.                                                      */
      while(*CurrentBufferLength < MaxLength)
      {
         /* Cap the data to copy at the maximum of the string length and*/
         /* the remaining amount that can be placed in the buffer.      */
         DataCount = (DataStrLen > (MaxLength-*CurrentBufferLength))?(MaxLength-*CurrentBufferLength):DataStrLen;

         /* Build the data string into the SPPLEBuffer.                 */
         memcpy(&Buffer[*CurrentBufferLength], DataStr, DataCount);

         /* Increment the index.                                        */
         *CurrentBufferLength += DataCount;

         /* Add whatever bytes remaining in the DataStr into the        */
         /* transmit buffer to keep the pattern consistent.             */
         Length = DataStrLen-DataCount;
         if(Length)
         {
            /* Add the bytes remaining in the string.                   */
            Added2Buffer += AddDataToBuffer(DataBuffer, Length, (uint8_t *)&DataStr[DataCount]);
         }
      }
   }

   return(Added2Buffer);
}

   /* The following function is responsible for handling a Send Process.*/
static void SendProcess(DeviceInfo_t *DeviceInfo)
{
   int          Result;
   boolean_t    Done = FALSE;
   unsigned int TransmitIndex;
   unsigned int DataCount;
   unsigned int MaxLength;
   unsigned int SPPLEBufferLength;
   unsigned int Added2Buffer;

   /* Verify that the input parameter is semi-valid.                    */
   if(DeviceInfo)
   {
      /* Loop while we have data to send and we have not used up all    */
      /* Transmit Credits.                                              */
      TransmitIndex     = 0;
      SPPLEBufferLength = 0;
      Added2Buffer      = 0;
      while((SendInfo.BytesToSend) && (DeviceInfo->TransmitCredits) && (!Done))
      {
         /* Get the maximum length of what we can send in this          */
         /* transaction.                                                */
         MaxLength = (SendInfo.BytesToSend > DeviceInfo->TransmitCredits)?DeviceInfo->TransmitCredits:SendInfo.BytesToSend;
         MaxLength = (MaxLength > SPPLE_DATA_BUFFER_LENGTH)?SPPLE_DATA_BUFFER_LENGTH:MaxLength;

         /* If we do not have any outstanding data get some more data.  */
         if(!SPPLEBufferLength)
         {
            /* Send any buffered data first.                            */
            if(DeviceInfo->TransmitBuffer.BytesFree != DeviceInfo->TransmitBuffer.BufferSize)
            {
               /* Remove the queued data from the Transmit Buffer.      */
               SPPLEBufferLength = RemoveDataFromBuffer(&(DeviceInfo->TransmitBuffer), MaxLength, SPPLEBuffer);

               /* If we added some data to the transmit buffer decrement*/
               /* what we just removed.                                 */
               if(Added2Buffer)
                  Added2Buffer -= SPPLEBufferLength;
            }

            /* Fill up the rest of the buffer with the data string.     */
            Added2Buffer     += FillBufferWithString(&(DeviceInfo->TransmitBuffer), &SPPLEBufferLength, MaxLength, SPPLEBuffer);

            /* Set the count of data that we can send.                  */
            DataCount         = SPPLEBufferLength;

            /* Reset the Transmit Index to 0.                           */
            TransmitIndex     = 0;
         }
         else
         {
            /* Move the data that to the beginning of the buffer.       */
            memmove(SPPLEBuffer, &SPPLEBuffer[TransmitIndex], SPPLEBufferLength);

            /* Send any buffered data first.                            */
            if(DeviceInfo->TransmitBuffer.BytesFree != DeviceInfo->TransmitBuffer.BufferSize)
            {
               /* Remove the queued data from the Transmit Buffer.      */
               TransmitIndex = RemoveDataFromBuffer(&(DeviceInfo->TransmitBuffer), MaxLength-SPPLEBufferLength, &SPPLEBuffer[SPPLEBufferLength]);

               /* If we added some data to the transmit buffer decrement*/
               /* what we just removed.                                 */
               if(Added2Buffer)
                  Added2Buffer -= TransmitIndex;

               /* Increment the buffer length.                          */
               SPPLEBufferLength += TransmitIndex;
            }

            /* Reset the Transmit Index to 0.                           */
            TransmitIndex     = 0;

            /* Fill up the rest of the buffer with the data string.     */
            Added2Buffer += FillBufferWithString(&(DeviceInfo->TransmitBuffer), &SPPLEBufferLength, MaxLength, SPPLEBuffer);

            /* We have data to send so cap it at the maximum that can be*/
            /* transmitted.                                             */
            DataCount     = (SPPLEBufferLength > MaxLength)?MaxLength:SPPLEBufferLength;
         }

         /* Use the correct API based on device role for SPPLE.         */
         if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_SERVER)
         {
            /* We are acting as SPPLE Server, so notify the Tx          */
            /* Characteristic.                                          */
            if(DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor == QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
               Result = qapi_BLE_GATT_Handle_Value_Notification(BluetoothStackID, SPPLEServiceID, DeviceInfo->ConnectionID, SPPLE_TX_CHARACTERISTIC_ATTRIBUTE_OFFSET, (uint16_t)DataCount, SPPLEBuffer);
            else
            {
               /* Not configured for notifications so exit the loop.    */
               Done = TRUE;
            }
         }
         else
         {
            /* We are acting as SPPLE Client, so write to the Rx        */
            /* Characteristic.                                          */
            if(DeviceInfo->ClientInfo.Tx_Characteristic)
               Result = qapi_BLE_GATT_Write_Without_Response_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->ClientInfo.Rx_Characteristic, (uint16_t)DataCount, SPPLEBuffer);
            else
            {
               /* We have not discovered the Tx Characteristic, so exit */
               /* the loop.                                             */
               Done = TRUE;
            }
         }

         /* Check to see if any data was written.                       */
         if(!Done)
         {
            /* Check to see if the data was written successfully.       */
            if(Result >= 0)
            {
               /* Adjust the counters.                                  */
               SendInfo.BytesToSend        -= (unsigned int)Result;
               SendInfo.BytesSent          += (unsigned int)Result;
               TransmitIndex               += (unsigned int)Result;
               SPPLEBufferLength           -= (unsigned int)Result;
               DeviceInfo->TransmitCredits -= (unsigned int)Result;

               /* If we have no more remaining Tx Credits AND we have   */
               /* data built up to send, we need to queue this in the Tx*/
               /* Buffer.                                               */
               if((!(DeviceInfo->TransmitCredits)) && (SPPLEBufferLength))
               {
                  /* Add the remaining data to the transmit buffer.     */
                  AddDataToBuffer(&(DeviceInfo->TransmitBuffer), SPPLEBufferLength, &SPPLEBuffer[TransmitIndex]);

                  SPPLEBufferLength = 0;
               }
            }
            else
            {
               QCLI_Printf(spple_group, "SEND failed with error %d\n", Result);

               SendInfo.BytesToSend  = 0;
            }
         }
      }

      /* If we have added more bytes to the transmit buffer than we can */
      /* send in this process remove the extra.                         */
      if(Added2Buffer > SendInfo.BytesToSend)
         RemoveDataFromBuffer(&(DeviceInfo->TransmitBuffer), Added2Buffer-SendInfo.BytesToSend, NULL);

      /* Display a message if we have sent all required data.           */
      if((!SendInfo.BytesToSend) && (SendInfo.BytesSent))
      {
         QCLI_Printf(spple_group, "\n");
         QCLI_Printf(spple_group, "Send Complete, Sent %u.\n", (unsigned int)SendInfo.BytesSent);

         SendInfo.BytesSent = 0;
      }
   }
}

   /* The following function is responsible for transmitting the        */
   /* specified number of credits to the remote device.                 */
static void SendCredits(DeviceInfo_t *DeviceInfo, unsigned int DataLength)
{
   qapi_BLE_NonAlignedWord_t Credits;

   /* Verify that the input parameters are semi-valid.                  */
   if((DeviceInfo) && (DataLength))
   {
      /* Format the credit packet.                                      */
      ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(&Credits, DataLength);

      /* Determine how to send credits based on the role.               */
      if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_SERVER)
      {
         /* We are acting as a server so notify the Rx Credits          */
         /* characteristic.                                             */
         if(DeviceInfo->ServerInfo.Rx_Credit_Client_Configuration_Descriptor == QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
            qapi_BLE_GATT_Handle_Value_Notification(BluetoothStackID, SPPLEServiceID, DeviceInfo->ConnectionID, SPPLE_RX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET, sizeof(Credits), (uint8_t *)&Credits);
      }
      else
      {
         /* We are acting as a client so send a Write Without Response  */
         /* packet to the Tx Credit Characteristic.                     */
         if(DeviceInfo->ClientInfo.Tx_Credit_Characteristic)
            qapi_BLE_GATT_Write_Without_Response_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->ClientInfo.Tx_Credit_Characteristic, sizeof(Credits), &Credits);
      }
   }
}

   /* The following function is responsible for handling a received     */
   /* credit, event.                                                    */
static boolean_t ReceiveCreditEvent(DeviceInfo_t *DeviceInfo, unsigned int Credits)
{
   boolean_t ret_val;

   /* Verify that the input parameters are semi-valid.                  */
   if(DeviceInfo)
   {
      /* If this is a real credit event store the number of credits.    */
      DeviceInfo->TransmitCredits += Credits;

      /* Handle any active send process.                                */
      SendProcess(DeviceInfo);

      /* Send all queued data.                                          */
      SendData(DeviceInfo, 0, NULL);

      /* It is possible that we have received data queued, so call the  */
      /* Data Indication Event to handle this.                          */
      ret_val = DataIndicationEvent(DeviceInfo, 0, NULL);
   }
   else
      ret_val = false;

   return(ret_val);
}

   /* The following function sends the specified data to the specified  */
   /* data.  This function will queue any of the data that does not go  */
   /* out.  This function returns TRUE if all the data was sent, or     */
   /* FALSE.                                                            */
   /* * NOTE * If DataLength is 0 and Data is NULL then all queued data */
   /*          will be sent.                                            */
static boolean_t SendData(DeviceInfo_t *DeviceInfo, unsigned int DataLength, uint8_t *Data)
{
   int          Result;
   boolean_t    DataSent = FALSE;
   boolean_t    Done;
   unsigned int DataCount;
   unsigned int MaxLength;
   unsigned int TransmitIndex;
   unsigned int SPPLEBufferLength;

   /* Verify that the input parameters are semi-valid.                  */
   if(DeviceInfo)
   {
      /* Loop while we have data to send and we can send it.            */
      Done              = FALSE;
      TransmitIndex     = 0;
      SPPLEBufferLength = 0;
      while(!Done)
      {
         /* Check to see if we have credits to use to transmit the data.*/
         if(DeviceInfo->TransmitCredits)
         {
            /* Get the maximum length of what we can send in this       */
            /* transaction.                                             */
            MaxLength = (SPPLE_DATA_BUFFER_LENGTH > DeviceInfo->TransmitCredits)?DeviceInfo->TransmitCredits:SPPLE_DATA_BUFFER_LENGTH;

            /* If we do not have any outstanding data get some more     */
            /* data.                                                    */
            if(!SPPLEBufferLength)
            {
               /* Send any buffered data first.                         */
               if(DeviceInfo->TransmitBuffer.BytesFree != DeviceInfo->TransmitBuffer.BufferSize)
               {
                  /* Remove the queued data from the Transmit Buffer.   */
                  SPPLEBufferLength = RemoveDataFromBuffer(&(DeviceInfo->TransmitBuffer), MaxLength, SPPLEBuffer);
               }
               else
               {
                  /* Check to see if we have data to send.              */
                  if((DataLength) && (Data))
                  {
                     /* Copy the data to send into the SPPLEBuffer.     */
                     SPPLEBufferLength = (DataLength > MaxLength)?MaxLength:DataLength;
                     memcpy(SPPLEBuffer, Data, SPPLEBufferLength);

                     DataLength -= SPPLEBufferLength;
                     Data       += SPPLEBufferLength;
                  }
                  else
                  {
                     /* No data queued or data left to send so exit the */
                     /* loop.                                           */
                     Done = TRUE;
                  }
               }

               /* Set the count of data that we can send.               */
               DataCount         = SPPLEBufferLength;

               /* Reset the Transmit Index to 0.                        */
               TransmitIndex     = 0;
            }
            else
            {
               /* We have data to send so cap it at the maximum that can*/
               /* be transmitted.                                       */
               DataCount = (SPPLEBufferLength > MaxLength)?MaxLength:SPPLEBufferLength;
            }

            /* Try to write data if not exiting the loop.               */
            if(!Done)
            {
               /* Use the correct API based on device role for SPPLE.   */
               if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_SERVER)
               {
                  /* We are acting as SPPLE Server, so notify the Tx    */
                  /* Characteristic.                                    */
                  if(DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor == QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                     Result = qapi_BLE_GATT_Handle_Value_Notification(BluetoothStackID, SPPLEServiceID, DeviceInfo->ConnectionID, SPPLE_TX_CHARACTERISTIC_ATTRIBUTE_OFFSET, (uint16_t)DataCount, &SPPLEBuffer[TransmitIndex]);
                  else
                  {
                     /* Not configured for notifications so exit the    */
                     /* loop.                                           */
                     Done = TRUE;
                  }
               }
               else
               {
                  /* We are acting as SPPLE Client, so write to the Rx  */
                  /* Characteristic.                                    */
                  if(DeviceInfo->ClientInfo.Tx_Characteristic)
                     Result = qapi_BLE_GATT_Write_Without_Response_Request(BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->ClientInfo.Rx_Characteristic, (uint16_t)DataCount, &SPPLEBuffer[TransmitIndex]);
                  else
                  {
                     /* We have not discovered the Tx Characteristic, so*/
                     /* exit the loop.                                  */
                     Done = TRUE;
                  }
               }

               /* Check to see if any data was written.                 */
               if(!Done)
               {
                  /* Check to see if the data was written successfully. */
                  if(Result >= 0)
                  {
                     /* Adjust the counters.                            */
                     TransmitIndex               += (unsigned int)Result;
                     SPPLEBufferLength           -= (unsigned int)Result;
                     DeviceInfo->TransmitCredits -= (unsigned int)Result;

                     /* Flag that data was sent.                        */
                     DataSent                     = TRUE;

                     /* If we have no more remaining Tx Credits AND we  */
                     /* have data built up to send, we need to queue    */
                     /* this in the Tx Buffer.                          */
                     if((!(DeviceInfo->TransmitCredits)) && (SPPLEBufferLength))
                     {
                        /* Add the remaining data to the transmit       */
                        /* buffer.                                      */
                        AddDataToBuffer(&(DeviceInfo->TransmitBuffer), SPPLEBufferLength, &SPPLEBuffer[TransmitIndex]);

                        SPPLEBufferLength = 0;
                     }
                  }
                  else
                  {
                     QCLI_Printf(spple_group, "SEND failed with error %d\n", Result);

                     DataSent  = FALSE;
                  }
               }
            }
         }
         else
         {
            /* We have no transmit credits, so buffer the data.         */
            DataCount = AddDataToBuffer(&(DeviceInfo->TransmitBuffer), DataLength, Data);
            if(DataCount == DataLength)
               DataSent = TRUE;
            else
               DataSent = FALSE;

            /* Exit the loop.                                           */
            Done = TRUE;
         }
      }
   }

   return(DataSent);
}

   /* The following function is responsible for handling a data         */
   /* indication event.                                                 */
static boolean_t DataIndicationEvent(DeviceInfo_t *DeviceInfo, unsigned int DataLength, uint8_t *Data)
{
   uint64_t     CurrentTime;
   boolean_t    ret_val;
   boolean_t    Done;
   unsigned int ReadLength;
   unsigned int Length;

   ret_val = false;

   /* Verify that the input parameters are semi-valid.                  */
   if(DeviceInfo)
   {
      /* Throughput mode calcuations are active.                        */
      if(DeviceInfo->ThroughputModeActive)
      {
         /* Save the current time which will be the starting time or the*/
         /* latest time the device has received a notification.         */
         CurrentTime = (uint64_t)qurt_timer_convert_ticks_to_time(qurt_timer_get_ticks(), QURT_TIME_MSEC) / 1000;

         /* Determine if this is the first time a transfer has occurred */
         /* with the remote device since starting throughput            */
         /* calculations.                                               */
         if (DeviceInfo->XferInfo.TimingStarted == FALSE)
         {
            DeviceInfo->XferInfo.TimingStarted = TRUE;
            DeviceInfo->XferInfo.FirstTime = CurrentTime;
         }

         DeviceInfo->XferInfo.LastTime = CurrentTime;
         DeviceInfo->XferInfo.RxCount += DataLength;
      }

      /* If we are automatically reading the data, go ahead and credit  */
      /* what we just received, as well as reading everything in the    */
      /* buffer.                                                        */
      if((AutomaticReadActive) || (LoopbackActive))
      {
         /* Loop until we read all of the data queued.                  */
         Done = FALSE;
         while(!Done)
         {
            /* If in loopback mode cap what we remove at the max of what*/
            /* we can send or queue.                                    */
            if(LoopbackActive)
               ReadLength = (SPPLE_DATA_BUFFER_LENGTH > (DeviceInfo->TransmitCredits + DeviceInfo->TransmitBuffer.BytesFree))?(DeviceInfo->TransmitCredits + DeviceInfo->TransmitBuffer.BytesFree):SPPLE_DATA_BUFFER_LENGTH;
            else
               ReadLength = SPPLE_DATA_BUFFER_LENGTH;

            /* Read all queued data.                                    */
            Length = ReadData(DeviceInfo, ReadLength, SPPLEBuffer);
            if(Length > 0)
            {
               /* If loopback is active, loopback the data.             */
               if(LoopbackActive)
                  SendData(DeviceInfo, Length, SPPLEBuffer);

               /* If we are displaying the data then do that here.      */
               if(DisplayRawData)
               {
                  SPPLEBuffer[Length] = '\0';
                  QCLI_Printf(spple_group, "%s", (char *)SPPLEBuffer);
                  ret_val = true;
               }
            }
            else
               Done = TRUE;
         }

         /* Only send/display data just received if any is specified in */
         /* the call to this function.                                  */
         if((DataLength) && (Data))
         {
            /* If loopback is active, loopback the data just received.  */
            if((AutomaticReadActive) || (LoopbackActive))
            {
               /* If we are displaying the data then do that here.      */
               if(DisplayRawData)
               {
                  memcpy(SPPLEBuffer, Data, DataLength);
                  SPPLEBuffer[DataLength] = '\0';
                  QCLI_Printf(spple_group, "%s", (char *)SPPLEBuffer);
                  ret_val = true;
               }

               /* Check to see if Loopback is active, if it is we will  */
               /* loopback the data we just received.                   */
               if(LoopbackActive)
               {
                  /* Only queue the data in the receive buffer that we  */
                  /* cannot send.                                       */
                  ReadLength = (DataLength > (DeviceInfo->TransmitCredits + DeviceInfo->TransmitBuffer.BytesFree))?(DeviceInfo->TransmitCredits + DeviceInfo->TransmitBuffer.BytesFree):DataLength;

                  /* Send the data.                                     */
                  if(SendData(DeviceInfo, ReadLength, Data))
                  {
                     /* Credit the data we just sent.                   */
                     SendCredits(DeviceInfo, ReadLength);

                     /* Increment what was just sent.                   */
                     DataLength -= ReadLength;
                     Data       += ReadLength;
                  }
               }
               else
               {
                  /* Loopback is not active so just credit back the data*/
                  /* we just received.                                  */
                  SendCredits(DeviceInfo, DataLength);

                  DataLength = 0;
               }

               /* If we have data left that cannot be sent, queue this  */
               /* in the receive buffer.                                */
               if((DataLength) && (Data))
               {
                  /* We are not in Loopback or Automatic Read Mode so   */
                  /* just buffer all the data.                          */
                  Length = AddDataToBuffer(&(DeviceInfo->ReceiveBuffer), DataLength, Data);
                  if(Length != DataLength)
                  {
                     QCLI_Printf(spple_group, "Receive Buffer Overflow of %u bytes", DataLength - Length);
                     ret_val = true;
                  }
               }
            }

            /* If we are displaying the data then do that here.         */
            if(DisplayRawData)
            {
               memcpy(SPPLEBuffer, Data, DataLength);
               SPPLEBuffer[DataLength] = '\0';
               QCLI_Printf(spple_group, "%s", (char *)SPPLEBuffer);
               ret_val = true;
            }
         }
      }
      else
      {
         if((DataLength) && (Data))
         {
            /* Display a Data indication event.                         */
            QCLI_Printf(spple_group, "Data Indication Event, Connection ID %u, Received %u bytes.\n", DeviceInfo->ConnectionID, DataLength);

            /* We are not in Loopback or Automatic Read Mode so just    */
            /* buffer all the data.                                     */
            Length = AddDataToBuffer(&(DeviceInfo->ReceiveBuffer), DataLength, Data);
            if(Length != DataLength)
               QCLI_Printf(spple_group, "Receive Buffer Overflow of %u bytes.\n", DataLength - Length);

            ret_val = true;
         }
      }
   }

   return(ret_val);
}

   /* The following function is used to read data from the specified    */
   /* device.  The final two parameters specify the BufferLength and the*/
   /* Buffer to read the data into.  On success this function returns   */
   /* the number of bytes read.  If an error occurs this will return a  */
   /* negative error code.                                              */
static int ReadData(DeviceInfo_t *DeviceInfo, unsigned int BufferLength, uint8_t *Buffer)
{
   int          ret_val;
   boolean_t    Done;
   unsigned int Length;
   unsigned int TotalLength;

   /* Verify that the input parameters are semi-valid.                  */
   if((DeviceInfo) && (BufferLength) && (Buffer))
   {
      Done        = FALSE;
      TotalLength = 0;
      while(!Done)
      {
         Length = RemoveDataFromBuffer(&(DeviceInfo->ReceiveBuffer), BufferLength, Buffer);
         if(Length > 0)
         {
            BufferLength -= Length;
            Buffer       += Length;
            TotalLength   = Length;
         }
         else
            Done = TRUE;
      }

      /* Credit what we read.                                           */
      SendCredits(DeviceInfo, TotalLength);

      /* Return the total number of bytes read.                         */
      ret_val = (int)TotalLength;
   }
   else
      ret_val = QAPI_BLE_BTPS_ERROR_INVALID_PARAMETER;

   return(ret_val);
}

   /* Tx Power Service (TPS) helper functions.                          */

   /* The following function queries the Connection Tx Power Level.     */
   /* This function returns TRUE if successful or FALSE otherwise.      */
static boolean_t QueryTxPowerLevel(boolean_t ConnectionTxPower, int8_t *TxPowerLevel)
{
   int       Result;
   boolean_t ret_val = FALSE;

   /* Verify the input parameters.                                      */
   if((BluetoothStackID) && (TxPowerLevel))
   {
      /* Call the power to get the power level.                         */
#ifdef V2
      if((Result = qapi_BLE_BSC_GetTxPower(BluetoothStackID, ConnectionTxPower, TxPowerLevel)) == 0)
#else
      if((Result = qapi_BLE_BSC_Query_Default_Tx_Power(BluetoothStackID, ConnectionTxPower, TxPowerLevel)) == 0)
#endif
      {
         /* Print the Tx Power to the console.                          */
         QCLI_Printf(ble_group, "%s Tx Power: %d.\n", (ConnectionTxPower?"Connection":"Advertising Channel"), (int)*TxPowerLevel);
      }
      else
         DisplayFunctionError("qapi_BLE_HCI_Send_Raw_Command()", Result);
   }

   /* Return the result to the caller.                                  */
   return(ret_val);
}


   /* ***************************************************************** */
   /*                         Event Callbacks                           */
   /* ***************************************************************** */

   /* BSC Timer Callback function prototype.                            */
void BSC_Timer_Callback(uint32_t BluetoothStackID, uint32_t TimerID, uint32_t CallbackParameter)
{
   /* Verify the input parameters.                                      */
   if(BluetoothStackID)
   {
      QCLI_Printf(ble_group, "Stopping scan after scanning for %u seconds.\n", CallbackParameter);

      /* Clear the Scan Timer ID.                                       */
      ScanTimerID = 0;

      /* Stop scanning.                                                 */
      StopScan(BluetoothStackID);
   }
}

   /* The following function is for the GAP LE Event Receive Data       */
   /* Callback.  This function will be called whenever a Callback has   */
   /* been registered for the specified GAP LE Action that is associated*/
   /* with the Bluetooth Stack.  This function passes to the caller the */
   /* GAP LE Event Data of the specified Event and the GAP LE Event     */
   /* Callback Parameter that was specified when this Callback was      */
   /* installed.  The caller is free to use the contents of the GAP LE  */
   /* Event Data ONLY in the context of this callback.  If the caller   */
   /* requires the Data for a longer period of time, then the callback  */
   /* function MUST copy the data into another Data Buffer.  This       */
   /* function is guaranteed NOT to be invoked more than once           */
   /* simultaneously for the specified installed callback (i.e.  this   */
   /* function DOES NOT have be reentrant).  It Needs to be noted       */
   /* however, that if the same Callback is installed more than once,   */
   /* then the callbacks will be called serially.  Because of this, the */
   /* processing in this function should be as efficient as possible.   */
   /* It should also be noted that this function is called in the Thread*/
   /* Context of a Thread that the User does NOT own.  Therefore,       */
   /* processing in this function should be as efficient as possible    */
   /* (this argument holds anyway because other GAP Events will not be  */
   /* processed while this function call is outstanding).               */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GAP_LE_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GAP_LE_Event_Data_t *GAP_LE_Event_Data, uint32_t CallbackParameter)
{
   boolean_t                                              DisplayPrompt;
   int                                                    Result;
   uint16_t                                               EDIV;
   BoardStr_t                                             BoardStr;
   unsigned int                                           Index;
   DeviceInfo_t                                          *DeviceInfo;
   qapi_BLE_Random_Number_t                               RandomNumber;
   qapi_BLE_Long_Term_Key_t                               GeneratedLTK;
   qapi_BLE_GAP_LE_Security_Information_t                 GAP_LE_Security_Information;
   qapi_BLE_GAP_LE_Connection_Parameters_t                ConnectionParams;
   qapi_BLE_GAP_LE_Advertising_Report_Data_t             *DeviceEntryPtr;
   qapi_BLE_GAP_LE_Authentication_Event_Data_t           *Authentication_Event_Data;
   qapi_BLE_GAP_LE_Direct_Advertising_Report_Data_t      *DirectDeviceEntryPtr;
#ifdef V2
   qapi_BLE_GAP_LE_Extended_Advertising_Report_Data_t    *ExtDeviceEntryPtr;
#endif
   qapi_BLE_GAP_LE_Authentication_Response_Information_t  GAP_LE_Authentication_Response_Information;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GAP_LE_Event_Data))
   {
      DisplayPrompt = true;

      switch(GAP_LE_Event_Data->Event_Data_Type)
      {
#ifdef V2
         case QAPI_BLE_ET_LE_SCAN_TIMEOUT_E:
            QCLI_Printf(ble_group, "etLE_Scan_Timeout with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);
            break;
         case QAPI_BLE_ET_LE_PHY_UPDATE_COMPLETE_E:
            QCLI_Printf(ble_group, "etLE_PHY_Update_Complete with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

            QCLI_Printf(ble_group, "  Status:  %d.\n", (int)(GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->Status));
            QCLI_Printf(ble_group, "  Address: 0x%02X%02X%02X%02X%02X%02X.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR5,
                                                                               GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR4,
                                                                               GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR3,
                                                                               GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR2,
                                                                               GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR1,
                                                                               GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR0);
            QCLI_Printf(ble_group, "  Tx PHY:  %s.\n", PHYToString(GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->TX_PHY));
            QCLI_Printf(ble_group, "  Rx PHY:  %s.\n", PHYToString(GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->RX_PHY));

            break;
         case QAPI_BLE_ET_LE_ADVERTISING_SET_TERMINATED_E:
            QCLI_Printf(ble_group, "etLE_Advertising_Set_Terminated with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

            QCLI_Printf(ble_group, "  Status:                                  %d.\n", (int)(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Status));
            QCLI_Printf(ble_group, "  Advertising Handle:                      %u.\n", (unsigned int)(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Advertising_Handle));
            QCLI_Printf(ble_group, "  Number of Completed Advertising Events:  %u.\n", (unsigned int)(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Num_Completed_Ext_Advertising_Events));

            if(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Status == QAPI_BLE_HCI_ERROR_CODE_SUCCESS)
            {
               /* Display the Address Type.                             */
               switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Connection_Address_Type)
               {
                  case QAPI_BLE_LAT_PUBLIC_E:
                     QCLI_Printf(ble_group, "  Connection Address Type:                 %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_E:
                     QCLI_Printf(ble_group, "  Connection Address Type:                 %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                     break;
                  case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                     QCLI_Printf(ble_group, "  Connection Address Type:                 %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                     QCLI_Printf(ble_group, "  Connection Address Type:                 %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                     break;
                  default:
                     QCLI_Printf(ble_group, "  Connection Address Type:                 Invalid.\n");
                     break;
               }

               BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Connection_Address, BoardStr);
               QCLI_Printf(ble_group, "  Connection Address:                      %s.\n", BoardStr);
            }
            break;
         case QAPI_BLE_ET_LE_SCAN_REQUEST_RECEIVED_E:
            QCLI_Printf(ble_group, "etLE_Scan_Request_Received with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

            QCLI_Printf(ble_group, "  Advertising Handle:          %d.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Scan_Request_Received_Event_Data->Advertising_Handle);

            /* Display the Address Type.                                */
            switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Scan_Request_Received_Event_Data->Scanner_Address_Type)
            {
               case QAPI_BLE_LAT_PUBLIC_E:
                  QCLI_Printf(ble_group, "  Scanner Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                  break;
               case QAPI_BLE_LAT_RANDOM_E:
                  QCLI_Printf(ble_group, "  Scanner Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                  break;
               case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                  QCLI_Printf(ble_group, "  Scanner Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                  break;
               case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                  QCLI_Printf(ble_group, "  Scanner Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                  break;
               default:
                  QCLI_Printf(ble_group, "  Scanner Address Type:        Invalid.\n");
                  break;
            }

            BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Scan_Request_Received_Event_Data->Scanner_Address, BoardStr);
            QCLI_Printf(ble_group, "  Scanner Address:             %s.\n", BoardStr);
            break;
         case QAPI_BLE_ET_LE_CHANNEL_SELECTION_ALGORITHM_UPDATE_E:
            QCLI_Printf(ble_group, "etLE_Channel_Selection_Algorithm_Update with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);

            /* Display the new CSA.                                     */
            switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Channel_Selection_Algorithm_Update_Event_Data->Channel_Selection_Algorithm)
            {
               case QAPI_BLE_SA_ALGORITHM_NUM1_E:
                  QCLI_Printf(ble_group, "  Channel Selection Algorithm:        %s.\n", "CSA #1");
                  break;
               case QAPI_BLE_SA_ALGORITHM_NUM2_E:
                  QCLI_Printf(ble_group, "  Channel Selection Algorithm:        %s.\n", "CSA #2");
                  break;
               default:
                  QCLI_Printf(ble_group, "  Channel Selection Algorithm:        %s.\n", "CSA Unkown");
                  break;
            }

            /* Display the Address Type.                                */
            switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Channel_Selection_Algorithm_Update_Event_Data->Connection_Address_Type)
            {
               case QAPI_BLE_LAT_PUBLIC_E:
                  QCLI_Printf(ble_group, "  Connection Address Type:            %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                  break;
               case QAPI_BLE_LAT_RANDOM_E:
                  QCLI_Printf(ble_group, "  Connection Address Type:            %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                  break;
               case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                  QCLI_Printf(ble_group, "  Connection Address Type:            %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                  break;
               case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                  QCLI_Printf(ble_group, "  Connection Address Type:            %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                  break;
               default:
                  QCLI_Printf(ble_group, "  Connection Address Type:            Invalid.\n");
                  break;
            }

            BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Channel_Selection_Algorithm_Update_Event_Data->Connection_Address, BoardStr);
            QCLI_Printf(ble_group, "  Connection Address:                 %s.\n", BoardStr);
            break;
         case QAPI_BLE_ET_LE_EXTENDED_ADVERTISING_REPORT_E:
            QCLI_Printf(ble_group, "etLE_Extended_Advertising_Report with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);
            QCLI_Printf(ble_group, "  %d Responses.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Extended_Advertising_Report_Event_Data->Number_Device_Entries);

            for(Index = 0; Index < GAP_LE_Event_Data->Event_Data.GAP_LE_Extended_Advertising_Report_Event_Data->Number_Device_Entries; Index++)
            {
               ExtDeviceEntryPtr = &(GAP_LE_Event_Data->Event_Data.GAP_LE_Extended_Advertising_Report_Event_Data->Extended_Advertising_Data[Index]);

               /* Display the Address Type.                             */
               switch(ExtDeviceEntryPtr->Address_Type)
               {
                  case QAPI_BLE_LAT_PUBLIC_E:
                     QCLI_Printf(ble_group, "  Address Type:     %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_E:
                     QCLI_Printf(ble_group, "  Address Type:     %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                     break;
                  case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                     QCLI_Printf(ble_group, "  Address Type:     %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                     QCLI_Printf(ble_group, "  Address Type:     %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                     break;
                  case QAPI_BLE_LAT_ANONYMOUS_E:
                     QCLI_Printf(ble_group, "  Address Type:     %s.\n", "Anonymous");
                     break;
                  default:
                     QCLI_Printf(ble_group, "  Address Type:     Invalid.\n");
                     break;
               }

               QCLI_Printf(ble_group, "  Address:          0x%02X%02X%02X%02X%02X%02X.\n", ExtDeviceEntryPtr->BD_ADDR.BD_ADDR5, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR4, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR3, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR2, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR1, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR0);

               if(DisplayAdvertisingEventData)
               {
                  QCLI_Printf(ble_group, "  Event Type Flags: 0x%08X.\n", ExtDeviceEntryPtr->Event_Type_Flags);
                  QCLI_Printf(ble_group, "  Tx Power:         %d.\n", (int)ExtDeviceEntryPtr->Tx_Power);
                  QCLI_Printf(ble_group, "  RSSI:             %d.\n", (int)ExtDeviceEntryPtr->RSSI);
                  QCLI_Printf(ble_group, "  Advertising SID:  %d.\n", (int)ExtDeviceEntryPtr->Advertising_SID);
                  QCLI_Printf(ble_group, "  Primary PHY:      %s.\n", PHYToString(ExtDeviceEntryPtr->Primary_PHY));

                  switch(ExtDeviceEntryPtr->Data_Status)
                  {
                     case QAPI_BLE_DS_COMPLETE_E:
                        QCLI_Printf(ble_group, "  Data Status:      %s.\n", "Complete");
                        break;
                     case QAPI_BLE_DS_INCOMPLETE_DATA_PENDING_E:
                        QCLI_Printf(ble_group, "  Data Status:      %s.\n", "Incomplete - More data pending");
                        break;
                     default:
                     case QAPI_BLE_DS_INCOMPLETE_DATA_TRUNCATED_E:
                        QCLI_Printf(ble_group, "  Data Status:      %s.\n", "Incomplete - data truncated");
                        break;
                  }

                  if(ExtDeviceEntryPtr->Event_Type_Flags & GAP_LE_EXTENDED_ADVERTISING_EVENT_TYPE_SECONDARY_PHY_VALID)
                     QCLI_Printf(ble_group, "  Secondary PHY:    %s.\n", PHYToString(ExtDeviceEntryPtr->Secondary_PHY));

                  QCLI_Printf(ble_group, "  Data Length:      %u.\n", (unsigned int)ExtDeviceEntryPtr->Raw_Report_Length);
               }
            }
            break;
#endif

         case QAPI_BLE_ET_LE_DATA_LENGTH_CHANGE_E:
            QCLI_Printf(ble_group, "etLE_Data_Length_Change with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);

            BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->BD_ADDR, BoardStr);
            QCLI_Printf(ble_group, "  Connection Address:                 %s.\n", BoardStr);
            QCLI_Printf(ble_group, "  Max Tx Octets:                      %u.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->MaxTxOctets);
            QCLI_Printf(ble_group, "  Max Tx Time:                        %u.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->MaxTxTime);
            QCLI_Printf(ble_group, "  Max Rx Octets:                      %u.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->MaxRxOctets);
            QCLI_Printf(ble_group, "  Max Rx Time:                        %u.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->MaxRxTime);
            break;
         case QAPI_BLE_ET_LE_ADVERTISING_REPORT_E:
            QCLI_Printf(ble_group, "etLE_Advertising_Report with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);
            QCLI_Printf(ble_group, "  %d Responses.\n",GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Report_Event_Data->Number_Device_Entries);

            for(Index = 0; Index < GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Report_Event_Data->Number_Device_Entries; Index++)
            {
               DeviceEntryPtr = &(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Report_Event_Data->Advertising_Data[Index]);

               /* Display the Address Type.                             */
               switch(DeviceEntryPtr->Address_Type)
               {
                  case QAPI_BLE_LAT_PUBLIC_E:
                     QCLI_Printf(ble_group, "  Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_E:
                     QCLI_Printf(ble_group, "  Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                     break;
                  case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                     QCLI_Printf(ble_group, "  Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                     QCLI_Printf(ble_group, "  Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                     break;
                  default:
                     QCLI_Printf(ble_group, "  Address Type:        Invalid.\n");
                     break;
               }

               /* Display the Device Address.                           */
               QCLI_Printf(ble_group, "  Address: 0x%02X%02X%02X%02X%02X%02X.\n", DeviceEntryPtr->BD_ADDR.BD_ADDR5, DeviceEntryPtr->BD_ADDR.BD_ADDR4, DeviceEntryPtr->BD_ADDR.BD_ADDR3, DeviceEntryPtr->BD_ADDR.BD_ADDR2, DeviceEntryPtr->BD_ADDR.BD_ADDR1, DeviceEntryPtr->BD_ADDR.BD_ADDR0);

               if(DisplayAdvertisingEventData)
               {
                  /* Display the packet type for the device             */
                  switch(DeviceEntryPtr->Advertising_Report_Type)
                  {
                     case QAPI_BLE_RT_CONNECTABLE_UNDIRECTED_E:
                        QCLI_Printf(ble_group, "  Advertising Type: %s.\n", "QAPI_BLE_RT_CONNECTABLE_UNDIRECTED_E");
                        break;
                     case QAPI_BLE_RT_CONNECTABLE_DIRECTED_E:
                        QCLI_Printf(ble_group, "  Advertising Type: %s.\n", "QAPI_BLE_RT_CONNECTABLE_DIRECTED_E");
                        break;
                     case QAPI_BLE_RT_SCANNABLE_UNDIRECTED_E:
                        QCLI_Printf(ble_group, "  Advertising Type: %s.\n", "QAPI_BLE_RT_SCANNABLE_UNDIRECTED_E");
                        break;
                     case QAPI_BLE_RT_NON_CONNECTABLE_UNDIRECTED_E:
                        QCLI_Printf(ble_group, "  Advertising Type: %s.\n", "QAPI_BLE_RT_NON_CONNECTABLE_UNDIRECTED_E");
                        break;
                     case QAPI_BLE_RT_SCAN_RESPONSE_E:
                        QCLI_Printf(ble_group, "  Advertising Type: %s.\n", "QAPI_BLE_RT_SCAN_RESPONSE_E");
                        break;
                  }

                  QCLI_Printf(ble_group, "  RSSI: %d.\n", (int)(DeviceEntryPtr->RSSI));
                  QCLI_Printf(ble_group, "  Data Length: %d.\n", DeviceEntryPtr->Raw_Report_Length);
               }
            }
            break;
         case QAPI_BLE_ET_LE_CONNECTION_COMPLETE_E:
            QCLI_Printf(ble_group, "etLE_Connection_Complete with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

            if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data)
            {
               BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address, BoardStr);

               QCLI_Printf(ble_group, "   Status:              0x%02X.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Status);
               QCLI_Printf(ble_group, "   Role:                %s.\n", (GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Master)?"Master":"Slave");
               switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type)
               {
                  case QAPI_BLE_LAT_PUBLIC_E:
                     QCLI_Printf(ble_group, "   Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_E:
                     QCLI_Printf(ble_group, "   Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                     break;
                  case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                     QCLI_Printf(ble_group, "   Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                     QCLI_Printf(ble_group, "   Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                     break;
                  default:
                     QCLI_Printf(ble_group, "   Address Type:        Invalid.\n");
                     break;
               }
               QCLI_Printf(ble_group, "   BD_ADDR:             %s.\n", BoardStr);

               if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Status == QAPI_BLE_HCI_ERROR_CODE_NO_ERROR)
               {
                  QCLI_Printf(ble_group, "   Connection Interval: %u.\n", (unsigned int)GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Current_Connection_Parameters.Connection_Interval);
                  QCLI_Printf(ble_group, "   Slave Latency:       %u.\n", (unsigned int)GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Current_Connection_Parameters.Slave_Latency);

                  /* Store the GAP LE Connection information that needs */
                  /* to be stored for the remote device.                */
                  /* * NOTE * These are temporary globals that will hold*/
                  /*          information that needs to be stored for   */
                  /*          the remote device that just connected.    */
                  /* * NOTE * For consistency, this information will NOT*/
                  /*          be stored until the GATT Connection       */
                  /*          Complete event has been received.  This   */
                  /*          event ALWAYS follows the GAP LE Connection*/
                  /*          Complete event.                           */
                  LocalDeviceIsMaster =  GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Master;
                  RemoteAddressType   = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type;

                  /* Attempt to find the entry via the address and      */
                  /* address type.  This function will update the entry */
                  /* if it is found to already exist and resolution is  */
                  /* now being done in the controller.                  */
                  if((DeviceInfo = SearchDeviceInfoEntryTypeAddress(&DeviceInfoList, GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type, GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address)) != NULL)
                  {
                     uint8_t            Peer_Identity_Address_Type;
                     uint8_t            StatusResult;
                     qapi_BLE_BD_ADDR_t Peer_Identity_Address;
                     qapi_BLE_BD_ADDR_t Local_Resolvable_Address;

                     if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type == QAPI_BLE_LAT_PUBLIC_IDENTITY_E)
                        Peer_Identity_Address_Type = 0x00;
                     else if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type == QAPI_BLE_LAT_RANDOM_IDENTITY_E)
                        Peer_Identity_Address_Type = 0x01;
                     else
                        Peer_Identity_Address_Type = 0x02;

                     if(Peer_Identity_Address_Type != 0x02)
                     {
                        Peer_Identity_Address = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address;

                        if(!qapi_BLE_HCI_LE_Read_Local_Resolvable_Address(BluetoothStackID, Peer_Identity_Address_Type, Peer_Identity_Address, &StatusResult, &Local_Resolvable_Address))
                        {
                           QCLI_Printf(ble_group, "   qapi_BLE_HCI_LE_Read_Local_Resolvable_Address(): 0x%02X.\n", StatusResult);
                           if(!StatusResult)
                           {
                              BD_ADDRToStr(Local_Resolvable_Address, BoardStr);
                              QCLI_Printf(ble_group, "   Local RPA:           %s.\n", BoardStr);
                           }
                        }
                     }

                     /* If we have previously connected and bonded with */
                     /* the remote device, then the remote device       */
                     /* information MUST exist and we can attempt to    */
                     /* re-establish security using the LTK if we are   */
                     /* the master.                                     */
                     /* * NOTE * If the LTK was NOT valid on            */
                     /*          disconnection, then the remote device  */
                     /*          information will be deleted.           */
                     if(LocalDeviceIsMaster)
                     {
                        /* Make sure the LTK is valid for this remote   */
                        /* device.                                      */
                        if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                        {
                           /* Re-Establish Security with this LTK.      */
                           QCLI_Printf(ble_group, "Attempting to Re-Establish Security.\n");

                           /* Attempt to re-establish security to this  */
                           /* device.                                   */
                           GAP_LE_Security_Information.Local_Device_Is_Master                                      = TRUE;
                           memcpy(&(GAP_LE_Security_Information.Security_Information.Master_Information.LTK), &(DeviceInfo->LTK), sizeof(DeviceInfo->LTK));
                           GAP_LE_Security_Information.Security_Information.Master_Information.EDIV                = DeviceInfo->EDIV;
                           memcpy(&(GAP_LE_Security_Information.Security_Information.Master_Information.Rand), &(DeviceInfo->Rand), sizeof(DeviceInfo->Rand));
                           GAP_LE_Security_Information.Security_Information.Master_Information.Encryption_Key_Size = DeviceInfo->EncryptionKeySize;

                           Result = qapi_BLE_GAP_LE_Reestablish_Security(BluetoothStackID, GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address, &GAP_LE_Security_Information, GAP_LE_Event_Callback, 0);
                           if(Result)
                              QCLI_Printf(ble_group, "GAP_LE_Reestablish_Security returned %d.\n", Result);
                        }
                        else
                        {
                           /* This shouldn't occur, but we will inform  */
                           /* the user if it does.                      */
                           QCLI_Printf(ble_group, "Can't re-establish security: LTK is missing.\n");
                        }
                     }
                  }
               }
            }
            break;
         case QAPI_BLE_ET_LE_DISCONNECTION_COMPLETE_E:
            QCLI_Printf(ble_group, "etLE_Disconnection_Complete with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);

            if(GAP_LE_Event_Data->Event_Data.GAP_LE_Disconnection_Complete_Event_Data)
            {
               QCLI_Printf(ble_group, "   Status: 0x%02X.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Disconnection_Complete_Event_Data->Status);
               QCLI_Printf(ble_group, "   Reason: 0x%02X.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Disconnection_Complete_Event_Data->Reason);

               BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Disconnection_Complete_Event_Data->Peer_Address, BoardStr);
               QCLI_Printf(ble_group, "   BD_ADDR: %s.\n", BoardStr);

               /* Clear the Send Information.                           */
               SendInfo.BytesToSend = 0;
               SendInfo.BytesSent   = 0;
            }
            break;
         case QAPI_BLE_ET_LE_CONNECTION_PARAMETER_UPDATE_REQUEST_E:
            QCLI_Printf(ble_group, "etLE_Connection_Parameter_Update_Request with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

            if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data)
            {
               BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->BD_ADDR, BoardStr);
               QCLI_Printf(ble_group, "   BD_ADDR:                     %s\n", BoardStr);
               QCLI_Printf(ble_group, "   Connection Interval Minimum: %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Interval_Min);
               QCLI_Printf(ble_group, "   Connection Interval Maximum: %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Interval_Max);
               QCLI_Printf(ble_group, "   Slave Latency:               %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Slave_Latency);
               QCLI_Printf(ble_group, "   Supervision Timeout:         %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Supervision_Timeout);

               ConnectionParams.Connection_Interval_Min    = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Interval_Min;
               ConnectionParams.Connection_Interval_Max    = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Interval_Max;
               ConnectionParams.Slave_Latency              = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Slave_Latency;
               ConnectionParams.Supervision_Timeout        = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Supervision_Timeout;
               ConnectionParams.Minimum_Connection_Length  = 0;
               ConnectionParams.Maximum_Connection_Length  = 10000;

               qapi_BLE_GAP_LE_Connection_Parameter_Update_Response(BluetoothStackID, GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->BD_ADDR, TRUE, &ConnectionParams);
            }
            break;
         case QAPI_BLE_ET_LE_CONNECTION_PARAMETER_UPDATED_E:
            QCLI_Printf(ble_group, "etLE_Connection_Parameter_Updated with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

            if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data)
            {
               BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->BD_ADDR, BoardStr);
               QCLI_Printf(ble_group, "   BD_ADDR:             %s\n", BoardStr);
               QCLI_Printf(ble_group, "   Status:              %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->Status);
               QCLI_Printf(ble_group, "   Connection Interval: %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->Current_Connection_Parameters.Connection_Interval);
               QCLI_Printf(ble_group, "   Slave Latency:       %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->Current_Connection_Parameters.Slave_Latency);
               QCLI_Printf(ble_group, "   Supervision Timeout: %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->Current_Connection_Parameters.Supervision_Timeout);
            }
            break;
         case QAPI_BLE_ET_LE_ENCRYPTION_CHANGE_E:
            QCLI_Printf(ble_group, "etLE_Encryption_Change with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);
            break;
         case QAPI_BLE_ET_LE_ENCRYPTION_REFRESH_COMPLETE_E:
            QCLI_Printf(ble_group, "etLE_Encryption_Refresh_Complete with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);
            break;
         case QAPI_BLE_ET_LE_AUTHENTICATION_E:
            QCLI_Printf(ble_group, "etLE_Authentication with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);

            /* Make sure the authentication event data is valid before  */
            /* continuing.                                              */
            if((Authentication_Event_Data = GAP_LE_Event_Data->Event_Data.GAP_LE_Authentication_Event_Data) != NULL)
            {
               BD_ADDRToStr(Authentication_Event_Data->BD_ADDR, BoardStr);

               switch(Authentication_Event_Data->GAP_LE_Authentication_Event_Type)
               {
                  case QAPI_BLE_LAT_LONG_TERM_KEY_REQUEST_E:
                     QCLI_Printf(ble_group, "    latKeyRequest: \n");
                     QCLI_Printf(ble_group, "      BD_ADDR: %s.\n", BoardStr);

                     /* Initialize the authentication response data to  */
                     /* indicate no LTK present (if we find or          */
                     /* re-generate the LTK we will update this         */
                     /* structure accordingly).                         */
                     GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_LONG_TERM_KEY_E;
                     GAP_LE_Authentication_Response_Information.Authentication_Data_Length = 0;

                     /* Initialize some variables to determine if this  */
                     /* is a request for a Long Term Key generated via  */
                     /* Secure Connections (which we must store and can */
                     /* NOT re-generate).                               */
                     memset(&RandomNumber, 0, sizeof(RandomNumber));
                     EDIV = 0;

                     /* Check to see if this is a request for a SC      */
                     /* generated Long Term Key.                        */
                     if((Authentication_Event_Data->Authentication_Event_Data.Long_Term_Key_Request.EDIV == EDIV) && (QAPI_BLE_COMPARE_RANDOM_NUMBER(Authentication_Event_Data->Authentication_Event_Data.Long_Term_Key_Request.Rand, RandomNumber)))
                     {
                        /* Search for the entry for this slave to store */
                        /* the information into.                        */
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                        {
                           /* Check to see if the LTK is valid.         */
                           if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                           {
                              /* Respond with the stored Long Term Key. */
                              GAP_LE_Authentication_Response_Information.Authentication_Data_Length                                        = QAPI_BLE_GAP_LE_LONG_TERM_KEY_INFORMATION_DATA_SIZE;
                              GAP_LE_Authentication_Response_Information.Authentication_Data.Long_Term_Key_Information.Encryption_Key_Size = DeviceInfo->EncryptionKeySize;

                              memcpy(&(GAP_LE_Authentication_Response_Information.Authentication_Data.Long_Term_Key_Information.Long_Term_Key), &(DeviceInfo->LTK), QAPI_BLE_LONG_TERM_KEY_SIZE);
                           }
                        }
                     }
                     else
                     {
                        /* The other side of a connection is requesting */
                        /* that we start encryption.  Thus we should    */
                        /* regenerate LTK for this connection and send  */
                        /* it to the chip.                              */
                        Result = qapi_BLE_GAP_LE_Regenerate_Long_Term_Key(BluetoothStackID, (qapi_BLE_Encryption_Key_t *)(&DHK), (qapi_BLE_Encryption_Key_t *)(&ER), Authentication_Event_Data->Authentication_Event_Data.Long_Term_Key_Request.EDIV, &(Authentication_Event_Data->Authentication_Event_Data.Long_Term_Key_Request.Rand), &GeneratedLTK);
                        if(!Result)
                        {
                           QCLI_Printf(ble_group, "      GAP_LE_Regenerate_Long_Term_Key Success.\n");

                           /* Respond with the Re-Generated Long Term   */
                           /* Key.                                      */
                           GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type                                        = QAPI_BLE_LAR_LONG_TERM_KEY_E;
                           GAP_LE_Authentication_Response_Information.Authentication_Data_Length                                        = QAPI_BLE_GAP_LE_LONG_TERM_KEY_INFORMATION_DATA_SIZE;
                           GAP_LE_Authentication_Response_Information.Authentication_Data.Long_Term_Key_Information.Encryption_Key_Size = QAPI_BLE_GAP_LE_MAXIMUM_ENCRYPTION_KEY_SIZE;
                           GAP_LE_Authentication_Response_Information.Authentication_Data.Long_Term_Key_Information.Long_Term_Key       = GeneratedLTK;
                        }
                        else
                        {
                           QCLI_Printf(ble_group, "      GAP_LE_Regenerate_Long_Term_Key returned %d.\n",Result);
                        }
                     }

                     /* Send the Authentication Response.               */
                     Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                     if(Result)
                     {
                        QCLI_Printf(ble_group, "      GAP_LE_Authentication_Response returned %d.\n",Result);
                     }
                     break;
                  case QAPI_BLE_LAT_SECURITY_REQUEST_E:
                     /* Display the data for this event.                */
                     /* * NOTE * This is only sent from Slave to Master.*/
                     /*          Thus we must be the Master in this     */
                     /*          connection.                            */
                     QCLI_Printf(ble_group, "    latSecurityRequest:.\n");
                     QCLI_Printf(ble_group, "      BD_ADDR: %s.\n", BoardStr);
                     QCLI_Printf(ble_group, "      Bonding Type: %s.\n", ((Authentication_Event_Data->Authentication_Event_Data.Security_Request.Bonding_Type == QAPI_BLE_LBT_BONDING_E)?"Bonding":"No Bonding"));
                     QCLI_Printf(ble_group, "      MITM: %s.\n", ((Authentication_Event_Data->Authentication_Event_Data.Security_Request.MITM)?"YES":"NO"));

                     /* Make sure we are NOT pairing or re-establishing */
                     /* security with another remote device.            */
                     if(QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
                     {
                        /* Go ahead and store the address of the remote */
                        /* device we are currently pairing or           */
                        /* re-establishing security with.               */
                        SecurityRemoteBD_ADDR = Authentication_Event_Data->BD_ADDR;

                        /* Determine if we have previously paired with  */
                        /* the device.  If we have paired we will       */
                        /* attempt to re-establish security using a     */
                        /* previously exchanged LTK.                    */
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                        {
                           /* Determine if a Valid Long Term Key is     */
                           /* stored for this device.                   */
                           if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                           {
                              QCLI_Printf(ble_group, "Attempting to Re-Establish Security.\n");

                              /* Attempt to re-establish security to    */
                              /* this device.                           */
                              GAP_LE_Security_Information.Local_Device_Is_Master                                      = TRUE;
                              memcpy(&(GAP_LE_Security_Information.Security_Information.Master_Information.LTK), &(DeviceInfo->LTK), sizeof(DeviceInfo->LTK));
                              GAP_LE_Security_Information.Security_Information.Master_Information.EDIV                = DeviceInfo->EDIV;
                              memcpy(&(GAP_LE_Security_Information.Security_Information.Master_Information.Rand), &(DeviceInfo->Rand), sizeof(DeviceInfo->Rand));
                              GAP_LE_Security_Information.Security_Information.Master_Information.Encryption_Key_Size = DeviceInfo->EncryptionKeySize;

                              Result = qapi_BLE_GAP_LE_Reestablish_Security(BluetoothStackID, SecurityRemoteBD_ADDR, &GAP_LE_Security_Information, GAP_LE_Event_Callback, 0);
                              if(Result)
                              {
                                 QCLI_Printf(ble_group, "GAP_LE_Reestablish_Security returned %d.\n", Result);
                              }
                           }
                           else
                           {
                              /* We do not have a stored Link Key for   */
                              /* this device so go ahead and pair to    */
                              /* this device.                           */
                              SendPairingRequest(SecurityRemoteBD_ADDR, TRUE);
                           }
                        }
                        else
                        {
                           /* There is no Key Info Entry for this device*/
                           /* so we will just treat this as a slave     */
                           /* request and initiate pairing.             */
                           SendPairingRequest(SecurityRemoteBD_ADDR, TRUE);
                        }
                     }
                     else
                     {
                        /* Inform the user that we cannot accept the    */
                        /* request at this time.                        */
                        QCLI_Printf(ble_group, "\nSecurity is already in progress with another remote device.\n");

                        /* We are currently pairing/re-establishing     */
                        /* security with another remote device so we    */
                        /* should send the negative authentication      */
                        /* response.                                    */
                        GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_ERROR_E;
                        GAP_LE_Authentication_Response_Information.Authentication_Data_Length = 0;

                        /* Submit the Authentication Response.          */
                        if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                           DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                     }
                     break;
                  case QAPI_BLE_LAT_PAIRING_REQUEST_E:
                     QCLI_Printf(ble_group, "Pairing Request: %s.\n", BoardStr);
                     DisplayLegacyPairingInformation(&Authentication_Event_Data->Authentication_Event_Data.Pairing_Request);

                     /* Make sure we are NOT pairing or re-establishing */
                     /* security with another remote device.            */
                     if(QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
                     {
                        /* Go ahead and store the address of the remote */
                        /* device we are currently pairing or           */
                        /* re-establishing security with.               */
                        SecurityRemoteBD_ADDR = Authentication_Event_Data->BD_ADDR;

                        /* This is a pairing request.  Respond with a   */
                        /* Pairing Response.                            */
                        /* * NOTE * This is only sent from Master to    */
                        /*          Slave.  Thus we must be the Slave in*/
                        /*          this connection.                    */

                        /* Send the Pairing Response.                   */
                        SlavePairingRequestResponse(SecurityRemoteBD_ADDR);
                     }
                     else
                     {
                        /* Inform the user that we cannot accept the    */
                        /* request at this time.                        */
                        QCLI_Printf(ble_group, "\nSecurity is already in progress with another remote device.\n");

                        /* We are currently pairing/re-establishing     */
                        /* security with another remote device so we    */
                        /* should send the negative authentication      */
                        /* response.                                    */
                        GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_ERROR_E;
                        GAP_LE_Authentication_Response_Information.Authentication_Data_Length = 0;

                        /* Submit the Authentication Response.          */
                        if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                           DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                     }
                     break;
                  case QAPI_BLE_LAT_EXTENDED_PAIRING_REQUEST_E:
                     QCLI_Printf(ble_group, "Extended Pairing Request: %s.\n", BoardStr);
                     DisplayPairingInformation(&(Authentication_Event_Data->Authentication_Event_Data.Extended_Pairing_Request));

                     /* Make sure we are NOT pairing or re-establishing */
                     /* security with another remote device.            */
                     if(QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
                     {
                        /* Go ahead and store the address of the remote */
                        /* device we are currently pairing or           */
                        /* re-establishing security with.               */
                        SecurityRemoteBD_ADDR = Authentication_Event_Data->BD_ADDR;

                        /* This is a pairing request.  Respond with a   */
                        /* Pairing Response.                            */
                        /* * NOTE * This is only sent from Master to    */
                        /*          Slave.  Thus we must be the Slave in*/
                        /*          this connection.                    */

                        /* Send the Pairing Response.                   */
                        SlavePairingRequestResponse(Authentication_Event_Data->BD_ADDR);
                     }
                     else
                     {
                        /* Inform the user that we cannot accept the    */
                        /* request at this time.                        */
                        QCLI_Printf(ble_group, "\nSecurity is already in progress with another remote device.\n");

                        /* We are currently pairing/re-establishing     */
                        /* security with another remote device so we    */
                        /* should send the negative authentication      */
                        /* response.                                    */
                        GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_ERROR_E;
                        GAP_LE_Authentication_Response_Information.Authentication_Data_Length = 0;

                        /* Submit the Authentication Response.          */
                        if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                           DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                     }
                     break;
                  case QAPI_BLE_LAT_CONFIRMATION_REQUEST_E:
                     QCLI_Printf(ble_group, "latConfirmationRequest.\n");

                     /* Check to see what type of confirmation request  */
                     /* this is.                                        */
                     switch(Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Request_Type)
                     {
                        case QAPI_BLE_CRT_NONE_E:
                           /* Handle the just works request.            */
                           GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_CONFIRMATION_E;

                           /* By setting the Authentication_Data_Length */
                           /* to any NON-ZERO value we are informing the*/
                           /* GAP LE Layer that we are accepting Just   */
                           /* Works Pairing.                            */
                           GAP_LE_Authentication_Response_Information.Authentication_Data_Length = sizeof(uint32_t);

                           /* Handle this differently based on the local*/
                           /* IO Caps.                                  */
                           switch(LE_Parameters.IOCapability)
                           {
                              case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
                                 QCLI_Printf(ble_group, "Invoking Just Works.\n");

                                 /* By setting the                      */
                                 /* Authentication_Data_Length to any   */
                                 /* NON-ZERO value we are informing the */
                                 /* GAP LE Layer that we are accepting  */
                                 /* Just Works Pairing.                 */

                                 Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                                 if(Result)
                                 {
                                    QCLI_Printf(ble_group, "qapi_BLE_GAP_LE_Authentication_Response returned %d.\n", Result);
                                 }
                                 break;
                              case QAPI_BLE_LIC_DISPLAY_ONLY_E:
                                 QCLI_Printf(ble_group, "Confirmation of Pairing.\n");

                                 GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Display_Passkey;

                                 /* Submit the Authentication Response. */
                                 if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                    DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                 break;
                              default:
                                 QCLI_Printf(ble_group, "Confirmation of Pairing.\n");

                                 /* Submit the Authentication Response. */
                                 if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                    DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                 break;
                           }
                           break;
                        case QAPI_BLE_CRT_PASSKEY_E:
                           /* Inform the user to call the appropriate   */
                           /* command.                                  */
                           QCLI_Printf(ble_group, "Call LEPasskeyResponse [PASSCODE].\n");
                           break;
                        case QAPI_BLE_CRT_DISPLAY_E:
                           QCLI_Printf(ble_group, "Passkey: %06u.\n", (unsigned int)(Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Display_Passkey));
                           break;
                        default:
                           /* This application doesn't support OOB and  */
                           /* Secure Connections request types will be  */
                           /* handled by the ExtendedConfirmationRequest*/
                           /* event.  So we will simply inform the user.*/
                           QCLI_Printf(ble_group, "Authentication method not supported.\n");
                           break;
                     }
                     break;
                  case QAPI_BLE_LAT_EXTENDED_CONFIRMATION_REQUEST_E:
                     QCLI_Printf(ble_group, "latExtendedConfirmationRequest.\n");

                     QCLI_Printf(ble_group, "   Secure Connections:     %s.\n", (Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Flags & QAPI_BLE_GAP_LE_EXTENDED_CONFIRMATION_REQUEST_FLAGS_SECURE_CONNECTIONS)?"YES":"NO");
                     QCLI_Printf(ble_group, "   Just Works Pairing:     %s.\n", (Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Flags & QAPI_BLE_GAP_LE_EXTENDED_CONFIRMATION_REQUEST_FLAGS_JUST_WORKS_PAIRING)?"YES":"NO");
                     QCLI_Printf(ble_group, "   Keypress Notifications: %s.\n", (Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Flags & QAPI_BLE_GAP_LE_EXTENDED_CONFIRMATION_REQUEST_FLAGS_KEYPRESS_NOTIFICATIONS_REQUESTED)?"YES":"NO");

                     /* Check to see what type of confirmation request  */
                     /* this is.                                        */
                     switch(Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Request_Type)
                     {
                        case QAPI_BLE_CRT_NONE_E:
                           /* Handle the just works request.            */
                           GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_CONFIRMATION_E;

                           /* By setting the Authentication_Data_Length */
                           /* to any NON-ZERO value we are informing the*/
                           /* GAP LE Layer that we are accepting Just   */
                           /* Works Pairing.                            */
                           GAP_LE_Authentication_Response_Information.Authentication_Data_Length = sizeof(uint32_t);

                           /* Handle this differently based on the local*/
                           /* IO Caps.                                  */
                           switch(LE_Parameters.IOCapability)
                           {
                              case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
                                 QCLI_Printf(ble_group, "Invoking Just Works.\n");

                                 /* Just Accept Just Works Pairing.     */
                                 Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                                 if(Result)
                                 {
                                    QCLI_Printf(ble_group, "qapi_BLE_GAP_LE_Authentication_Response returned %d.\n", Result);
                                 }
                                 break;
                              case QAPI_BLE_LIC_DISPLAY_ONLY_E:
                                 QCLI_Printf(ble_group, "Confirmation of Pairing.\n");

                                 GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Display_Passkey;

                                 /* Submit the Authentication Response. */
                                 if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                    DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                 break;
                              default:
                                 QCLI_Printf(ble_group, "Confirmation of Pairing.\n");

                                 /* Submit the Authentication Response. */
                                 if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                    DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                 break;
                           }
                           break;
                        case QAPI_BLE_CRT_PASSKEY_E:
                           /* Inform the user to call the appropriate   */
                           /* command.                                  */
                           QCLI_Printf(ble_group, "Call LEPasskeyResponse [PASSKEY].\n");
                           break;
                        case QAPI_BLE_CRT_DISPLAY_E:
                           QCLI_Printf(ble_group, "Passkey: %06u.\n", Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Display_Passkey);

                           GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type  = QAPI_BLE_LAR_PASSKEY_E;
                           GAP_LE_Authentication_Response_Information.Authentication_Data_Length  = (uint8_t)(sizeof(uint32_t));
                           GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Display_Passkey;

                           /* Since this is in an extended confirmation */
                           /* request we need to respond to the display */
                           /* request.                                  */
                           if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                              DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                           break;
                        case QAPI_BLE_CRT_DISPLAY_YES_NO_E:
                           /* Handle the Display Yes/No request.        */
                           GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_CONFIRMATION_E;

                           /* By setting the Authentication_Data_Length */
                           /* to any NON-ZERO value we are informing the*/
                           /* GAP LE Layer that we are accepting Just   */
                           /* Works Pairing.                            */
                           GAP_LE_Authentication_Response_Information.Authentication_Data_Length = sizeof(uint32_t);

                           /* Check to see if this is Just Works or     */
                           /* Numeric Comparison.                       */
                           if(Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Flags & QAPI_BLE_GAP_LE_EXTENDED_CONFIRMATION_REQUEST_FLAGS_JUST_WORKS_PAIRING)
                           {
                              /* Handle this differently based on the   */
                              /* local IO Caps.                         */
                              switch(LE_Parameters.IOCapability)
                              {
                                 case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
                                    QCLI_Printf(ble_group, "Invoking Just Works.\n");

                                    /* Just Accept Just Works Pairing.  */
                                    Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                                    if(Result)
                                    {
                                       QCLI_Printf(ble_group, "qapi_BLE_GAP_LE_Authentication_Response returned %d.\n", Result);
                                    }
                                    break;
                                 case QAPI_BLE_LIC_DISPLAY_ONLY_E:
                                    QCLI_Printf(ble_group, "Confirmation of Pairing.\n");

                                    GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Display_Passkey;

                                    /* Submit the Authentication        */
                                    /* Response.                        */
                                    if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                       DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                    break;
                                 default:
                                    QCLI_Printf(ble_group, "Confirmation of Pairing.\n");

                                    /* Submit the Authentication        */
                                    /* Response.                        */
                                    if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                       DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                    break;
                              }
                           }
                           else
                           {
                              /* This is numeric comparison so go ahead */
                              /* and display the numeric value to       */
                              /* confirm.                               */
                              QCLI_Printf(ble_group, "Confirmation Value: %ld\n", (unsigned long)Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Display_Passkey);

                              /* Submit the Authentication Response.    */
                              if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                 DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                              break;
                           }
                           break;
                        case QAPI_BLE_CRT_OOB_SECURE_CONNECTIONS_E:
                           QCLI_Printf(ble_group, "OOB Data Request.\n");

                           /* Format the response.                      */
                           GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_OUT_OF_BAND_DATA_E;
                           GAP_LE_Authentication_Response_Information.Authentication_Data_Length = QAPI_BLE_GAP_LE_SECURE_CONNECTIONS_OOB_DATA_SIZE;

                           /* Check to see if we have remote OOB data.  */
                           if(RemoteOOBValid)
                           {
                              GAP_LE_Authentication_Response_Information.Authentication_Data.Secure_Connections_OOB_Data.Flags        = 0;
                              GAP_LE_Authentication_Response_Information.Authentication_Data.Secure_Connections_OOB_Data.Confirmation = RemoteOOBConfirmation;
                              GAP_LE_Authentication_Response_Information.Authentication_Data.Secure_Connections_OOB_Data.Randomizer   = RemoteOOBRandomizer;
                           }
                           else
                              GAP_LE_Authentication_Response_Information.Authentication_Data.Secure_Connections_OOB_Data.Flags = QAPI_BLE_GAP_LE_SECURE_CONNECTIONS_OOB_DATA_FLAGS_OOB_NOT_RECEIVED;

                           /* Submit the Authentication Response.       */
                           if((Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                              DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                           break;
                        default:
                           /* This application doesn't support OOB so we*/
                           /* will simply inform the user.              */
                           QCLI_Printf(ble_group, "Authentication method not supported.\n");
                           break;
                     }
                     break;
                  case QAPI_BLE_LAT_SECURITY_ESTABLISHMENT_COMPLETE_E:
                     QCLI_Printf(ble_group, "Security Re-Establishment Complete: %s.\n", BoardStr);
                     QCLI_Printf(ble_group, "                            Status: 0x%02X.\n", Authentication_Event_Data->Authentication_Event_Data.Security_Establishment_Complete.Status);

                     /* If this failed due to a LTK issue then we should*/
                     /* delete the LTK.                                 */
                     if(Authentication_Event_Data->Authentication_Event_Data.Security_Establishment_Complete.Status == QAPI_BLE_GAP_LE_SECURITY_ESTABLISHMENT_STATUS_CODE_LONG_TERM_KEY_ERROR)
                     {
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                        {
                           /* Clear the flag indicating the LTK is      */
                           /* valid.                                    */
                           DeviceInfo->Flags &= ~DEVICE_INFO_FLAGS_LTK_VALID;
                        }
                     }

                     /* Flag the we are no longer                       */
                     /* pairing/re-establishing security with a remote  */
                     /* device.                                         */
                     QAPI_BLE_ASSIGN_BD_ADDR(SecurityRemoteBD_ADDR, 0, 0, 0, 0, 0, 0);
                     break;
                  case QAPI_BLE_LAT_PAIRING_STATUS_E:
                     QCLI_Printf(ble_group, "Pairing Status: %s.\n", BoardStr);
                     QCLI_Printf(ble_group, "        Status: 0x%02X.\n", Authentication_Event_Data->Authentication_Event_Data.Pairing_Status.Status);

                     if(Authentication_Event_Data->Authentication_Event_Data.Pairing_Status.Status == QAPI_BLE_GAP_LE_PAIRING_STATUS_NO_ERROR)
                     {
                        QCLI_Printf(ble_group, "        Key Size: %d.\n", Authentication_Event_Data->Authentication_Event_Data.Pairing_Status.Negotiated_Encryption_Key_Size);
                     }
                     else
                     {
                        /* Disconnect the Link.                         */
                        /* * NOTE * Since we failed to pair, the remote */
                        /*          device information will be deleted  */
                        /*          when the GATT Disconnection event is*/
                        /*          received.                           */
                        qapi_BLE_GAP_LE_Disconnect(BluetoothStackID, Authentication_Event_Data->BD_ADDR);
                     }

                     /* Flag the we are no longer                       */
                     /* pairing/re-establishing security with a remote  */
                     /* device.                                         */
                     QAPI_BLE_ASSIGN_BD_ADDR(SecurityRemoteBD_ADDR, 0, 0, 0, 0, 0, 0);
                     break;
                  case QAPI_BLE_LAT_ENCRYPTION_INFORMATION_REQUEST_E:
                     QCLI_Printf(ble_group, "Encryption Information Request %s.\n", BoardStr);

                     /* Generate new LTK, EDIV and Rand and respond with*/
                     /* them.                                           */
                     EncryptionInformationRequestResponse(Authentication_Event_Data->BD_ADDR, Authentication_Event_Data->Authentication_Event_Data.Encryption_Request_Information.Encryption_Key_Size, &GAP_LE_Authentication_Response_Information);
                     break;
                  case QAPI_BLE_LAT_IDENTITY_INFORMATION_REQUEST_E:
                     QCLI_Printf(ble_group, "Identity Information Request %s.\n", BoardStr);

                     /* Store our identity information to send to the   */
                     /* remote device since it has been requested.      */
                     /* * NOTE * This demo will ALWAYS use the local    */
                     /*          public address as the identity address */
                     /*          since it is known to the user.         */
                     GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type                            = QAPI_BLE_LAR_IDENTITY_INFORMATION_E;
                     GAP_LE_Authentication_Response_Information.Authentication_Data_Length                            = (uint8_t)QAPI_BLE_GAP_LE_IDENTITY_INFORMATION_DATA_SIZE;
                     GAP_LE_Authentication_Response_Information.Authentication_Data.Identity_Information.Address      = LocalBD_ADDR;
                     GAP_LE_Authentication_Response_Information.Authentication_Data.Identity_Information.Address_Type = QAPI_BLE_LAT_PUBLIC_IDENTITY_E;
                     GAP_LE_Authentication_Response_Information.Authentication_Data.Identity_Information.IRK          = IRK;

                     /* Send the authentication response.               */
                     Result = qapi_BLE_GAP_LE_Authentication_Response(BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                     if(!Result)
                     {
                        QCLI_Printf(ble_group, "   qapi_BLE_GAP_LE_Authentication_Response (larEncryptionInformation) success.\n");
                     }
                     else
                     {
                        QCLI_Printf(ble_group, "   Error - SM_Generate_Long_Term_Key returned %d.\n", Result);
                     }
                     break;
                  case QAPI_BLE_LAT_ENCRYPTION_INFORMATION_E:
                     /* Display the information from the event.         */
                     QCLI_Printf(ble_group, " Encryption Information from RemoteDevice: %s.\n", BoardStr);
                     QCLI_Printf(ble_group, "                             Key Size: %d.\n", Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.Encryption_Key_Size);

                     /* Search for the entry for this slave to store the*/
                     /* information into.                               */
                     if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                     {
                        memcpy(&(DeviceInfo->LTK), &(Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.LTK), sizeof(DeviceInfo->LTK));
                        DeviceInfo->EDIV              = Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.EDIV;
                        memcpy(&(DeviceInfo->Rand), &(Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.Rand), sizeof(DeviceInfo->Rand));
                        DeviceInfo->EncryptionKeySize = Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.Encryption_Key_Size;
                        DeviceInfo->Flags            |= DEVICE_INFO_FLAGS_LTK_VALID;
                     }
                     else
                     {
                        QCLI_Printf(ble_group, "No Key Info Entry for this device.\n");
                     }
                     break;
                  case QAPI_BLE_LAT_IDENTITY_INFORMATION_E:
                     /* Display the information from the event.         */
                     QCLI_Printf(ble_group, " Identity Information from RemoteDevice: %s.\n", BoardStr);

                     /* Search for the entry for this slave to store the*/
                     /* information into.                               */
                     if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                     {
                        /* Store the identity information for the remote*/
                        /* device.                                      */
                        memcpy(&(DeviceInfo->IRK), &(Authentication_Event_Data->Authentication_Event_Data.Identity_Information.IRK), sizeof(DeviceInfo->IRK));
                        DeviceInfo->IdentityAddressBD_ADDR = Authentication_Event_Data->Authentication_Event_Data.Identity_Information.Address;
                        DeviceInfo->IdentityAddressType    = Authentication_Event_Data->Authentication_Event_Data.Identity_Information.Address_Type;
                        DeviceInfo->Flags                 |= DEVICE_INFO_FLAGS_IRK_VALID;

                        /* Setup the resolving list entry to add to the */
                        /* resolving list.                              */
                        DeviceInfo->ResolvingListEntry.Peer_Identity_Address      = DeviceInfo->IdentityAddressBD_ADDR;
                        DeviceInfo->ResolvingListEntry.Peer_Identity_Address_Type = DeviceInfo->IdentityAddressType;
                        DeviceInfo->ResolvingListEntry.Peer_IRK                   = DeviceInfo->IRK;
                        DeviceInfo->ResolvingListEntry.Local_IRK                  = IRK;
                     }
                     else
                     {
                        QCLI_Printf(ble_group, "No Key Info Entry for this device.\n");
                     }
                     break;
                  default:
                     QCLI_Printf(ble_group, "Unhandled event: %u\n", Authentication_Event_Data->GAP_LE_Authentication_Event_Type);
                     break;
               }
            }
            break;
         case QAPI_BLE_ET_LE_DIRECT_ADVERTISING_REPORT_E:
            QCLI_Printf(ble_group, "etLE_Direct_Advertising_Report with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);
            QCLI_Printf(ble_group, "  %d Responses.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Direct_Advertising_Report_Event_Data->Number_Device_Entries);

            for(Index = 0; Index < GAP_LE_Event_Data->Event_Data.GAP_LE_Direct_Advertising_Report_Event_Data->Number_Device_Entries; Index++)
            {
               DirectDeviceEntryPtr = &(GAP_LE_Event_Data->Event_Data.GAP_LE_Direct_Advertising_Report_Event_Data->Direct_Advertising_Data[Index]);

               /* Display the Address Type.                             */
               switch(DirectDeviceEntryPtr->Address_Type)
               {
                  case QAPI_BLE_LAT_PUBLIC_E:
                     QCLI_Printf(ble_group, "  Address Type: %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_E:
                     QCLI_Printf(ble_group, "  Address Type: %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                     break;
                  case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                     QCLI_Printf(ble_group, "  Address Type: %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                     break;
                  case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                     QCLI_Printf(ble_group, "  Address Type: %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                     break;
                  default:
                     QCLI_Printf(ble_group, "  Address Type: Invalid.\n");
                     break;
               }

               /* Display the Device Address.                           */
               QCLI_Printf(ble_group, "  Address:      0x%02X%02X%02X%02X%02X%02X.\n", DirectDeviceEntryPtr->BD_ADDR.BD_ADDR5, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR4, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR3, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR2, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR1, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR0);
               QCLI_Printf(ble_group, "  RSSI:         %d.\n", (int)(DirectDeviceEntryPtr->RSSI));
            }
            break;
         default:
            DisplayPrompt = false;
            break;
      }

      if(DisplayPrompt)
         QCLI_Display_Prompt();
   }
}

   /* Generic Attribute Profile (GATT) Event Callback function          */
   /* prototypes.                                                       */

   /* The following function is for an GATT Connection Event Callback.  */
   /* This function is called for GATT Connection Events that occur on  */
   /* the specified Bluetooth Stack.  This function passes to the caller*/
   /* the GATT Connection Event Data that occurred and the GATT         */
   /* Connection Event Callback Parameter that was specified when this  */
   /* Callback was installed.  The caller is free to use the contents of*/
   /* the GATT Client Event Data ONLY in the context of this callback.  */
   /* If the caller requires the Data for a longer period of time, then */
   /* the callback function MUST copy the data into another Data Buffer.*/
   /* This function is guaranteed NOT to be invoked more than once      */
   /* simultaneously for the specified installed callback (i.e.  this   */
   /* function DOES NOT have be reentrant).  It Needs to be noted       */
   /* however, that if the same Callback is installed more than once,   */
   /* then the callbacks will be called serially.  Because of this, the */
   /* processing in this function should be as efficient as possible.   */
   /* It should also be noted that this function is called in the Thread*/
   /* Context of a Thread that the User does NOT own.  Therefore,       */
   /* processing in this function should be as efficient as possible    */
   /* (this argument holds anyway because another GATT Event            */
   /* (Server/Client or Connection) will not be processed while this    */
   /* function call is outstanding).                                    */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_Connection_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GATT_Connection_Event_Data_t *GATT_Connection_Event_Data, uint32_t CallbackParameter)
{
   boolean_t                    DisplayPrompt;
   int                          Result;
   uint16_t                     Credits;
   uint16_t                     MTU;
   BoardStr_t                   BoardStr;
   DeviceInfo_t                *DeviceInfo = NULL;
   uint32_t                     ConnectionID;
   unsigned int                 Index;
   boolean_t                    FoundMatch = FALSE;
   AIOP_Client_Instance_Info_t *ClientInstancePtr;
   unsigned int                 Index1;
   unsigned int                 Index2;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GATT_Connection_Event_Data))
   {
      DisplayPrompt = true;

      /* Determine the Connection Event that occurred.                  */
      switch(GATT_Connection_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_GATT_CONNECTION_DEVICE_CONNECTION_E:
            if(GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data)
            {
               /* Save the Connection ID for later use.                 */
               ConnectionID = GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->ConnectionID;

               QCLI_Printf(ble_group, "etGATT_Connection_Device_Connection with size %u: \n", GATT_Connection_Event_Data->Event_Data_Size);
               BD_ADDRToStr(GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice, BoardStr);
               QCLI_Printf(ble_group, "   Connection ID:   %u.\n", GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->ConnectionID);
               QCLI_Printf(ble_group, "   Connection Type: %s.\n", ((GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
               QCLI_Printf(ble_group, "   Remote Device:   %s.\n", BoardStr);
               QCLI_Printf(ble_group, "   Connection MTU:  %u.\n", GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->MTU);

               /* Let's try to find the remote device information.  This*/
               /* will be the case if we previously connected and bonded*/
               /* with the remote device.                               */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice)) == NULL)
               {
                  /* This MUST be a new remote device so we will create */
                  /* a remote device information entry.                 */
                  if((DeviceInfo = CreateNewDeviceInfoEntry(&DeviceInfoList, GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice)) == NULL)
                     QCLI_Printf(ble_group, "Failed to create remote device information.\n");
               }

               /* Make sure we found the remote device information entry*/
               /* or created it.                                        */
               if(DeviceInfo)
               {
                  /* Increment the number of connected remote devices.  */
                  ConnectionCount++;

                  /* The connected remote device will always become the */
                  /* selected remote device.                            */
                  SelectedRemoteBD_ADDR = GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice;

                  /* Inform the user of the selected remote device.     */
                  QCLI_Printf(ble_group, "\nSelected Remote Device:\n");
                  QCLI_Printf(ble_group, "   Address:       %s\n", BoardStr);
                  QCLI_Printf(ble_group, "   ID:            %u\n", ConnectionID);

                  /* Store the information for the remote device.       */
                  /* * NOTE * The LocalDeviceIsMaster and               */
                  /*          RemoteAddressType are temporary globals   */
                  /*          that hold information from the GAP LE     */
                  /*          Connection Complete event that MUST be    */
                  /*          stored in the remote device infromation.  */
                  /* * NOTE * The ConnectionID is a unique value for    */
                  /*          every GATT Connection and will be used to */
                  /*          update the selected remote device.        */
                  DeviceInfo->RemoteDeviceIsMaster = (LocalDeviceIsMaster) ? FALSE : TRUE;
                  DeviceInfo->RemoteAddressType    = RemoteAddressType;
                  DeviceInfo->ConnectionID         = ConnectionID;

                  /* Set the HIDS Protocol Mode to Report by default.   */
                  HIDS_Protocol_Mode = QAPI_BLE_PM_REPORT_E;

                  /* Initialize the Transmit and Receive Buffers.       */
                  InitializeBuffer(&(DeviceInfo->ReceiveBuffer));
                  InitializeBuffer(&(DeviceInfo->TransmitBuffer));

                  /* Initialize the Transmit Credits count.             */
                  DeviceInfo->TransmitCredits = 0;

                  /* Attempt to update the MTU to the maximum supported.*/
                  if(!qapi_BLE_GATT_Query_Maximum_Supported_MTU(BluetoothStackID, &MTU))
                     qapi_BLE_GATT_Exchange_MTU_Request(BluetoothStackID, DeviceInfo->ConnectionID, MTU, GATT_ClientEventCallback_GAPS, 0);

                  /* Check to see if we are bonded and the Tx Credit    */
                  /* notifications have been enabled.                   */
                  if((DeviceInfo->Flags & (DEVICE_INFO_FLAGS_LTK_VALID | DEVICE_INFO_FLAGS_SPPLE_SERVER)) == (DEVICE_INFO_FLAGS_LTK_VALID | DEVICE_INFO_FLAGS_SPPLE_SERVER))
                  {
                     if(DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                     {
                        /* Send the Initial Credits if the Rx Credit CCD*/
                        /* is already configured (for a bonded device   */
                        /* this could be the case).                     */
                        SendCredits(DeviceInfo, DeviceInfo->ReceiveBuffer.BytesFree);
                     }
                  }
               }
               else
               {
                  /* Simply disconnect the remote device since an error */
                  /* occured.                                           */
                  if((Result = qapi_BLE_GAP_LE_Disconnect(BluetoothStackID, GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice)) != 0)
                     QCLI_Printf(ble_group, "qapi_BLE_GAP_LE_Disconnect returned %d.\n", Result);
               }
            }
            else
               QCLI_Printf(ble_group, "Error - Null Connection Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CONNECTION_DEVICE_DISCONNECTION_E:
            if(GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data)
            {
               QCLI_Printf(ble_group, "etGATT_Connection_Device_Disconnection with size %u: \n", GATT_Connection_Event_Data->Event_Data_Size);
               BD_ADDRToStr(GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data->RemoteDevice, BoardStr);
               QCLI_Printf(ble_group, "   Connection ID:   %u.\n", GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data->ConnectionID);
               QCLI_Printf(ble_group, "   Connection Type: %s.\n", ((GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
               QCLI_Printf(ble_group, "   Remote Device:   %s.\n", BoardStr);

               /* Get the remote device information.                    */
               /* * NOTE * If the stack is shutting down, then the      */
               /*          ConnectionCount will be reset to zero.       */
               /*          CloseStack() will send a disconnection       */
               /*          request to each connected remote device.  It */
               /*          will also free the remote device information */
               /*          entries, so we do not need to handle it here.*/
               if((ConnectionCount) && (DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data->RemoteDevice)) != NULL)
               {
                  /* Decrement the number of connected remote devices.  */
                  ConnectionCount--;

                  /* Try to print out the throughput in case it was not */
                  /* printed before the disconnection.                  */
                  DisplayThroughput(DeviceInfo);

                  /* If we have paired with the remote device, then the */
                  /* LTK will be valid and the device information MUST  */
                  /* persist between connections.                       */
                  if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                  {
                     /* Flag that no service discovery operation is     */
                     /* outstanding for this device.                    */
                     DeviceInfo->Flags &= ~DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING;

                     /* Reset the GATT Connection ID to indicate that   */
                     /* the remote device is no longer connected.       */
                     DeviceInfo->ConnectionID = 0;
                  }
                  else
                  {
                     /* Remove the remote device information entry from */
                     /* the list since it is no longer needed.          */
                     if((DeviceInfo = DeleteDeviceInfoEntry(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                     {
                        /* Inform the user the remote device information*/
                        /* is being deleted.                            */
                        QCLI_Printf(ble_group, "\nThe remote device information has been deleted.\n", BoardStr);

                        /* The entry has been removed from the list so  */
                        /* we just need to free the memory.             */
                        FreeDeviceInfoEntryMemory(DeviceInfo);
                        DeviceInfo = NULL;
                     }
                  }
               }

               /* If a remote device is still connected, then the first */
               /* connected remote device will become the selected      */
               /* remote device.                                        */
               if(ConnectionCount)
               {
                  /* Loop through the device information.               */
                  DeviceInfo = DeviceInfoList;
                  while(DeviceInfo)
                  {
                     /* Simply check if the GATT Connection ID is       */
                     /* non-zero.  If this is the case, then we are     */
                     /* connected to the remote device.                 */
                     if(DeviceInfo->ConnectionID)
                     {
                        /* Update the selected remote device.           */
                        SelectedRemoteBD_ADDR = DeviceInfo->RemoteAddress;

                        /* Inform the user of the selected remote       */
                        /* device.                                      */
                        QCLI_Printf(ble_group, "\nSelected Remote Device:\n");
                        BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
                        QCLI_Printf(ble_group, "   Address:       %s\n", BoardStr);
                        QCLI_Printf(ble_group, "   ID:            %u\n", DeviceInfo->ConnectionID);

                        /* We are done.                                 */
                        break;
                     }

                     /* Get the next remote device's information.       */
                     DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
                  }
               }
            }
            else
               QCLI_Printf(ble_group, "Error - Null Disconnection Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CONNECTION_SERVER_NOTIFICATION_E:
            if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data)
            {
               DisplayPrompt = false;

               /* Find the Device Info for the device that has sent us  */
               /* the notification.                                     */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->RemoteDevice)) != NULL)
               {
                  /* Handle the AIOS notifications.                     */

                  /* We will first loop through the AIOS Digital        */
                  /* Characteristic instances for a matching attribute  */
                  /* handle.                                            */
                  for(Index = 0; (!FoundMatch) && (Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES); Index++)
                  {
                     /* Store a pointer to the AIOS Client's instance   */
                     /* information.                                    */
                     ClientInstancePtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_DIGITAL_E].Instances[Index]);

                     /* If we find a match.                             */
                     if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == ClientInstancePtr->Digital_Characteristic_Handle)
                     {
                        /* Flag that we found a match.                  */
                        FoundMatch = TRUE;

                        /* Decode and display the digital               */
                        /* characteristic.                              */
                        DecodeDisplayDigitalCharacteristic(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue, Index);
                        break;
                     }
                  }

                  /* Loop through the AIOS Analog Characteristic        */
                  /* instances for a matching attribute handle.         */
                  for(Index = 0; (!FoundMatch) && (Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES); Index++)
                  {
                     /* Store a pointer to the AIOS Client's instance   */
                     /* information.                                    */
                     ClientInstancePtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_ANALOG_E].Instances[Index]);

                     /* If we find a match.                             */
                     if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == ClientInstancePtr->Analog_Charactersitic_Handle)
                     {
                        /* Flag that we found a match.                  */
                        FoundMatch = TRUE;

                        /* Decode and display the analog characteristic.*/
                        DecodeDisplayAnalogCharacteristic(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue, Index);
                        break;
                     }
                  }

                  /* If a match has been found.                         */
                  if(FoundMatch == TRUE)
                  {
                     /* We found a match so we are done.                */
                     break;
                  }

                  /* Handle the BAS notifications.                      */

                  /* If multiple BAS instances are supported, then we   */
                  /* MUST check each instances attribute handle for a   */
                  /* match.                                             */
                  for(Index = 0; (!FoundMatch) && (Index < (unsigned int)MAX_SUPPORTED_BATTERY_INSTANCES); Index++)
                  {
                     /* Determine if this notification is for the BAS   */
                     /* Battery Level.                                  */
                     if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->BASClientInfo[Index].Battery_Level)
                     {
                        /* Make sure the ValueLength is valid.          */
                        if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength >= (uint16_t)QAPI_BLE_BAS_BATTERY_LEVEL_VALUE_LENGTH)
                        {
                           /* Display the battery level.                */
                           /* * NOTE * The battery level is already     */
                           /*          decoded.                         */
                           QCLI_Printf(ble_group, "\nBattery Level:  %u%%.\n", *(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue));
                        }
                        else
                           QCLI_Printf(ble_group, "Invaid length received for the battery level notification.\n");

                        /* Flag that we found a match.                  */
                        FoundMatch = TRUE;
                     }
                  }

                  /* If a match has been found.                         */
                  if(FoundMatch == TRUE)
                  {
                     /* We found a match so we are done.                */
                     break;
                  }

                  /* Handle the HIDS notifications.                     */

                  /* Loop through the HIDS instances to see if this was */
                  /* a HID report Notification.                         */
                  for(Index1 = 0; (!FoundMatch) && (Index1 < MAX_SUPPORTED_HID_INSTANCES); Index1++)
                  {
                     /* Loop through the reports and see if this was a  */
                     /* HID Report Notification.                        */
                     for(Index2 = 0; Index2 < HIDS_MAXIMUM_NUMBER_REPORTS; Index2++)
                     {
                        /* Check the HID report attribute handle.       */
                        if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->HIDSClientInfo[Index1].Reports[Index2].Handle)
                        {
                           QCLI_Printf(ble_group, "\nReceived HIDS report notification.\n");

                           /* Flag that we found a match.               */
                           FoundMatch = TRUE;

                           /* We cannot match another attribute handle. */
                           break;
                        }
                     }
                  }

                  /* If a match has been found.                         */
                  if(FoundMatch == TRUE)
                  {
                     //xxxDisplayreport

                     /* We found a match so we are done.                */
                     break;
                  }

                  /* Handle the HRS notifications.                      */

                  /* If this notification is for the HRS Measurement    */
                  /* Characteristic.                                    */
                  if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->HRSClientInfo.Heart_Rate_Measurement)
                  {
                     /* Simply call the internal function to decode and */
                     /* display the HRS Measurement.                    */
                     DecodeDisplayHeartRate(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue, TRUE);

                     /* We cannot match another attribute handle.       */
                     break;
                  }

                  /* Handle the SCPS notifications.                     */

                  /* If this notification is for the SCPS Scan Refresh  */
                  /* Characteristic.                                    */
                  if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->SCPSClientInfo.Scan_Refresh)
                  {
                     /* Verify that the length of the SCPS Scan Refresh */
                     /* Notification is correct.                        */
                     if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength >= sizeof(uint8_t))
                     {
                        QCLI_Printf(ble_group, "\nScan Refresh:  %u.\n", *(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue));
                     }
                     else
                        QCLI_Printf(ble_group, "Invaid length received for the scan refresh notification.\n");

                     /* We cannot match another attribute handle.       */
                     break;
                  }

                  /* Handle the SPPLE notifications.                    */

                  /* If this notification is for the SPPLE Rx Credit    */
                  /* Characteristic.                                    */
                  if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->ClientInfo.Rx_Credit_Characteristic)
                  {
                     /* Verify that the length of the Rx Credit         */
                     /* Notification is correct.                        */
                     if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength == sizeof(uint16_t))
                     {
                        Credits = READ_UNALIGNED_WORD_LITTLE_ENDIAN(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue);

                        /* Handle the received credits event.           */
                        DisplayPrompt = ReceiveCreditEvent(DeviceInfo, Credits);
                     }

                     /* We cannot match another attribute handle.       */
                     break;
                  }

                  /* If this notification is for the SPPLE Tx Credit    */
                  /* Characteristic.                                    */
                  if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->ClientInfo.Tx_Characteristic)
                  {
                     /* This is a Tx Characteristic Event.  So call the */
                     /* function to handle the data indication event.   */
                     DisplayPrompt = DataIndicationEvent(DeviceInfo, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue);

                     /* We cannot match another attribute handle.       */
                     break;
                  }

                  /* Inform the user we received a notification for an  */
                  /* unknown handle.                                    */
                  QCLI_Printf(ble_group, "Error - Unknown attribute handle for notification.\n");
                  DisplayPrompt = true;
               }
            }
            else
               QCLI_Printf(ble_group, "Error - Null Server Notification Data.\n");
            break;
         default:
            DisplayPrompt = false;
            break;
      }

      if(DisplayPrompt)
         QCLI_Display_Prompt();
   }
}

   /* The following function is for an GATT Discovery Event Callback.   */
   /* This function will be called whenever a GATT Service is discovered*/
   /* or a previously started service discovery process is completed.   */
   /* This function passes to the caller the GATT Discovery Event Data  */
   /* that occurred and the GATT Client Event Callback Parameter that   */
   /* was specified when this Callback was installed.  The caller is    */
   /* free to use the contents of the GATT Discovery Event Data ONLY in */
   /* the context of this callback.  If the caller requires the Data for*/
   /* a longer period of time, then the callback function MUST copy the */
   /* data into another Data Buffer.  This function is guaranteed NOT to*/
   /* be invoked more than once simultaneously for the specified        */
   /* installed callback (i.e.  this function DOES NOT have be          */
   /* reentrant).  It Needs to be noted however, that if the same       */
   /* Callback is installed more than once, then the callbacks will be  */
   /* called serially.  Because of this, the processing in this function*/
   /* should be as efficient as possible.  It should also be noted that */
   /* this function is called in the Thread Context of a Thread that the*/
   /* User does NOT own.  Therefore, processing in this function should */
   /* be as efficient as possible (this argument holds anyway because   */
   /* another GATT Discovery Event will not be processed while this     */
   /* function call is outstanding).                                    */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_Service_Discovery_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GATT_Service_Discovery_Event_Data_t *GATT_Service_Discovery_Event_Data, uint32_t CallbackParameter)
{
   boolean_t     DisplayPrompt;
   DeviceInfo_t *DeviceInfo;

   if((BluetoothStackID) && (GATT_Service_Discovery_Event_Data))
   {
      DisplayPrompt = true;

      if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
      {
         switch(GATT_Service_Discovery_Event_Data->Event_Data_Type)
         {
            case QAPI_BLE_ET_GATT_SERVICE_DISCOVERY_INDICATION_E:
               /* Verify the event data.                                */
               if(GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data)
               {
                  QCLI_Printf(ble_group, "Service 0x%04X - 0x%04X, UUID: ", GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data->ServiceInformation.Service_Handle, GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data->ServiceInformation.End_Group_Handle);
                  DisplayUUID(&(GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data->ServiceInformation.UUID));
                  QCLI_Printf(ble_group, "\n");

                  /* Attempt to populate AIOS handles.                  */
                  AIOSPopulateHandles(&(DeviceInfo->AIOPClientInfo), GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                  /* Attempt to populate BAS handles.                   */
                  BASPopulateHandles(DeviceInfo, GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                  /* Attempt to populate the handles for the GAP        */
                  /* Service.                                           */
                  GAPSPopulateHandles(&(DeviceInfo->GAPSClientInfo), GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                  /* Attempt to populate the handles for the HID        */
                  /* Service.                                           */
                  HIDSPopulateHandles(&(DeviceInfo->HIDSClientInfo[HIDSInstanceIDIndex]), GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                  /* Attempt to populate the handles for the HRS        */
                  /* Service.                                           */
                  HRSPopulateHandles(DeviceInfo, GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                  /* Attempt to populate SCPS handles.                  */
                  SCPSPopulateHandles(DeviceInfo, GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                  /* Attempt to populate the handles for the SPPLE      */
                  /* Service.                                           */
                  SPPLEPopulateHandles(&(DeviceInfo->ClientInfo), GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);
               }
               break;
            case QAPI_BLE_ET_GATT_SERVICE_DISCOVERY_COMPLETE_E:
               /* Verify the event data.                                */
               if(GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Complete_Data)
               {
                  QCLI_Printf(ble_group, "Service Discovery Operation Complete, Status 0x%02X.\n", GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Complete_Data->Status);

                  if(SPPLE_CLIENT_INFORMATION_VALID(DeviceInfo->ClientInfo))
                     QCLI_Printf(ble_group, "Valid SPPLE Service Found.\n");
                  else
                     QCLI_Printf(ble_group, "No SPPLE Service Found.\n");

                  /* Flag that no service discovery operation is        */
                  /* outstanding for this device.                       */
                  DeviceInfo->Flags &= ~DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING;
               }
               break;
            default:
               DisplayPrompt = false;
               break;
         }
      }

      if(DisplayPrompt)
         QCLI_Display_Prompt();
   }
}

   /* Generic Attribute Profile (GATT) Service Event Callback function  */
   /* prototypes (Server).                                              */

   /* The following is a AIOS Server Event Callback.  This function will*/
   /* be called whenever an AIOS Server Profile Event occurs that is    */
   /* associated with the specified Bluetooth Stack ID.  This function  */
   /* passes to the caller the Bluetooth Stack ID, the AIOS Event Data  */
   /* that occurred and the AIOS Event Callback Parameter that was      */
   /* specified when this Callback was The caller is free to installed. */
   /* use the contents of the AIOS Event Data ONLY in the context If the*/
   /* caller requires the Data for a longer period of of this callback. */
   /* time, then the callback function MUST copy the data into another  */
   /* Data Buffer This function is guaranteed NOT to be invoked more    */
   /* than once simultaneously for the specified this function DOES NOT */
   /* have be re-entrant).  It needs to be installed callback (i.e.     */
   /* noted however, that if the same Callback is installed more than   */
   /* once, then the callbacks will Because of be called serially.      */
   /* this, the processing in this function should be as It should also */
   /* be noted that this function is called in efficient as possible.   */
   /* the Thread Context of a Thread that the User does NOT own.        */
   /* Therefore, processing in this function should be as efficient as  */
   /* possible (this argument holds anyway because another AIOS Event   */
   /* will not be processed while this function call is outstanding).   */
   /* ** NOTE ** This function MUST NOT Block and wait for events that  */
   /*            can only be satisfied by Receiving AIOS Event Packets. */
   /*            A Deadlock WILL occur because NO AIOS Event Callbacks  */
   /*            will be issued while this function is currently        */
   /*            outstanding.                                           */
static void QAPI_BLE_BTPSAPI AIOS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_AIOS_Event_Data_t *AIOS_Event_Data, uint32_t CallbackParameter)
{
   int                                  Result;
   BoardStr_t                           BoardStr;
   DeviceInfo_t                        *DeviceInfo;
   uint32_t                             InstanceID;
   uint32_t                             ConnectionID;
   uint32_t                             TransactionID;
   qapi_BLE_BD_ADDR_t                   RemoteDevice;
   qapi_BLE_GATT_Connection_Type_t      ConnectionType;
   qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo;
   AIOP_Server_Instance_Data_t         *ServerInstancePtr;
   qapi_BLE_AIOS_Characteristic_Data_t  Data;
   uint16_t                             ClientConfiguration;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (AIOS_Event_Data))
   {
      /* Determine the AIOS Event type.                                 */
      switch(AIOS_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_AIOS_SERVER_READ_CHARACTERISTIC_REQUEST_E:
            QCLI_Printf(aios_group, "\nQAPI_BLE_ET_AIOS_SERVER_READ_CHARACTERISTIC_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
            if(AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data)
            {
               /* Store event information.                              */
               InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->InstanceID;
               ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->ConnectionID;
               TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->TransactionID;
               ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->ConnectionType;
               RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->RemoteDevice;
               CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->CharacteristicInfo);

               /* Print event information.                              */
               QCLI_Printf(aios_group, "   Instance ID:          %u.\n", InstanceID);
               QCLI_Printf(aios_group, "   Connection ID:        %u.\n", ConnectionID);
               QCLI_Printf(aios_group, "   Transaction ID:       %u.\n", TransactionID);
               QCLI_Printf(aios_group, "   Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
               BD_ADDRToStr(RemoteDevice, BoardStr);
               QCLI_Printf(aios_group, "   Remote Device:        %s.\n", BoardStr);

               /* Display the Characteristic Information.               */
               DisplayAIOSCharacteristicInfo(CharacteristicInfo);

               /* Determine the Characteristic type so we know how to   */
               /* format the AIOS Characteristic for the response.      */
               switch(CharacteristicInfo->Type)
               {
                  case QAPI_BLE_ACT_DIGITAL_E:
                     /* Store a pointer to the Characteristic instance  */
                     /* data for readability.                           */
                     /* * NOTE * We will use the Characteristic         */
                     /*          information to access it.              */
                     if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                     {
                        /* Get the Digital Characteristic.              */
                        /* * NOTE * This demo uses two octets (8 digital*/
                        /*          signals) for a Digital              */
                        /*          Characteristic instance.            */
                        Data.Digital.Length = 2;
                        Data.Digital.Buffer = ServerInstancePtr->Data.Digital;

                        /* Send the response.                           */
                        if((Result = qapi_BLE_AIOS_Read_Characteristic_Request_Response(BluetoothStackID, InstanceID, ConnectionID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, &Data)) != 0)
                           DisplayFunctionError("qapi_BLE_AIOS_Read_Characteristic_Request_Response", Result);
                     }
                     else
                     {
                        /* Send the error response.                     */
                        if((Result = qapi_BLE_AIOS_Read_Characteristic_Request_Response(BluetoothStackID, InstanceID, ConnectionID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, NULL)) != 0)
                           DisplayFunctionError("qapi_BLE_AIOS_Read_Characteristic_Request_Response", Result);
                     }
                     break;
                  case QAPI_BLE_ACT_ANALOG_E:
                     /* Store a pointer to the Characteristic instance  */
                     /* data for readability.                           */
                     /* * NOTE * We will use the Characteristic         */
                     /*          information to access it.              */
                     if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                     {
                        /* Get the Analog Characteristic.               */
                        Data.Analog = ServerInstancePtr->Data.Analog;

                        /* Send the response.                           */
                        if((Result = qapi_BLE_AIOS_Read_Characteristic_Request_Response(BluetoothStackID, InstanceID, ConnectionID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, &Data)) != 0)
                           DisplayFunctionError("qapi_BLE_AIOS_Read_Characteristic_Request_Response", Result);
                     }
                     else
                     {
                        /* Send the error response.                     */
                        if((Result = qapi_BLE_AIOS_Read_Characteristic_Request_Response(BluetoothStackID, InstanceID, ConnectionID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, NULL)) != 0)
                           DisplayFunctionError("qapi_BLE_AIOS_Read_Characteristic_Request_Response", Result);
                     }
                     break;
                  default:
                     /* This CANNOT occur the event will not be         */
                     /* received.                                       */
                     break;
               }
            }
            break;
         case QAPI_BLE_ET_AIOS_SERVER_WRITE_CHARACTERISTIC_REQUEST_E:
            QCLI_Printf(aios_group, "\nQAPI_BLE_ET_AIOS_SERVER_WRITE_CHARACTERISTIC_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
            if(AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data)
            {
               /* Store event information.                              */
               InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->InstanceID;
               ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->ConnectionID;
               TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->TransactionID;
               ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->ConnectionType;
               RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->RemoteDevice;
               CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->CharacteristicInfo);
               Data               = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->Data;

               /* Print event information.                              */
               QCLI_Printf(aios_group, "   Instance ID:          %u.\n", InstanceID);
               QCLI_Printf(aios_group, "   Connection ID:        %u.\n", ConnectionID);
               QCLI_Printf(aios_group, "   Transaction ID:       %u.\n", TransactionID);
               QCLI_Printf(aios_group, "   Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
               BD_ADDRToStr(RemoteDevice, BoardStr);
               QCLI_Printf(aios_group, "   Remote Device:        %s.\n", BoardStr);

               /* Display the Characteristic Information.               */
               DisplayAIOSCharacteristicInfo(CharacteristicInfo);

               /* Determine the Characteristic type so we know what to  */
               /* store and print the Characteristic data.              */
               switch(CharacteristicInfo->Type)
               {
                  case QAPI_BLE_ACT_DIGITAL_E:
                     /* Store a pointer to the Characteristic instance  */
                     /* data for readability.                           */
                     /* * NOTE * We will use the Characteristic         */
                     /*          information to access it.              */
                     if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                     {
                        /* Make sure we have room to store the Digital  */
                        /* Characteristic.                              */
                        /* * NOTE * This demo uses two octets (8 digital*/
                        /*          signals) for a Digital              */
                        /*          Characteristic instance.            */
                        if(Data.Digital.Length == 2)
                        {
                           /* Simply copy the buffer that contains the  */
                           /* Digital Characteristic array to store the */
                           /* Digital Characteristic.                   */
                           memcpy(ServerInstancePtr->Data.Digital, Data.Digital.Buffer, Data.Digital.Length);

                           /* Display the Digital Characteristic.       */
                           DisplayDigitalCharacteristic(&(Data.Digital), CharacteristicInfo->ID);

                            /* Send the write request response.         */
                           if((Result = qapi_BLE_AIOS_Write_Characteristic_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo)) != 0)
                              DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                        }
                        else
                        {
                           /* We will simply reject the write request   */
                           /* since the Digital Characteristic being    */
                           /* written has an invalid length.            */
                           if((Result = qapi_BLE_AIOS_Write_Characteristic_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_ATTRIBUTE_VALUE_LENGTH, CharacteristicInfo)) != 0)
                              DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                        }
                     }
                     else
                     {
                        /* Send the error response.                     */
                        if((Result = qapi_BLE_AIOS_Write_Characteristic_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo)) != 0)
                           DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                     }
                     break;
                  case QAPI_BLE_ACT_ANALOG_E:
                     /* Store a pointer to the Characteristic instance  */
                     /* data for readability.                           */
                     /* * NOTE * We will use the Characteristic         */
                     /*          information to access it.              */
                     if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                     {
                        /* Store the Analog Characteristic.             */
                        ServerInstancePtr->Data.Analog = Data.Analog;

                        /* Display the Analog Characteristic.           */
                        DisplayAnalogCharacteristic(ServerInstancePtr->Data.Analog, CharacteristicInfo->ID);

                        /* Send the write request response.             */
                        if((Result = qapi_BLE_AIOS_Write_Characteristic_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo)) != 0)
                           DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                     }
                     else
                     {
                        /* Send the error response.                     */
                        if((Result = qapi_BLE_AIOS_Write_Characteristic_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo)) != 0)
                           DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                     }
                     break;
                  default:
                     /* This CANNOT occur the event will not be         */
                     /* received.                                       */
                     break;
               }
            }
            break;
         case QAPI_BLE_ET_AIOS_SERVER_READ_CCCD_REQUEST_E:
            QCLI_Printf(aios_group, "\nQAPI_BLE_ET_AIOS_SERVER_READ_CCCD_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
            if(AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data)
            {
               /* Store event information.                              */
               InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->InstanceID;
               ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->ConnectionID;
               TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->TransactionID;
               ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->ConnectionType;
               RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->RemoteDevice;
               CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->CharacteristicInfo);

               /* Print event information.                              */
               QCLI_Printf(aios_group, "   Instance ID:          %u.\n", InstanceID);
               QCLI_Printf(aios_group, "   Connection ID:        %u.\n", ConnectionID);
               QCLI_Printf(aios_group, "   Transaction ID:       %u.\n", TransactionID);
               QCLI_Printf(aios_group, "   Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
               BD_ADDRToStr(RemoteDevice, BoardStr);
               QCLI_Printf(aios_group, "   Remote Device:        %s.\n", BoardStr);

               /* Display the Characteristic Information.               */
               DisplayAIOSCharacteristicInfo(CharacteristicInfo);

               /* Make sure we can get the device information.          */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, RemoteDevice)) != NULL)
               {
                  /* Determine the Characteristic type so we know what  */
                  /* CCCD to send in the response.                      */
                  switch(CharacteristicInfo->Type)
                  {
                     case QAPI_BLE_ACT_DIGITAL_E:
                     case QAPI_BLE_ACT_ANALOG_E:
                        /* Intentional fall through.                    */
                        ClientConfiguration = DeviceInfo->AIOPServerConfiguration;

                        /* Send the response.                           */
                        if((Result = qapi_BLE_AIOS_Read_CCCD_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, ClientConfiguration)) != 0)
                           DisplayFunctionError("qapi_BLE_AIOS_Read_CCCD_Request_Response", Result);
                        break;
                     default:
                        /* This CANNOT occur the event will not be      */
                        /* received.                                    */
                        break;
                  }
               }
               else
               {
                  QCLI_Printf(aios_group, "\nError - Unknown device.\n");

                  /* Send the error response.                           */
                  if((Result = qapi_BLE_AIOS_Read_CCCD_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, 0)) != 0)
                     DisplayFunctionError("qapi_BLE_AIOS_Read_CCCD_Request_Response", Result);
               }
            }
            break;
         case QAPI_BLE_ET_AIOS_SERVER_WRITE_CCCD_REQUEST_E:
            QCLI_Printf(aios_group, "\nQAPI_BLE_ET_AIOS_SERVER_WRITE_CCCD_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
            if(AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data)
            {
               /* Store event information.                              */
               InstanceID          = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->InstanceID;
               ConnectionID        = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->ConnectionID;
               TransactionID       = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->TransactionID;
               ConnectionType      = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->ConnectionType;
               RemoteDevice        = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->RemoteDevice;
               CharacteristicInfo  = &(AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->CharacteristicInfo);
               ClientConfiguration = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->ClientConfiguration;

               /* Print event information.                              */
               QCLI_Printf(aios_group, "   Instance ID:          %u.\n", InstanceID);
               QCLI_Printf(aios_group, "   Connection ID:        %u.\n", ConnectionID);
               QCLI_Printf(aios_group, "   Transaction ID:       %u.\n", TransactionID);
               QCLI_Printf(aios_group, "   Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
               BD_ADDRToStr(RemoteDevice, BoardStr);
               QCLI_Printf(aios_group, "   Remote Device:        %s.\n", BoardStr);

               /* Display the Characteristic Information.               */
               DisplayAIOSCharacteristicInfo(CharacteristicInfo);

               /* Display the received configuration.                   */
               QCLI_Printf(aios_group, "   Client Configuration: 0x%04X.\n", ClientConfiguration);

               /* Determine the Characteristic type so we know how to   */
               /* verify the CCCD and where to store it.  where to store*/
               /* the new CCCD.                                         */
               switch(CharacteristicInfo->Type)
               {
                  case QAPI_BLE_ACT_DIGITAL_E:
                  case QAPI_BLE_ACT_ANALOG_E:
                     /* Make sure we can get the device information.    */
                     if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, RemoteDevice)) != NULL)
                     {
                        /* We will only accept notify or disabled (0).  */
                        if((!ClientConfiguration) || (ClientConfiguration & QAPI_BLE_AIOS_CLIENT_CHARACTERISTIC_CONFIGURATION_NOTIFY_ENABLE))
                        {
                           /* Store the Client Configuration.           */
                           DeviceInfo->AIOPServerConfiguration = ClientConfiguration;

                           /* Send the response.                        */
                           if((Result = qapi_BLE_AIOS_Write_CCCD_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo)) != 0)
                              DisplayFunctionError("qapi_BLE_AIOS_Write_CCCD_Request_Response", Result);

                           /* * NOTE * The user should send a           */
                           /*          notification of this             */
                           /*          Characteristic if notifications  */
                           /*          have been enabled.               */
                        }
                        else
                        {
                           /* Reject the write request since the CCCD is*/
                           /* improperly configured.                    */
                           if((Result = qapi_BLE_AIOS_Write_CCCD_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_CCCD_IMPROPERLY_CONFIGURED, CharacteristicInfo)) != 0)
                              DisplayFunctionError("qapi_BLE_AIOS_Write_CCCD_Request_Response", Result);
                        }
                     }
                     else
                     {
                        QCLI_Printf(aios_group, "\nError - Unknown device.\n");

                        /* Send the error response.                     */
                        if((Result = qapi_BLE_AIOS_Write_CCCD_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo)) != 0)
                           DisplayFunctionError("qapi_BLE_AIOS_Write_CCCD_Request_Response", Result);
                     }
                     break;
                  default:
                     /* This CANNOT occur the event will not be         */
                     /* received.                                       */
                     break;
               }
            }
            break;
         case QAPI_BLE_ET_AIOS_SERVER_READ_PRESENTATION_FORMAT_REQUEST_E:
            QCLI_Printf(aios_group, "\nQAPI_BLE_ET_AIOS_SERVER_READ_PRESENTATION_FORMAT_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
            if(AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data)
            {
               /* Store event information.                              */
               InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->InstanceID;
               ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->ConnectionID;
               TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->TransactionID;
               ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->ConnectionType;
               RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->RemoteDevice;
               CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->CharacteristicInfo);

               /* Print event information.                              */
               QCLI_Printf(aios_group, "   Instance ID:          %u.\n", InstanceID);
               QCLI_Printf(aios_group, "   Connection ID:        %u.\n", ConnectionID);
               QCLI_Printf(aios_group, "   Transaction ID:       %u.\n", TransactionID);
               QCLI_Printf(aios_group, "   Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
               BD_ADDRToStr(RemoteDevice, BoardStr);
               QCLI_Printf(aios_group, "   Remote Device:        %s.\n", BoardStr);

               /* Display the Characteristic Information.               */
               DisplayAIOSCharacteristicInfo(CharacteristicInfo);

               /* Store a pointer to the Characteristic instance data   */
               /* for readability.                                      */
               /* * NOTE * We will use the Characteristic information to*/
               /*          access it.                                   */
               if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
               {
                  /* Send the response.                                 */
                  if((Result = qapi_BLE_AIOS_Read_Presentation_Format_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, &(ServerInstancePtr->Presentation_Format))) != 0)
                     DisplayFunctionError("qapi_BLE_AIOS_Read_Presentation_Format_Request_Response", Result);
               }
               else
               {
                  /* Send the error response.                           */
                  if((Result = qapi_BLE_AIOS_Read_Presentation_Format_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, NULL)) != 0)
                     DisplayFunctionError("qapi_BLE_AIOS_Read_Presentation_Format_Request_Response", Result);
               }
            }
            break;
         case QAPI_BLE_ET_AIOS_SERVER_READ_NUMBER_OF_DIGITALS_REQUEST_E:
            QCLI_Printf(aios_group, "\nQAPI_BLE_ET_AIOS_SERVER_READ_NUMBER_OF_DIGITALS_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
            if(AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data)
            {
               /* Print event information.                              */
               InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->InstanceID;
               ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->ConnectionID;
               TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->TransactionID;
               ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->ConnectionType;
               RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->RemoteDevice;
               CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->CharacteristicInfo);

               /* Print event information.                              */
               QCLI_Printf(aios_group, "   Instance ID:          %u.\n", InstanceID);
               QCLI_Printf(aios_group, "   Connection ID:        %u.\n", ConnectionID);
               QCLI_Printf(aios_group, "   Transaction ID:       %u.\n", TransactionID);
               QCLI_Printf(aios_group, "   Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
               BD_ADDRToStr(RemoteDevice, BoardStr);
               QCLI_Printf(aios_group, "   Remote Device:        %s.\n", BoardStr);

               /* Display the characteristic Information.               */
               DisplayAIOSCharacteristicInfo(CharacteristicInfo);

               /* Store a pointer to the Characteristic instance data   */
               /* for readability.                                      */
               /* * NOTE * We will use the Characteristic information to*/
               /*          access it.                                   */
               if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
               {
                  /* Send the response.                                 */
                  if((Result = qapi_BLE_AIOS_Read_Number_Of_Digitals_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, ServerInstancePtr->Number_Of_Digitals)) != 0)
                     DisplayFunctionError("qapi_BLE_AIOS_Read_Number_Of_Digitals_Request_Response", Result);
               }
               else
               {
                  /* Send the error response.                           */
                  /* * NOTE * We pass zero in for the Number Of Digitals*/
                  /*          since it will be ignored.                 */
                  if((Result = qapi_BLE_AIOS_Read_Number_Of_Digitals_Request_Response(BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, 0)) != 0)
                     DisplayFunctionError("qapi_BLE_AIOS_Read_Number_Of_Digitals_Request_Response", Result);
               }
            }
            break;
         default:
            QCLI_Printf(aios_group, "\nUnknown AIOS Event\n");
            break;
      }
   }
   else
   {
      /* There was an error with one or more of the input parameters.   */
      QCLI_Printf(aios_group, "\n");

      QCLI_Printf(aios_group, "AIOS Callback Data: Event_Data = NULL.\n");
   }
}

   /* The following is a BAS Server Event Callback.  This function will */
   /* be called whenever an BAS Server Profile Event occurs that is     */
   /* associated with the specified Bluetooth Stack ID.  This function  */
   /* passes to the caller the Bluetooth Stack ID, the BAS Event Data   */
   /* that occurred and the BAS Event Callback Parameter that was       */
   /* specified when this Callback was installed.  The caller is free to*/
   /* use the contents of the BAS Event Data ONLY in the context of this*/
   /* callback.  If the caller requires the Data for a longer period of */
   /* time, then the callback function MUST copy the data into another  */
   /* Data Buffer This function is guaranteed NOT to be invoked more    */
   /* than once simultaneously for the specified installed callback     */
   /* (i.e.  this function DOES NOT have be re-entrant).  It needs to be*/
   /* noted however, that if the same Callback is installed more than   */
   /* once, then the callbacks will be called serially.  Because of     */
   /* this, the processing in this function should be as efficient as   */
   /* possible.  It should also be noted that this function is called in*/
   /* the Thread Context of a Thread that the User does NOT own.        */
   /* Therefore, processing in this function should be as efficient as  */
   /* possible (this argument holds anyway because another BAS Event    */
   /* will not be processed while this function call is outstanding).   */
   /* ** NOTE ** This function MUST NOT Block and wait for events that  */
   /*            can only be satisfied by Receiving BAS Event Packets.  */
   /*            A Deadlock WILL occur because NO BAS Event Callbacks   */
   /*            will be issued while this function is currently        */
   /*            outstanding.                                           */
static void QAPI_BLE_BTPSAPI BAS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_BAS_Event_Data_t *BAS_Event_Data, uint32_t CallbackParameter)
{
   int           Result;
   BoardStr_t    BoardStr;
   unsigned int  InstanceID;
   unsigned int  TransactionID;
   DeviceInfo_t *DeviceInfo;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (BAS_Event_Data))
   {
      switch(BAS_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_BAS_SERVER_READ_CLIENT_CONFIGURATION_REQUEST_E:
            QCLI_Printf(bas_group, "etBAS_Server_Read_Client_Configuration_Request with size %u.\n", BAS_Event_Data->Event_Data_Size);

            if(BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data)
            {
               BD_ADDRToStr(BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->RemoteDevice, BoardStr);
               InstanceID = BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->InstanceID;

               QCLI_Printf(bas_group, "   Instance ID:      %u.\n", InstanceID);
               QCLI_Printf(bas_group, "   Connection ID:    %u.\n", BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->ConnectionID);
               QCLI_Printf(bas_group, "   Transaction ID:   %u.\n", BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->TransactionID);
               QCLI_Printf(bas_group, "   Connection Type:  %s.\n", ((BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
               QCLI_Printf(bas_group, "   Remote Device:    %s.\n", BoardStr);

               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->RemoteDevice)) != NULL)
               {
                  switch(BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->ClientConfigurationType)
                  {
                     case QAPI_BLE_CT_BATTERY_LEVEL_E:
                        QCLI_Printf(bas_group, "Config Type:      ctBatteryLevel.\n");

                        Result = qapi_BLE_BAS_Read_Client_Configuration_Response(BluetoothStackID, InstanceID, BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->TransactionID, DeviceInfo->BASServerInfo[InstanceID-1].Battery_Level_Client_Configuration);
                        break;
                     default:
                        QCLI_Printf(bas_group, "Config Type:      Unknown.\n");

                        Result = 0;
                        break;
                  }

                  if(Result)
                     DisplayFunctionError("BAS_Read_Client_Configuration_Response", Result);
               }
               else
                  QCLI_Printf(bas_group, "\nUnknown Client.\n");
            }
            break;
         case QAPI_BLE_ET_BAS_SERVER_CLIENT_CONFIGURATION_UPDATE_E:
            QCLI_Printf(bas_group, "etBAS_Server_Client_Configuration_Update with size %u.\n", BAS_Event_Data->Event_Data_Size);

            if(BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data)
            {
               BD_ADDRToStr(BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->RemoteDevice, BoardStr);
               InstanceID = BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->InstanceID;

               QCLI_Printf(bas_group, "   Instance ID:      %u.\n", InstanceID);
               QCLI_Printf(bas_group, "   Connection ID:    %u.\n", BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->ConnectionID);
               QCLI_Printf(bas_group, "   Connection Type:  %s.\n", ((BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
               QCLI_Printf(bas_group, "   Remote Device:    %s.\n", BoardStr);

               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->RemoteDevice)) != NULL)
               {
                  switch(BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->ClientConfigurationType)
                  {
                     case QAPI_BLE_CT_BATTERY_LEVEL_E:
                        QCLI_Printf(bas_group, "   Config Type:      ctBatteryLevel.\n");
                        if(BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->Notify)
                           DeviceInfo->BASServerInfo[InstanceID-1].Battery_Level_Client_Configuration |= QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE;
                        else
                           DeviceInfo->BASServerInfo[InstanceID-1].Battery_Level_Client_Configuration &= ~QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE;
                        break;
                     default:
                        QCLI_Printf(bas_group, "   Config Type:      Unknown.\n");
                        break;
                  }

                  QCLI_Printf(bas_group, "Value:            0x%04X.\n", (uint16_t)BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->Notify);
               }
               else
               {
                  QCLI_Printf(bas_group, "\nUnknown Client.\n");
               }
            }
            break;
         case QAPI_BLE_ET_BAS_SERVER_READ_BATTERY_LEVEL_REQUEST_E:
            QCLI_Printf(bas_group, " etBAS_Server_Read_Battery_Level_Request EVENT received \n");

            InstanceID    = BAS_Event_Data->Event_Data.BAS_Read_Battery_Level_Data->InstanceID;
            TransactionID = BAS_Event_Data->Event_Data.BAS_Read_Battery_Level_Data->TransactionID;

            Result        = qapi_BLE_BAS_Battery_Level_Read_Request_Response(BluetoothStackID, TransactionID, BatteryLevel[InstanceID-1]);

            QCLI_Printf(bas_group, "Result:    %d.\n", Result);
            break;
         default:
            QCLI_Printf(bas_group, "Unknown BAS Event\n");
            break;
      }
   }
   else
   {
      /* There was an error with one or more of the input parameters.   */
      QCLI_Printf(bas_group, "\n");

      QCLI_Printf(bas_group, "BAS Callback Data: Event_Data = NULL.\n");
   }
}

   /* The following is a HID Server Event Callback.  This function will */
   /* be called whenever an HID Server Profile Event occurs that is     */
   /* associated with the specified Bluetooth Stack ID.  This function  */
   /* passes to the caller the Bluetooth Stack ID, the HIDS Event Data  */
   /* that occurred and the HIDS Profile Event Callback Parameter that  */
   /* was specified when this Callback was installed.  The caller is    */
   /* free to use the contents of the HIDS Profile Event Data ONLY in   */
   /* the context of this callback.  If the caller requires the Data for*/
   /* a longer period of time, then the callback function MUST copy the */
   /* data into another Data Buffer This function is guaranteed NOT to  */
   /* be invoked more than once simultaneously for the specified        */
   /* installed callback (i.e. this function DOES NOT have be           */
   /* re-entrant).  It needs to be noted however, that if the same      */
   /* Callback is installed more than once, then the callbacks will be  */
   /* called serially.  Because of this, the processing in this function*/
   /* should be as efficient as possible.  It should also be noted that */
   /* this function is called in the Thread Context of a Thread that the*/
   /* User does NOT own.  Therefore, processing in this function should */
   /* be as efficient as possible (this argument holds anyway because   */
   /* another HIDS Profile Event will not be processed while this       */
   /* function call is outstanding).                                    */
   /* ** NOTE ** This function MUST NOT Block and wait for events that  */
   /*            can only be satisfied by Receiving HIDS Profile Event  */
   /*            Packets.  A Deadlock WILL occur because NO HIDS Event  */
   /*            Callbacks will be issued while this function is        */
   /*            currently outstanding.                                 */
static void QAPI_BLE_BTPSAPI HIDS_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_HIDS_Event_Data_t *HIDS_Event_Data, uint32_t CallbackParameter)
{
   int                                      Result;
   uint8_t                                  ErrorCode;
   uint8_t                                 *ReportData;
   uint8_t                                  ReportBuffer[HID_KEYBOARD_INPUT_REPORT_SIZE];
   uint16_t                                 Configuration;
   DeviceInfo_t                            *DeviceInfo;
   unsigned int                             ReportDataLength;
   unsigned int                             Index;
   qapi_BLE_GAP_Encryption_Mode_t           GAPEncryptionMode;
   qapi_BLE_HIDS_Get_Report_Request_Data_t *GetReportRequestData;
   qapi_BLE_HIDS_Set_Report_Request_Data_t *SetReportRequestData;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (HIDS_Event_Data))
   {
      switch(HIDS_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_HIDS_SERVER_READ_CLIENT_CONFIGURATION_REQUEST_E:
            if(HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data)
            {
               /* Search for the Device entry.                          */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data->RemoteDevice)) != NULL)
               {
                  QCLI_Printf(hids_group, "HIDS Read Client Configuration Request: %u.\n", HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data->ReportType);

                  if(HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E)
                     Configuration = DeviceInfo->HIDSServerInfo.BootKeyboardInputConfiguration;
                  else
                     Configuration = DeviceInfo->HIDSServerInfo.ReportKeyboardInputConfiguration;

                  /* Respond to the read request.                       */
                  Result = qapi_BLE_HIDS_Read_Client_Configuration_Response(BluetoothStackID, HIDSInstanceID, HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data->TransactionID, Configuration);
                  if(Result)
                     QCLI_Printf(hids_group, "Error - qapi_BLE_HIDS_Read_Client_Configuration_Response() %d.\n", Result);
               }
            }
            break;
         case QAPI_BLE_ET_HIDS_SERVER_CLIENT_CONFIGURATION_UPDATE_REQUEST_E:
            if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data)
            {
               QCLI_Printf(hids_group, "HIDS Client Configuration Update: %u.\n", HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportType);

               /* Search for the Device entry.                          */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->RemoteDevice)) != NULL)
               {
                  if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E)
                  {
                     DeviceInfo->HIDSServerInfo.BootKeyboardInputConfiguration = HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ClientConfiguration;

                     QCLI_Printf(hids_group, "Boot Keyboard Input Report Configuration 0x%04X.\n", DeviceInfo->HIDSServerInfo.BootKeyboardInputConfiguration);
                  }
                  else
                  {
                     if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT)
                     {
                        DeviceInfo->HIDSServerInfo.BootMouseInputConfiguration = HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ClientConfiguration;

                        QCLI_Printf(hids_group, "Boot Mouse Input Report Configuration 0x%04X.\n", DeviceInfo->HIDSServerInfo.BootMouseInputConfiguration);
                     }
                     else
                     {
                        if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportType == QAPI_BLE_RT_REPORT_E)
                        {
                           if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportReferenceData.ReportID == HID_KEYBOARD_INPUT_REPORT_ID)
                           {
                              DeviceInfo->HIDSServerInfo.ReportKeyboardInputConfiguration = HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ClientConfiguration;

                              QCLI_Printf(hids_group, "Report Keyboard Input Report Configuration 0x%04X.\n", DeviceInfo->HIDSServerInfo.ReportKeyboardInputConfiguration);
                           }
                           else
                           {
                              if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportReferenceData.ReportID == HID_MOUSE_INPUT_REPORT_ID)
                              {
                                 DeviceInfo->HIDSServerInfo.ReportMouseInputConfiguration = HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ClientConfiguration;

                                 QCLI_Printf(hids_group, "Report Mouse Input Report Configuration 0x%04X.\n", DeviceInfo->HIDSServerInfo.ReportMouseInputConfiguration);
                              }
                              else
                                 QCLI_Printf(hids_group, "Unknown Client Configuration.\n");
                           }
                        }
                        else
                           QCLI_Printf(hids_group, "Unknown Client Configuration.\n");
                     }
                  }
               }
            }
            break;
         case QAPI_BLE_ET_HIDS_SERVER_GET_PROTOCOL_MODE_REQUEST_E:
            if(HIDS_Event_Data->Event_Data.HIDS_Get_Protocol_Mode_Request_Data)
            {
               QCLI_Printf(hids_group, "HIDS Get Protocol Mode Request.\n");

               /* Note that security is required to read this           */
               /* characteristic.                                       */
               if((qapi_BLE_GAP_LE_Query_Encryption_Mode(BluetoothStackID, HIDS_Event_Data->Event_Data.HIDS_Get_Protocol_Mode_Request_Data->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                  ErrorCode = 0;
               else
                  ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION;

               /* Respond the Get Protocol Mode request.                */
               Result = qapi_BLE_HIDS_Get_Protocol_Mode_Response(BluetoothStackID, HIDSInstanceID, HIDS_Event_Data->Event_Data.HIDS_Get_Protocol_Mode_Request_Data->TransactionID, ErrorCode, HIDS_Protocol_Mode);
               if(Result)
                  QCLI_Printf(hids_group, "Error - qapi_BLE_HIDS_Get_Protocol_Mode_Response() %d.\n", Result);
            }
            break;
         case QAPI_BLE_ET_HIDS_SERVER_SET_PROTOCOL_MODE_REQUEST_E:
            if(HIDS_Event_Data->Event_Data.HIDS_Set_Protocol_Mode_Request_Data)
            {
               QCLI_Printf(hids_group, "HIDS Set Protocol Mode Request: %s.\n", (HIDS_Event_Data->Event_Data.HIDS_Set_Protocol_Mode_Request_Data->ProtocolMode == QAPI_BLE_PM_BOOT_E)?"Boot":"Report");

               /* Note that security is required to write this          */
               /* characteristic.                                       */
               if((qapi_BLE_GAP_LE_Query_Encryption_Mode(BluetoothStackID, HIDS_Event_Data->Event_Data.HIDS_Set_Protocol_Mode_Request_Data->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                  HIDS_Protocol_Mode = HIDS_Event_Data->Event_Data.HIDS_Set_Protocol_Mode_Request_Data->ProtocolMode;
            }
            break;
         case QAPI_BLE_ET_HIDS_SERVER_GET_REPORT_MAP_REQUEST_E:
            if(HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data)
            {
               QCLI_Printf(hids_group, "HIDS Get Report Map Request: Offset = %u.\n", HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->ReportMapOffset);

               /* Note that security is required to read this           */
               /* characteristic.                                       */
               if((qapi_BLE_GAP_LE_Query_Encryption_Mode(BluetoothStackID, HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
               {
                  /* Initialize the return value to success.            */
                  ErrorCode = 0;

                  /* Verify that the offset being read is valid.        */
                  if(HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->ReportMapOffset < (sizeof(KeyboardReportDescriptor)))
                  {
                     /* Get a pointer to the report map to return.      */
                     ReportDataLength = (sizeof(KeyboardReportDescriptor) - HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->ReportMapOffset);
                     ReportData       = &(KeyboardReportDescriptor[HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->ReportMapOffset]);
                  }
                  else
                  {
                     ErrorCode        = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_OFFSET;
                     ReportDataLength = 0;
                     ReportData       = NULL;
                  }
               }
               else
               {
                  ErrorCode        = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION;
                  ReportDataLength = 0;
                  ReportData       = NULL;
               }

               /* Respond the Get Report Map request.                   */
               Result = qapi_BLE_HIDS_Get_Report_Map_Response(BluetoothStackID, HIDSInstanceID, HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->TransactionID, ErrorCode, ReportDataLength, ReportData);
               if(Result)
                  QCLI_Printf(hids_group, "Error - qapi_BLE_HIDS_Get_Report_Map_Response() %d.\n", Result);
            }
            break;
         case QAPI_BLE_ET_HIDS_SERVER_GET_REPORT_REQUEST_E:
            if(HIDS_Event_Data->Event_Data.HIDS_Get_Report_Request_Data)
            {
               GetReportRequestData = HIDS_Event_Data->Event_Data.HIDS_Get_Report_Request_Data;

               QCLI_Printf(hids_group, "\nHID Get Report Request: Type %u.\n", GetReportRequestData->ReportType);

               /* Note that security is required to read this           */
               /* characteristic.                                       */
               if((qapi_BLE_GAP_LE_Query_Encryption_Mode(BluetoothStackID, GetReportRequestData->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
               {
                  /* Flag that no error has occurred.                   */
                  ErrorCode = 0;

                  /* Determine what report the Host is attempting to    */
                  /* read.                                              */
                  if((GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E) || ((GetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT) && (GetReportRequestData->ReportReferenceData.ReportID == HID_KEYBOARD_INPUT_REPORT_ID)))
                  {
                     /* Respond with the Keyboard Input Report.  Note   */
                     /* that since our Report Mode Report is identical  */
                     /* to the Boot Mode Report we do not need to       */
                     /* differentiate here.                             */
                     ReportDataLength = KeyboardInputReportSize;

                     if(sizeof(ReportBuffer) >= KeyboardInputReportSize)
                        memcpy(ReportBuffer, KeyboardInputReport, KeyboardInputReportSize);
                     else
                     {
                        QCLI_Printf(hids_group, "Error Responding to Get Report Request - Insufficient Resources.\n");
                        ReportDataLength = 0;
                     }

                     if(GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E)
                        QCLI_Printf(hids_group, "   Boot Keyboard Input Report:\n");
                     else
                        QCLI_Printf(hids_group, "   Keyboard Input Report:\n");
                  }
                  else
                  {
                     if((GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT) || ((GetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT) && (GetReportRequestData->ReportReferenceData.ReportID == HID_MOUSE_INPUT_REPORT_ID)))
                     {
                        /* Respond with the Mouse Input Report.  Note   */
                        /* that since our Report Mode Report is         */
                        /* identical to the Boot Mode Report we do not  */
                        /* need to differentiate here.                  */
                        ReportDataLength = MouseInputReportSize;

                        if(sizeof(ReportBuffer) >= MouseInputReportSize)
                           memcpy(ReportBuffer, MouseInputReport, MouseInputReportSize);
                        else
                        {
                           QCLI_Printf(hids_group, "Error Responding to Get Report Request - Insufficient Resources.\n");
                           ReportDataLength = 0;
                        }

                        if(GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT)
                           QCLI_Printf(hids_group, "   Boot Mouse Input Report:\n");
                        else
                           QCLI_Printf(hids_group, "   Mouse Input Report:\n");
                     }
                     else
                     {
                        if((GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E) || ((GetReportRequestData->ReportType == QAPI_BLE_RT_REPORT_E) && (GetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT)))
                        {
                           /* Respond with the Keyboard Output Report.  */
                           /* Note that since our Report Mode Report is */
                           /* identical to the Boot Mode Report we do   */
                           /* not need to differentiate here.           */
                           ReportDataLength = KeyboardOutputReportSize;

                           if(sizeof(ReportBuffer) >= KeyboardOutputReportSize)
                              memcpy(ReportBuffer, KeyboardOutputReport, KeyboardOutputReportSize);
                           else
                           {
                              QCLI_Printf(hids_group, "Error Responding to Get Report Request - Insufficient Resources.\n");
                              ReportDataLength = 0;
                           }

                           if(GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E)
                              QCLI_Printf(hids_group, "   Boot Keyboard Output Report:\n");
                           else
                              QCLI_Printf(hids_group, "   Keyboard Output Report:\n");
                        }
                        else
                        {
                           ErrorCode        = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR;
                           ReportDataLength = 0;
                        }
                     }
                  }
               }
               else
               {
                  ErrorCode        = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION;
                  ReportDataLength = 0;
               }

               QCLI_Printf(hids_group, "      Report Length: %d.\n", ReportDataLength);

               QCLI_Printf(hids_group, "      Report Value:  ");
               for(Index = 0; Index < ReportDataLength; Index++)
                  QCLI_Printf(hids_group, "0x%02X ", ReportBuffer[Index]);
               QCLI_Printf(hids_group, "\n");

               /* Respond to the Get Report Request.                    */
               Result = qapi_BLE_HIDS_Get_Report_Response(BluetoothStackID, HIDSInstanceID, GetReportRequestData->TransactionID, GetReportRequestData->ReportType, &(GetReportRequestData->ReportReferenceData), ErrorCode, ReportDataLength, ReportBuffer);
               if(Result)
                  QCLI_Printf(hids_group, "Error - qapi_BLE_HIDS_Get_Report_Response() %d.\n", Result);
            }
            break;
         case QAPI_BLE_ET_HIDS_SERVER_SET_REPORT_REQUEST_E:
            if(HIDS_Event_Data->Event_Data.HIDS_Set_Report_Request_Data)
            {
               SetReportRequestData = HIDS_Event_Data->Event_Data.HIDS_Set_Report_Request_Data;

               QCLI_Printf(hids_group, "\nHID Set Report Request: Type %u.\n", HIDS_Event_Data->Event_Data.HIDS_Set_Report_Request_Data->ReportType);

               /* Note that security is required to write this          */
               /* characteristic.                                       */
               if((qapi_BLE_GAP_LE_Query_Encryption_Mode(BluetoothStackID, SetReportRequestData->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
               {
                  /* Flag that no error has occurred.                   */
                  ErrorCode = 0;

                  /* Determine what report the Host is attempting to    */
                  /* write.                                             */
                  if((SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E) || (SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E) || (SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT) || ((SetReportRequestData->ReportType == QAPI_BLE_RT_REPORT_E) && (SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT)) || ((SetReportRequestData->ReportType == QAPI_BLE_RT_REPORT_E) && (SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT)))
                  {
                     /* Handle the set keyboard output report request.  */
                     if((SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E) || ((SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT) && (SetReportRequestData->ReportReferenceData.ReportID == HID_KEYBOARD_OUTPUT_REPORT_ID)))
                     {
                        if(SetReportRequestData->ReportLength <= HID_KEYBOARD_OUTPUT_REPORT_SIZE)
                        {
                           KeyboardOutputReportSize = SetReportRequestData->ReportLength;
                           memcpy(KeyboardOutputReport, SetReportRequestData->Report, SetReportRequestData->ReportLength);

                           if(SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E)
                              QCLI_Printf(hids_group, "   Boot Keyboard Output Report:\n");
                           else
                              QCLI_Printf(hids_group, "   Keyboard Output Report:\n");

                           /* Set the LEDs appropriately.               */
                           if(KeyboardOutputReport[0] & HID_KEYBOARD_OUTPUT_REPORT_CAPS_LOCK)
                              QCLI_Printf(hids_group, "      Caps Lock Pressed.\n");

                           if(KeyboardOutputReport[0] & HID_KEYBOARD_OUTPUT_REPORT_NUM_LOCK)
                              QCLI_Printf(hids_group, "      Num Lock Pressed.\n");
                        }
                        else
                           ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_RESOURCES;
                     }
                     else
                     {
                        /* Store the keyboard input report data.        */
                        if((SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E) || ((SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT) && (SetReportRequestData->ReportReferenceData.ReportID == HID_KEYBOARD_INPUT_REPORT_ID)))
                        {
                           if(SetReportRequestData->ReportLength <= HID_KEYBOARD_INPUT_REPORT_SIZE)
                           {
                              KeyboardInputReportSize = SetReportRequestData->ReportLength;
                              memcpy(KeyboardInputReport, SetReportRequestData->Report, SetReportRequestData->ReportLength);

                              if(SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E)
                                 QCLI_Printf(hids_group, "   Boot Keyboard Input Report:\n");
                              else
                                 QCLI_Printf(hids_group, "   Keyboard Input Report:\n");
                           }
                           else
                              ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_RESOURCES;
                        }
                        else
                        {
                           /* Store the mouse input report data.        */
                           if((SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT) || ((SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT) && (SetReportRequestData->ReportReferenceData.ReportID == HID_MOUSE_INPUT_REPORT_ID)))
                           {
                              if(SetReportRequestData->ReportLength <= HID_MOUSE_INPUT_REPORT_SIZE)
                              {
                                 MouseInputReportSize = SetReportRequestData->ReportLength;
                                 memcpy(MouseInputReport, SetReportRequestData->Report, SetReportRequestData->ReportLength);

                                 if(SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT)
                                    QCLI_Printf(hids_group, "   Boot Mouse Input Report:\n");
                                 else
                                    QCLI_Printf(hids_group, "   Mouse Input Report:\n");
                              }
                              else
                                 ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_RESOURCES;
                           }
                        }
                     }
                  }
                  else
                     ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR;
               }
               else
                  ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION;

               QCLI_Printf(hids_group, "      Report Length: %d.\n", SetReportRequestData->ReportLength);

               /* Output the report value.                              */
               QCLI_Printf(hids_group, "      Report Value:  ");
               for(Index = 0; Index < SetReportRequestData->ReportLength; Index++)
                  QCLI_Printf(hids_group, "0x%02X ", SetReportRequestData->Report[Index]);
               QCLI_Printf(hids_group, "\n");

               /* Respond to the Set Report Request.                    */
               Result = qapi_BLE_HIDS_Set_Report_Response(BluetoothStackID, HIDSInstanceID, SetReportRequestData->TransactionID, SetReportRequestData->ReportType, &(SetReportRequestData->ReportReferenceData), ErrorCode);
               if(Result)
                  QCLI_Printf(hids_group, "Error - qapi_BLE_HIDS_Set_Report_Response() %d.\n", Result);
            }
            break;
         case QAPI_BLE_ET_HIDS_SERVER_CONTROL_POINT_COMMAND_INDICATION_E:
            if(HIDS_Event_Data->Event_Data.HIDS_Control_Point_Command_Data)
               QCLI_Printf(hids_group, "HID Control Point Command: %s (%u).\n", ((HIDS_Event_Data->Event_Data.HIDS_Control_Point_Command_Data->ControlPointCommand == QAPI_BLE_PC_SUSPEND_E)?"Suspend":"Exit Suspend"), (unsigned int)HIDS_Event_Data->Event_Data.HIDS_Control_Point_Command_Data->ControlPointCommand);
            break;
         default:
            QCLI_Printf(hids_group, "Unknown HIDS Event\n");
            break;
      }
   }
   else
   {
      /* There was an error with one or more of the input parameters.   */
      QCLI_Printf(hids_group, "\n");

      QCLI_Printf(hids_group, "HIDS Callback Data: Event_Data = NULL.\n");
   }
}

   /* The following is a SLoWP Server Event Callback. This function will*/
   /* be called whenever an SLoWP Server Profile Event occurs that is   */
   /* associated with the specified Bluetooth Stack ID. This function   */
   /* passes to the caller the Bluetooth Stack ID, the SLoWP Event Data */
   /* that occurred and the SLoWP Event Callback Parameter that was     */
   /* specified when this Callback was installed. The caller is free to */
   /* use the contents of the SLoWP Event Data ONLY in the context of   */
   /* this callback. If the caller requires the Data for a longer period*/
   /* of time, then the callback function MUST copy the data into       */
   /* another Data Buffer This function is guaranteed NOT to be invoked */
   /* more than once simultaneously for the specified installed callback*/
   /* (i.e. this function DOES NOT have be re-entrant). It needs to be  */
   /* noted however, that if the same Callback is installed more than   */
   /* once, then the callbacks will be called serially. Because of this,*/
   /* the processing in this function should be as efficient as         */
   /* possible. It should also be noted that this function is called in */
   /* the Thread Context of a Thread that the User does NOT own.        */
   /* Therefore, processing in this function should be as efficient as  */
   /* possible (this argument holds anyway because another SLoWP Event  */
   /* will not be processed while this function call is outstanding).   */
   /* ** NOTE ** This function MUST NOT Block and wait for events that  */
   /*            can only be satisfied by Receiving SLoWP Event Packets.*/
   /*            A Deadlock WILL occur because NO SLoWP Event Callbacks */
   /*            will be issued while this function is currently        */
   /*            outstanding.                                           */
static void QAPI_BLE_BTPSAPI SLoWP_EventCallback(uint32_t BluetoothStackID, qapi_BLE_SLoWP_Event_Data_t *SLoWP_Event_Data, uint32_t CallbackParameter)
{
   int        Result;
   boolean_t  DisplayPrompt;
   BoardStr_t BoardStr;

   /* Verify the input data.                                            */
   if(SLoWP_Event_Data)
   {
      /* Flag that we should display the prompt.                        */
      DisplayPrompt = TRUE;

      /* Handle the different events.                                   */
      switch(SLoWP_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_SLOWP_OPEN_INDICATION_E:
            QCLI_Printf(slowp_group, "etSLoWP_Open_Indication event with size %u.\n", SLoWP_Event_Data->Event_Data_Size);

            /* Verify the event data pointer.                           */
            if(SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data != NULL)
            {
               BD_ADDRToStr(SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->RemoteDevice, BoardStr);

               QCLI_Printf(slowp_group, "   Router BT Address: %s.\n", BoardStr);
               QCLI_Printf(slowp_group, "   Max SDU Size     : %u.\n", (unsigned int)SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->MaxSDUSize);
               QCLI_Printf(slowp_group, "   Max PDU Size     : %u.\n", (unsigned int)SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->MaxPDUSize);
               QCLI_Printf(slowp_group, "   Initial Credits  : %u.\n", (unsigned int)SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->InitialCredits);

               SLoWPRouterAddress = SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->RemoteDevice;
               SLoWPConnected     = TRUE;
            }
            break;
         case QAPI_BLE_ET_SLOWP_OPEN_REQUEST_INDICATION_E:
            QCLI_Printf(slowp_group, "etSLoWP_Open_Request_Indication event with size %u.\n", SLoWP_Event_Data->Event_Data_Size);

            /* Verify the event data pointer.                           */
            /* * NOTE * This event uses same event data as the          */
            /*          QAPI_BLE_ET_SLOWP_OPEN_INDICATION_E event.      */
            if(SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data != NULL)
            {
               BD_ADDRToStr(SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->RemoteDevice, BoardStr);

               QCLI_Printf(slowp_group, "   Router BT Address: %s.\n", BoardStr);
               QCLI_Printf(slowp_group, "   Max SDU Size     : %u.\n", (unsigned int)SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->MaxSDUSize);
               QCLI_Printf(slowp_group, "   Max PDU Size     : %u.\n", (unsigned int)SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->MaxPDUSize);
               QCLI_Printf(slowp_group, "   Initial Credits  : %u.\n", (unsigned int)SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->InitialCredits);

               QCLI_Printf(slowp_group, "Accepting the connection request.\n");

               /* Simply call the SLoWP function to accept the          */
               /* connection request.                                   */
               if((Result = qapi_BLE_SLoWP_Open_Connection_Request_Response(BluetoothStackID, SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->RemoteDevice, TRUE))== 0)
               {
                  SLoWPRouterAddress = SLoWP_Event_Data->Event_Data.SLoWP_Open_Indication_Info_Data->RemoteDevice;
                  SLoWPConnected     = TRUE;
               }
               else
                  DisplayFunctionError("qapi_BLE_SLoWP_Open_Connection_Request_Response", Result);
            }
            break;
         case QAPI_BLE_ET_SLOWP_OPEN_CONFIRMATION_E:
            QCLI_Printf(slowp_group, "etSLoWP_Open_Confirmation event with size %u.\n", SLoWP_Event_Data->Event_Data_Size);

            if(SLoWP_Event_Data->Event_Data.SLoWP_Open_Confirmation_Data != NULL)
            {
               BD_ADDRToStr(SLoWP_Event_Data->Event_Data.SLoWP_Open_Confirmation_Data->RemoteDevice, BoardStr);
               QCLI_Printf(slowp_group, "   Remote Device:  %s.\n", BoardStr);
               QCLI_Printf(slowp_group, "   Max SDU Size:   %u.\n", (unsigned int)SLoWP_Event_Data->Event_Data.SLoWP_Open_Confirmation_Data->MaxSDUSize);
               QCLI_Printf(slowp_group, "   Max PDU Size:   %u.\n", (unsigned int)SLoWP_Event_Data->Event_Data.SLoWP_Open_Confirmation_Data->MaxPDUSize);
               QCLI_Printf(slowp_group, "   Credits:        %u.\n", (unsigned int)SLoWP_Event_Data->Event_Data.SLoWP_Open_Confirmation_Data->InitialCredits);
               QCLI_Printf(slowp_group, "   Status:         ");

               /* Print the status.                                     */
               switch(SLoWP_Event_Data->Event_Data.SLoWP_Open_Confirmation_Data->ConnectionStatus)
               {
                  case QAPI_BLE_SLOWP_OPEN_STATUS_SUCCESS:
                     QCLI_Printf(slowp_group,"Success.\n");
                     break;
                  case QAPI_BLE_SLOWP_OPEN_STATUS_CONNECTION_TIMEOUT:
                     QCLI_Printf(slowp_group,"Connection Timeout.\n");
                     break;
                  case QAPI_BLE_SLOWP_OPEN_STATUS_CONNECTION_REFUSED:
                     QCLI_Printf(slowp_group,"Connection Refused.\n");
                     break;
                  case QAPI_BLE_SLOWP_OPEN_STATUS_UNKNOWN_ERROR:
                     QCLI_Printf(slowp_group,"Unknown Error.\n");
                     break;
                  default:
                     QCLI_Printf(slowp_group,"Unknown Status Code.\n");
                     break;
               }
            }

            break;
         case QAPI_BLE_ET_SLOWP_CLOSE_INDICATION_E:
            QCLI_Printf(slowp_group, "etSLoWP_Close_Indication event with size %u.\n", SLoWP_Event_Data->Event_Data_Size);

            if(SLoWP_Event_Data->Event_Data.SLoWP_Close_Indication_Data != NULL)
            {
               BD_ADDRToStr(SLoWP_Event_Data->Event_Data.SLoWP_Close_Indication_Data->RemoteDevice, BoardStr);

               QCLI_Printf(slowp_group, "   Router BT Address: %s.\n", BoardStr);
               QCLI_Printf(slowp_group, "   Reason           : 0x%08X.\n", SLoWP_Event_Data->Event_Data.SLoWP_Close_Indication_Data->Reason);
            }

            SLoWPConnected = FALSE;
            break;
         case QAPI_BLE_ET_SLOWP_CLOSE_CONFIRMATION_E:
            QCLI_Printf(slowp_group, "etSLoWP_Close_Confirmation event with size %u.\n", SLoWP_Event_Data->Event_Data_Size);

            if(SLoWP_Event_Data->Event_Data.SLoWP_Close_Confirmation_Data != NULL)
            {
               BD_ADDRToStr(SLoWP_Event_Data->Event_Data.SLoWP_Close_Confirmation_Data->RemoteDevice, BoardStr);

               QCLI_Printf(slowp_group, "   Router BT Address: %s.\n", BoardStr);
            }

            SLoWPConnected = FALSE;
            break;
         default:
            DisplayPrompt = FALSE;
            break;
      }

      if(DisplayPrompt)
         QCLI_Display_Prompt();
   }
}

   /* The following is a SCPS Server Event Callback.  This function will*/
   /* be called whenever an SCPS Server Profile Event occurs that is    */
   /* associated with the specified Bluetooth Stack ID.  This function  */
   /* passes to the caller the Bluetooth Stack ID, the SCPS Event Data  */
   /* that occurred and the SCPS Event Callback Parameter that was      */
   /* specified when this Callback was installed.  The caller is free to*/
   /* use the contents of the SCPS Event Data ONLY in the context of    */
   /* this callback.  If the caller requires the Data for a longer      */
   /* period of time, then the callback function MUST copy the data     */
   /* into another Data Buffer This function is guaranteed NOT to be    */
   /* invoked more than once simultaneously for the specified installed */
   /* callback (i.e.  this function DOES NOT have be re-entrant). It    */
   /* needs to be noted however, that if the same Callback is installed */
   /* more than once, then the callbacks will be called serially.       */
   /* Because of this, the processing in this function should be as     */
   /* efficient as possible.  It should also be noted that this function*/
   /* is called in the Thread Context of a Thread that the User does NOT*/
   /* own. Therefore, processing in this function should be as efficient*/
   /* as possible (this argument holds anyway because another SCPS Event*/
   /* will not be processed while this function call is outstanding).   */
   /* ** NOTE ** This function MUST NOT Block and wait for events that  */
   /*            can only be satisfied by Receiving SCPS Event Packets. */
   /*            A Deadlock WILL occur because NO SCPS Event Callbacks  */
   /*            will be issued while this function is currently        */
   /*            outstanding.                                           */
static void QAPI_BLE_BTPSAPI SCPS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_SCPS_Event_Data_t *SCPS_Event_Data, uint32_t CallbackParameter)
{
   int           Result;
   BoardStr_t    BoardStr;
   DeviceInfo_t *DeviceInfo;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (SCPS_Event_Data))
   {
      switch(SCPS_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_SCPS_SERVER_READ_CLIENT_CONFIGURATION_REQUEST_E:
            QCLI_Printf(scps_group, "etSCPS_Server_Read_Client_Configuration_Request with size %u.\n", SCPS_Event_Data->Event_Data_Size);

            if(SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data)
            {
               BD_ADDRToStr(SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->RemoteDevice, BoardStr);

               QCLI_Printf(scps_group, "   Instance ID:      %u.\n", SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->InstanceID);
               QCLI_Printf(scps_group, "   Connection ID:    %u.\n", SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->ConnectionID);
               QCLI_Printf(scps_group, "   Transaction ID:   %u.\n", SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->TransactionID);
               QCLI_Printf(scps_group, "   Connection Type:  %s.\n", ((SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
               QCLI_Printf(scps_group, "   Remote Device:    %s.\n", BoardStr);

               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->RemoteDevice)) != NULL)
               {
                  if(SCPSInstanceID == SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->InstanceID)
                  {
                     switch(SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->ClientConfigurationType)
                     {
                        case QAPI_BLE_CT_SCAN_REFRESH_E:
                           QCLI_Printf(scps_group, "Config Type:      QAPI_BLE_CT_SCAN_REFRESH_E.\n");

                           Result = qapi_BLE_SCPS_Read_Client_Configuration_Response(BluetoothStackID, SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->InstanceID, SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->TransactionID, DeviceInfo->SCPSServerInfo.Scan_Refresh_Client_Configuration);
                           break;

                        default:
                           Result = 0;
                           QCLI_Printf(scps_group, "Config Type:      Unknown.\n");
                           break;
                     }

                     if(Result)
                        DisplayFunctionError("qapi_BLE_SCPS_Read_Client_Configuration_Response", Result);
                  }
                  else
                  {
                     QCLI_Printf(scps_group, "\nInvalid Event data.\n");
                  }
               }
               else
               {
                  QCLI_Printf(scps_group, "\nUnknown Client.\n");
               }
            }
            break;
         case QAPI_BLE_ET_SCPS_SERVER_UPDATE_CLIENT_CONFIGURATION_REQUEST_E:
            QCLI_Printf(scps_group, "etSCPS_Server_Update_Client_Configuration_Request with size %u.\n", SCPS_Event_Data->Event_Data_Size);

            if(SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data)
            {
               BD_ADDRToStr(SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->RemoteDevice, BoardStr);

               QCLI_Printf(scps_group, "   Instance ID:      %u.\n", SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->InstanceID);
               QCLI_Printf(scps_group, "   Connection ID:    %u.\n", SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ConnectionID);
               QCLI_Printf(scps_group, "   Connection Type:  %s.\n", ((SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
               QCLI_Printf(scps_group, "   Remote Device:    %s.\n", BoardStr);

               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->RemoteDevice)) != NULL)
               {
                  if(SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->InstanceID == SCPSInstanceID)
                  {
                     switch(SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ClientConfigurationType)
                     {
                        case QAPI_BLE_CT_SCAN_REFRESH_E:
                           QCLI_Printf(scps_group, "   Config Type:      QAPI_BLE_CT_SCAN_REFRESH_E.\n");

                           DeviceInfo->SCPSServerInfo.Scan_Refresh_Client_Configuration = SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ClientConfiguration;
                           break;
                        default:
                           QCLI_Printf(scps_group, "   Config Type:      Unknown.\n");
                           break;
                     }

                     QCLI_Printf(scps_group, "Value:            0x%04X.\n", (uint16_t)SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ClientConfiguration);
                  }
                  else
                  {
                     QCLI_Printf(scps_group, "\nInvalid Event data.\n");
                  }
               }
               else
               {
                  QCLI_Printf(scps_group, "\nUnknown Client.\n");
               }
            }
            break;
         case QAPI_BLE_ET_SCPS_SERVER_WRITE_SCAN_INTERVAL_WINDOW_REQUEST_E:
            QCLI_Printf(scps_group, "etSCPS_Server_Write_Scan_Interval_Window_Request with size %u.\n", SCPS_Event_Data->Event_Data_Size);

            if(SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data)
            {
               BD_ADDRToStr(SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->RemoteDevice, BoardStr);
               QCLI_Printf(scps_group, "   Instance ID:      %u.\n", SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->InstanceID);
               QCLI_Printf(scps_group, "   Connection ID:    %u.\n", SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->ConnectionID);
               QCLI_Printf(scps_group, "   Connection Type:  %s.\n", ((SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
               QCLI_Printf(scps_group, "   Remote Device:    %s.\n", BoardStr);
               QCLI_Printf(scps_group, "   LE Scan Interval: %d.\n", SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->ScanIntervalWindowData.LE_Scan_Interval);
               QCLI_Printf(scps_group, "   LE Scan Window:   %d.\n", SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->ScanIntervalWindowData.LE_Scan_Window);
            }
            break;
        default:
            QCLI_Printf(scps_group, "Unknown SCPS Event\n");
            break;
      }
   }
   else
   {
      /* There was an error with one or more of the input parameters.   */
      QCLI_Printf(scps_group, "\n");

      QCLI_Printf(scps_group, "SCPS Callback Data: Event_Data = NULL.\n");
   }
}

   /* The following function is for an GATT Server Event Callback.  This*/
   /* function will be called whenever a GATT Request is made to the    */
   /* server who registers this function that cannot be handled         */
   /* internally by GATT.  This function passes to the caller the GATT  */
   /* Server Event Data that occurred and the GATT Server Event Callback*/
   /* Parameter that was specified when this Callback was installed.    */
   /* The caller is free to use the contents of the GATT Server Event   */
   /* Data ONLY in the context of this callback.  If the caller requires*/
   /* the Data for a longer period of time, then the callback function  */
   /* MUST copy the data into another Data Buffer.  This function is    */
   /* guaranteed NOT to be invoked more than once simultaneously for the*/
   /* specified installed callback (i.e.  this function DOES NOT have be*/
   /* reentrant).  It Needs to be noted however, that if the same       */
   /* Callback is installed more than once, then the callbacks will be  */
   /* called serially.  Because of this, the processing in this function*/
   /* should be as efficient as possible.  It should also be noted that */
   /* this function is called in the Thread Context of a Thread that the*/
   /* User does NOT own.  Therefore, processing in this function should */
   /* be as efficient as possible (this argument holds anyway because   */
   /* another GATT Event (Server/Client or Connection) will not be      */
   /* processed while this function call is outstanding).               */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ServerEventCallback_SPPLE(uint32_t BluetoothStackID, qapi_BLE_GATT_Server_Event_Data_t *GATT_ServerEventData, uint32_t CallbackParameter)
{
   boolean_t     DisplayPrompt;
   uint8_t       Temp[2];
   uint16_t      Value;
   uint16_t      PreviousValue;
   uint16_t      AttributeOffset;
   uint16_t      AttributeLength;
   DeviceInfo_t *DeviceInfo;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GATT_ServerEventData))
   {
      DisplayPrompt = false;

      /* Grab the device for the currently connected device.            */
      if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
      {
         switch(GATT_ServerEventData->Event_Data_Type)
         {
            case QAPI_BLE_ET_GATT_SERVER_READ_REQUEST_E:
               /* Verify that the Event Data is valid.                  */
               if(GATT_ServerEventData->Event_Data.GATT_Read_Request_Data)
               {
                  if(GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->AttributeValueOffset == 0)
                  {
                     /* Determine which request this read is coming for.*/
                     switch(GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->AttributeOffset)
                     {
                        case SPPLE_TX_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET:
                           ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(Temp, DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor);
                           break;
                        case SPPLE_TX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET:
                           ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(Temp, DeviceInfo->TransmitCredits);
                           break;
                        case SPPLE_RX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET:
                           ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(Temp, DeviceInfo->ReceiveBuffer.BytesFree);
                           break;
                        case SPPLE_RX_CREDITS_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET:
                           ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(Temp, DeviceInfo->ServerInfo.Rx_Credit_Client_Configuration_Descriptor);
                           break;
                     }

                     qapi_BLE_GATT_Read_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->TransactionID, sizeof(Temp), Temp);
                  }
                  else
                     qapi_BLE_GATT_Error_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->TransactionID, GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->AttributeOffset, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_ATTRIBUTE_NOT_LONG);
               }
               else
               {
                  QCLI_Printf(ble_group, "Invalid Read Request Event Data.\n");
                  DisplayPrompt = true;
               }
               break;
            case QAPI_BLE_ET_GATT_SERVER_WRITE_REQUEST_E:
               /* Verify that the Event Data is valid.                  */
               if(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data)
               {
                  if(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValueOffset == 0)
                  {
                     /* Cache the Attribute Offset.                     */
                     AttributeOffset = GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeOffset;
                     AttributeLength = GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValueLength;

                     /* Check to see if this write is OK for our role.  */
                     if((AttributeOffset == SPPLE_TX_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET) || (AttributeOffset == SPPLE_RX_CREDITS_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET))
                     {
                        /* Check to see if we know if we are the Client */
                        /* or Server.                                   */
                        if(!(DeviceInfo->Flags & (DEVICE_INFO_FLAGS_SPPLE_CLIENT | DEVICE_INFO_FLAGS_SPPLE_SERVER)))
                        {
                           /* We will be the Server for this device.    */
                           DeviceInfo->Flags |= DEVICE_INFO_FLAGS_SPPLE_SERVER;
                        }
                        else
                        {
                           /* This indicates that we are acting as a    */
                           /* Server.  Error the request if we are a    */
                           /* Client                                    */
                           if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_CLIENT)
                           {
                              /* Cause the Request to be invalid.       */
                              AttributeLength = 0;
                           }
                        }
                     }

                     /* Verify that the value is of the correct length. */
                     if((AttributeOffset == SPPLE_RX_CHARACTERISTIC_ATTRIBUTE_OFFSET) || ((AttributeLength) && (AttributeLength <= sizeof(uint16_t))))
                     {
                        /* Since the value appears valid go ahead and   */
                        /* accept the write request.                    */
                        qapi_BLE_GATT_Write_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->TransactionID);

                        /* If this is not a write to the Rx             */
                        /* Characteristic we will read the data here.   */
                        if(AttributeOffset != SPPLE_RX_CHARACTERISTIC_ATTRIBUTE_OFFSET)
                        {
                           if(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValueLength == sizeof(uint16_t))
                              Value = READ_UNALIGNED_WORD_LITTLE_ENDIAN(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValue);
                           else
                              Value = READ_UNALIGNED_BYTE_LITTLE_ENDIAN(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValue);
                        }
                        else
                           Value = 0;

                        /* Determine which attribute this write request */
                        /* is for.                                      */
                        switch(AttributeOffset)
                        {
                           case SPPLE_TX_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET:
                              /* Client has updated the Tx CCCD.  Now we*/
                              /* need to check if we have any data to   */
                              /* send.                                  */
                              DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor = Value;

                              /* If may be possible for transmit queued */
                              /* data now.  So fake a Receive Credit    */
                              /* event with 0 as the received credits.  */
                              DisplayPrompt = ReceiveCreditEvent(DeviceInfo, 0);
                              break;
                           case SPPLE_TX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET:
                              /* Client has sent updated credits.       */
                              DisplayPrompt = ReceiveCreditEvent(DeviceInfo, Value);
                              break;
                           case SPPLE_RX_CHARACTERISTIC_ATTRIBUTE_OFFSET:
                              /* Client has sent data, so we should     */
                              /* handle this as a data indication event.*/
                              DisplayPrompt = DataIndicationEvent(DeviceInfo, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValueLength, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValue);
                              break;
                           case SPPLE_RX_CREDITS_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET:
                              /* Cache the previous CCD Value.          */
                              PreviousValue = DeviceInfo->ServerInfo.Rx_Credit_Client_Configuration_Descriptor;

                              /* Note the updated Rx CCCD Value.        */
                              DeviceInfo->ServerInfo.Rx_Credit_Client_Configuration_Descriptor = Value;

                              /* If we were not previously configured   */
                              /* for notifications send the initial     */
                              /* credits to the device.                 */
                              if(PreviousValue != QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                              {
                                 /* Send the initial credits to the     */
                                 /* device.                             */
                                 SendCredits(DeviceInfo, DeviceInfo->ReceiveBuffer.BytesFree);
                              }
                              break;
                        }
                     }
                     else
                        qapi_BLE_GATT_Error_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->TransactionID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeOffset, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_ATTRIBUTE_VALUE_LENGTH);
                  }
                  else
                     qapi_BLE_GATT_Error_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->TransactionID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeOffset, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_ATTRIBUTE_NOT_LONG);
               }
               else
               {
                  QCLI_Printf(ble_group, "Invalid Write Request Event Data.\n");
                  DisplayPrompt = true;
               }
               break;
            default:
               break;
         }
      }

      if(DisplayPrompt)
         QCLI_Display_Prompt();
   }
}

   /* Handles event callbacks for the OTA server.                       */
static void OTA_EventCallback(uint32_t BluetoothStackID, BLE_OTA_Server_Event_Data_t *BLE_OTA_Server_Event_Data, void *CallbackParameter)
{
   uint32_t                     TransactionID;
   uint32_t                     ConnectionID;
   uint32_t                     ImageID;
   uint32_t                     FileOffset;
   uint32_t                     DataLength;
   uint8_t                      Index;
   uint8_t                     *DataBuffer = NULL;
   uint8_t                      Status = BLE_OTA_STATUS_FAILURE;
   int                          Result;
   int32_t                      Unused;
   BLE_OTA_Demo_Image_Info_t   *DemoImageInfo;

   if((BluetoothStackID) && (BLE_OTA_Server_Event_Data))
   {
      switch(BLE_OTA_Server_Event_Data->Event_Data_Type)
      {
         case BLE_OTA_SERVER_EVENT_TYPE_IMAGE_DATA_REQUEST_E:
            TransactionID = BLE_OTA_Server_Event_Data->Event_Data.BLE_OTA_Server_Image_Data_Request_Event_Data->TransactionID;
            ConnectionID  = BLE_OTA_Server_Event_Data->Event_Data.BLE_OTA_Server_Image_Data_Request_Event_Data->ConnectionID;
            ImageID       = BLE_OTA_Server_Event_Data->Event_Data.BLE_OTA_Server_Image_Data_Request_Event_Data->ImageID;
            FileOffset    = BLE_OTA_Server_Event_Data->Event_Data.BLE_OTA_Server_Image_Data_Request_Event_Data->FileOffset;
            DataLength    = BLE_OTA_Server_Event_Data->Event_Data.BLE_OTA_Server_Image_Data_Request_Event_Data->DataLength;

            QCLI_Printf(ota_group, "BLE_OTA_SERVER_EVENT_TYPE_IMAGE_DATA_REQUEST_E received, image ID %d, file offset %d, length %d.\n", ImageID, FileOffset, DataLength);

            DemoImageInfo = NULL;

            if(UseOTADefaultImages)
            {
               /* Find this image ID.                                   */
               for(Index = 0; Index < sizeof(DefaultOTAServerImageData)/sizeof(BLE_OTA_Server_Image_Data_t); Index++)
               {
                  if(DefaultOTAServerImageData[Index].ImageID == ImageID)
                  {
                     DemoImageInfo = &DefaultOTAImageInfo[Index];
                     break;
                  }
               }
            }
            else
            {
               /* Find this image ID.                                   */
               for(Index = 0; Index < sizeof(ManualOTAServerImageData)/sizeof(BLE_OTA_Server_Image_Data_t); Index++)
               {
                  if(ManualOTAServerImageData[Index].ImageID == ImageID)
                  {
                     DemoImageInfo = &ManualOTAImageInfo[Index];
                     break;
                  }
               }
            }

            if(DemoImageInfo)
            {
               /* Open the file.                                        */
               if((DemoImageInfo->ImageFd) || ((!DemoImageInfo->ImageFd) && (qapi_Fs_Open(DemoImageInfo->FilePath, QAPI_FS_O_RDONLY, &DemoImageInfo->ImageFd) == QAPI_OK)))
               {
                  /* Seek to the image offset.                          */
                  if(qapi_Fs_Lseek(DemoImageInfo->ImageFd, FileOffset, QAPI_FS_SEEK_SET, &Unused) == QAPI_OK)
                  {
                     DataBuffer = (uint8_t *)malloc(DataLength);

                     if(DataBuffer)
                     {
                        /* Read the data into the buffer.               */
                        if(qapi_Fs_Read(DemoImageInfo->ImageFd, DataBuffer, DataLength, &DataLength) == QAPI_OK)
                        {
                           Status = BLE_OTA_STATUS_SUCCESS;
                        }
                        else
                           QCLI_Printf(ota_group, "Error, could not read from flash.\n");
                     }
                     else
                     {
                        Status = BLE_OTA_STATUS_OUT_OF_MEMORY;
                        QCLI_Printf(ota_group, "Error, could not allocate buffer.\n");
                     }
                  }
                  else
                     QCLI_Printf(ota_group, "Error, could not seek data.\n");
               }
               else
               {
                  QCLI_Printf(ota_group, "Error, could not open file.\n");
                  DemoImageInfo->ImageFd = 0;
               }
            }
            else
            {
               Status = BLE_OTA_STATUS_INVALID_PARAMETER;
               DataLength = 0;
               QCLI_Printf(ota_group, "Could not find OTA image with ID %d.\n", ImageID);
            }

            /* Issue the response.                                      */
            Result = BLE_OTA_Image_Data_Response(BluetoothStackID, OTAInstanceID, ConnectionID, TransactionID, ImageID, Status, DataBuffer, DataLength, FileOffset);

            /* Free the buffer.                                         */
            if(DataBuffer)
               free(DataBuffer);

            if(Result != BLE_OTA_STATUS_SUCCESS)
               QCLI_Printf(ota_group, "BLE_OTA_Image_Data_Response() returned failure, %d.\n", Status);


            break;
         default:
            break;
      }
   }
}

   /* Generic Attribute Profile (GATT) Service Event Callback function  */
   /* prototypes (Client).                                              */

   /* The following function is for an GATT Client Event Callback.  This*/
   /* function will be called whenever a GATT Response is received for a*/
   /* request that was made when this function was registered.  This    */
   /* function passes to the caller the GATT Client Event Data that     */
   /* occurred and the GATT Client Event Callback Parameter that was    */
   /* specified when this Callback was installed.  The caller is free to*/
   /* use the contents of the GATT Client Event Data ONLY in the context*/
   /* of this callback.  If the caller requires the Data for a longer   */
   /* period of time, then the callback function MUST copy the data into*/
   /* another Data Buffer.  This function is guaranteed NOT to be       */
   /* invoked more than once simultaneously for the specified installed */
   /* callback (i.e.  this function DOES NOT have be reentrant).  It    */
   /* Needs to be noted however, that if the same Callback is installed */
   /* more than once, then the callbacks will be called serially.       */
   /* Because of this, the processing in this function should be as     */
   /* efficient as possible.  It should also be noted that this function*/
   /* is called in the Thread Context of a Thread that the User does NOT*/
   /* own.  Therefore, processing in this function should be as         */
   /* efficient as possible (this argument holds anyway because another */
   /* GATT Event (Server/Client or Connection) will not be processed    */
   /* while this function call is outstanding).                         */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_AIOS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
   int                                         Result;
   DeviceInfo_t                               *DeviceInfo;
   BoardStr_t                                  BoardStr;
   uint32_t                                    ConnectionID;
   uint32_t                                    TransactionID;
   qapi_BLE_GATT_Connection_Type_t             ConnectionType;
   qapi_BLE_BD_ADDR_t                          RemoteDevice;
   uint16_t                                    ValueLength;
   uint8_t                                    *Value;
   uint16_t                                    BytesWritten;
   qapi_BLE_GATT_Request_Error_Type_t          ErrorType;
   AIOP_Client_Instance_Info_t                *InstanceInfoPtr = NULL;
   union
   {
      qapi_BLE_AIOS_Characteristic_Data_t      Data;
      uint16_t                                 CCCD;
      qapi_BLE_AIOS_Presentation_Format_Data_t PresentationFormat;
   } ReadResponseData;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GATT_Client_Event_Data))
   {
      /* Determine the event that occurred.                             */
      switch(GATT_Client_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
            QCLI_Printf(aios_group, "\nQAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E\n");
            if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
            {
               /* Store the event data.                                 */
               ConnectionID   = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID;
               RemoteDevice   = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice;
               TransactionID  = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID;
               ConnectionType = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType;
               ErrorType      = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType;

               QCLI_Printf(aios_group, "   Connection ID:    %u.\n", ConnectionID);
               QCLI_Printf(aios_group, "   Transaction ID:   %u.\n", TransactionID);
               QCLI_Printf(aios_group, "   Connection Type:  %s.\n", (ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR");
               BD_ADDRToStr(RemoteDevice, BoardStr);
               QCLI_Printf(aios_group, "   BD_ADDR:          %s.\n", BoardStr);
               QCLI_Printf(aios_group, "   Error Type:       %s.\n", (ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E) ? "Response Error" : "Response Timeout");

               /* Only print out the rest if it is valid.               */
               if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
               {
                  QCLI_Printf(aios_group, "   Request Opcode:   0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                  QCLI_Printf(aios_group, "   Request Handle:   0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                  QCLI_Printf(aios_group, "   Error Code:       0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);

                  /* Print common error codes.                          */
                  switch(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode)
                  {
                     case QAPI_BLE_AIOS_ERROR_CODE_TRIGGER_CONDITION_VALUE_NOT_SUPPORTED:
                        QCLI_Printf(aios_group, "   Error Mesg:       AIOS_ERROR_CODE_TRIGGER_CONDITION_VALUE_NOT_SUPPORTED\n");
                        break;
                     default:
                        if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode < NUMBER_OF_ERROR_CODES)
                        {
                           QCLI_Printf(aios_group, "   Error Mesg:       %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
                        }
                        else
                        {
                           QCLI_Printf(aios_group, "   Error Mesg:       Unknown.\n");
                        }
                        break;
                  }
               }
            }
            else
               QCLI_Printf(aios_group, "Error - Null Error Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
            QCLI_Printf(aios_group, "\nQAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E\n");
            if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
            {
               /* Store the event data.                                 */
               ConnectionID   = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionID;
               RemoteDevice   = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice;
               TransactionID  = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->TransactionID;
               ConnectionType = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionType;
               ValueLength    = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength;
               Value          = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue;

               /* Print the event data.                                 */
               QCLI_Printf(aios_group, "   Connection ID:    %u.\n", ConnectionID);
               QCLI_Printf(aios_group, "   Transaction ID:   %u.\n", TransactionID);
               QCLI_Printf(aios_group, "   Connection Type:  %s.\n", (ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR");
               BD_ADDRToStr(RemoteDevice, BoardStr);
               QCLI_Printf(aios_group, "   BD_ADDR:          %s.\n", BoardStr);
               QCLI_Printf(aios_group, "   Handle:           0x%04X.\n", CallbackParameter);
               QCLI_Printf(aios_group, "   Value Length:     %u.\n", ValueLength);

               /* Make sure we can get the device information.          */
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, RemoteDevice)) != NULL)
               {
                  /* Process the request depending on the attribute     */
                  /* handle type we set before issuing the read request.*/
                  switch(DeviceInfo->AIOPClientInfo.Client_Request_Info.AttributeHandleType)
                  {
                     case ahtCharacteristic:
                        /* We need to determine the type of AIOS        */
                        /* Characteristic to properly decode the value. */
                        switch(DeviceInfo->AIOPClientInfo.Client_Request_Info.Type)
                        {
                           case QAPI_BLE_ACT_DIGITAL_E:
                              /* Call the function to decode and display*/
                              /* the Digital Characteristic.            */
                              DecodeDisplayDigitalCharacteristic(ValueLength, Value, DeviceInfo->AIOPClientInfo.Client_Request_Info.ID);
                              break;
                           case QAPI_BLE_ACT_ANALOG_E:
                              /* Call the function to decode and display*/
                              /* the Analog Characteristic.             */
                              DecodeDisplayAnalogCharacteristic(ValueLength, Value, DeviceInfo->AIOPClientInfo.Client_Request_Info.ID);
                              break;
                           default:
                              QCLI_Printf(aios_group, "\nError - Invalid Characteristic type.\n");
                              break;
                        }
                        break;
                     case ahtPresentationFormat:
                        /* Simply call the AIOS Client API to decode the*/
                        /* Presentation Format.                         */
                        if((Result = qapi_BLE_AIOS_Decode_Presentation_Format(ValueLength, Value, &ReadResponseData.PresentationFormat)) == 0)
                        {
                           /* Simply call the internal function to      */
                           /* display the Presentation Format           */
                           /* descriptor.                               */
                           DisplayAIOSPresentationFormatData(&ReadResponseData.PresentationFormat);
                        }
                        else
                           DisplayFunctionError("qapi_BLE_AIOS_Decode_Presentation_Format",  Result);
                        break;
                     case ahtNumberOfDigitals:
                        /* Display the descriptor type.                 */
                        QCLI_Printf(aios_group, "\nNumber Of Digitals:\n");

                        /* Verify the length of the number of digitals. */
                        /* * NOTE * At least one octet, or 4 possible   */
                        /*          digital signals MUST be present.    */
                        if(ValueLength >= (uint16_t)QAPI_BLE_NON_ALIGNED_BYTE_SIZE)
                        {
                           /* Let's get the instance information based  */
                           /* on the Type and ID we previously stored   */
                           /* when the request was sent so we can store */
                           /* the Number of Digitals value in the       */
                           /* instance's information.                   */
                           InstanceInfoPtr = GetAIOSClientInstanceInfoPtr(&(DeviceInfo->AIOPClientInfo));
                           if(InstanceInfoPtr)
                           {
                              /* Decode the value.                      */
                              InstanceInfoPtr->Number_Of_Digitals = READ_UNALIGNED_BYTE_LITTLE_ENDIAN(Value);

                              /* Display the value.                     */
                              QCLI_Printf(aios_group, "   Value:  %u\n", InstanceInfoPtr->Number_Of_Digitals);
                           }
                           else
                              QCLI_Printf(aios_group, "\nError - Could not find the Characteristic instance's information.\n");
                        }
                        else
                           QCLI_Printf(aios_group, "   Value:  Invalid length.\n");
                        break;
                     default:
                        QCLI_Printf(aios_group, "\nError - Invalid attribute handle type.\n");
                        break;
                  }
               }
               else
                  QCLI_Printf(aios_group, "\nError - Unknown device.\n");
            }
            else
               QCLI_Printf(aios_group, "\nError - Null Read Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
            QCLI_Printf(aios_group, "\netGATT_Client_Write_Response.\n");
            if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
            {
               /* Store the event data.                                 */
               ConnectionID   = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID;
               RemoteDevice   = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice;
               TransactionID  = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID;
               ConnectionType = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType;
               BytesWritten   = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten;

               /* Print the event data.                                 */
               QCLI_Printf(aios_group, "   Connection ID:    %u.\n", ConnectionID);
               QCLI_Printf(aios_group, "   Transaction ID:   %u.\n", TransactionID);
               QCLI_Printf(aios_group, "   Connection Type:  %s.\n", (ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR");
               BD_ADDRToStr(RemoteDevice, BoardStr);
               QCLI_Printf(aios_group, "   BD_ADDR:          %s.\n", BoardStr);
               QCLI_Printf(aios_group, "   Bytes Written:    %u.\n", BytesWritten);
            }
            else
               QCLI_Printf(aios_group, "\nError - Null Write Response Data.\n");
            break;
         default:
            /* Prevent compiler warnings.                               */
            break;
      }
   }
   else
   {
      /* There was an error with one or more of the input parameters.   */
      QCLI_Printf(bas_group, "\n");

      QCLI_Printf(bas_group, "GATT Callback Data: Event_Data = NULL.\n");
   }
}

   /* The following function is for an GATT Client Event Callback.  This*/
   /* function will be called whenever a GATT Response is received for a*/
   /* request that was made when this function was registered.  This    */
   /* function passes to the caller the GATT Client Event Data that     */
   /* occurred and the GATT Client Event Callback Parameter that was    */
   /* specified when this Callback was installed.  The caller is free to*/
   /* use the contents of the GATT Client Event Data ONLY in the context*/
   /* of this callback.  If the caller requires the Data for a longer   */
   /* period of time, then the callback function MUST copy the data into*/
   /* another Data Buffer.  This function is guaranteed NOT to be       */
   /* invoked more than once simultaneously for the specified installed */
   /* callback (i.e.  this function DOES NOT have be reentrant).  It    */
   /* Needs to be noted however, that if the same Callback is installed */
   /* more than once, then the callbacks will be called serially.       */
   /* Because of this, the processing in this function should be as     */
   /* efficient as possible.  It should also be noted that this function*/
   /* is called in the Thread Context of a Thread that the User does NOT*/
   /* own.  Therefore, processing in this function should be as         */
   /* efficient as possible (this argument holds anyway because another */
   /* GATT Event (Server/Client or Connection) will not be processed    */
   /* while this function call is outstanding).                         */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_BAS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
   int                                      Result;
   uint8_t                                  BatteryLevel;
   uint16_t                                 ValueLength;
   uint16_t                                 Index;
   BoardStr_t                               BoardStr;
   DeviceInfo_t                            *DeviceInfo;
   qapi_BLE_BAS_Presentation_Format_Data_t  BatteryLevelFormatData;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GATT_Client_Event_Data))
   {
      /* Determine the event that occurred.                             */
      switch(GATT_Client_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
            {
               QCLI_Printf(bas_group, "\nError Response: %02X\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
               QCLI_Printf(bas_group, "   Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
               QCLI_Printf(bas_group, "   Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
               QCLI_Printf(bas_group, "   Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(bas_group, "   BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(bas_group, "   Error Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

               /* Only print out the rest if it is valid.               */
               if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
               {
                  QCLI_Printf(bas_group, "   Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                  QCLI_Printf(bas_group, "   Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                  QCLI_Printf(bas_group, "   Error Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                  QCLI_Printf(bas_group, "   Error Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
               }
            }
            else
               QCLI_Printf(bas_group, "Error - Null Error Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
            {
               QCLI_Printf(bas_group, "\nRead Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice, BoardStr);
               QCLI_Printf(bas_group, "Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionID);
               QCLI_Printf(bas_group, "Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->TransactionID);
               QCLI_Printf(bas_group, "Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(bas_group, "BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(bas_group, "Data Length:     %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength);

               /* If we know about this device and a callback parameter */
               /* exists, then check if we know what read response this */
               /* is.                                                   */
               ValueLength = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength;
               if(ValueLength != 0)
               {
                  if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                  {
                     if(IsBatteryLevelHandle((uint16_t)CallbackParameter, DeviceInfo))
                     {
                        if(ValueLength == QAPI_BLE_BAS_BATTERY_LEVEL_VALUE_LENGTH)
                        {
                           BatteryLevel = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue[0];
                           if(QAPI_BLE_BAS_VALID_BATTERY_LEVEL(BatteryLevel))
                              QCLI_Printf(bas_group, "\n   Battery Level: %u%%.\n", (uint16_t)BatteryLevel);
                           else
                              QCLI_Printf(bas_group, "\nError - Battery Level has been corrupted %d\n", BatteryLevel);
                        }
                        else
                           QCLI_Printf(bas_group, "\nError - Invalid length (%u) for Battery Level response\n", ValueLength);
                     }
                     else
                     {
                        if(IsBatteryLevelPresentationFormatHandle((uint16_t)CallbackParameter,DeviceInfo))
                        {
                           if(ValueLength == QAPI_BLE_BAS_PRESENTATION_FORMAT_SIZE)
                           {
                              if((Result = qapi_BLE_BAS_Decode_Characteristic_Presentation_Format(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue, &BatteryLevelFormatData)) == 0)
                              {
                                 QCLI_Printf(bas_group, "\n   Format: %u.\n",      BatteryLevelFormatData.Format);
                                 QCLI_Printf(bas_group, "\n   Exponent: %u.\n",    BatteryLevelFormatData.Exponent);
                                 QCLI_Printf(bas_group, "\n   Unit: %u.\n",        BatteryLevelFormatData.Unit);
                                 QCLI_Printf(bas_group, "\n   NameSpace: %u.\n",   BatteryLevelFormatData.NameSpace);
                                 QCLI_Printf(bas_group, "\n   Description: %u.\n", BatteryLevelFormatData.Description);
                              }
                              else
                                 DisplayFunctionError("qapi_BLE_BAS_Decode_Characteristic_Presentation_Format", Result);
                           }
                           else
                              QCLI_Printf(bas_group, "\nError - Invalid length (%u) for Battery Level Presentation Format response.\n", ValueLength);
                        }
                        else
                        {
                           /* Could not find a descriptor to match the  */
                           /* read response, so display raw data        */
                           CallbackParameter = 0;
                        }
                     }
                  }

                  /* If the data has not been decoded and displayed,    */
                  /* then just display the raw data                     */
                  if((DeviceInfo == NULL) || (CallbackParameter == 0))
                  {
                     QCLI_Printf(bas_group, "Data:            { ");
                     for(Index = 0; Index < (ValueLength - 1); Index++)
                        QCLI_Printf(bas_group, "0x%02x, ", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue[Index]);

                     QCLI_Printf(bas_group, "0x%02x }\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue[Index]);
                  }
               }
            }
            else
               QCLI_Printf(bas_group, "\nError - Null Read Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
            {
               QCLI_Printf(bas_group, "\nWrite Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
               QCLI_Printf(bas_group, "Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
               QCLI_Printf(bas_group, "Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
               QCLI_Printf(bas_group, "Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(bas_group, "BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(bas_group, "Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);

               /* If we know about this device and a callback parameter */
               /* exists, then check if we know what write response this*/
               /* is.                                                   */
               if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
               {
                  if(IsBASClientConfigurationHandle((uint16_t)CallbackParameter, DeviceInfo))
                     QCLI_Printf(bas_group, "\nWrite Battery Level CC Compete.\n");
               }
            }
            else
               QCLI_Printf(bas_group, "\nError - Null Write Response Data.\n");
            break;
         default:
            break;
      }
   }
   else
   {
      /* There was an error with one or more of the input parameters.   */
      QCLI_Printf(bas_group, "\n");

      QCLI_Printf(bas_group, "GATT Callback Data: Event_Data = NULL.\n");
   }
}

   /* The following function is for an GATT Client Event Callback. This */
   /* function will be called whenever a GATT Response is received for  */
   /* a request that was made when this function was registered. This   */
   /* function passes to the caller the GATT Client Event Data that     */
   /* occurred and the GATT Client Event Callback Parameter that was    */
   /* specified when this Callback was installed. The caller is free to */
   /* use the contents of the GATT Client Event Data ONLY in the        */
   /* context of this callback. If the caller requires the Data for a   */
   /* longer period of time, then the callback function MUST copy the   */
   /* data into another Data Buffer. This function is guaranteed NOT to */
   /* be invoked more than once simultaneously for the specified        */
   /* installed callback (i.e. this function DOES NOT have be           */
   /* reentrant). It Needs to be noted however, that if the same        */
   /* Callback is installed more than once, then the callbacks will be  */
   /* called serially. Because of this, the processing in this function */
   /* should be as efficient as possible. It should also be noted that  */
   /* this function is called in the Thread Context of a Thread that    */
   /* the User does NOT own. Therefore, processing in this function     */
   /* should be as efficient as possible (this argument holds anyway    */
   /* because another GATT Event (Server/Client or Connection) will not */
   /* be processed while this function call is outstanding).            */
   /* * NOTE * This function MUST NOT Block and wait for Events that    */
   /*          can only be satisfied by Receiving a Bluetooth Event     */
   /*          Callback. A Deadlock WILL occur because NO Bluetooth     */
   /*          Callbacks will be issued while this function is          */
   /*          currently outstanding.                                   */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_HIDS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
   int                 Result;
   uint8_t            *ReportMap;
   uint8_t            *AttributeValue;
   uint16_t            AttributeValueLength;
   uint16_t            Index;
   boolean_t           CallbackParameterFound = FALSE;
   BoardStr_t          BoardStr;
   unsigned int        InstanceIndex;
   DeviceInfo_t       *DeviceInfo;
   HIDS_Client_Info_t *ClientInfo             = NULL;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GATT_Client_Event_Data))
   {
      /* Determine the event that occurred.                             */
      switch(GATT_Client_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
            {
               /* Get the device info.                                  */
               if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
               {
                  /* Loop through the HIDS client information array and */
                  /* find the service for this callback parameter.      */
                  for(Index = 0; Index < MAX_SUPPORTED_HID_INSTANCES; Index++)
                  {
                     if((CallbackParameter >= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Starting_Handle) && (CallbackParameter <= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Ending_Handle))
                     {
                        ClientInfo = &DeviceInfo->HIDSClientInfo[Index];
                        InstanceIndex = Index;
                        break;
                     }
                  }

                  /* Make sure the HIDS client information was found.   */
                  if(ClientInfo)
                  {
                     /* Output the error data unless this is an invalid */
                     /* offset error for the report map, as sometimes   */
                     /* this will mark the end of the attribute value.  */
                     if((CallbackParameter != ClientInfo->ReportMapHandle) || ((CallbackParameter == ClientInfo->ReportMapHandle) && (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode != QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_OFFSET)))
                     {
                        QCLI_Printf(hids_group, "\nError Response.\n");
                        BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
                        QCLI_Printf(hids_group, "   Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
                        QCLI_Printf(hids_group, "   Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
                        QCLI_Printf(hids_group, "   Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                        QCLI_Printf(hids_group, "   BD_ADDR:         %s.\n", BoardStr);
                        QCLI_Printf(hids_group, "   Error Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

                        /* Only print out the rest if it is valid.      */
                        if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
                        {
                           QCLI_Printf(hids_group, "   Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                           QCLI_Printf(hids_group, "   Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                           QCLI_Printf(hids_group, "   Error Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);

                           if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode < NUMBER_OF_ERROR_CODES)
                              QCLI_Printf(hids_group, "Error Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
                        }
                     }

                     /* Handle the report map callback.                 */
                     if(CallbackParameter == ClientInfo->ReportMapHandle)
                     {
                        /* Output the data if it exists.                */
                        if((ClientInfo->ReportMap) && (ClientInfo->ReportMapLength))
                        {
                           QCLI_Printf(hids_group, "\nHIDS Report Map:\n");

                           QCLI_Printf(hids_group, "   Report Map Length:  %d\n", ClientInfo->ReportMapLength);
                           QCLI_Printf(hids_group, "   Report Map:         { ");
                           for(Index = 0; Index < (ClientInfo->ReportMapLength-1); Index++)
                              QCLI_Printf(hids_group, "0x%02x, ", ClientInfo->ReportMap[Index]);

                           QCLI_Printf(hids_group, "0x%02x }\n\nRead HIDS information complete.\n", ClientInfo->ReportMap[Index]);
                        }

                        /* Read the next HID service information if it  */
                        /* exists.                                      */
                        if((InstanceIndex < (MAX_SUPPORTED_HID_INSTANCES - 1)) && (DeviceInfo->HIDSClientInfo[InstanceIndex+1].ReportMapHandle))
                        {
                           QCLI_Printf(hids_group, "\nAttempting to read HIDS information (Instance ID %u)\n", InstanceIndex + 2);
                           ReadHIDSInfo(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID, &(DeviceInfo->HIDSClientInfo[InstanceIndex+1]));
                        }
                     }
                     else
                     {
                        /* Handle the Boot Keyboard Input Report CCCD   */
                        /* callback.                                    */
                        if(CallbackParameter == ClientInfo->BootKeyboardInputReport_CCCD)
                           QCLI_Printf(hids_group, "\nWrite HIDS Boot Keyboard Input Report CCCD failure.\n");
                        else
                        {
                           /* Handle the Boot Mouse Input Report CCCD   */
                           /* callback.                                 */
                           if(CallbackParameter == ClientInfo->BootMouseInputReport_CCCD)
                              QCLI_Printf(hids_group, "\nWrite HIDS Boot Mouse Input Report CCCD failure.\n");
                           else
                           {
                              /* Handle an external report reference    */
                              /* callback by looping through the list   */
                              /* of external report references.         */
                              for(Index=0; Index < HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES; Index++)
                              {
                                 /* See if the callback exists as an    */
                                 /* external report reference handle.   */
                                 if(CallbackParameter == ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle)
                                 {
                                    QCLI_Printf(hids_group, "Read HIDS External Report Reference Data failure.\n");

                                    break;
                                 }
                              }

                              /* Handle a report reference callback by  */
                              /* looping through the list of reports.   */
                              for(Index=0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                              {
                                 /* See if the callback exists as a     */
                                 /* report CCCD handle.                 */
                                 if(CallbackParameter == ClientInfo->Reports[Index].CCCDHandle)
                                 {
                                    QCLI_Printf(hids_group, "\nWrite HIDS Report ID %d CCCD failure.\n", ClientInfo->Reports[Index].ReportReferenceData.ReportID);
                                    break;
                                 }

                                 /* See if the callback exists as a     */
                                 /* report reference handle.            */
                                 if(CallbackParameter == ClientInfo->Reports[Index].ReportReferenceHandle)
                                 {
                                    QCLI_Printf(hids_group, "\nRead HIDS Report Reference Data failure.\n");
                                    break;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            else
               QCLI_Printf(hids_group, "Error - Null Error Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_READ_LONG_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data)
            {
               AttributeValue       = GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data->AttributeValue;
               AttributeValueLength = GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data->AttributeValueLength;

               /* If we know about this device and a callback parameter */
               /* exists, then check if we know what read long response */
               /* this is.                                              */
               if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
               {
                  /* Loop through the HIDS client information array and */
                  /* find the service for this callback parameter.      */
                  for(Index = 0; Index < MAX_SUPPORTED_HID_INSTANCES; Index++)
                  {
                     if((CallbackParameter >= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Starting_Handle) && (CallbackParameter <= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Ending_Handle))
                     {
                        ClientInfo = &DeviceInfo->HIDSClientInfo[Index];
                        InstanceIndex = Index;
                        break;
                     }
                  }

                  /* Make sure the HIDS client information was found.   */
                  if(ClientInfo)
                  {
                     /* Handle the report map callback.                 */
                     if(CallbackParameter == ClientInfo->ReportMapHandle)
                     {
                        /* Handle any report map data returned.         */
                        if(AttributeValueLength != 0)
                        {
                           /* Make sure the report map was previously   */
                           /* allocated.                                */
                           if(ClientInfo->ReportMap)
                           {
                              /* Allocate a buffer to hold the previuos */
                              /* and the new report map data.           */
                              if((ReportMap = malloc(AttributeValueLength + ClientInfo->ReportMapLength)) != NULL)
                              {
                                 /* Copy the old data into the buffer.  */
                                 memcpy(ReportMap, ClientInfo->ReportMap, ClientInfo->ReportMapLength);

                                 /* Append the new data into the        */
                                 /* buffer.                             */
                                 memcpy((ReportMap + ClientInfo->ReportMapLength), AttributeValue, AttributeValueLength);

                                 /* Free the old data and increment the */
                                 /* report map length.                  */
                                 free(ClientInfo->ReportMap);
                                 ClientInfo->ReportMapLength += AttributeValueLength;

                                 /* Allocate the static buffer to the   */
                                 /* new size to hold the data we just   */
                                 /* copied.                             */
                                 if((ClientInfo->ReportMap = malloc(ClientInfo->ReportMapLength)) != NULL)
                                 {
                                    /* Copy the old and new data into   */
                                    /* the static buffer.               */
                                    memcpy(ClientInfo->ReportMap, ReportMap, ClientInfo->ReportMapLength);

                                    /* Try to read the next blob of     */
                                    /* report map data.                 */
                                    Result = qapi_BLE_GATT_Read_Long_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, ClientInfo->ReportMapHandle, ClientInfo->ReportMapLength, GATT_ClientEventCallback_HIDS, ClientInfo->ReportMapHandle);
                                 }
                                 else
                                    QCLI_Printf(hids_group, "Read report map failure: Insufficient Buffer Space.\n");

                                 /* Free the local buffer.              */
                                 free(ReportMap);
                              }
                              else
                                 QCLI_Printf(hids_group, "Read report map failure: Insufficient Buffer Space.\n");
                           }
                        }
                        else
                        {
                           /* Handle zero data received, marking the    */
                           /* end of the report map.                    */
                           if(ClientInfo->ReportMapLength)
                           {
                              /* Print the data.                        */
                              QCLI_Printf(hids_group, "\nHIDS Report Map:\n");

                              QCLI_Printf(hids_group, "   Report Map Length:  %d\n", ClientInfo->ReportMapLength);
                              QCLI_Printf(hids_group, "   Report Map:         { ");
                              for(Index = 0; Index < (ClientInfo->ReportMapLength-1); Index++)
                                 QCLI_Printf(hids_group, "0x%02x, ", ClientInfo->ReportMap[Index]);

                              QCLI_Printf(hids_group, "0x%02x }\n\nRead HIDS information complete.\n", ClientInfo->ReportMap[Index]);

                              /* Read the next HID service information  */
                              /* if it exists.                          */
                              if((InstanceIndex < (MAX_SUPPORTED_HID_INSTANCES - 1)) && (DeviceInfo->HIDSClientInfo[InstanceIndex+1].ReportMapHandle))
                              {
                                 QCLI_Printf(hids_group, "\nAttempting to read HIDS information (Instance ID %u)\n", InstanceIndex + 2);
                                 ReadHIDSInfo(GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data->ConnectionID, &(DeviceInfo->HIDSClientInfo[InstanceIndex + 1]));
                              }
                           }
                        }
                     }
                     else
                     {
                        /* Could not find a descriptor to match the     */
                        /* read response, so display raw data           */
                        CallbackParameter = 0;
                     }

                     /* If the data has not been decoded and displayed, */
                     /* then just display the raw data                  */
                     if((DeviceInfo == NULL) || (CallbackParameter == 0))
                     {
                        QCLI_Printf(hids_group, "   Data:            { ");
                        for(Index = 0; Index < (AttributeValueLength - 1); Index++)
                           QCLI_Printf(hids_group, "0x%02x, ", AttributeValue[Index]);

                        QCLI_Printf(hids_group, "0x%02x }\n", AttributeValue[Index]);
                     }
                  }
               }
            }
            else
               QCLI_Printf(hids_group, "\nError - Null Read Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
            {
               AttributeValue       = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue;
               AttributeValueLength = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength;

               /* If we know about this device and a callback parameter */
               /* exists, then check if we know what read response this */
               /* is.                                                   */
               if(AttributeValueLength != 0)
               {
                  /* Get the device info.                               */
                  if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                  {
                     /* Loop through the HIDS client information array  */
                     /* and find the service for this callback          */
                     /* parameter.                                      */
                     for(Index = 0; Index < MAX_SUPPORTED_HID_INSTANCES; Index++)
                     {
                        if((CallbackParameter >= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Starting_Handle) && (CallbackParameter <= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Ending_Handle))
                        {
                           ClientInfo = &DeviceInfo->HIDSClientInfo[Index];
                           InstanceIndex = Index;
                           break;
                        }
                     }

                     /* Make sure the HIDS client information was       */
                     /* found.                                          */
                     if(ClientInfo)
                     {
                        /* Handle the HID Information callback.         */
                        if(CallbackParameter == ClientInfo->HIDSInformationHandle)
                        {
                           /* Check the value length.                   */
                           if(AttributeValueLength == QAPI_BLE_HIDS_HID_INFORMATION_SIZE)
                           {
                              /* Decode the HID Information value.      */
                              if((Result = qapi_BLE_HIDS_Decode_HID_Information(AttributeValueLength, AttributeValue, &ClientInfo->HIDSInformation)) == 0)
                              {
                                 /* Print out the information.          */
                                 QCLI_Printf(hids_group, "\nHIDS Information:\n");
                                 QCLI_Printf(hids_group, "   Version:              %d\n", ClientInfo->HIDSInformation.Version);
                                 QCLI_Printf(hids_group, "   Country Code:         %d\n", ClientInfo->HIDSInformation.CountryCode);
                                 QCLI_Printf(hids_group, "   Remote Wake:          %s\n", ((ClientInfo->HIDSInformation.Flags & QAPI_BLE_HIDS_HID_INFORMATION_FLAGS_REMOTE_WAKE) ? "Supported" : "Not Supported"));
                                 QCLI_Printf(hids_group, "   Normally Connectable: %s\n", ((ClientInfo->HIDSInformation.Flags & QAPI_BLE_HIDS_HID_INFORMATION_FLAGS_REMOTE_WAKE) ? "Yes" : "No"));
                              }
                              else
                                 DisplayFunctionError("HIDS_Decode_HID_Information", Result);
                           }
                           else
                              QCLI_Printf(hids_group, "\nError - Invalid length (%u) for HID Information response.\n", AttributeValueLength);
                        }
                        else
                        {
                           /* Handle the Report Map callback.           */
                           if(CallbackParameter == ClientInfo->ReportMapHandle)
                           {
                              if(ClientInfo->ReportMap)
                                 free(ClientInfo->ReportMap);

                              if((ClientInfo->ReportMap = malloc(AttributeValueLength)) != NULL)
                              {
                                 ClientInfo->ReportMapLength = AttributeValueLength;
                                 memcpy(ClientInfo->ReportMap, AttributeValue, ClientInfo->ReportMapLength);

                                 Result = qapi_BLE_GATT_Read_Long_Value_Request(BluetoothStackID, DeviceInfo->ConnectionID, ClientInfo->ReportMapHandle, ClientInfo->ReportMapLength, GATT_ClientEventCallback_HIDS, ClientInfo->ReportMapHandle);
                              }
                              else
                                 QCLI_Printf(hids_group, "Read report map failure: Insufficient Buffer Space.\n");
                           }
                           else
                           {
                              /* Handle the Protocol Mode callback.     */
                              if(CallbackParameter == ClientInfo->ProtocolModeHandle)
                              {
                                 if(AttributeValueLength == QAPI_BLE_HIDS_PROTOCOL_MODE_VALUE_LENGTH)
                                 {
                                    ClientInfo->ProtocolMode = READ_UNALIGNED_BYTE_LITTLE_ENDIAN(AttributeValue);

                                    QCLI_Printf(hids_group, "\nHIDS Protocol Mode:\n");
                                    QCLI_Printf(hids_group, "   Protocol Mode:        %s\n", (ClientInfo->ProtocolMode ? "Report" : "Boot"));
                                 }
                                 else
                                    QCLI_Printf(hids_group, "\nError - Invalid length (%u) for HID Protocol Mode response.\n", AttributeValueLength);
                              }
                              else
                              {
                                 /* Handle a report reference callback  */
                                 /* by looping through the list of      */
                                 /* reports.                            */
                                 for(Index=0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                                 {
                                    if(CallbackParameter == ClientInfo->Reports[Index].ReportReferenceHandle)
                                    {
                                       /* Decode the report reference.  */
                                       if((Result = qapi_BLE_HIDS_Decode_Report_Reference(AttributeValueLength, AttributeValue, &ClientInfo->Reports[Index].ReportReferenceData)) == 0)
                                       {
                                          QCLI_Printf(hids_group, "\nHIDS Report Reference:\n");
                                          QCLI_Printf(hids_group, "   Report ID:            %d\n", ClientInfo->Reports[Index].ReportReferenceData.ReportID);

                                          /* Print the report type.     */
                                          switch(ClientInfo->Reports[Index].ReportReferenceData.ReportType)
                                          {
                                             case QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT:
                                                QCLI_Printf(hids_group, "   Report Type:          Input Report\n");
                                                break;
                                             case QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT:
                                                QCLI_Printf(hids_group, "   Report Type:          Output Report\n");
                                                break;
                                             case QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_FEATURE_REPORT:
                                                QCLI_Printf(hids_group, "   Report Type:          Feature Report\n");
                                                break;
                                             default:
                                                QCLI_Printf(hids_group, "   Report Type:          Unknown.\n");
                                                break;
                                          }
                                       }
                                       else
                                          DisplayFunctionError("HIDS_Decode_Report_Reference", Result);

                                       CallbackParameterFound = TRUE;

                                       break;
                                    }
                                 }

                                 /* Handle an external report reference */
                                 /* callback by looping through the     */
                                 /* list of external report references. */
                                 for(Index=0; Index < HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES; Index++)
                                 {
                                    if(CallbackParameter == ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle)
                                    {
                                       /* Decode the external report    */
                                       /* reference.                    */
                                       if((Result = qapi_BLE_HIDS_Decode_External_Report_Reference(AttributeValueLength, AttributeValue, &ClientInfo->ExternalReportReferences[Index].ExternalReportReference)) == 0)
                                       {
                                          QCLI_Printf(hids_group, "\nHIDS External Report Reference:\n");

                                          /* Print the UUID and type.   */
                                          switch(ClientInfo->ExternalReportReferences[Index].ExternalReportReference.UUID_Type)
                                          {
                                             case QAPI_BLE_GU_UUID_16_E:
                                                QCLI_Printf(hids_group, "   UUID Type:            UUID 16\n");
                                                break;
                                             case QAPI_BLE_GU_UUID_128_E:
                                                QCLI_Printf(hids_group, "   UUID Type:            UUID 128\n");
                                                break;
                                             default:
                                                break;
                                          }
                                          QCLI_Printf(hids_group, "   UUID:                 ");
                                          DisplayUUID(&ClientInfo->ExternalReportReferences[Index].ExternalReportReference);
                                       }
                                       else
                                          DisplayFunctionError("HIDS_Decode_External_Report_Reference", Result);

                                       CallbackParameterFound = TRUE;

                                       break;
                                    }
                                 }

                                 if(!CallbackParameterFound)
                                 {
                                    /* Could not find a descriptor to   */
                                    /* match the read response, so      */
                                    /* display raw data                 */
                                    CallbackParameter = 0;
                                 }
                              }
                           }
                        }
                     }
                  }

                  /* If the data has not been decoded and displayed,    */
                  /* then just display the raw data                     */
                  if((DeviceInfo == NULL) || (CallbackParameter == 0))
                  {
                     QCLI_Printf(hids_group, "\nRead Response.\n");
                     BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice, BoardStr);
                     QCLI_Printf(hids_group, "   Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionID);
                     QCLI_Printf(hids_group, "   Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->TransactionID);
                     QCLI_Printf(hids_group, "   Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                     QCLI_Printf(hids_group, "   BD_ADDR:         %s.\n", BoardStr);
                     QCLI_Printf(hids_group, "   Data Length:     %u.\n", AttributeValueLength);

                     QCLI_Printf(hids_group, "   Data:            { ");
                     for(Index = 0; Index < (AttributeValueLength - 1); Index++)
                        QCLI_Printf(hids_group, "0x%02x, ", AttributeValue[Index]);

                     QCLI_Printf(hids_group, "0x%02x }\n", AttributeValue[Index]);
                  }
               }
            }
            else
               QCLI_Printf(hids_group, "\nError - Null Read Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
            {
               /* If we know about this device and a callback parameter */
               /* exists, then check if we know what write response     */
               /* this is.                                              */
               if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
               {
                  /* Loop through the HIDS client information array and */
                  /* find the service for this callback parameter.      */
                  for(Index = 0; Index < MAX_SUPPORTED_HID_INSTANCES; Index++)
                  {
                     if((CallbackParameter >= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Starting_Handle) && (CallbackParameter <= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Ending_Handle))
                     {
                        ClientInfo    = &(DeviceInfo->HIDSClientInfo[Index]);
                        InstanceIndex = Index;
                        break;
                     }
                  }

                  /* Make sure the HIDS client information was found.   */
                  if(ClientInfo)
                  {
                     /* Handle a Boot Keyboard Input Report CCCD write. */
                     if(CallbackParameter == ClientInfo->BootKeyboardInputReport_CCCD)
                        QCLI_Printf(hids_group, "\nWrite HIDS Boot Keyboard Input Report CCCD complete.\n");
                     else
                     {
                        /* Handle a Boot Mouse Input Report CCCD write. */
                        if(CallbackParameter == ClientInfo->BootMouseInputReport_CCCD)
                           QCLI_Printf(hids_group, "\nWrite HIDS Boot Mouse Input Report CCCD complete.\n");
                        else
                        {
                           CallbackParameterFound = FALSE;

                           /* Handle a Report CCCD write by looping     */
                           /* through the reports.                      */
                           for(Index=0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                           {
                              if(CallbackParameter == ClientInfo->Reports[Index].CCCDHandle)
                              {
                                 QCLI_Printf(hids_group, "\nWrite HIDS Report ID %d CCCD complete.\n", ClientInfo->Reports[Index].ReportReferenceData.ReportID);
                                 CallbackParameterFound = TRUE;
                                 break;
                              }
                           }

                           if(!CallbackParameterFound)
                           {
                              QCLI_Printf(hids_group, "\nWrite Response.\n");
                              BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
                              QCLI_Printf(hids_group, "Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
                              QCLI_Printf(hids_group, "Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
                              QCLI_Printf(hids_group, "Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                              QCLI_Printf(hids_group, "BD_ADDR:         %s.\n", BoardStr);
                              QCLI_Printf(hids_group, "Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);
                           }
                        }
                     }
                  }
               }
            }
            else
               QCLI_Printf(hids_group, "\nError - Null Write Response Data.\n");
            break;
         default:
            break;
      }
   }
   else
   {
      /* There was an error with one or more of the input parameters.   */
      QCLI_Printf(hids_group, "\n");

      QCLI_Printf(hids_group, "GATT Callback Data: Event_Data = NULL.\n");
   }
}

   /* The following function is for an GATT Client Event Callback.  This*/
   /* function will be called whenever a GATT Response is received for a*/
   /* request that was made when this function was registered.  This    */
   /* function passes to the caller the GATT Client Event Data that     */
   /* occurred and the GATT Client Event Callback Parameter that was    */
   /* specified when this Callback was installed.  The caller is free to*/
   /* use the contents of the GATT Client Event Data ONLY in the context*/
   /* of this callback.  If the caller requires the Data for a longer   */
   /* period of time, then the callback function MUST copy the data into*/
   /* another Data Buffer.  This function is guaranteed NOT to be       */
   /* invoked more than once simultaneously for the specified installed */
   /* callback (i.e.  this function DOES NOT have be reentrant).  It    */
   /* Needs to be noted however, that if the same Callback is installed */
   /* more than once, then the callbacks will be called serially.       */
   /* Because of this, the processing in this function should be as     */
   /* efficient as possible.  It should also be noted that this function*/
   /* is called in the Thread Context of a Thread that the User does NOT*/
   /* own.  Therefore, processing in this function should be as         */
   /* efficient as possible (this argument holds anyway because another */
   /* GATT Event (Server/Client or Connection) will not be processed    */
   /* while this function call is outstanding).                         */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_GAPS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
   boolean_t     DisplayPrompt;
   char         *NameBuffer;
   uint16_t      Appearance;
   BoardStr_t    BoardStr;
   DeviceInfo_t *DeviceInfo;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GATT_Client_Event_Data))
   {
      DisplayPrompt = true;

      /* Determine the event that occurred.                             */
      switch(GATT_Client_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
            {
               QCLI_Printf(gaps_group, "Error Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
               QCLI_Printf(gaps_group, "Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
               QCLI_Printf(gaps_group, "Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
               QCLI_Printf(gaps_group, "Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(gaps_group, "BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(gaps_group, "Error Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

               /* Only print out the rest if it is valid.               */
               if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
               {
                  QCLI_Printf(gaps_group, "Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                  QCLI_Printf(gaps_group, "Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                  QCLI_Printf(gaps_group, "Error Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                  QCLI_Printf(gaps_group, "Error Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
               }
            }
            else
               QCLI_Printf(gaps_group, "Error - Null Error Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_EXCHANGE_MTU_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data)
            {
               QCLI_Printf(gaps_group, "Exchange MTU Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->RemoteDevice, BoardStr);
               QCLI_Printf(gaps_group, "Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->ConnectionID);
               QCLI_Printf(gaps_group, "Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->TransactionID);
               QCLI_Printf(gaps_group, "Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(gaps_group, "BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(gaps_group, "MTU:             %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->ServerMTU);
            }
            else
            {
               QCLI_Printf(gaps_group, "Error - Null Write Response Data.\n");
            }
            break;
         case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
            {
               DisplayPrompt = false;
               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL)
               {
                  if((uint16_t)CallbackParameter == DeviceInfo->GAPSClientInfo.DeviceNameHandle)
                  {
                     /* Display the remote device name.                 */
                     if((NameBuffer = (char *)malloc(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength+1)) != NULL)
                     {
                        memset(NameBuffer, 0, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength+1);
                        memcpy(NameBuffer, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength);

                        QCLI_Printf(gaps_group, "Remote Device Name: %s.\n", NameBuffer);
                        DisplayPrompt = true;

                        free(NameBuffer);
                     }
                  }
                  else
                  {
                     if((uint16_t)CallbackParameter == DeviceInfo->GAPSClientInfo.DeviceAppearanceHandle)
                     {
                        if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength == QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_LENGTH)
                        {
                           Appearance = READ_UNALIGNED_WORD_LITTLE_ENDIAN(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue);
                           if(AppearanceToString(Appearance, &NameBuffer))
                              QCLI_Printf(gaps_group, "Remote Device Appearance: %s(%u).\n", NameBuffer, Appearance);
                           else
                              QCLI_Printf(gaps_group, "Remote Device Appearance: Unknown(%u).\n", Appearance);
                        }
                        else
                           QCLI_Printf(gaps_group, "Invalid Remote Appearance Value Length %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength);

                        DisplayPrompt = true;
                     }
                  }
               }
            }
            else
            {
               QCLI_Printf(gaps_group, "Error - Null Read Response Data.\n");
            }
            break;
         default:
            break;
      }

      if(DisplayPrompt)
         QCLI_Display_Prompt();
   }
}

   /* The following function is for an GATT Client Event Callback.  This*/
   /* function will be called whenever a GATT Response is received for a*/
   /* request that was made when this function was registered.  This    */
   /* function passes to the caller the GATT Client Event Data that     */
   /* occurred and the GATT Client Event Callback Parameter that was    */
   /* specified when this Callback was installed.  The caller is free to*/
   /* use the contents of the GATT Client Event Data ONLY in the context*/
   /* of this callback.  If the caller requires the Data for a longer   */
   /* period of time, then the callback function MUST copy the data into*/
   /* another Data Buffer.  This function is guaranteed NOT to be       */
   /* invoked more than once simultaneously for the specified installed */
   /* callback (i.e.  this function DOES NOT have be reentrant).  It    */
   /* Needs to be noted however, that if the same Callback is installed */
   /* more than once, then the callbacks will be called serially.       */
   /* Because of this, the processing in this function should be as     */
   /* efficient as possible.  It should also be noted that this function*/
   /* is called in the Thread Context of a Thread that the User does NOT*/
   /* own.  Therefore, processing in this function should be as         */
   /* efficient as possible (this argument holds anyway because another */
   /* GATT Event (Server/Client or Connection) will not be processed    */
   /* while this function call is outstanding).                         */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_HRS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
   BoardStr_t    BoardStr;
   DeviceInfo_t *DeviceInfo;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GATT_Client_Event_Data))
   {
      /* Determine the event that occurred.                             */
      switch(GATT_Client_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
            {
               QCLI_Printf(hrs_group, "\nError Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
               QCLI_Printf(hrs_group, "   Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
               QCLI_Printf(hrs_group, "   Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
               QCLI_Printf(hrs_group, "   Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(hrs_group, "   BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(hrs_group, "   Error Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

               /* Only print out the rest if it is valid.               */
               if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
               {
                  QCLI_Printf(hrs_group, "   Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                  QCLI_Printf(hrs_group, "   Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                  QCLI_Printf(hrs_group, "   Error Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                  QCLI_Printf(hrs_group, "   Error Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
               }
            }
            else
               QCLI_Printf(hrs_group, "Error - Null Error Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
            {
               QCLI_Printf(hrs_group, "\nWrite Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
               QCLI_Printf(hrs_group, "   Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
               QCLI_Printf(hrs_group, "   Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
               QCLI_Printf(hrs_group, "   Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(hrs_group, "   BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(hrs_group, "   Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);

               /* If we know about this device and a callback parameter */
               /* exists, then check if we know what write response this*/
               /* is.                                                   */
               if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
               {
                  if(CallbackParameter == DeviceInfo->HRSClientInfo.Heart_Rate_Measurement_Client_Configuration)
                     QCLI_Printf(hrs_group, "\nWrite HRS Measurement CC Complete.\n");
               }
            }
            else
               QCLI_Printf(hrs_group, "\nError - Null Write Response Data.\n");
            break;
         default:
            break;
      }
   }
   else
   {
      /* There was an error with one or more of the input parameters.   */
      QCLI_Printf(hrs_group, "\n");

      QCLI_Printf(hrs_group, "GATT Callback Data: Event_Data = NULL.\n");
   }
}

   /* The following function is for an GATT Client Event Callback.  This*/
   /* function will be called whenever a GATT Response is received for a*/
   /* request that was made when this function was registered.  This    */
   /* function passes to the caller the GATT Client Event Data that     */
   /* occurred and the GATT Client Event Callback Parameter that was    */
   /* specified when this Callback was installed.  The caller is free to*/
   /* use the contents of the GATT Client Event Data ONLY in the context*/
   /* of this callback.  If the caller requires the Data for a longer   */
   /* period of time, then the callback function MUST copy the data into*/
   /* another Data Buffer.  This function is guaranteed NOT to be       */
   /* invoked more than once simultaneously for the specified installed */
   /* callback (i.e.  this function DOES NOT have be reentrant).  It    */
   /* Needs to be noted however, that if the same Callback is installed */
   /* more than once, then the callbacks will be called serially.       */
   /* Because of this, the processing in this function should be as     */
   /* efficient as possible.  It should also be noted that this function*/
   /* is called in the Thread Context of a Thread that the User does NOT*/
   /* own.  Therefore, processing in this function should be as         */
   /* efficient as possible (this argument holds anyway because another */
   /* GATT Event (Server/Client or Connection) will not be processed    */
   /* while this function call is outstanding).                         */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_SCPS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
   BoardStr_t    BoardStr;
   DeviceInfo_t *DeviceInfo;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GATT_Client_Event_Data))
   {
      /* Determine the event that occurred.                             */
      switch(GATT_Client_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
            {
               QCLI_Printf(scps_group, "\nError Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
               QCLI_Printf(scps_group, "   Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
               QCLI_Printf(scps_group, "   Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
               QCLI_Printf(scps_group, "   Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(scps_group, "   BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(scps_group, "   Error Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

               /* Only print out the rest if it is valid.               */
               if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
               {
                  QCLI_Printf(scps_group, "   Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                  QCLI_Printf(scps_group, "   Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                  QCLI_Printf(scps_group, "   Error Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                  QCLI_Printf(scps_group, "   Error Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
               }
            }
            else
               QCLI_Printf(scps_group, "Error - Null Error Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
            {
               QCLI_Printf(scps_group, "\nRead Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice, BoardStr);
               QCLI_Printf(scps_group, "   Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionID);
               QCLI_Printf(scps_group, "   Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->TransactionID);
               QCLI_Printf(scps_group, "   Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(scps_group, "   BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(scps_group, "   AttributeValue:  %u.\n", ((uint16_t)(*(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue))));
               QCLI_Printf(scps_group, "   Data Length:     %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength);
            }
            else
               QCLI_Printf(scps_group, "\nError - Null Read Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
            {
               QCLI_Printf(scps_group, "\nWrite Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
               QCLI_Printf(scps_group, "   Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
               QCLI_Printf(scps_group, "   Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
               QCLI_Printf(scps_group, "   Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(scps_group, "   BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(scps_group, "   Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);

               /* If we know about this device and a callback parameter */
               /* exists, then check if we know what write response this*/
               /* is.                                                   */
               if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
               {
                  if(CallbackParameter == DeviceInfo->SCPSClientInfo.Scan_Refresh_Client_Configuration)
                     QCLI_Printf(scps_group, "\nWrite Refresh Scan CC Complete.\n");
               }
            }
            else
               QCLI_Printf(scps_group, "\nError - Null Write Response Data.\n");
            break;
         default:
            break;
      }
   }
   else
   {
      /* There was an error with one or more of the input parameters.   */
      QCLI_Printf(scps_group, "\n");

      QCLI_Printf(scps_group, "GATT Callback Data: Event_Data = NULL.\n");
   }
}

   /* The following function is for an GATT Client Event Callback.  This*/
   /* function will be called whenever a GATT Response is received for a*/
   /* request that was made when this function was registered.  This    */
   /* function passes to the caller the GATT Client Event Data that     */
   /* occurred and the GATT Client Event Callback Parameter that was    */
   /* specified when this Callback was installed.  The caller is free to*/
   /* use the contents of the GATT Client Event Data ONLY in the context*/
   /* of this callback.  If the caller requires the Data for a longer   */
   /* period of time, then the callback function MUST copy the data into*/
   /* another Data Buffer.  This function is guaranteed NOT to be       */
   /* invoked more than once simultaneously for the specified installed */
   /* callback (i.e.  this function DOES NOT have be reentrant).  It    */
   /* Needs to be noted however, that if the same Callback is installed */
   /* more than once, then the callbacks will be called serially.       */
   /* Because of this, the processing in this function should be as     */
   /* efficient as possible.  It should also be noted that this function*/
   /* is called in the Thread Context of a Thread that the User does NOT*/
   /* own.  Therefore, processing in this function should be as         */
   /* efficient as possible (this argument holds anyway because another */
   /* GATT Event (Server/Client or Connection) will not be processed    */
   /* while this function call is outstanding).                         */
   /* * NOTE * This function MUST NOT Block and wait for Events that can*/
   /*          only be satisfied by Receiving a Bluetooth Event         */
   /*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
   /*          Callbacks will be issued while this function is currently*/
   /*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_SPPLE(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
   boolean_t     DisplayPrompt;
   uint16_t      Credits;
   BoardStr_t    BoardStr;
   DeviceInfo_t *DeviceInfo;

   /* Verify that all parameters to this callback are Semi-Valid.       */
   if((BluetoothStackID) && (GATT_Client_Event_Data))
   {
      DisplayPrompt = true;

      /* Determine the event that occurred.                             */
      switch(GATT_Client_Event_Data->Event_Data_Type)
      {
         case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
            {
               QCLI_Printf(spple_group, "\nError Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
               QCLI_Printf(spple_group, "Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
               QCLI_Printf(spple_group, "Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
               QCLI_Printf(spple_group, "Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(spple_group, "BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(spple_group, "Error Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

               /* Only print out the rest if it is valid.               */
               if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
               {
                  QCLI_Printf(spple_group, "Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                  QCLI_Printf(spple_group, "Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                  QCLI_Printf(spple_group, "Error Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                  QCLI_Printf(spple_group, "Error Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
               }
            }
            else
               QCLI_Printf(spple_group, "Error - Null Error Response Data.\n");
            break;
         case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
            {
               DisplayPrompt = false;

               if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL)
               {
                  if((uint16_t)CallbackParameter == DeviceInfo->ClientInfo.Rx_Credit_Characteristic)
                  {
                     if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength == sizeof(uint16_t))
                     {
                        /* Display the credits we just received.        */
                        Credits = READ_UNALIGNED_WORD_LITTLE_ENDIAN(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue);
                        QCLI_Printf(spple_group, "Received %u Initial Credits.\n", Credits);

                        DisplayPrompt = true;

                        /* We have received the initial credits from the*/
                        /* device so go ahead and handle a Receive      */
                        /* Credit Event.                                */
                        ReceiveCreditEvent(DeviceInfo, Credits);
                     }
                  }
               }
            }
            else
            {
               QCLI_Printf(spple_group, "Error - Null Read Response Data.\n");
            }
            break;
         case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
            if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
            {
               QCLI_Printf(spple_group, "Write Response.\n");
               BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
               QCLI_Printf(spple_group, "Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
               QCLI_Printf(spple_group, "Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
               QCLI_Printf(spple_group, "Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
               QCLI_Printf(spple_group, "BD_ADDR:         %s.\n", BoardStr);
               QCLI_Printf(spple_group, "Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);
            }
            else
            {
               QCLI_Printf(spple_group, "Error - Null Write Response Data.\n");
            }
            break;
         default:
            break;
      }

      if(DisplayPrompt)
         QCLI_Display_Prompt();
   }
}

/******************************************************************************/
/**  EventCallback(uint32_t, HCI_Event_Data_t *, uint32_t)                   **/
/******************************************************************************/
/**  EventCallback Function.                                                 **/
/******************************************************************************/
static void EventCallback(uint32_t BluetoothStackID, qapi_BLE_HCI_Event_Data_t *HCI_Event_Data, uint32_t CallbackParameter)
{
   int          i;
   int          Event;
   uint16_t     Connection_Handle;
   unsigned int _NumberPackets;

   if((BluetoothStackID) && (HCI_Event_Data))
   {
      Event = (int)HCI_Event_Data->Event_Data_Type;
      switch(Event)
      {
         case QAPI_BLE_ET_NUMBER_OF_COMPLETED_PACKETS_EVENT_E:
            if((CurrentTest == CURRENT_TEST_TX_ACL) || (CurrentTest == CURRENT_TEST_PERIODIC))
            {
               for(i=0; i < HCI_Event_Data->Event_Data.HCI_Number_Of_Completed_Packets_Event_Data->Number_of_Handles; i++)
               {
                  /* Iterate through all of the handles and determine   */
                  /* the number of packets that have been sent for each */
                  /* connection.                                        */
                  Connection_Handle = HCI_Event_Data->Event_Data.HCI_Number_Of_Completed_Packets_Event_Data->HCI_Number_Of_Completed_Packets_Data[i].Connection_Handle;

                  if(Connection_Handle == ConnectionHandle)
                  {
                     /* Debit the number of packets sent for this       */
                     /* connection handle and Credit the number of      */
                     /* packets that can now be sent.                   */
                     _NumberPackets = HCI_Event_Data->Event_Data.HCI_Number_Of_Completed_Packets_Event_Data->HCI_Number_Of_Completed_Packets_Data[i].HC_Num_Of_Completed_Packets;

                     if(_NumberPackets > NumberOutstandingACLPackets)
                        _NumberPackets = NumberOutstandingACLPackets;

                     NumberOutstandingACLPackets -= _NumberPackets;

                     if(CurrentTest == CURRENT_TEST_TX_ACL)
                        SendACLData(PacketLength, TestBuffer);
                     break;
                  }
               }
            }
            break;
         case QAPI_BLE_ET_DISCONNECTION_COMPLETE_EVENT_E:
            if(ConnectionHandle == HCI_Event_Data->Event_Data.HCI_Disconnection_Complete_Event_Data->Connection_Handle)
            {
               ConnectionHandle            = QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE;
               CurrentTest                 = CURRENT_TEST_NONE;
               NumberOutstandingACLPackets = 0;
            }
            break;
      }
   }
}

/******************************************************************************/
/**  ACLDataCallback()                                                       **/
/******************************************************************************/
/**  ACLDataCallback Function.                                               **/
/******************************************************************************/
static void ACLDataCallback(uint32_t BluetoothStackID, uint16_t Connection_Handle, uint16_t Flags, uint16_t ACLDataLength, uint8_t *ACLData, uint32_t CallbackParameter)
{
   if((BluetoothStackID) && (CurrentTest == CURRENT_TEST_RX_ACL))
   {
      /* This callback assumes the data coming in are L2CAP packets,    */
      /* since that is what it sends.                                   */

      /* First check to see if this is a ACL packet we are interested   */
      /* in.                                                            */
      if(Connection_Handle == ConnectionHandle)
      {
         if(!StartTime)
            StartTime = (uint32_t)qurt_timer_get_ticks();

         NumberBytes += ACLDataLength;
      }
   }
}

   /* This function is used to register the SPPLE Command Group with    */
   /* QCLI.                                                             */
void Initialize_SPPLE_Demo(void)
{
   boolean_t Error = FALSE;

   /* Attempt to reqister the BLE Command Group with the qcli framework.*/
   ble_group = QCLI_Register_Command_Group(NULL, &ble_cmd_group);
   if(ble_group)
   {

#ifdef V2

      /* Attempt to register the BT5 sub-group.                         */
      bt5_group = QCLI_Register_Command_Group(ble_group, &bt5_cmd_group);
      if(bt5_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register BT5 sub group with QCLI.\n");

         Error = TRUE;
      }

#endif

      /* Attempt to register the Automation IO Service (AIOS) sub-group.*/
      aios_group = QCLI_Register_Command_Group(ble_group, &aios_cmd_group);
      if(aios_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register AIOS sub group with QCLI.\n");

         Error = TRUE;
      }

      /* Attempt to register the Battery Alert Service (BAS) sub-group. */
      bas_group = QCLI_Register_Command_Group(ble_group, &bas_cmd_group);
      if(bas_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register BAS sub group with QCLI.\n");

         Error = TRUE;
      }

      /* Attempt to register the Generic Access Profile Service (GAPS)  */
      /* sub-group.                                                     */
      gaps_group = QCLI_Register_Command_Group(ble_group, &gaps_cmd_group);
      if(gaps_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register GAPS sub group with QCLI.\n");

         Error = TRUE;
      }

      /* Attempt to register the HID over GATT service sub-group.       */
      hids_group = QCLI_Register_Command_Group(ble_group, &hogp_cmd_group);
      if(hids_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register HOGP sub group with QCLI.\n");

         Error = TRUE;
      }

      /* Attempt to register the Heart Rate Service sub-group.          */
      hrs_group = QCLI_Register_Command_Group(ble_group, &hrs_cmd_group);
      if(hrs_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register HRS sub group with QCLI.\n");

         Error = TRUE;
      }

      /* Attempt to register the OTA service sub-group.                 */
      ota_group = QCLI_Register_Command_Group(ble_group, &ota_cmd_group);
      if(ota_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register OTA sub group with QCLI.\n");

         Error = TRUE;
      }

      /* Attempt to register the SLoWP service sub-group.               */
      slowp_group = QCLI_Register_Command_Group(ble_group, &slowp_cmd_group);
      if(slowp_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register SLoWP sub group with QCLI.\n");

         Error = TRUE;
      }

      /* Attempt to register the Scan Parameter service sub-group.      */
      scps_group = QCLI_Register_Command_Group(ble_group, &scps_cmd_group);
      if(scps_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register SCPS sub group with QCLI.\n");

         Error = TRUE;
      }

      /* Attempt to register the SPPLE sub-group.                       */
      spple_group = QCLI_Register_Command_Group(ble_group, &spple_cmd_group);
      if(spple_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register SPPLE sub group with QCLI.\n");

         Error = TRUE;
      }

#ifdef V2
      /* Attempt to register the SPPLE sub-group.                       */
      ble_fpga_group = QCLI_Register_Command_Group(ble_group, &ble_fpga_cmd_group);
      if(ble_fpga_group == NULL)
      {
         QCLI_Printf(ble_group, "Error - failed to register SPPLE sub group with QCLI.\n");

         Error = TRUE;
      }
#endif

      /* Check to see if all sub-groups were registered successfully.   */
      if(!Error)
      {
         /* Initialize the BLE Parameters.                              */
         memset(&BLEParameters, 0, sizeof(BLEParameters));

         /* Set the HCI driver information.                             */
         QAPI_BLE_HCI_DRIVER_SET_COMM_INFORMATION(&HCI_DriverInformation, 1, 115200, QAPI_BLE_COMM_PROTOCOL_UART_E);
      }
      else
      {
         /* Un-register the BLE Group.                                  */
         QCLI_Unregister_Command_Group(ble_group);

         ble_group      = NULL;
         aios_group     = NULL;
         bas_group      = NULL;
         gaps_group     = NULL;
         scps_group     = NULL;
         spple_group    = NULL;
         ble_fpga_group = NULL;
      }
   }
}

   /* Returns the current Bluetooth Stack ID.                           */
uint32_t GetBluetoothStackID(void)
{
   return(BluetoothStackID);
}

   /* Returns the current Bluetooth Stack ID.                           */
unsigned int GetConnectionID(qapi_BLE_BD_ADDR_t RemoteDevice)
{
   unsigned int  RetVal = 0;
   DeviceInfo_t *DeviceInfo;

   /* Get the device info for the remote device.                        */
   if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, RemoteDevice)) != NULL)
      RetVal = DeviceInfo->ConnectionID;
   return(RetVal);
}

   /* The following function is responsible for the specified string    */
   /* into data of type BD_ADDR.  The first parameter of this function  */
   /* is the BD_ADDR string to be converted to a BD_ADDR.  The second   */
   /* parameter of this function is a pointer to the BD_ADDR in which   */
   /* the converted BD_ADDR String is to be stored.                     */
void StrToBD_ADDR(char *BoardStr, qapi_BLE_BD_ADDR_t *Board_Address)
{
   char Buffer[5];

   if((BoardStr) && (strlen(BoardStr) == sizeof(qapi_BLE_BD_ADDR_t)*2) && (Board_Address))
   {
      Buffer[0] = '0';
      Buffer[1] = 'x';
      Buffer[4] = '\0';

      Buffer[2] = BoardStr[0];
      Buffer[3] = BoardStr[1];
      Board_Address->BD_ADDR5 = (uint8_t)StringToUnsignedInteger(Buffer);

      Buffer[2] = BoardStr[2];
      Buffer[3] = BoardStr[3];
      Board_Address->BD_ADDR4 = (uint8_t)StringToUnsignedInteger(Buffer);

      Buffer[2] = BoardStr[4];
      Buffer[3] = BoardStr[5];
      Board_Address->BD_ADDR3 = (uint8_t)StringToUnsignedInteger(Buffer);

      Buffer[2] = BoardStr[6];
      Buffer[3] = BoardStr[7];
      Board_Address->BD_ADDR2 = (uint8_t)StringToUnsignedInteger(Buffer);

      Buffer[2] = BoardStr[8];
      Buffer[3] = BoardStr[9];
      Board_Address->BD_ADDR1 = (uint8_t)StringToUnsignedInteger(Buffer);

      Buffer[2] = BoardStr[10];
      Buffer[3] = BoardStr[11];
      Board_Address->BD_ADDR0 = (uint8_t)StringToUnsignedInteger(Buffer);
   }
   else
   {
      if(Board_Address)
         memset(Board_Address, 0, sizeof(qapi_BLE_BD_ADDR_t));
   }
}
