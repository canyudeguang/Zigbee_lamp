/*
 * Copyright (c) 2018 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 */
// Copyright (c) 2018 Qualcomm Technologies, Inc.
// All rights reserved.
// Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) 
// provided that the following conditions are met:
// Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// Redistributions in binary form must reproduce the above copyright notice, 
// this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
// Neither the name of Qualcomm Technologies, Inc. nor the names of its contributors may be used to endorse or promote products derived 
// from this software without specific prior written permission.
// NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, 
// BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
// OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "qapi_otp_tlv.h"
#include "qapi_timer.h"
#include "qurt_timer.h"    /* Timer for Throughput Calculation.         */
#include "qc_at_ble.h"    /* Main Application Prototypes and Constants.*/
#include "qosa_util.h"
#include "qcli_util.h"

#include "qc_at_ble_service.h"

#include "qapi_fs.h"

#define APP_STRCMP(_a, _b) strcmp((char const*)(_a), (const char *)(_b))
/* Demo Constants.                                                   */

#ifndef V2
#define QAPI_BLE_LAT_ANONYMOUS_E                   255
#endif

/* Some MACROs for accessing little-endian unaligned values.         */
#define READ_UNALIGNED_BYTE_LITTLE_ENDIAN(_x)  (((uint8_t *)(_x))[0])
#define READ_UNALIGNED_WORD_LITTLE_ENDIAN(_x)  ((uint16_t)((((uint16_t)(((uint8_t *)(_x))[1])) << 8) | ((uint16_t)(((uint8_t *)(_x))[0]))))

#define ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(_x, _y)        \
{                                                                       \
    ((uint8_t *)(_x))[0] = ((uint8_t)(((uint16_t)(_y)) & 0xFF));          \
    ((uint8_t *)(_x))[1] = ((uint8_t)((((uint16_t)(_y)) >> 8) & 0xFF));   \
}

#define CONVERT_TO_BASEBAND_SLOTS(_x)                             ((unsigned long)((((8000L * ((unsigned long)(_x))) / 500L) + 5L)/10L))

/* Determine the Name we will use for this compilation.              */
#define DEVICE_FRIENDLY_NAME                       "lpw-spple-demo"

/* The following MACRO is used to convert an ASCII character into the*/
/* equivalent decimal value.  The MACRO converts lower case          */
/* characters to upper case before the conversion.                   */
#define ToInt(_x)                                  (((_x) > 0x39)?(((_x) & ~0x20)-0x37):((_x)-0x30))

/* Generic Access Profile (GAP) Constants.                           */

#define DEFAULT_IO_CAPABILITY      (QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E)
/* Denotes the       */
/* default I/O       */
/* Capability that is*/
/* used with Pairing.*/

#define DEFAULT_MITM_PROTECTION                  (TRUE)  /* Denotes the       */
/* default value used*/
/* for Man in the    */
/* Middle (MITM)     */
/* protection used   */
/* with Secure Simple*/
/* Pairing.          */

#define DEFAULT_SECURE_CONNECTIONS               (TRUE)  /* Denotes the       */
/* default value used*/
/* for Secure        */
/* Connections used  */
/* with Secure Simple*/
/* Pairing.          */

/* Automation IO Service (AIOS) Constants.                           */

#define AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS   (2)   /* Denotes the number*/
/* of                */
/* characteristics   */
/* supported by the  */
/* AIOS Server.      */

#define AIOP_NUMBER_OF_SUPPORTED_INSTANCES         (2)   /* Denotes the number*/
/* of                */
/* instances for each*/
/* Characteristic    */
/* supported by the  */
/* AIOS Server.      */

#define AIOP_DEFAULT_INPUT_CHARACTERISTIC_PROPERTY_FLAGS  (QAPI_BLE_AIOS_INPUT_CHARACTERISTIC_PROPERTY_FLAGS_NOTIFY)
/* Denotes the default*/
/* input              */
/* Characteristic     */
/* Property Flags.    */

#define AIOP_DEFAULT_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS (QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE | \
        QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_READ  | \
        QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_NOTIFY)
/* Denotes the default*/
/* output             */
/* Characteristic     */
/* Property Flags.    */

/* Battery Alert Service (BAS) Constants.                            */

#define MAX_SUPPORTED_BATTERY_INSTANCES            (1)   /* Denotes the       */
/* maximum number of */
/* Battery Service   */
/* Instances that are*/
/* supported by this */
/* application.      */


/* HID over GATT Service (HOGP) Constants.                           */

#define MAX_SUPPORTED_HID_INSTANCES                (1)   /* Denotes the       */
/* maximum number of */
/* HID Service       */
/* Instances that are*/
/* supported by this */
/* application.      */

#define HIDS_MAXIMUM_NUMBER_REPORTS                (5)   /* Denotes the       */
/* maximum number of */
/* supported HIDS    */
/* reports.          */

#define HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES (5) /* Denotes the     */
/* maximum number of */
/* supported HIDS    */
/* external report   */
/* references.       */

#define HID_KEYBOARD_INPUT_REPORT_SIZE               (8) /* Defines the size  */
/* of the application*/
/* keyboard input    */
/* report.           */

#define HID_KEYBOARD_OUTPUT_REPORT_SIZE              (1) /* Defines the size  */
/* of the application*/
/* keyboard output   */
/* report.           */

#define HID_MOUSE_INPUT_REPORT_SIZE                  (8) /* Defines the size  */
/* of the application*/
/* mouse input       */
/* report.           */

/* The following define the valid bits that may be set as part of the*/
/* Keyboard Output Report.                                           */
#define HID_KEYBOARD_OUTPUT_REPORT_NUM_LOCK         0x01
#define HID_KEYBOARD_OUTPUT_REPORT_CAPS_LOCK        0x02
#define HID_KEYBOARD_OUTPUT_REPORT_SCOLL_LOCK       0x04
#define HID_KEYBOARD_OUTPUT_REPORT_COMPOSE          0x08
#define HID_KEYBOARD_OUTPUT_REPORT_KANA             0x10

/* The following define the report IDs to be used with HID reports.  */
#define HID_KEYBOARD_INPUT_REPORT_ID                1
#define HID_KEYBOARD_OUTPUT_REPORT_ID               2
#define HID_MOUSE_INPUT_REPORT_ID                   3

/* The following MACRO is used to calculate if an ASCII              */
/* characteristic is valid.                                          */
#define CHECK_ASCII_VALID(_x)                         (((_x) >= ' ') && ((_x) <= '~'))

/* 6LoWPAN for BLE (SLoWP) Constants.                                */

/* The following constants represent the application's default SLoWP */
/* channel parameters.                                               */
#define SLoWP_CHANNEL_PARAMETERS_FLAGS              (0)
#define SLoWP_CHANNEL_PARAMETERS_MAX_SDU_SIZE       (1280)
#define SLoWP_CHANNEL_PARAMETERS_MAX_PDU_SIZE       (237)
#define SLoWP_CHANNEL_PARAMETERS_PDU_QUEUE_DEPTH    (5)
#define SLoWP_CHANNEL_PARAMETERS_MAX_CREDITS        (5)

/* The following constants represent the application's default       */
/* queuing parameters for sending packet data over the SLoWP         */
/* connection.                                                       */
#define SLoWP_QP_DATA_PACKET_QUEUEING_FLAGS         (QAPI_BLE_L2CA_QUEUEING_FLAG_LIMIT_BY_PACKETS)
#define SLoWP_QP_MAXIMUM_NUMBER_QUEUED_DATA_PACKETS (3)
#define SLoWP_QP_QUEUED_DATA_PACKETS_THRESHOLD      (2)

/* Serial Port Profile over LE (SPPLE) Constants.                    */

#ifndef SPPLE_DATA_BUFFER_LENGTH
#define SPPLE_DATA_BUFFER_LENGTH    (517)
/* Defines the length*/
/* of a SPPLE Data   */
/* Buffer.           */
#endif

#define SPPLE_DATA_CREDITS        (SPPLE_DATA_BUFFER_LENGTH*3)
/* Defines the       */
/* number of credits */
/* in an SPPLE Buffer*/

/* Generic Access Profile (GAP) structures.                          */

/* Structure used to hold all of the GAP LE Parameters.              */
typedef struct _tagGAPLE_Parameters_t
{
    qapi_BLE_GAP_LE_Connectability_Mode_t ConnectableMode;
    qapi_BLE_GAP_Discoverability_Mode_t   DiscoverabilityMode;
    qapi_BLE_GAP_LE_IO_Capability_t       IOCapability;
    boolean_t                             MITMProtection;
    boolean_t                             SecureConnections;
    boolean_t                             OOBDataPresent;
} GAPLE_Parameters_t;

#define GAPLE_PARAMETERS_DATA_SIZE                       (sizeof(GAPLE_Parameters_t))

/* The following bit mask values may be used for the Flags field of  */
/* the BLEParameters_t structure.                                    */
#define BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID   0x00000001
#define BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID          0x00000002
#define BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID    0x00000004

/* The following structure is used to hold the Scan Window and       */
/* Interval parameters for LE Scanning.                              */
typedef struct _tagBLEScanParameters_t
{
    uint16_t ScanInterval;
    uint16_t ScanWindow;
} BLEScanParameters_t;

/* The following structure is used to hold information on the        */
/* configured Scan/Advertising/Connection Parameters.                */
typedef struct _tagBLEParameters_t
{
    unsigned long                            Flags;
    qapi_BLE_GAP_LE_Advertising_Parameters_t AdvertisingParameters;
    qapi_BLE_GAP_LE_Connection_Parameters_t  ConnectionParameters;
    BLEScanParameters_t                      ScanParameters;
} BLEParameters_t;

/* Automation IO Service (AIOS) structures.                          */

/* The following structure contains the information for an AIOS      */
/* Characteristic instance that the AIOS Server will need to store.  */
/* * NOTE * The Instance_Entry below will need to be copied to the   */
/*          qapi_BLE_AIOS_Characteristic_Entry_t structure, a        */
/*          sub-structure of qapi_BLE_AIOS_Initialize_Data_t         */
/*          structure, that is expected as a parameter to            */
/*          qapi_BLE_AIOS_Initialize_Service().  This is REQUIRED to */
/*          intialize the service and allows us to retain the        */
/*          information that we used to initialize the service.      */
/* * NOTE * Some fields of this structure will not be used.  The     */
/*          fields depend on the optional AIOS Characteristic        */
/*          descriptors included for this Characteristic instance    */
/*          specified by the Instance_Entry field and whether this   */
/*          instance is a Digital or Analog Characteristic.          */
/* * NOTE * The AIOS Server will support 8 digital signals (2 octets)*/
/*          for each Digital Characteristic for simplicity.          */
typedef struct _tagAIOP_Server_Instance_Data_t
{
    qapi_BLE_AIOS_Characteristic_Instance_Entry_t Instance_Entry;

    union
    {
        uint8_t                                    Digital[2];
        uint16_t                                   Analog;
    } Data;

    uint16_t                                      Client_Configuration;
    qapi_BLE_AIOS_Presentation_Format_Data_t      Presentation_Format;
    uint8_t                                       Number_Of_Digitals;
} AIOP_Server_Instance_Data_t;

#define AIOP_SERVER_INSTANCE_DATA_SIZE                   (sizeof(AIOP_Server_Instance_Data_t))

/* The following structure contains the information for each AIOS    */
/* Digital/Analog Characteristc that the AIOS Server will need to    */
/* store.  Information for each AIOS Characteristic instance will be */
/* stored by the Instances field.                                    */
/* * NOTE * The Characteristic_Entry field below will need to be     */
/*          copied to the qapi_BLE_AIOS_Initialize_Data_t structure  */
/*          that is expected as a parameter to                       */
/*          qapi_BLE_AIOS_Initialize_Service().  This is REQUIRED to */
/*          initialize the service and allows us to retain the       */
/*          information that we used to intialize the service.       */
/* * NOTE * The AIOS Server will support two instances of each AIOS  */
/*          Characteristic (Digital and Analog) for simplicity.      */
typedef struct _tagAIOP_Server_Characteristic_Data_t
{
    qapi_BLE_AIOS_Characteristic_Entry_t Characteristic_Entry;
    AIOP_Server_Instance_Data_t          Instances[AIOP_NUMBER_OF_SUPPORTED_INSTANCES];
} AIOP_Server_Characteristic_Data_t;

#define AIOP_SERVER_CHARACTERISTIC_DATA_SIZE             (sizeof(AIOP_Server_Characteristic_Data_t))

/* The following structure contains the AIOS Server information.     */
/* This information (and sub structures) are needed to initialize the*/
/* AIOS Server with a call to qapi_BLE_AIOS_Initialize_Service().    */
/* This structure will also hold the information needed to process   */
/* AIOS Server events and will retain the values for AIOS            */
/* Characteristics and descriptors.                                  */
/* * NOTE * Some fields below will need to be copied to the          */
/*          qapi_BLE_AIOS_Initialize_Data_t structure that is        */
/*          expected as a parameter to                               */
/*          qapi_BLE_AIOS_Initialize_Service().  This is REQUIRED to */
/*          initialize the service and allows us to retain the       */
/*          information that we used to intialize the service.       */
/* * NOTE * The AIOS Server will support two characteristics: the    */
/*          Digital and Analog Characteristics, for simplicity.      */
typedef struct _tagAIOP_Server_Information_t
{
    AIOP_Server_Characteristic_Data_t Characteristic[AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS];
} AIOP_Server_Information_t;

#define AIOP_SERVER_INFORMATION_DATA_SIZE                (sizeof(AIOP_Server_Information_t))

/* The following enumeration will be used to determine the correct   */
/* Attribute Handle to select for an AIOS Characteristic or          */
/* Descriptor.                                                       */
typedef enum
{
    ahtCharacteristic,
    ahtClientCharacteristicConfig,
    ahtPresentationFormat,
    ahtNumberOfDigitals
} AIOP_Attribute_Handle_Type_t;

/* The following structure holds the request information that the    */
/* AIOP Client MUST store before issuing a GATT request to the AIOS  */
/* Server.  This is so that we can easily handle the response.       */
/* * NOTE * The Type and ID fields MUST be valid for all requests    */
/*          since this information is required to quickly look up the*/
/*          AIOS Characteristic Instance's information associated    */
/*          with the request in the GATT_ClientEventCallback_AIOS()  */
/*          when the response is received.                           */
/* * NOTE * The AttributeHandleType field (Mandatory) allows us to   */
/*          specify the type of the attribute handle we are expecting*/
/*          in the response.  This way with the Type and ID fields,  */
/*          we can quickly locate the correct attribute handle to    */
/*          verify.  Otherwise we would need to check every attribute*/
/*          handle for a match to know how to process the response.  */
typedef struct _tagAIOP_Client_Request_Info_t
{
    qapi_BLE_AIOS_Characteristic_Type_t Type;
    uint16_t                            ID;
    AIOP_Attribute_Handle_Type_t        AttributeHandleType;
} AIOP_Client_Request_Info_t;

/* The following structure contains the information that needs to be */
/* stored by an AIOS Client for each AIOS Characteristic instance    */
/* discovered during service discovery.  This struture also stores   */
/* the information that the AIOP Client needs to store when          */
/* read/writing AIOS Characteristic instances.                       */
/* * NOTE * The Properties field will simply be used to store the    */
/*          Characteristic instance properties found during service  */
/*          discovery.                                               */
/* * NOTE * The Number_Of_Digitals will hold the number of digitals  */
/*          that has been automatically read by the AIOS Client if   */
/*          the Aggregate Characteristic is discoverd and after      */
/*          service discovery has been peformed.  This is REQUIRED   */
/*          since in order to decode the Aggregate Characteristic we */
/*          MUST know how many digitals are included for each Digital*/
/*          Characteristic that is part of the Aggregate             */
/*          Characteristic.                                          */
/* * NOTE * Either the Digital_Characteristic_Handle or              */
/*          Analog_Charactersitic_Handle will be cached.  Only one   */
/*          will be cached for this instance and can be determined by*/
/*          the Characteristic type (Type field) of the parent       */
/*          structure below.                                         */
/* * NOTE * The AIOS_Number_Of_Digitals_Handle will only be cached if*/
/*          the instance is for a Digital Characteristic.            */
typedef struct _tagAIOP_Client_Instance_Info_t
{
    boolean_t               Valid;
    uint8_t                 Properties;
    qapi_BLE_AIOS_IO_Type_t IOType;
    uint8_t                 Number_Of_Digitals;

    uint16_t                Analog_Charactersitic_Handle;
    uint16_t                Digital_Characteristic_Handle;
    uint16_t                CCCD_Handle;
    uint16_t                Presentation_Format_Handle;
    uint16_t                Number_Of_Digitals_Handle;
} AIOP_Client_Instance_Info_t;

#define AIOP_CLIENT_INSTANCE_INFO_SIZE                   (sizeof(AIOP_Client_Instance_Info_t))

/* The following structure contains the information that needs to be */
/* stored by an AIOS Client for a specified AIOS Characteristic type */
/* and all of its instances that may be cached by an AIOP Client     */
/* during service discovery.                                         */
typedef struct _tagAIOP_Client_Characteristic_Info_t
{
    qapi_BLE_AIOS_Characteristic_Type_t Type;
    AIOP_Client_Instance_Info_t         Instances[AIOP_NUMBER_OF_SUPPORTED_INSTANCES];
} AIOP_Client_Characteristic_Info_t;

#define AIOP_CLIENT_CHARACTERISTIC_INFO_SIZE             (sizeof(AIOP_Client_Characteristic_Info_t))

/* The following structure contains the information that will need to*/
/* be cached by a AIOS Client in order to only do service discovery  */
/* once.  This structure also contains the information that needs to */
/* be stored by an AIOP Client when read/writing AIOS Characteristic */
/* instances.                                                        */
/* ** NOTE ** This demo will only support the demo's AIOS Server.  If*/
/*            it is used to against another AIOS Server, then        */
/*            optional Characteristics and descriptors, the Aggregate*/
/*            Characteristic, and more Digital and Analog            */
/*            Characteristics instances greater than the maximum     */
/*            supported by the demo's AIOS Server will not be cached */
/*            by the demo's AIOS Client.  This constraint applies to */
/*            all sub structures.                                    */
/* * NOTE * The Characteristics field may only be valid for a Digital*/
/*          or Analog Characteristic.                                */
/* * NOTE * The Number_Digital_Characteristics_In_Aggregate field    */
/*          will be used to quickly determine how many Digital       */
/*          Characteristics are included in the Aggregate            */
/*          Characteristic during service discovery.  We can use this*/
/*          information to automatically issue GATT read requests    */
/*          (after service discovery has been peformed) for the      */
/*          Number Of Digitals descriptor for each Digital           */
/*          Characteristic included in the Aggregate that needs to be*/
/*          cached in order to decode the Aggregate Characteristic.  */
typedef struct _tagAIOP_Client_Information_t
{
    AIOP_Client_Characteristic_Info_t Characteristics[AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS];
    AIOP_Client_Request_Info_t        Client_Request_Info;
} AIOP_Client_Information_t;

#define AIOP_CLIENT_INFORMATION_DATA_SIZE                (sizeof(AIOP_Client_Information_t))

/* HID over GATT (HIDS) structures.                                  */

/* The following structure defines a key mapping.                    */
typedef struct _tagKeyMapping_t
{
    char    Ascii;
    uint8_t HID;
    uint8_t Modifiers;
} KeyMapping_t;

/* Serial Port Profile over LE (SPPLE) structures.                   */

/* The following structure holds status information about a send     */
/* process.                                                          */
typedef struct _tagSend_Info_t
{
    uint32_t BytesToSend;
    uint32_t BytesSent;
} Send_Info_t;

/* The following defines the format of a SPPLE Data Buffer.          */
typedef struct __tagSPPLE_Data_Buffer_t
{
    unsigned int  InIndex;
    unsigned int  OutIndex;
    unsigned int  BytesFree;
    unsigned int  BufferSize;
    uint8_t       Buffer[SPPLE_DATA_BUFFER_LENGTH*3];
} SPPLE_Data_Buffer_t;

/* Generic Access Profile Service (GAPS) structures.                 */

/* The following structure represents the information we will store  */
/* on a Discovered GAP Service.                                      */
typedef struct _tagGAPS_Client_Info_t
{
    uint16_t DeviceNameHandle;
    uint16_t DeviceAppearanceHandle;
} GAPS_Client_Info_t;

/* The following structure holds information on known Device         */
/* Appearance Values.                                                */
typedef struct _tagGAPS_Device_Appearance_Mapping_t
{
    uint16_t  Appearance;
    char     *String;
} GAPS_Device_Appearance_Mapping_t;

/* Remote Device Information structure.                              */

/* The following bit mask values may be used for the Flags field of  */
/* the DeviceInfo_t structure.                                       */
#define DEVICE_INFO_FLAGS_LTK_VALID                         0x01
#define DEVICE_INFO_FLAGS_SPPLE_SERVER                      0x02
#define DEVICE_INFO_FLAGS_SPPLE_CLIENT                      0x04
#define DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING     0x08
#define DEVICE_INFO_FLAGS_IRK_VALID                         0x10
#define DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST               0x20
#define DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST           0x40

/* The following structure holds information on known HIDS reports.  */
typedef struct _tagHIDS_Report_t
{
    qapi_BLE_HIDS_Report_Reference_Data_t ReportReferenceData;
    uint16_t                              Handle;
    uint16_t                              ReportReferenceHandle;
    uint16_t                              CCCDHandle;
} HIDS_Report_t;

typedef struct _tagHIDS_External_Report_t
{
    uint16_t             ExternalReportReferenceHandle;
    qapi_BLE_GATT_UUID_t ExternalReportReference;
} HIDS_External_Report_t;

/* The following enum represents the report names of HID Service     */
/* reports for use in application functions.                         */
typedef enum
{
    hrtHIDSInputReport             = 1,
    hrtHIDSOutputReport            = 2,
    hrtHIDSFeatureReport           = 3,
    hrtHIDSBootKeyboardInputReport = 4,
    hrtHIDSBootKeyboardOuputReport = 5,
    hrtHIDSBootMouseInputReport    = 6
} HIDS_Report_Type_Value_t;

/* The following structure represents the information we will store  */
/* for a discovered HID Service.                                     */
typedef struct _tagHIDS_Client_Info_t
{
    qapi_BLE_GATT_Attribute_Handle_Group_t  ServiceHandleRange;
    uint8_t                                *ReportMap;
    unsigned int                            ReportMapLength;
    qapi_BLE_HIDS_HID_Information_Data_t    HIDSInformation;
    HIDS_Report_t                           Reports[HIDS_MAXIMUM_NUMBER_REPORTS];
    HIDS_External_Report_t                  ExternalReportReferences[HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES];
    qapi_BLE_DIS_PNP_ID_Data_t              PNP_ID_Data;
    uint16_t                                ProtocolModeHandle;
    uint16_t                                ReportMapHandle;
    uint16_t                                BootKeyboardInputReport;
    uint16_t                                BootKeyboardOutputReport;
    uint16_t                                BootMouseInputReport;
    uint16_t                                HIDSInformationHandle;
    uint16_t                                ControlPoint;
    uint16_t                                BootKeyboardInputReport_CCCD;
    uint16_t                                BootMouseInputReport_CCCD;
    qapi_BLE_HIDS_Protocol_Mode_t           ProtocolMode;
} HIDS_Client_Info_t;

/* The following holds all the information stored for a HID Server   */
/* role per device.                                                  */
typedef struct _tagHIDS_Server_Info_t
{
    uint16_t BootMouseInputConfiguration;
    uint16_t BootKeyboardInputConfiguration;
    uint16_t ReportKeyboardInputConfiguration;
    uint16_t ReportMouseInputConfiguration;
} HIDS_Server_Info_t;

/* The following structure is used to track the sending and receiving*/
/* of data for the throughput test.                                  */
typedef struct _tagXferInfo_t
{
    uint64_t  RxCount;
    boolean_t TimingStarted;
    uint64_t  FirstTime;
    uint64_t  LastTime;
} XferInfo_t;

/* The following structure holds the information that needs to be    */
/* stored for a connected remote device.                             */
/* * NOTE * If the local device pairs with the remote device, then   */
/*          the LTK MUST ve valid, and the remote device information */
/*          MUST persist between connections.  If the local device   */
/*          does NOT pair with the remote device, then the LTK will  */
/*          NOT be valid, and the remote device information will be  */
/*          deleted when the remote device is disconnected.          */
/* * NOTE * The ConnectionID will be used to indicate that a remote  */
/*          device is currently connected.  Otherwise it will be set */
/*          to zero to indicate that the remote device is currently  */
/*          disconnected.                                            */
/* * NOTE * The SelectedRemoteBD_ADDR will correspond to the         */
/*          RemoteAddress field of the remote device that is         */
/*          currently connected.                                     */
typedef struct _tagDeviceInfo_t
{
    uint8_t                                Flags;
    unsigned int                           ConnectionID;
    boolean_t                              RemoteDeviceIsMaster;
    qapi_BLE_BD_ADDR_t                     RemoteAddress;
    qapi_BLE_GAP_LE_Address_Type_t         RemoteAddressType;
    qapi_BLE_GAP_LE_Address_Type_t         IdentityAddressType;
    qapi_BLE_BD_ADDR_t                     IdentityAddressBD_ADDR;
    uint8_t                                EncryptionKeySize;
    qapi_BLE_Long_Term_Key_t               LTK;
    qapi_BLE_Encryption_Key_t              IRK;
    qapi_BLE_Random_Number_t               Rand;
    uint16_t                               EDIV;
    qapi_BLE_GAP_LE_White_List_Entry_t     WhiteListEntry;
    qapi_BLE_GAP_LE_Resolving_List_Entry_t ResolvingListEntry;
    AIOP_Client_Information_t              AIOPClientInfo;
    uint16_t                               AIOPServerConfiguration;
    qapi_BLE_BAS_Client_Information_t      BASClientInfo[MAX_SUPPORTED_BATTERY_INSTANCES];
    qapi_BLE_BAS_Server_Information_t      BASServerInfo[MAX_SUPPORTED_BATTERY_INSTANCES];
    GAPS_Client_Info_t                     GAPSClientInfo;
    qapi_BLE_SCPS_Client_Information_t     SCPSClientInfo;
    qapi_BLE_SCPS_Server_Information_t     SCPSServerInfo;
    HIDS_Client_Info_t                     HIDSClientInfo[MAX_SUPPORTED_HID_INSTANCES];
    HIDS_Server_Info_t                     HIDSServerInfo;
    qapi_BLE_HRS_Client_Information_t      HRSClientInfo;
    SPPLE_Client_Info_t                    ClientInfo;
    SPPLE_Server_Info_t                    ServerInfo;
    unsigned int                           TransmitCredits;
    SPPLE_Data_Buffer_t                    ReceiveBuffer;
    SPPLE_Data_Buffer_t                    TransmitBuffer;
    XferInfo_t                             XferInfo;
    boolean_t                              ThroughputModeActive;
    struct _tagDeviceInfo_t               *NextDeviceInfoInfoPtr;
} DeviceInfo_t;

#define DEVICE_INFO_DATA_SIZE                            (sizeof(DeviceInfo_t))

typedef struct _tagPersistentRemoteDeviceData_t
{
    uint8_t                        Flags;
    qapi_BLE_BD_ADDR_t             LastAddress;
    qapi_BLE_GAP_LE_Address_Type_t LastAddressType;
    qapi_BLE_BD_ADDR_t             IdentityAddress;
    qapi_BLE_GAP_LE_Address_Type_t IdentityAddressType;
    uint8_t                        EncryptionKeySize;
    qapi_BLE_Long_Term_Key_t       LTK;
    qapi_BLE_Encryption_Key_t      IRK;
} PersistentRemoteDeviceData_t;

#define PERSISTENT_REMOTE_DEVICE_DATA_SIZE               (sizeof(PersistentRemoteDeviceData_t))

#define PERSISTENT_REMOTE_DEVICE_DATA_FLAG_LTK_VALID        0x01
#define PERSISTENT_REMOTE_DEVICE_DATA_FLAG_IDENTITY_VALID   0x02

typedef struct _tagPersistentData_t
{
    qapi_BLE_BD_ADDR_t LocalAddress;
    uint8_t NumberRemoteDevices;
    PersistentRemoteDeviceData_t RemoteDevices[1];
} PersistentData_t;

#define PERSISTENT_DATA_SIZE(_x)                         (QAPI_BLE_BTPS_STRUCTURE_OFFSET(PersistentData_t, RemoteDevices) + (PERSISTENT_REMOTE_DEVICE_DATA_SIZE * (_x)))

/* Internal Variables to this Module (Remember that all variables    */
/* declared static are initialized to 0 automatically by the         */
/* compiler as part of standard C/C++).                              */

static QCLI_Group_Handle_t ble_group;               /* Handle for our main QCLI Command*/
/* Group.                          */

static uint32_t            BluetoothStackID;        /* Variable which holds the Handle */
/* of the opened Bluetooth Protocol*/
/* Stack.                          */

static uint32_t            ScanTimerID;             /* Scan Timer ID.                  */

static qapi_BLE_HCI_DriverInformation_t HCI_DriverInformation;
/* The HCI Driver structure that   */
/* holds the HCI Transports        */
/* settings used to initialize     */
/* Bluetopia.                      */

static unsigned int        ConnectionCount;         /* Holds the number of connected   */
/* remote devices.                 */

static DeviceInfo_t       *DeviceInfoList;          /* Holds the list head for the     */
/* remote device info list         */

typedef char               BoardStr_t[16];          /* User to represent a structure to*/
/* hold a BD_ADDR return from      */
/* BD_ADDRToStr.                   */

/* Generic Access Profile (GAPLE) Internal Variables.                */

static GAPLE_Parameters_t  LE_Parameters;           /* Holds GAP Parameters like       */
/* Discoverability, Connectability */
/* Modes.                          */

static BLEParameters_t     BLEParameters;           /* Variable which is used to hold  */
/* the BLE Scan/Advertising/...    */
/* Connection Parameters that have */
/* been configured at the CLI.     */

static qapi_BLE_BD_ADDR_t  LocalBD_ADDR;            /* Holds the BD_ADDR of the        */
/* local device.                   */

static qapi_BLE_BD_ADDR_t  SelectedRemoteBD_ADDR;   /* Holds the BD_ADDR of the        */
/* connected remote device that is */
/* currently selected.             */

static qapi_BLE_BD_ADDR_t  SecurityRemoteBD_ADDR;   /* Variable which holds the        */
/* current BD_ADDR of the device   */
/* which is currently pairing or   */
/* authenticating.                 */

static qapi_BLE_Encryption_Key_t ER = {0x28, 0xBA, 0xE1, 0x37, 0x13, 0xB2, 0x20, 0x45, 0x16, 0xB2, 0x19, 0xD0, 0x80, 0xEE, 0x4A, 0x51};
/* The Encryption Root Key should  */
/* be generated in such a way as   */
/* to guarantee 128 bits of        */
/* entropy.                        */

static qapi_BLE_Encryption_Key_t IR = {0x41, 0x09, 0xA0, 0x88, 0x09, 0x6B, 0x70, 0xC0, 0x95, 0x23, 0x3C, 0x8C, 0x48, 0xFC, 0xC9, 0xFE};
/* The Identity Root Key should    */
/* be generated in such a way as   */
/* to guarantee 128 bits of        */
/* entropy.                        */

static qapi_BLE_Encryption_Key_t DHK;               /* The DHK key can be              */
/* regenerated on the fly using the*/
/* constant IR and ER keys and     */
/* are used globally, for all      */
/* devices.                        */

static qapi_BLE_Encryption_Key_t IRK;               /* The IRK key can be              */
/* regenerated on the fly using the*/
/* constant IR and ER keys and     */
/* are used globally, for all      */
/* devices.                        */

static boolean_t           ScanInProgress;          /* A boolean flag to show if a scan*/
/* is in process                   */

static boolean_t           LocalDeviceIsMaster;     /* Variable which indicates if the */
/* local device is the master      */
/* of the connection.              */

static qapi_BLE_GAP_LE_Address_Type_t  RemoteAddressType;
/* Variable which holds the remote */
/* address type for a connected    */
/* remote device until it can be   */
/* stored in the remote device     */
/* information.                    */

static qapi_Persist_Handle_t PersistHandle;         /* Variable which holds the handle */
/* to a persistent storage         */
/* instance.                       */

static boolean_t                                  LocalOOBValid; /* Variable which     */
/* holds if we have received OOB   */
/* from Local device.              */

static qapi_BLE_Secure_Connections_Randomizer_t   LocalOOBRandomizer; /* Variable      */
/* which holds Local OOB           */
/* Randomizer.                     */

static qapi_BLE_Secure_Connections_Confirmation_t LocalOOBConfirmation; /* Variable    */
/* which holds Local OOB           */
/* Confirmation.                   */

static boolean_t                                  RemoteOOBValid; /* Variable which    */
/* holds if we have received OOB   */
/* from remote device.             */

static qapi_BLE_Secure_Connections_Randomizer_t   RemoteOOBRandomizer; /* Variable     */
/* which holds remote OOB          */
/* Randomizer.                     */

static qapi_BLE_Secure_Connections_Confirmation_t RemoteOOBConfirmation; /* Variable   */
/* which holds remote OOB          */
/* Confirmation.                   */

/* BT5 Internal Variables.                                           */
#ifdef V2

static QCLI_Group_Handle_t bt5_group;            /* Handle for our HCI Command      */
/* Group.                          */

#endif

/* Automation IO Service (AIOS) Internal Variables.                  */

static QCLI_Group_Handle_t aios_group;              /* Handle for our AIOS Command     */
/* Group.                          */

static uint32_t            AIOSInstanceID;          /* The following holds the AIOS    */
/* Instance ID that is returned    */
/* from                            */
/* qapi_BLE_GATT_Register_Service()*/

static AIOP_Server_Information_t  AIOSServerInfo;   /* Variable which holds the        */
/* information that needs to be    */
/* stored by the AIOS Server.      */

/* Battery Alert Service (BAS) Internal Variables.                   */

static QCLI_Group_Handle_t bas_group;               /* Handle for our BAS Command      */
/* Group.                          */

static uint32_t            BASInstanceID[MAX_SUPPORTED_BATTERY_INSTANCES];
/* The following holds the BAS     */
/* Instance IDs that are returned  */
/* from BAS_Initialize_Service().  */

static unsigned int        BASInstanceIDIndex;      /* Index used to navigate          */
/* BASInstanceID[] array while     */
/* Populating BAS Handles          */

static uint8_t             BatteryLevel[MAX_SUPPORTED_BATTERY_INSTANCES];
/* Variable which is used to hold  */
/* the Battery Level of all        */
/* instances a Device.             */

/* Device Information Service (DIS) Internal Variables.              */

static uint32_t            DISInstanceID;           /* Holds the Instance ID for the   */
/* DIS Service.                    */

/* Generic Access Profile Service (GAPS) Internal Variables.         */

static QCLI_Group_Handle_t gaps_group;              /* Handle for our GAPS Command     */
/* Group.                          */

static uint32_t            GAPSInstanceID;          /* Holds the Instance ID for the   */
/* GAP Service.                    */

/* HID over GATT (HOGP) Internal Variables.                          */

static unsigned int        HIDSInstanceID;          /* The following holds the HIDS    */
/* Instance ID that is returned    */
/* from HIDS_Initialize_Service(). */

static QCLI_Group_Handle_t hids_group;              /* Handle for our HIDS Command     */
/* Group.                          */

static unsigned int        HIDSInstanceIDIndex;     /* Index used to navigate          */
/* HIDSInstanceID[] array while    */
/* Populating HID Handles          */

static qapi_BLE_UUID_128_t NULL_UUID_128;           /* Holds a NULL UUID 128 for       */
/* comparison.                     */

static uint8_t             MouseInputReport[HID_MOUSE_INPUT_REPORT_SIZE]; /* Holds the*/
/* current HID mouse input report. */

static unsigned int        MouseInputReportSize = HID_MOUSE_INPUT_REPORT_SIZE;
/* Holds the current HID mouse     */
/* input report size.              */

static uint8_t             KeyboardInputReport[HID_KEYBOARD_INPUT_REPORT_SIZE];
/* Holds the current HID keyboard  */
/* input report.                   */

static unsigned int        KeyboardInputReportSize = HID_KEYBOARD_INPUT_REPORT_SIZE;
/* Holds the current HID keyboard  */
/* input report size.              */

static uint8_t             KeyboardOutputReport[HID_KEYBOARD_OUTPUT_REPORT_SIZE];
/* Holds the current HID keyboard  */
/* output report.                  */

static unsigned int        KeyboardOutputReportSize = HID_KEYBOARD_OUTPUT_REPORT_SIZE;
/* Holds the current HID keyboard  */
/* output report size.             */

static qapi_BLE_HIDS_Protocol_Mode_t HIDS_Protocol_Mode;
/* Holds the current mode of the   */
/* HID connection (Boot vs Report).*/

/* The following table represent the Keyboard Report Descriptor for  */
/* this HID Keyboard Device.                                         */
static uint8_t KeyboardReportDescriptor[] =
{
    0x05, 0x01,  /* USAGE_PAGE (Generic Desktop)                        */
    0x09, 0x06,  /* USAGE (Keyboard)                                    */
    0xa1, 0x01,  /* COLLECTION (Application)                            */
    0x85, 0x01,  /* REPORT_ID (1)                                       */
    0x05, 0x07,  /* USAGE_PAGE (Keyboard)                               */
    0x19, 0xe0,  /* USAGE_MINIMUM (Keyboard LeftControl)                */
    0x29, 0xe7,  /* USAGE_MAXIMUM (Keyboard Right GUI)                  */
    0x15, 0x00,  /* LOGICAL_MINIMUM (0)                                 */
    0x25, 0x01,  /* LOGICAL_MAXIMUM (1)                                 */
    0x75, 0x01,  /* REPORT_SIZE (1)                                     */
    0x95, 0x08,  /* REPORT_COUNT (8)                                    */
    0x81, 0x02,  /* INPUT (Data,Var,Abs)                                */
    0x95, 0x01,  /* REPORT_COUNT (1)                                    */
    0x75, 0x08,  /* REPORT_SIZE (8)                                     */
    0x81, 0x03,  /* INPUT (Cnst,Var,Abs)                                */
    0x95, 0x05,  /* REPORT_COUNT (5)                                    */
    0x75, 0x01,  /* REPORT_SIZE (1)                                     */
    0x05, 0x08,  /* USAGE_PAGE (LEDs)                                   */
    0x19, 0x01,  /* USAGE_MINIMUM (Num Lock)                            */
    0x29, 0x05,  /* USAGE_MAXIMUM (Kana)                                */
    0x91, 0x02,  /* OUTPUT (Data,Var,Abs)                               */
    0x95, 0x01,  /* REPORT_COUNT (1)                                    */
    0x75, 0x03,  /* REPORT_SIZE (3)                                     */
    0x91, 0x03,  /* OUTPUT (Cnst,Var,Abs)                               */
    0x95, 0x06,  /* REPORT_COUNT (6)                                    */
    0x75, 0x08,  /* REPORT_SIZE (8)                                     */
    0x15, 0x00,  /* LOGICAL_MINIMUM (0)                                 */
    0x25, 0x65,  /* LOGICAL_MAXIMUM (101)                               */
    0x05, 0x07,  /* USAGE_PAGE (Keyboard)                               */
    0x19, 0x00,  /* USAGE_MINIMUM (Reserved (no event indicated))       */
    0x29, 0x65,  /* USAGE_MAXIMUM (Keyboard Application)                */
    0x81, 0x00,  /* INPUT (Data,Ary,Abs)                                */
    0xc0         /* END_COLLECTION                                      */
};

/* Heart Rate Service (HRS) Internal Variables.                      */

static QCLI_Group_Handle_t hrs_group;               /* Handle for our HRS Command      */
/* Group.                          */
static QCLI_Group_Handle_t dis_group;               /* Handle for our DIS Command      */
/* Group.                          */
static QCLI_Group_Handle_t tps_group;               /* Handle for our TPS Command      */
/* Group.                          */

/* Scan Parameter Service (SCPS) Internal Variables.                 */

static QCLI_Group_Handle_t scps_group;              /* Handle for our SCSP Command     */
/* Group.                          */

static uint32_t            SCPSInstanceID;          /* The following holds the SCPS    */
/* Instance ID.                    */


/* Serial Port Profile over LE (SPPLE) Internal Variables.           */

static QCLI_Group_Handle_t spple_group;             /* Handle for our SPPLE Command    */
/* Group.                          */
static uint32_t            SPPLEServiceID;          /* The following holds the SPP LE  */
/* Service ID that is returned from*/
/* qapi_BLE_GATT_Register_Service()*/

static uint8_t             SPPLEBuffer[SPPLE_DATA_BUFFER_LENGTH+1];  /* Buffer that is */
/* used for Sending/Receiving      */
/* SPPLE Service Data.             */

static Send_Info_t         SendInfo;                /* Variable that contains          */
/* information about a data        */
/* transfer process.               */

static boolean_t           LoopbackActive;          /* Variable which flags whether or */
/* not the application is currently*/
/* operating in Loopback Mode      */
/* (TRUE) or not (FALSE).          */

static boolean_t           DisplayRawData;          /* Variable which flags whether or */
/* not the application is to       */
/* simply display the Raw Data     */
/* when it is received (when not   */
/* operating in Loopback Mode).    */

static boolean_t           AutomaticReadActive;     /* Variable which flags whether or */
/* not the application is to       */
/* automatically read all data     */
/* as it is received.              */

static boolean_t           DisplayAdvertisingEventData; /* Flag to indicate if we      */
/* should have verbose adv report  */
/* outputs.                        */

/* Transport Power Service (TPS) Internal Variables.                 */

static uint32_t            TPSInstanceID;           /* Holds the Instance ID for the   */
/* TPS Service.                    */

/* The following is used to map from ATT Error Codes to a printable  */
/* string.                                                           */
static char *ErrorCodeStr[] =
{
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_NO_ERROR",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_HANDLE",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_READ_NOT_PERMITTED",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_WRITE_NOT_PERMITTED",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_PDU",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_AUTHENTICATION",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_REQUEST_NOT_SUPPORTED",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_OFFSET",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_AUTHORIZATION",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_PREPARE_QUEUE_FULL",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_ATTRIBUTE_NOT_FOUND",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_ATTRIBUTE_NOT_LONG",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION_KEY_SIZE",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_ATTRIBUTE_VALUE_LENGTH",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNSUPPORTED_GROUP_TYPE",
    "QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_RESOURCES"
} ;

#define NUMBER_OF_ERROR_CODES     (sizeof(ErrorCodeStr)/sizeof(char *))

/* The following array is used to map Device Appearance Values to    */
/* strings.                                                          */
static GAPS_Device_Appearance_Mapping_t AppearanceMappings[] =
{
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_UNKNOWN,                        "Unknown"                   },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_PHONE,                  "Generic Phone"             },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_COMPUTER,               "Generic Computer"          },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_WATCH,                  "Generic Watch"             },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_SPORTS_WATCH,                   "Sports Watch"              },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_CLOCK,                  "Generic Clock"             },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_DISPLAY,                "Generic Display"           },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_GENERIC_REMOTE_CONTROL, "Generic Remote Control"    },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_EYE_GLASSES,            "Eye Glasses"               },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_TAG,                    "Generic Tag"               },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_KEYRING,                "Generic Keyring"           },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_MEDIA_PLAYER,           "Generic Media Player"      },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_BARCODE_SCANNER,        "Generic Barcode Scanner"   },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_THERMOMETER,            "Generic Thermometer"       },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_THERMOMETER_EAR,                "Ear Thermometer"           },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_HEART_RATE_SENSOR,      "Generic Heart Rate Sensor" },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_BELT_HEART_RATE_SENSOR,         "Belt Heart Rate Sensor"    },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_BLOOD_PRESSURE,         "Generic Blood Pressure"    },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_BLOOD_PRESSURE_ARM,             "Blood Pressure: ARM"       },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_BLOOD_PRESSURE_WRIST,           "Blood Pressure: Wrist"     },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HUMAN_INTERFACE_DEVICE,         "Human Interface Device"    },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_KEYBOARD,                   "HID Keyboard"              },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_MOUSE,                      "HID Mouse"                 },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_JOYSTICK,                   "HID Joystick"              },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_GAMEPAD,                    "HID Gamepad"               },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_DIGITIZER_TABLET,           "HID Digitizer Tablet"      },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_CARD_READER,                "HID Card Reader"           },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_DIGITAL_PEN,                "HID Digitizer Pen"         },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_HID_BARCODE_SCANNER,            "HID Bardcode Scanner"      },
    { QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_GLUCOSE_METER,          "Generic Glucose Meter"     }
} ;

#define NUMBER_OF_APPEARANCE_MAPPINGS     (sizeof(AppearanceMappings)/sizeof(GAPS_Device_Appearance_Mapping_t))

/* The following string table is used to map HCI Version information */
/* to an easily displayable version string.                          */
const char *HCIVersionStrings[] =
{
    "1.0b",
    "1.1",
    "1.2",
    "2.0",
    "2.1",
    "3.0",
    "4.0",
    "4.1",
    "4.2",
    "5.0",
    "Unknown (greater 5.0)"
} ;

#define NUM_SUPPORTED_HCI_VERSIONS              (sizeof(HCIVersionStrings)/sizeof(char *) - 1)

/* The following string table is used to map the API I/O Capabilities*/
/* values to an easily displayable string.                           */
static const char *IOCapabilitiesStrings[] =
{
    "Display Only",
    "Display Yes/No",
    "Keyboard Only",
    "No Input/Output",
    "Keyboard/Display"
} ;

/* Internal Variables to this Module (Remember that all variables    */
/* declared static are initialized to 0 automatically by the         */
/* compiler as part of standard C/C++).                              */
#define CURRENT_TEST_NONE                       0
#define CURRENT_TEST_TX_ACL                     1
#define CURRENT_TEST_RX_ACL                     3
#define CURRENT_TEST_PERIODIC                   4

#define MAXIMUM_TEST_BUFFER                  1024

static unsigned int        CurrentTest = CURRENT_TEST_NONE;
static unsigned int        NumberACLPackets;
static unsigned int        NumberOutstandingACLPackets;
static unsigned int        MaxACLPacketSize;
static unsigned long       StartTime;
static unsigned long       EndTime;
static unsigned long       NumberBytes;
static unsigned long       PacketLength;
static unsigned char       TestBuffer[MAXIMUM_TEST_BUFFER];
static uint16_t            ConnectionHandle;
static uint32_t            TransmitPeriod;
static qapi_TIMER_handle_t PeriodicSendTimer;

/* The following defines a data sequence that will be used to        */
/* generate message data.                                            */
static char  DataStr[]  = "~!@#$%^&*()_+`1234567890-=:;\"'<>?,./@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]`abcdefghijklmnopqrstuvwxyz{|}<>\n";
static int   DataStrLen = (sizeof(DataStr)-1);

/*********************************************************************/
/**                     SPPLE Service Table                         **/
/*********************************************************************/

/* The SPPLE Service Declaration UUID.                               */
static const qapi_BLE_GATT_Primary_Service_128_Entry_t SPPLE_Service_UUID =
{
    SPPLE_SERVICE_UUID_CONSTANT
} ;

/* The Tx Characteristic Declaration.                                */
static const qapi_BLE_GATT_Characteristic_Declaration_128_Entry_t SPPLE_Tx_Declaration =
{
    QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_NOTIFY,
    SPPLE_TX_CHARACTERISTIC_UUID_CONSTANT
} ;

/* The Tx Characteristic Value.                                      */
static const qapi_BLE_GATT_Characteristic_Value_128_Entry_t  SPPLE_Tx_Value =
{
    SPPLE_TX_CHARACTERISTIC_UUID_CONSTANT,
    0,
    NULL
} ;

/* The Tx Credits Characteristic Declaration.                        */
static const qapi_BLE_GATT_Characteristic_Declaration_128_Entry_t SPPLE_Tx_Credits_Declaration =
{
    (QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ|QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE_WITHOUT_RESPONSE|QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE),
    SPPLE_TX_CREDITS_CHARACTERISTIC_UUID_CONSTANT
} ;

/* The Tx Credits Characteristic Value.                              */
static const qapi_BLE_GATT_Characteristic_Value_128_Entry_t SPPLE_Tx_Credits_Value =
{
    SPPLE_TX_CREDITS_CHARACTERISTIC_UUID_CONSTANT,
    0,
    NULL
} ;

/* The SPPLE RX Characteristic Declaration.                          */
static const qapi_BLE_GATT_Characteristic_Declaration_128_Entry_t SPPLE_Rx_Declaration =
{
    (QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE_WITHOUT_RESPONSE),
    SPPLE_RX_CHARACTERISTIC_UUID_CONSTANT
} ;

/* The SPPLE RX Characteristic Value.                                */
static const qapi_BLE_GATT_Characteristic_Value_128_Entry_t  SPPLE_Rx_Value =
{
    SPPLE_RX_CHARACTERISTIC_UUID_CONSTANT,
    0,
    NULL
} ;

/* The SPPLE Rx Credits Characteristic Declaration.                  */
static const qapi_BLE_GATT_Characteristic_Declaration_128_Entry_t SPPLE_Rx_Credits_Declaration =
{
    (QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ|QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_NOTIFY),
    SPPLE_RX_CREDITS_CHARACTERISTIC_UUID_CONSTANT
};

/* The SPPLE Rx Credits Characteristic Value.                        */
static const qapi_BLE_GATT_Characteristic_Value_128_Entry_t SPPLE_Rx_Credits_Value =
{
    SPPLE_RX_CREDITS_CHARACTERISTIC_UUID_CONSTANT,
    0,
    NULL
};

/* Client Characteristic Configuration Descriptor.                   */
static qapi_BLE_GATT_Characteristic_Descriptor_16_Entry_t Client_Characteristic_Configuration =
{
    QAPI_BLE_GATT_CLIENT_CHARACTERISTIC_CONFIGURATION_BLUETOOTH_UUID_CONSTANT,
    QAPI_BLE_GATT_CLIENT_CHARACTERISTIC_CONFIGURATION_LENGTH,
    NULL
};

/* The following defines the SPPLE service that is registered with   */
/* the GATT_Register_Service function call.                          */
/* * NOTE * This array will be registered with GATT in the call to   */
/*          GATT_Register_Service.                                   */
const qapi_BLE_GATT_Service_Attribute_Entry_t SPPLE_Service[] =
{
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_PRIMARY_SERVICE_128_E,            (uint8_t *)&SPPLE_Service_UUID                  },
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_DECLARATION_128_E, (uint8_t *)&SPPLE_Tx_Declaration                },
    { 0,                                               QAPI_BLE_AET_CHARACTERISTIC_VALUE_128_E,       (uint8_t *)&SPPLE_Tx_Value                      },
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE_WRITABLE, QAPI_BLE_AET_CHARACTERISTIC_DESCRIPTOR_16_E,   (uint8_t *)&Client_Characteristic_Configuration },
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_DECLARATION_128_E, (uint8_t *)&SPPLE_Tx_Credits_Declaration        },
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE_WRITABLE, QAPI_BLE_AET_CHARACTERISTIC_VALUE_128_E,       (uint8_t *)&SPPLE_Tx_Credits_Value              },
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_DECLARATION_128_E, (uint8_t *)&SPPLE_Rx_Declaration                },
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_WRITABLE,          QAPI_BLE_AET_CHARACTERISTIC_VALUE_128_E,       (uint8_t *)&SPPLE_Rx_Value                      },
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_DECLARATION_128_E, (uint8_t *)&SPPLE_Rx_Credits_Declaration        },
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,          QAPI_BLE_AET_CHARACTERISTIC_VALUE_128_E,       (uint8_t *)&SPPLE_Rx_Credits_Value              },
    { QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE_WRITABLE, QAPI_BLE_AET_CHARACTERISTIC_DESCRIPTOR_16_E,   (uint8_t *)&Client_Characteristic_Configuration }
} ;

#define SPPLE_SERVICE_ATTRIBUTE_COUNT               (sizeof(SPPLE_Service)/sizeof(qapi_BLE_GATT_Service_Attribute_Entry_t))

#define SPPLE_TX_CHARACTERISTIC_ATTRIBUTE_OFFSET               2
#define SPPLE_TX_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET           3
#define SPPLE_TX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET       5
#define SPPLE_RX_CHARACTERISTIC_ATTRIBUTE_OFFSET               7
#define SPPLE_RX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET       9
#define SPPLE_RX_CREDITS_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET   10

/*********************************************************************/
/**                    END OF SERVICE TABLE                         **/
/*********************************************************************/

/* External function prototypes.                                     */
extern int HCI_VS_GetPatchVersion(unsigned int BluetoothStackID, uint32_t *ProductID, uint32_t *BuildVersion);
extern int HCI_VS_EnableBBIF(unsigned int BluetoothStackID, boolean_t Enable);
extern int HCI_VS_SetRadio(unsigned int BluetoothStackID, unsigned int RadioNumber);

/* Demo QCLI command functions.                                      */
static QCLI_Command_Status_t  BluetoothService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetBLERadio(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

/* Demo helper functions.                                            */
static DeviceInfo_t *CreateNewDeviceInfoEntry(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress);
static DeviceInfo_t *SearchDeviceInfoEntryByBD_ADDR(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress);
static DeviceInfo_t *SearchDeviceInfoEntryTypeAddress(DeviceInfo_t **ListHead, qapi_BLE_GAP_LE_Address_Type_t AddressType, qapi_BLE_BD_ADDR_t RemoteAddress);
static DeviceInfo_t *SearchDeviceInfoEntryByConnectionID(DeviceInfo_t **ListHead, unsigned int ConnectionID);
static DeviceInfo_t *DeleteDeviceInfoEntry(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress);
static void FreeDeviceInfoEntryMemory(DeviceInfo_t *EntryToFree);
static void FreeDeviceInfoList(DeviceInfo_t **ListHead);

static void BD_ADDRToStr(qapi_BLE_BD_ADDR_t Board_Address, BoardStr_t BoardStr);
static unsigned int StringToUnsignedInteger(char *StringInteger);

static int OpenStack(qapi_BLE_HCI_DriverInformation_t *HCI_DriverInformation);
static int CloseStack(void);

static int RegisterForHCIEvents(void);
static int RegisterForACLData(void);

static void GenerateData2Send(unsigned int Length, uint8_t *Data);
static void Period_Tx_Callback(uint32_t data);
static int  SendACLData(unsigned int Length, unsigned char *Data);

static void EventCallback(uint32_t BluetoothStackID, qapi_BLE_HCI_Event_Data_t *HCI_Event_Data, uint32_t CallbackParameter);
static void ACLDataCallback(uint32_t BluetoothStackID, uint16_t Connection_Handle, uint16_t Flags, uint16_t ACLDataLength, uint8_t *ACLData, uint32_t CallbackParameter);

static QCLI_Command_Status_t StartTXRXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t StopTXRXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

/* Generic Access Profile (GAPLE) QCLI command functions.            */
static QCLI_Command_Status_t SetConnectionMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetPairabilityMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ChangePairingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t LEPassKeyResponse(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t LEQueryEncryption(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t LESetPasskey(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetLocalAddress(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t AdvertiseLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ScanLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GapLeconnect(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);


static QCLI_Command_Status_t LEServiceDeactivate(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t PairLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t DisplayRemoteDevice(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t DeviceList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

static QCLI_Command_Status_t AddRemoveDeviceToResolvingList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetAuthenticatedPayloadTimeout(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

static QCLI_Command_Status_t SetGetScanParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

static QCLI_Command_Status_t SetGetAdvertisingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

static QCLI_Command_Status_t SetGetConnectionParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

static QCLI_Command_Status_t SetTestDataPeriod(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetDataLength(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

static QCLI_Command_Status_t PersistentDataService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureAdvReportDisplay(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t QueryLocalOOBData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetRemoteOOOBData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

#ifndef V1
static QCLI_Command_Status_t LowPowerTransmitOverride(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
#endif

/* Generic Access Profile (GAPLE) helper functions.                  */
static int SetDisc(void);
static int SetConnect(void);
static int SetPairable(void);
static int StartScan(uint32_t BluetoothStackID, qapi_BLE_GAP_LE_Filter_Policy_t FilterPolicy, unsigned int ScanDuration);
static int StopScan(uint32_t BluetoothStackID);
static int ConnectLEDevice(uint32_t BluetoothStackID, boolean_t UseWhiteList, qapi_BLE_BD_ADDR_t *BD_ADDR, qapi_BLE_GAP_LE_Address_Type_t AddressType);
static void ConfigureCapabilities(qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t *Capabilities);
static int SendPairingRequest(qapi_BLE_BD_ADDR_t BD_ADDR, boolean_t ConnectionMaster);
static int SlavePairingRequestResponse(qapi_BLE_BD_ADDR_t BD_ADDR);
static int EncryptionInformationRequestResponse(qapi_BLE_BD_ADDR_t BD_ADDR, uint8_t KeySize, qapi_BLE_GAP_LE_Authentication_Response_Information_t *GAP_LE_Authentication_Response_Information);
static void DisplayIOCapabilities(void);

static void DisplayLegacyPairingInformation(qapi_BLE_GAP_LE_Pairing_Capabilities_t *Pairing_Capabilities);
static void DisplayPairingInformation(qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t *Pairing_Capabilities);
static void DisplayUUID(qapi_BLE_GATT_UUID_t *UUID);
static void DisplayFunctionError(char *Function, int Status);
static void GenerateRandomKeys(void);

/* v2 QCLI command functions.                                        */
#ifdef V2
char *PHYToString(qapi_BLE_GAP_LE_PHY_Type_t PHY);
static QCLI_Command_Status_t BLE5PHY(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ExtendedAdvertisingParams(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ExtendedScanParams(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ExtendedConnect(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
#endif

/* Generic Attribute Profile (GATT) QCLI command functions.          */
static QCLI_Command_Status_t DiscoverServices(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetGetGATTMTU(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

/* Generic Attribute Profile (GATT) helper functions.                */
static int EnableDisableNotificationsIndications(uint16_t ClientConfigurationHandle, uint16_t ClientConfigurationValue, unsigned int ConnectionID, qapi_BLE_GATT_Client_Event_Callback_t ClientEventCallback);

/* Automation IO Service (AIOS) QCLI command functions.              */
static QCLI_Command_Status_t AIOSService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t AIOSRead(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t AIOSWrite(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureRemoteAIOS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

/* Automation IO Service (AIOS) helper functions.                    */
static void ConfigureAIOSServer(void);
static AIOP_Server_Instance_Data_t *GetAIOSServerInstanceInfoPtr(qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo);
static AIOP_Client_Instance_Info_t *GetAIOSClientInstanceInfoPtr(AIOP_Client_Information_t *ClientInfo);
static void AIOSPopulateHandles(AIOP_Client_Information_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);
static void StoreDescriptorHandles(AIOP_Client_Instance_Info_t *InstanceInfoPtr, qapi_BLE_GATT_Characteristic_Information_t *CharacteristicInfoPtr);
static void DisplayAIOSCharacteristicInfo(qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo);
static void DisplayDigitalCharacteristic(qapi_BLE_AIOS_Digital_Characteristic_Data_t *DigitalData, uint32_t ID);
static void DisplayDigitalByte(uint8_t DigitalByte);
static void DisplayAnalogCharacteristic(uint16_t AnalogData, uint32_t ID);
static void DisplayAIOSPresentationFormatData(qapi_BLE_AIOS_Presentation_Format_Data_t *PresentationFormatData);
static void DecodeDisplayDigitalCharacteristic(uint16_t ValueLength, uint8_t *Value, uint32_t ID);
static void DecodeDisplayAnalogCharacteristic(uint16_t ValueLength, uint8_t *Value, uint32_t ID);

/* Battery Alert Service (BAS) QCLI command functions.               */
static QCLI_Command_Status_t RegUnregBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureRemoteBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetSetBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t NotifyBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t GetSetBatteryLevelPresentationFormat(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

/* Battery Alert Service (BAS) helper functions.                     */
static void BASPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);
static boolean_t IsBatteryLevelHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo);
static boolean_t IsBatteryLevelPresentationFormatHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo);
static boolean_t IsBASClientConfigurationHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo);

/* Generic Access Profile Service (GAPS) QCLI command functions.     */
static QCLI_Command_Status_t ReadSetLocalName(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadRemoteNameApp(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ReadSetLocalAppearance(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

/* Generic Access Profile Service (GAPS) helper functions.           */
static void GAPSPopulateHandles(GAPS_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceInfo);
static void DumpAppearanceMappings(void);
static boolean_t AppearanceToString(uint16_t Appearance, char **String);
static boolean_t AppearanceIndexToAppearance(unsigned int Index, uint16_t *Appearance);

/* HID over GATT Service (HIDS) QCLI command functions.              */
static QCLI_Command_Status_t HIDSService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t HIDSReport(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t HIDSMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

/* HID over GATT Service (HIDS) helper functions.                    */
static void HIDSPopulateHandles(HIDS_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);
static void ReadHIDSInfo(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo);
static int  HIDSGetReport(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo, uint8_t ReportType, uint8_t ReportID);
static int  HIDSSetReport(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo, uint8_t ReportType, uint8_t ReportID, uint8_t *Value, unsigned int ValueLength, boolean_t ResponseExpected);
static unsigned int ExtractHexString(char *String, uint8_t **Buffer);

/* Heart Rate Service (HRS) QCLI command functions.                  */
static QCLI_Command_Status_t ConfigureRemoteHRS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureDisService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t ConfigureTpsService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

/* Heart Rate Service (HRS) helper functions.                        */
static void HRSPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);
static qapi_BLE_HRS_Heart_Rate_Measurement_Data_t *DecodeDisplayHeartRate(unsigned int ValueLength, uint8_t *Value, boolean_t PrintData);

/* Scan Parameter Service (SCPS) QCLI command functions.             */
static QCLI_Command_Status_t SCPSService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SetScanIntervalWindow(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);

/* Scan Parameter Service (SCPS) helper functions.                   */
static void SCPSPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData);

/* Serial Port over LE (SPPLE) QCLI command functions.               */
static QCLI_Command_Status_t SPPLEService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SPPLEData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
static QCLI_Command_Status_t SPPLEext(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List);
/* Serial Port over LE (SPPLE) helper functions.                     */
static void DisplayThroughput(DeviceInfo_t *DeviceInfo);
static char *SecondsToString(uint32_t Seconds, uint8_t BufferLength, char *Buffer);
static void SPPLEPopulateHandles(SPPLE_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceInfo);
static unsigned int AddDataToBuffer(SPPLE_Data_Buffer_t *DataBuffer, unsigned int DataLength, uint8_t *Data);
static unsigned int RemoveDataFromBuffer(SPPLE_Data_Buffer_t *DataBuffer, unsigned int BufferLength, uint8_t *Buffer);
static void InitializeBuffer(SPPLE_Data_Buffer_t *DataBuffer);
static unsigned int FillBufferWithString(SPPLE_Data_Buffer_t *DataBuffer, unsigned *CurrentBufferLength, unsigned int MaxLength, uint8_t *Buffer);
static void SendProcess(DeviceInfo_t *DeviceInfo);
static void SendCredits(DeviceInfo_t *DeviceInfo, unsigned int DataLength);
static boolean_t ReceiveCreditEvent(DeviceInfo_t *DeviceInfo, unsigned int Credits);
static boolean_t SendData(DeviceInfo_t *DeviceInfo, unsigned int DataLength, uint8_t *Data);
static boolean_t DataIndicationEvent(DeviceInfo_t *DeviceInfo, unsigned int DataLength, uint8_t *Data);
static int ReadData(DeviceInfo_t *DeviceInfo, unsigned int BufferLength, uint8_t *Buffer);

/* Tx Power Service (TPS) helper functions.                          */
static boolean_t QueryTxPowerLevel(boolean_t ConnectionTxPower, int8_t *TxPowerLevel);

/* BSC Timer Callback function prototype.                            */
void BSC_Timer_Callback(uint32_t BluetoothStackID, uint32_t TimerID, uint32_t CallbackParameter);

/* Generic Access Profile (GAPLE) Event Callback function prototypes.*/
static void QAPI_BLE_BTPSAPI GAP_LE_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GAP_LE_Event_Data_t *GAP_LE_Event_Data, uint32_t CallbackParameter);

/* Generic Attribute Profile (GATT) Event Callback function          */
/* prototypes.                                                       */
static void QAPI_BLE_BTPSAPI GATT_Connection_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GATT_Connection_Event_Data_t *GATT_Connection_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_Service_Discovery_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GATT_Service_Discovery_Event_Data_t *GATT_Service_Discovery_Event_Data, uint32_t CallbackParameter);

/* Generic Attribute Profile (GATT) Service/Profile Event Callback   */
/* function prototypes (Server).                                     */
static void QAPI_BLE_BTPSAPI AIOS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_AIOS_Event_Data_t *AIOS_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI BAS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_BAS_Event_Data_t *BAS_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI HIDS_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_HIDS_Event_Data_t *HIDS_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI SCPS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_SCPS_Event_Data_t *SCPS_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ServerEventCallback_SPPLE(uint32_t BluetoothStackID, qapi_BLE_GATT_Server_Event_Data_t *GATT_ServerEventData, uint32_t CallbackParameter);

/* Generic Attribute Profile (GATT) Service Event Callback function  */
/* prototypes (Client).                                              */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_AIOS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_BAS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_GAPS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_HIDS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_HRS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_SCPS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_SPPLE(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter);

/* Over the air demo service event callback.                         */
//static void OTA_EventCallback(uint32_t BluetoothStackID, BLE_OTA_Server_Event_Data_t *BLE_OTA_Server_Event_Data, void *CallbackParameter);

/*********************************************************************/
/* qcli Command Group Definitions                                    */
/*********************************************************************/

#ifdef V2

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t BT5_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}

const QCLI_Command_t bt5_cmd_list[] =
{
    // cmd_function                 start_thread   cmd_string                 usage_string description
    { BT5_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the BT5 commands." },
    { BLE5PHY,                  false,           "PHY",               "[<Tx_phy>,<Rx_phy>]", "Reads the current PHY for the specified connection and Sets the PHY for the specified connection."},
    { ExtendedAdvertisingParams,    false,      "EXTADV",               "<set_ext_adv_params>, [AdvertisingHandle],[EventProperties], [Adv_Tx_pow] \n <en_ext_adv>,[Enable],[num_of_sets],[adv_handle],[duration],[max_ext_adv_events]", "Sets Extended Advertising Parameters and Enables/Disabled Extended Advertising."},
    { ExtendedScanParams,            false,      "EXTSCAN",              " <set_ext_scan_params>, [scan_interval],[scan_window], [filter]\n <en_ext_scan>,[Enable],[duration],[period]", "Sets the Extended Scanning Parameters and Enables/Disables Extended Scanning."},
    { ExtendedConnect,              false,         "EXTCON",         "[BD_ADDR] [ADDR Type (0 = Public, 1 = Random, 2 = Public Identity, 3 = Random Identity)]",                                                    "Sends an Extended Connection request to a remote device." },
};

const QCLI_Command_Group_t bt5_cmd_group =
{
    "V5",
    (sizeof(bt5_cmd_list) / sizeof(bt5_cmd_list[0])),
    bt5_cmd_list
};

#endif

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t AIOS_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}

const QCLI_Command_t aios_cmd_list[] =
{
    // cmd_function               start_thread   cmd_string                   usage_string description
    {AIOS_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the AIOS commands." },
    {AIOSService,				false,			"SERVICE","<register|unregister>","Registers an AIOS instance with the GATT layer/Un-registers an AIOS instance"},
    {ConfigureRemoteAIOS,        false,         "CFGREMAIOS","<Characteristic_Type>,<Characteristic_ID>,<Configure_Notifications>","[Characteristic Type (0 = digital, 1 = analog)] [Characteristic ID (0-1)] [Configure Notification (0 = disable, 1 = enable)]""Configures discovered AIOS service on a remote device."                                  },
    {AIOSRead,					false,			"READ", "<ReadChar>,<Characteristic_Type>,<Characteristic_ID>\n<ReadPresent>,<Characteristic_Type>,<Characteristic_ID>\n< ReadNumber >,<Characteristic_ID>\n<NotifyAIOSChar>,<Characteristic_ID>,<Characteristic_ID>\n","Reads an AIOS Characteristic's Value on a remote device/Reads an AIOS Characteristic's Presentation Format Descriptor on a remote device/Reads an AIOS Digital Characteristic's Number of Digitals Descriptor on a remote device/Sets an AIOS Characteristic to an AIOS Client" },
    {AIOSWrite,					false,			"WRITE", "<WriteDigOutput>,<Characteristic_ID>,<Digital_oct_1>,<Digital_oct_2>\n<WriteAnOutput>,<Characteristic_ID>,<Analog_Value>\n<SetDigOutput>,<Characteristic_ID>,<Digital_oct_1>,<Digital_oct_2>\n<SetAnOutput>,<Characteristic_ID>,<Analog_Value>\n","Writes an AIOS Digital Output Characteristic/Writes an AIOS Analog Output Characteristic/Sets an AIOS Digital Input Characteristic on the AIOS Server/Sets an AIOS Analog Input Characteristic on the AIOS Server"},
};

const QCLI_Command_Group_t aios_cmd_group =
{
    "AIOS",
    (sizeof(aios_cmd_list) / sizeof(aios_cmd_list[0])),
    aios_cmd_list
};

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t bas_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();;
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();;

    return QCLI_STATUS_ERROR_E;
}

const QCLI_Command_t bas_cmd_list[] =
{
    // cmd_function       start_thread      cmd_string                 usage_string description

    {bas_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the bas commands." },
    { RegUnregBAS,               false, "BAS",                       "<register> | <unregister>",                                                                                                                                   "Registers/unregisters a local BAS instance"                             },


#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

    { ConfigureRemoteBAS,                false, "CFGREMBAS",                "[Battery Level Notification (0 = disable, 1 = enable)] [InstanceID]",                                                                "Configures discovered BAS service on remote device."                        },
    { GetSetBatteryLevel,                   false, "BATTLVL",                   "<get_bat(0)/set_bat(1)> <bat_level (0 - 100)> [InstanceID]",                                                                                                                       "Get/Set current battery level."                                                 },
    { NotifyBatteryLevel,                false, "NOTIBATTLVL",                "[Value (0 - 100)] [InstanceID]",                                                                                                     "Notify current battery level."                                              },
    { GetSetBatteryLevelPresentationFormat, false, "BATTLVLPSTFMT", "<get_bat(0)/set_bat(1)> <name_space> <description> [InstanceID]",                                                                                                                       "Get/Set current battery level presentation format."                             },

#else

    { ConfigureRemoteBAS,                false, "CFGREMBAS",                "[Battery Level Notification (0 = disable, 1 = enable)]",                                                                             "Configures discovered BAS service on remote device."                        },
    { GetSetBatteryLevel,                   false, "BATTLVL",                   "<get_bat(0)/set_bat(1)> <bat_level (0 - 100)>",                                                                                                                       "Get/Set current battery level."                                                 },
    { NotifyBatteryLevel,                false, "NOTIBATTLVL",                "[Value (0 - 100)]",                                                                                                                  "Notify current battery level."                                              },
    { GetSetBatteryLevelPresentationFormat, false, "BATTLVLPSTFMT", "<get_bat(0)/set_bat(1)> <name_space> <description>",                                                                                                                       "Get/Set current battery level presentation format."                             },

#endif
};

const QCLI_Command_Group_t bas_cmd_group =
{
    "BAS",
    (sizeof(bas_cmd_list) / sizeof(bas_cmd_list[0])),
    bas_cmd_list
};

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t gaps_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();;
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}

const QCLI_Command_t gaps_cmd_list[] =
{
    // cmd_function       start_thread      cmd_string                 usage_string description
    {gaps_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the gaps commands." },
    { ReadSetLocalName,                  false, "LOCNAME",                 "[<device_name>]",                                                                                                                                   "Reads/Sets local friendly name."                                                   },
    { ReadRemoteNameApp,                 false, "RDREMPARAMS",                "",                                                                                                                                   "Read friendly name and appearance of remote device."                                         },
    { ReadSetLocalAppearance,            false, "LOCAPP",           "[<ID>]",                                                                                                                                   "Reads/Sets local device apperance value."                                          },
};

const QCLI_Command_Group_t gaps_cmd_group =
{
    "GAPS",
    (sizeof(gaps_cmd_list) / sizeof(gaps_cmd_list[0])),
    gaps_cmd_list
};

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t HIDS_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}

const QCLI_Command_t hogp_cmd_list[] =
{
    // cmd_function       start_thread      cmd_string                 usage_string description
    {HIDS_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the HOGP commands." },
    {HIDSService,					false,	"SERVICE", "<register|unregister> \n<configure>,<InstanceID>,<ReportNotify>\n<ReadHIDSconfig>,<InstanceID>", "\nRegister HID over GATT Service/UnRegister HID over GATT Service/Configure remote HID Service"},
    {HIDSReport,					false, "REPORT", "<Get>,< InstanceID>,<Report_Type>,<Report_ID>\n<Set>\n<send>,< InstanceID>,<Protocol_Mode>\n",

        "[InstanceID] [ReportType] [ReportID (0 = None]\n"
            "ReportType = \n"
            " Input                 = 1\n"
            " Output                = 2\n"
            " Feature               = 3\n"
            " Boot Keyboard Input   = 4\n"
            " Boot Keyboard Output  = 5\n"
            " Boot Mouse Input      = 6\n"
            "Get specified report data\n"
            "\nSet report"
            "\nSend HID Report to remote device\n"                                   },
    {HIDSMode,						false,"MODE",	"<Suspend>,< InstanceID>,<suspend_mode>\n<Protocol>,< InstanceID>,<protocol_mode>\n", "Set suspend mode on remote device / Set report mode on remote device"  },
};

const QCLI_Command_Group_t hogp_cmd_group =
{
    "HIDS",
    (sizeof(hogp_cmd_list) / sizeof(hogp_cmd_list[0])),
    hogp_cmd_list
};

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t HRS_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}

const QCLI_Command_t hrs_cmd_list[] =
{
    // cmd_function       start_thread      cmd_string                 usage_string description
    {HRS_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the HRS commands." },
    { ConfigureRemoteHRS,       false,      "CONFIG",      " [HRS Measurement Notification (0 = disable, 1 = enable)]",                                                                                 "Configure remote HRS Service."                                                 },
};

const QCLI_Command_Group_t hrs_cmd_group =
{
    "HRS",
    (sizeof(hrs_cmd_list) / sizeof(hrs_cmd_list[0])),
    hrs_cmd_list
};

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t DIS_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}

const QCLI_Command_t dis_cmd_list[] =
{
    // cmd_function       start_thread      cmd_string                 usage_string description
    { DIS_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the DIS commands." },
    { ConfigureDisService,      false,      "SERVICE",   " <mode>", "(0 = disable, 1 = enable) registers/un-registers the DIS service"},

};

const QCLI_Command_Group_t dis_cmd_group =
{
    "DIS",
    (sizeof(dis_cmd_list) / sizeof(dis_cmd_list[0])),
    dis_cmd_list
};

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t TPS_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}

const QCLI_Command_t tps_cmd_list[] =
{
    // cmd_function       start_thread      cmd_string                 usage_string description
    {TPS_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the TPS commands." },
    { ConfigureTpsService,      false,      "SERVICE",   " <mode>", "(0 = disable, 1 = enable) registers/un-registers the TPS service"},

};

const QCLI_Command_Group_t tps_cmd_group =
{
    "TPS",
    (sizeof(tps_cmd_list) / sizeof(tps_cmd_list[0])),
    tps_cmd_list
};

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t SCPS_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}
const QCLI_Command_t scps_cmd_list[] =
{
    // cmd_function                start_thread  cmd_string                   usage_string description
    {SCPS_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the SCPS commands." },
    {SCPSService,						 false, "SERVICE",	"<register|unregister> / <configure>", "Registers a local Scan Parameter service with GATT laye|Un-registers local Scan Parameter service / Configure's remote devices Scan Parameter service"},
    { SetScanIntervalWindow,              false, "SETSCANWIN", "<LE_Scan_Interval uint16> <LE_Scan_Window uint16>",                                                                                  "Configures LE Scan Interval and Window stored in SCP Service."                },
};

const QCLI_Command_Group_t scps_cmd_group =
{
    "SCPS",
    (sizeof(scps_cmd_list) / sizeof(scps_cmd_list[0])),
    scps_cmd_list
};

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t SPPLE_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}
const QCLI_Command_t spple_cmd_list[] =
{
    // cmd_function       start_thread      cmd_string                 usage_string description
    {SPPLE_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the SPPLE commands." },
    {SPPLEService,					 false, "SERVICE", "register/unregister/configure","Registers a local SPPLE service with GATT layer/Un-registers local SPPLE service/Configures discovered SPPLE service on remote device"},
    {SPPLEData,						 false, "DATA", "[Number of bytes to send]", "Sends data using SPPLE to remote device/Reads data received via SPPLE from remote device"},
    {SPPLEext,						 false, "XT", "<Loopback>,<mode>\n<DispRawData>,<mode>\n<AutoReadMode>,<mode>\n", "Enables/Disables loopback mode/ Enables/Disables display data mode/ Enables/Disables automatic data read mode"},
};

const QCLI_Command_Group_t spple_cmd_group =
{
    "SPPLE",
    (sizeof(spple_cmd_list) / sizeof(spple_cmd_list[0])),
    spple_cmd_list
};

extern QCLI_Context_t QCLI_Context;
QCLI_Command_Status_t qc_at_ble_Help(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    if(TAKE_LOCK(QCLI_Context.CLI_Mutex))
    {
        Display_Help(QCLI_Context.Executing_Group, Parameter_Count, Parameter_List);
        RELEASE_LOCK(QCLI_Context.CLI_Mutex);
        LOG_AT_OK();
        return QCLI_STATUS_SUCCESS_E;
    }

    LOG_AT_ERROR();

    return QCLI_STATUS_ERROR_E;
}

const QCLI_Command_t ble_cmd_list[] =
{
    // cmd_function       start_thread      cmd_string                 usage_string description
    {qc_at_ble_Help,                  false, "HELP",                          "",                                                                                                                                   "Display the ble commands."
    },
    { BluetoothService,				false, "SERVICE",		"<start/stop>", "Initializes the Bluetopia stack (must be called before any other commands) and Queries version of Bluetopia and Bluetooth Controller/Shuts down the Bluetopia stack."},
    { SetBLERadio,                    false, "SETRADIO",                   "[Radio (1/2)]",                                                                                                                      "Sets the radio that BLE uses."                                                },
    { SetConnectionMode,				false, "SETDISCCONN",		"<discover/connect> <mode> [mode(0 = Non Discoverable, 1 = Limited Discoverable, 2 = General Discoverable)]/[(0 = NonConectable, 1 = Connectable, 2 = Direct Connectable)]", "Set device discoverability mode (for use during advertising)/Set device connectability mode (for use during advertising)."
    },
    { SetPairabilityMode,             false, "SETPAIR",            "[Mode (0 = Non Pairable, 1 = Pairable, 2 = Pairable w/ Secure Connections]",                                                         "Set device pairability mode."                                                 },
    { ChangePairingParameters,        false, "CHNGPAIR",       "[I/O Capability (0=DisplayOnly, 1=Display Yes/No, 2=Keyboard Only, 3=No Input/Output, 4=Keyboard/Display)] [MITM Req (0=No,1=Yes)] [Secure Connections (0 = None, 1 = Yes)", "Changes IO Capabilities used during pairing."      },
    { LEPassKeyResponse,              false, "PASSKEYRESP",             "[Numeric Passkey(0 - 999999)]",                                                                                                      "Responds to passkey request."                                                 },
    { LEQueryEncryption,              false, "QUERYENCRYPT",             "",                                                                                                                                   "Queries encryption state of LE connection."                                   },
    { LESetPasskey,                   false, "PASSKEY",                  "[(0 = Clear, 1 = Set) Passkey] [6 Digit Passkey (optional)]",                                                                        "Sets fixed passkey to use when IO caps are Display Only."                     },
    { GetLocalAddress,                false, "GETLOCADDR",               "",                                                                                                                                   "Querys Bluetooth Address of local Bluetooth controller."                      },
#ifndef V1
    { AdvertiseLE,                    false, "ADV",                   "[(0 = Disable, 1 = Enable)] [Direct BD_ADDR (Optional)]",                                                                            "Starts/Stops Advertising Process."                                            },
#else
    { AdvertiseLE,                    false, "ADV",                   "[(0 = Disable, 1 = Enable Channels 37 and 38, 2 = Enable Channel 37, 3 = Enable Channel 38, 4 = Enable Channel 39)] [Direct BD_ADDR (Optional)]", "Starts/Stops Advertising Process."                                            },
#endif
    { ScanLE,                         false, "SCAN",                        "[(0 = Disable, 1 = Enable)] [Filter Policy (0=No Filter, 1=White List, 2=No White List Directed RPA, 3=White List Directed RPA) (Optional)] [Duration (if enabling scan) (seconds, optional)]", "Starts/Stops Scan Process."     },
    {GapLeconnect,					false, "CONN",	"<connect|disconnect>,[<white_list>,<BD_ADDR>,<ADDR_type>] [Use White List (0=Disable, 1=Enable)] [BD_ADDR] [ADDR Type (0 = Public, 1 = Random, 2 = Public Identity, 3 = Random Identity)", "Sends a GAP LE connection/disconnections request to a remote device"},
    {LEServiceDeactivate,			false, "STPCONN", "", "Cancels an outstanding connection request that has been sent to a remote device"},
    { DiscoverServices,               false, "DSERVICE",              "",                                                                                                                                   "Starts process to discover all GATT Service on active LE connection."         },
    { PairLE,                         false, "PAIR",                        "<value> = 0|1, 0 - unpair, 1 - pair",                                                                                                                                   "Starts pairing/unpairing process with active BLE connection."                            },
    {DisplayRemoteDevice,			false, "REMDEV",	"[Connection ID]","Selects a remote device based on the GATT Connection ID/Displays information for paired devices."},
    {DeviceList,					 false,	"DEVWLIST", "<BD_ADDR>,[<Addr_type>] [BD_ADDR] [Address Type (0=Public, 1=Random, 2=Public Identity, 3=Random Identity,255=Anonymous Address)]/[BD_ADDR (all zeros to remove anonymous address type)]", "Adds a device to the white list in the controller/Removes a device from the white list in the controller."},
    {AddRemoveDeviceToResolvingList,	false, "DEVRESOLVLIST","<value>,<BD_ADDR>","value = 1 (Adds a device to the resolving list in the controller)/value = 0 (Removes a device from the resolving list in the controller)."},
    { SetAuthenticatedPayloadTimeout, false, "SETAUTHPAYTOUT",         "[BD_ADDR] [Timeout (ms)]",                                                                                                           "Sets the authentication payload timeout for the specified remote device."     },
    {SetGetGATTMTU,					false, "MTU",	"[MTU]", "Changes the maximum supported GATT MTU, Queries maximum supported GATT MTU."},
    {SetGetScanParameters,			false,	"SCANPARAMS", "[Scan Interval (ms)] [Scan Window (ms)]", "Set BLE scan parameters, Query the current BLE scan parameters."},
    {SetGetAdvertisingParameters,		false, "ADVPARAMS",	"[Minimum Advertising Interval (ms)] [Maximum Advertising Interval (ms)]","Set BLE advertising parameters, Query the current BLE advertising parameters."},
    {SetGetConnectionParameters,	false,	"CONNPARAMS", "[<min_adv_interval>,< max_adv_interval >,<slave_latency>] [Minimum Connection Interval (ms)] [Maximum Connection Interval (ms)] [Slave Latency (number of Connection Events)]/", "Set BLE connection parameters/Query the current BLE connection parameters."},
    { SetTestDataPeriod,              false, "SETTESTDATAPERIOD",             "[BD_ADDR] [Period to wakeup and send data (milliseconds)] [Size of data to send (Bytes, >= 1)]",                                     "Sets a the periodic interval to wakeup and send data on connected device."    },
    { SetDataLength,                  false, "SETDATALEN",                 "[Suggested Packet Size]",                                                                                                            "Set suggested BLE packet size for connection."                                },
    {PersistentDataService,			false,	"PERSISTDATA",	"<store|load|delete>,[<force>]","Store application data to persistent storage/[Force (1=true) (optional)]Load application from to persistent storage/Delete application data from persistent storage"},
    { ConfigureAdvReportDisplay,      false, "CFGADVREPDISP",     "[0 = Limited Advertising Display, 1 = Verbose Advertising Display]",                                                                  "Configure how much advertising data to display."                              },
    { QueryLocalOOBData,              false, "GETLOCOOBDATA",             "",                                                                                                                                    "Query local out of band data to send to remote device."                       },
    { SetRemoteOOOBData,              false, "SETREMOOBDATA",             "[Confirmation] [Randomizer]",                                                                                                         "Configures OOB data received from remote device."                             },

#ifndef V1
    { LowPowerTransmitOverride,       false, "LOWPOWTRANS",      "[Enable (1=true)] [Tx Power Level (-128 to 127, 127 means don't care)] [FEM Mode (0=shutdown,1=rx)]",                                "Override Tx Power by choosing Tx step and FEM control settings. Tx Power Level and FEM Mode parameters are only used when the mode is enabled." },
#endif
    {StartTXRXTest,					false,	"STARTTEST"	,"<transmit|receive>,<BD_ADDR>,[<packet_size>]",	"Starts HCI Transmit Packet Test/Starts Data Receive Packet Test."},
    {StopTXRXTest,                   false, "STPTXRXTEST",                  "",                                                                                                                                                                           "Stops Data Transmit/Receive Packet Test."                                     },
};

const QCLI_Command_Group_t ble_cmd_group =
{
    "ATBLE",
    (sizeof(ble_cmd_list) / sizeof(ble_cmd_list[0])),
    ble_cmd_list
};

static QCLI_Command_Status_t  BluetoothService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    char                  *HostVersion = NULL;
    uint8_t                Status;
    uint8_t                Version;
    uint16_t               Revision;
    uint8_t                LMPVersion;
    uint16_t               ManufacturerName;
    uint16_t               LMPSubversion;
    uint32_t               ProductID;
    uint32_t               BuildVersion;
    QCLI_Command_Status_t ret_val;

    if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"start") == 0)) {

        /* First, check that the stack is not currently initialized.         */
        if(!BluetoothStackID)
        {
            /* Attempt to open the stack.                                     */
            Result = OpenStack(&HCI_DriverInformation);
            if(!Result)
            {
                /* Set the default pairability.                                */
                Result = SetPairable();
                if(!Result)
                {
                    /* Set the default discoverability.                         */
                    Result = SetDisc();
                    if(!Result)
                    {
                        /* Set the default connectability.                       */
                        Result = SetConnect();
                    }

                    /* Print the Bluetopia Version first..                            */
                    qc_drv_ble_BSC_Query_Host_Version(qc_api_get_qc_drv_context(), HostVersion);

                    LOG_INFO("        Bluetopia        : %s.\n", HostVersion?HostVersion:"Unknown");

                    /* Print the Controller Version.                                  */
                    if(((Result = qc_drv_ble_HCI_Read_Local_Version_Information(qc_api_get_qc_drv_context(), BluetoothStackID, &Status, &Version, &Revision, &LMPVersion, &ManufacturerName, &LMPSubversion)) == 0) && (!Status))
                    {
                        LOG_INFO("        HCI Version      : 0x%02X.\n", Version);
                        LOG_INFO("        HCI Revision     : 0x%04X.\n", Revision);
                        LOG_INFO("        LMP Version      : 0x%02X.\n", LMPVersion);
                        LOG_INFO("        LMP Sub Version  : 0x%04X.\n", LMPSubversion);
                        LOG_INFO("        Manufacturer Name: 0x%04X.\n", ManufacturerName);
                    }
                    else
                        LOG_ERR("Error retrieving Version Information: %d.\n", (!Result?Status:Result));

                    /* Now attempt to query the patch version information.            */
                    Result = HCI_VS_GetPatchVersion(BluetoothStackID, &ProductID, &BuildVersion);
                    if(!Result)
                    {
                        LOG_INFO("\n        Product ID       : 0x%08X.\n", ProductID);
                        LOG_INFO("        Build Version    : 0x%08X.\n", BuildVersion);
                    }
                    else
                        LOG_ERR("\n        Error retrieving Patch Version Information: %d.\n", Result);

                    /* Flag success to the caller.                                    */
                }

                /* If the failure occurred after the stack initialized then    */
                /* shut it down.                                               */
                if(Result)
                    CloseStack();
            }

            /* Set the QCLI error type appropriately.                         */
            if(!Result)
                ret_val = QCLI_STATUS_SUCCESS_E;
            else
                ret_val = QCLI_STATUS_ERROR_E;
        }
        else
        {
            /* No valid Bluetooth Stack ID exists.                            */
            LOG_INFO("Bluetooth stack is already initialized.\r\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else if((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"stop") == 0)) {
        /* First, check that the stack is currently initialized.             */
        if(BluetoothStackID)
        {
            /* Close the stack and set the QCLI error code.                   */
            if(!CloseStack())
                ret_val = QCLI_STATUS_SUCCESS_E;
            else
                ret_val = QCLI_STATUS_ERROR_E;
        }
        else
        {
            /* No valid Bluetooth Stack ID exists.                            */
            LOG_ERR("Bluetooth stack is not initialized.\r\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for setting the radio that  */
/* is used for BLE.  This function returns QCLI_STATUS_SUCCESS_E on  */
/* success or an error enumeration if an error occurs.               */
static QCLI_Command_Status_t SetBLERadio(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    QCLI_Command_Status_t ret_val;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Make sure that all of the parameters required for this function*/
        /* appear to be at least semi-valid.                              */
        if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && ((Parameter_List[0].Integer_Value >= 1) && (Parameter_List[0].Integer_Value <= 2)))
        {
            /* Now attempt to query the version of the Bluetooth           */
            /* Controller.                                                 */
            Result = HCI_VS_SetRadio(BluetoothStackID, Parameter_List[0].Integer_Value);
            if(!Result)
                LOG_INFO("        Success setting Radio %d.\n", Parameter_List[0].Integer_Value);
            else
                LOG_ERR("        Error %d setting Radio %d.\n", Result, Parameter_List[0].Integer_Value);

            /* Flag success to the caller.                                 */
            ret_val = QCLI_STATUS_SUCCESS_E;
        }
        else
        {
            /* One or more of the necessary parameters is/are invalid.     */
            ret_val = QCLI_STATUS_USAGE_E;
        }
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* Demo helper functions.                                            */

/* The following function will create a device information entry and */
/* add it to the specified List.  This function, if successful, will */
/* return a pointer to the Entry that has been created and added to  */
/* the specified list.  This function will return NULL if NO Entry   */
/* was added.  This can occur if the element passed in was deemed    */
/* invalid or the actual List Head was invalid.                      */
/* ** NOTE ** This function does not insert duplicate entries into   */
/*            the list.  An element is considered a duplicate if the */
/*            RemoteAddress already exists for an entry.  When this  */
/*            occurs, this function returns NULL.                    */
static DeviceInfo_t *CreateNewDeviceInfoEntry(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress)
{
    DeviceInfo_t *ret_val = NULL;
    boolean_t     Result;

    /* Verify that the passed in parameters seem semi-valid.             */
    if((ListHead) && (!QAPI_BLE_COMPARE_NULL_BD_ADDR(RemoteAddress)))
    {
        /* Allocate the memory for the entry.                             */
        if((ret_val = malloc(sizeof(DeviceInfo_t))) != NULL)
        {
            /* Initialize the entry.                                       */
            memset(ret_val, 0, sizeof(DeviceInfo_t));

            /* Store the remote device address.                            */
            ret_val->RemoteAddress = RemoteAddress;

            Result = qc_drv_ble_BSC_AddGenericListEntry_Actual(qc_api_get_qc_drv_context(), QAPI_BLE_EK_BD_ADDR_T_E, QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, RemoteAddress), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, NextDeviceInfoInfoPtr), (void **)(ListHead), (void *)(ret_val));
            if(!Result)
            {
                /* Failed to add to list so we should free the memory that  */
                /* we allocated for the entry.                              */
                free(ret_val);
            }
        }
    }

    if (ret_val != NULL )
        LOG_AT_OK();
    else if(ret_val == NULL)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function searches the specified List for the        */
/* specified Connection BD_ADDR.  This function returns NULL if      */
/* either the List Head is invalid, the BD_ADDR is invalid, or the   */
/* Connection BD_ADDR was NOT found.                                 */
static DeviceInfo_t *SearchDeviceInfoEntryByBD_ADDR(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress)
{
    BoardStr_t    BoardStr;
    DeviceInfo_t *ret_val = NULL;
    DeviceInfo_t *DeviceInfo;

    /* Verify the list head.                                             */
    if(ListHead)
    {
        /* Loop through the device information.                           */
        DeviceInfo = *ListHead;
        while(DeviceInfo)
        {
            /* If the BD_ADDR is a match then we found the remote device   */
            /* information.                                                */
            if(QAPI_BLE_COMPARE_BD_ADDR(DeviceInfo->RemoteAddress, RemoteAddress))
            {
                /* Set the remote device information pointer to the return  */
                /* value and break since we are done.                       */
                ret_val = DeviceInfo;
                break;
            }
            else
            {
                /* Determine if the remote device is using a resolvable     */
                /* private address (RPA).                                   */
                if(QAPI_BLE_GAP_LE_TEST_RESOLVABLE_ADDRESS_BITS(RemoteAddress))
                {
                    /* Check if we stored the Identity Resolving Key (IRK)   */
                    /* for the remote device.                                */
                    if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_IRK_VALID)
                    {
                        /* Use the IRK to resolve the address.                */
                        if(qapi_BLE_GAP_LE_Resolve_Address(BluetoothStackID, &(DeviceInfo->IRK), RemoteAddress))
                        {
                            /* If we resolved the address let's update the     */
                            /* Bluetooth address stored for the remote device. */
                            /* * NOTE * We are doing this so we don't have to  */
                            /*          re-resolve the remote device address   */
                            /*          for future connections.  However, if   */
                            /*          the resolvable address changes we will */
                            /*          need to resolve it again.              */
                            DeviceInfo->RemoteAddress     = RemoteAddress;
                            DeviceInfo->RemoteAddressType = QAPI_BLE_LAT_RANDOM_E;

                            /* Inform the user we resolved the address.        */
                            LOG_DEBUG("\nResolved Address (");
                            BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
                            LOG_DEBUG("%s", BoardStr);
                            LOG_DEBUG(")\n");
                            LOG_DEBUG("   Identity Address:       ");
                            BD_ADDRToStr(DeviceInfo->IdentityAddressBD_ADDR, BoardStr);
                            LOG_DEBUG("%s\n", BoardStr);
                            LOG_DEBUG("   Identity Address Type:  %s\n", ((DeviceInfo->IdentityAddressType == QAPI_BLE_LAT_PUBLIC_IDENTITY_E) ? "Public Identity" : "Random Identity"));

                            /* Set the remote device information pointer to the*/
                            /* return value and break since we are done.       */
                            ret_val = DeviceInfo;
                            break;
                        }
                    }
                }
            }

            DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
        }
    }

    if (ret_val != NULL )
        LOG_AT_OK();
    else if(ret_val == NULL)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function searches the specified List for the        */
/* specified Address and Type.  This function returns NULL if        */
/* either the List Head is invalid, the BD_ADDR is invalid, or the   */
/* Connection BD_ADDR was NOT found.                                 */
static DeviceInfo_t *SearchDeviceInfoEntryTypeAddress(DeviceInfo_t **ListHead, qapi_BLE_GAP_LE_Address_Type_t AddressType, qapi_BLE_BD_ADDR_t RemoteAddress)
{
    BoardStr_t                      BoardStr;
    DeviceInfo_t                   *ret_val = NULL;
    DeviceInfo_t                   *DeviceInfo;
    qapi_BLE_GAP_LE_Address_Type_t  TempType;

    /* Verify the list head.                                             */
    if(ListHead)
    {
        /* Loop through the device information.                           */
        DeviceInfo = *ListHead;
        while(DeviceInfo)
        {
            /* If the BD_ADDR is a match then we found the remote device   */
            /* information.                                                */
            if((DeviceInfo->RemoteAddressType == AddressType) && (QAPI_BLE_COMPARE_BD_ADDR(DeviceInfo->RemoteAddress, RemoteAddress)))
            {
                /* Set the remote device information pointer to the return  */
                /* value and break since we are done.                       */
                ret_val = DeviceInfo;
                break;
            }
            else
            {
                /* Check to see if this is an identity address.             */
                if((AddressType == QAPI_BLE_LAT_PUBLIC_IDENTITY_E) || (AddressType == QAPI_BLE_LAT_RANDOM_IDENTITY_E))
                {
                    /* Convert the address type.                             */
                    if(AddressType == QAPI_BLE_LAT_PUBLIC_IDENTITY_E)
                        TempType = QAPI_BLE_LAT_PUBLIC_E;
                    else
                        TempType = QAPI_BLE_LAT_RANDOM_E;

                    /* Check if the identity address field is valid.         */
                    if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_IRK_VALID)
                    {
                        /* Compare the identity address and type.             */
                        if((DeviceInfo->IdentityAddressType == TempType) && (QAPI_BLE_COMPARE_BD_ADDR(DeviceInfo->IdentityAddressBD_ADDR, RemoteAddress)))
                        {
                            /* Update the address field for this entry.        */
                            DeviceInfo->RemoteAddressType = AddressType;
                            DeviceInfo->RemoteAddress     = DeviceInfo->IdentityAddressBD_ADDR;

                            /* Set the remote device information pointer to the*/
                            /* return value and break since we are done.       */
                            ret_val = DeviceInfo;
                            break;
                        }
                    }
                }
                else
                {
                    /* Determine if the remote device is using a resolvable */
                    /* private address (RPA).                               */
                    if((AddressType == QAPI_BLE_LAT_RANDOM_E) && (QAPI_BLE_GAP_LE_TEST_RESOLVABLE_ADDRESS_BITS(RemoteAddress)))
                    {
                        /* Check if we stored the Identity Resolving Key     */
                        /* (IRK) for the remote device.                      */
                        if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_IRK_VALID)
                        {
                            /* Use the IRK to resolve the address.            */
                            if(qapi_BLE_GAP_LE_Resolve_Address(BluetoothStackID, &(DeviceInfo->IRK), RemoteAddress))
                            {
                                /* If we resolved the address let's update the */
                                /* Bluetooth address stored for the remote     */
                                /* device.                                     */
                                /* * NOTE * We are doing this so we don't have */
                                /*          to re-resolve the remote device    */
                                /*          address for future connections.    */
                                /*          However, if the resolvable address */
                                /*          changes we will need to resolve it */
                                /*          again.                             */
                                DeviceInfo->RemoteAddress     = RemoteAddress;
                                DeviceInfo->RemoteAddressType = QAPI_BLE_LAT_RANDOM_E;

                                /* Inform the user we resolved the address.    */
                                LOG_DEBUG("\nResolved Address (");
                                BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
                                LOG_DEBUG("%s", BoardStr);
                                LOG_DEBUG(")\n");
                                LOG_DEBUG("   Identity Address:       ");
                                BD_ADDRToStr(DeviceInfo->IdentityAddressBD_ADDR, BoardStr);
                                LOG_DEBUG("%s\n", BoardStr);
                                LOG_DEBUG("   Identity Address Type:  %s\n", ((DeviceInfo->IdentityAddressType == QAPI_BLE_LAT_PUBLIC_IDENTITY_E) ? "Public Identity" : "Random Identity"));

                                /* Set the remote device information pointer to*/
                                /* the return value and break since we are     */
                                /* done.                                       */
                                ret_val = DeviceInfo;
                                break;
                            }
                        }
                    }
                }
            }

            DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
        }
    }

    if (ret_val != NULL )
        LOG_AT_OK();
    else if(ret_val == NULL)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function searches the specified List for the        */
/* specified GATT Connection ID.  This function returns NULL if      */
/* either the List Head is invalid, the Connection ID is invalid, or */
/* the Connection ID was NOT found.                                  */
static DeviceInfo_t *SearchDeviceInfoEntryByConnectionID(DeviceInfo_t **ListHead, unsigned int ConnectionID)
{
    return(qapi_BLE_BSC_SearchGenericListEntry(QAPI_BLE_EK_UNSIGNED_INTEGER_E, (void *)(&ConnectionID), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, ConnectionID), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, NextDeviceInfoInfoPtr), (void **)(ListHead)));
}

/* The following function searches the specified Key Info List for   */
/* the specified BD_ADDR and removes it from the List.  This function*/
/* returns NULL if either the List Head is invalid, the BD_ADDR is   */
/* invalid, or the specified Entry was NOT present in the list.  The */
/* entry returned will have the Next Entry field set to NULL, and    */
/* the caller is responsible for deleting the memory associated with */
/* this entry by calling the FreeKeyEntryMemory() function.          */
static DeviceInfo_t *DeleteDeviceInfoEntry(DeviceInfo_t **ListHead, qapi_BLE_BD_ADDR_t RemoteAddress)
{
    return(qapi_BLE_BSC_DeleteGenericListEntry(QAPI_BLE_EK_BD_ADDR_T_E, (void *)(&RemoteAddress), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, RemoteAddress), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, NextDeviceInfoInfoPtr), (void **)(ListHead)));
}

/* This function frees the specified Key Info Information member     */
/* memory.                                                           */
static void FreeDeviceInfoEntryMemory(DeviceInfo_t *EntryToFree)
{
    unsigned int InstanceID;

    /* Loop through all HIDS instance.                                   */
    for(InstanceID = 0; InstanceID < MAX_SUPPORTED_HID_INSTANCES; InstanceID++)
    {
        /* Free the report map.                                           */
        if(EntryToFree->HIDSClientInfo[InstanceID].ReportMap)
            free(EntryToFree->HIDSClientInfo[InstanceID].ReportMap);
    }

    qapi_BLE_BSC_FreeGenericListEntryMemory((void *)(EntryToFree));
}

/* The following function deletes (and frees all memory) every       */
/* element of the specified Key Info List. Upon return of this       */
/* function, the Head Pointer is set to NULL.                        */
static void FreeDeviceInfoList(DeviceInfo_t **ListHead)
{
    DeviceInfo_t *DeviceInfo;
    unsigned int  InstanceID;

    DeviceInfo = *ListHead;

    while(DeviceInfo)
    {
        /* Loop through all HIDS instance.                                */
        for(InstanceID = 0; InstanceID < MAX_SUPPORTED_HID_INSTANCES; InstanceID++)
        {
            /* Free the report map.                                        */
            if(DeviceInfo->HIDSClientInfo[InstanceID].ReportMap)
                free(DeviceInfo->HIDSClientInfo[InstanceID].ReportMap);
        }

        DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
    }

    qapi_BLE_BSC_FreeGenericListEntryList((void **)(ListHead), QAPI_BLE_BTPS_STRUCTURE_OFFSET(DeviceInfo_t, NextDeviceInfoInfoPtr));
}

/* The following function is responsible for converting data of type */
/* BD_ADDR to a string.  The first parameter of this function is the */
/* BD_ADDR to be converted to a string.  The second parameter of this*/
/* function is a pointer to the string in which the converted BD_ADDR*/
/* is to be stored.                                                  */
static void BD_ADDRToStr(qapi_BLE_BD_ADDR_t Board_Address, BoardStr_t BoardStr)
{
    snprintf((char *)BoardStr, (sizeof(BoardStr_t)/sizeof(char)), "0x%02X%02X%02X%02X%02X%02X", Board_Address.BD_ADDR5, Board_Address.BD_ADDR4, Board_Address.BD_ADDR3, Board_Address.BD_ADDR2, Board_Address.BD_ADDR1, Board_Address.BD_ADDR0);
}

/* The following function is responsible for converting number       */
/* strings to there unsigned integer equivalent.  This function can  */
/* handle leading and tailing white space, however it does not handle*/
/* signed or comma delimited values.  This function takes as its     */
/* input the string which is to be converted.  The function returns  */
/* zero if an error occurs otherwise it returns the value parsed from*/
/* the string passed as the input parameter.                         */
static unsigned int StringToUnsignedInteger(char *StringInteger)
{
    int          IsHex;
    unsigned int Index;
    unsigned int ret_val = 0;

    /* Before proceeding make sure that the parameter that was passed as */
    /* an input appears to be at least semi-valid.                       */
    if((StringInteger) && (strlen(StringInteger)))
    {
        /* Initialize the variable.                                       */
        Index = 0;

        /* Next check to see if this is a hexadecimal number.             */
        if(strlen(StringInteger) > 2)
        {
            if((StringInteger[0] == '0') && ((StringInteger[1] == 'x') || (StringInteger[1] == 'X')))
            {
                IsHex = 1;

                /* Increment the String passed the Hexadecimal prefix.      */
                StringInteger += 2;
            }
            else
                IsHex = 0;
        }
        else
            IsHex = 0;

        /* Process the value differently depending on whether or not a    */
        /* Hexadecimal Number has been specified.                         */
        if(!IsHex)
        {
            /* Decimal Number has been specified.                          */
            while(1)
            {
                /* First check to make sure that this is a valid decimal    */
                /* digit.                                                   */
                if((StringInteger[Index] >= '0') && (StringInteger[Index] <= '9'))
                {
                    /* This is a valid digit, add it to the value being      */
                    /* built.                                                */
                    ret_val += (StringInteger[Index] & 0xF);

                    /* Determine if the next digit is valid.                 */
                    if(((Index + 1) < strlen(StringInteger)) && (StringInteger[Index+1] >= '0') && (StringInteger[Index+1] <= '9'))
                    {
                        /* The next digit is valid so multiply the current    */
                        /* return value by 10.                                */
                        ret_val *= 10;
                    }
                    else
                    {
                        /* The next value is invalid so break out of the loop.*/
                        break;
                    }
                }

                Index++;
            }
        }
        else
        {
            /* Hexadecimal Number has been specified.                      */
            while(1)
            {
                /* First check to make sure that this is a valid Hexadecimal*/
                /* digit.                                                   */
                if(((StringInteger[Index] >= '0') && (StringInteger[Index] <= '9')) || ((StringInteger[Index] >= 'a') && (StringInteger[Index] <= 'f')) || ((StringInteger[Index] >= 'A') && (StringInteger[Index] <= 'F')))
                {
                    /* This is a valid digit, add it to the value being      */
                    /* built.                                                */
                    if((StringInteger[Index] >= '0') && (StringInteger[Index] <= '9'))
                        ret_val += (StringInteger[Index] & 0xF);
                    else
                    {
                        if((StringInteger[Index] >= 'a') && (StringInteger[Index] <= 'f'))
                            ret_val += (StringInteger[Index] - 'a' + 10);
                        else
                            ret_val += (StringInteger[Index] - 'A' + 10);
                    }

                    /* Determine if the next digit is valid.                 */
                    if(((Index + 1) < strlen(StringInteger)) && (((StringInteger[Index+1] >= '0') && (StringInteger[Index+1] <= '9')) || ((StringInteger[Index+1] >= 'a') && (StringInteger[Index+1] <= 'f')) || ((StringInteger[Index+1] >= 'A') && (StringInteger[Index+1] <= 'F'))))
                    {
                        /* The next digit is valid so multiply the current    */
                        /* return value by 16.                                */
                        ret_val *= 16;
                    }
                    else
                    {
                        /* The next value is invalid so break out of the loop.*/
                        break;
                    }
                }

                Index++;
            }
        }
    }

    return(ret_val);
}

/* The following function is responsible for opening the SS1         */
/* Bluetooth Protocol Stack.  This function accepts a pre-populated  */
/* HCI Driver Information structure that contains the HCI Driver     */
/* Transport Information.  This function returns zero on successful  */
/* execution and a negative value on all errors.                     */
static int OpenStack(qapi_BLE_HCI_DriverInformation_t *HCI_DriverInformation)
{
    int                    Result;
    int                    ret_val = 0;
    char                   BluetoothAddress[16];
    //   int8_t                 TxPowerLevel;
    uint32_t               ServiceID;
    qapi_BLE_HCI_Version_t HCIVersion;
    uint8_t                HC_SCO_Data_Packet_Length;
    uint16_t               HC_Total_Num_SCO_Data_Packets;
    uint16_t               HC_Total_Num_LE_Data_Packets;
    uint16_t               HC_LE_Data_Packet_Length;
    uint8_t                TempData;
    uint8_t                Status;

    /* First check to see if the Stack has already been opened.          */
    if(!BluetoothStackID)
    {
        /* Next, makes sure that the Driver Information passed appears to */
        /* be semi-valid.                                                 */
        if(HCI_DriverInformation)
        {
            LOG_DEBUG("\n");

            LOG_DEBUG("OpenStack().\n");

            /* Initialize the Stack                                        */
            Result = qc_drv_ble_BSC_Initialize(qc_api_get_qc_drv_context(), HCI_DriverInformation, 0);

            /* Next, check the return value of the initialization to see if*/
            /* it was successful.                                          */
            if(Result > 0)
            {
                /* The Stack was initialized successfully, inform the user  */
                /* and set the return value of the initialization function  */
                /* to the Bluetooth Stack ID.                               */
                BluetoothStackID = Result;
                LOG_DEBUG("Bluetooth Stack ID: %d.\n", BluetoothStackID);

                /* Initialize the Default Pairing Parameters.               */
                LE_Parameters.IOCapability      = DEFAULT_IO_CAPABILITY;
                LE_Parameters.OOBDataPresent    = FALSE;
                LE_Parameters.MITMProtection    = (LE_Parameters.IOCapability != QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E) ? DEFAULT_MITM_PROTECTION : FALSE;
                LE_Parameters.SecureConnections = DEFAULT_SECURE_CONNECTIONS;

                if(!qapi_BLE_HCI_Version_Supported(BluetoothStackID, &HCIVersion))
                    LOG_DEBUG("Device Chipset: %s.\n", (HCIVersion <= NUM_SUPPORTED_HCI_VERSIONS)?HCIVersionStrings[HCIVersion]:HCIVersionStrings[NUM_SUPPORTED_HCI_VERSIONS]);

                /* Read the LE Buffer Size.                                 */
                Result = qc_drv_ble_HCI_LE_Read_Buffer_Size(qc_api_get_qc_drv_context(), BluetoothStackID, &Status, &HC_LE_Data_Packet_Length, &TempData);

                /* If HCI_LE_Read_Buffer_Size returned an error OR it returned */
                /* ZERO for the LE Data Packet Buffers we need to call         */
                /* HCI_Read_Buffer_Size to get the Data Packet Buffers (which  */
                /* must be shared between Classic and LE Bluetooth).           */
                if((Result) || (Status != 0) || (!HC_LE_Data_Packet_Length) || (!TempData))
                {
                    if((!qapi_BLE_HCI_Read_Buffer_Size(BluetoothStackID, &Status, &HC_LE_Data_Packet_Length, &HC_SCO_Data_Packet_Length, &HC_Total_Num_LE_Data_Packets, &HC_Total_Num_SCO_Data_Packets)) && (!Status))
                        Result = 0;
                    else
                        Result = -1;
                }
                else
                {
                    HC_Total_Num_LE_Data_Packets = (uint16_t)TempData;
                    Result                       = 0;
                }

                NumberACLPackets            = HC_Total_Num_LE_Data_Packets;
                NumberOutstandingACLPackets = 0;
                MaxACLPacketSize            = HC_LE_Data_Packet_Length;

                if(!Result)
                    LOG_DEBUG("Number ACL Buffers: %d, ACL Buffer Size: %d\n", NumberACLPackets, MaxACLPacketSize);
                else
                    LOG_WARN("Unable to determine ACL Buffer Size.\n");

                RegisterForHCIEvents();
                RegisterForACLData();

                GenerateData2Send(MAXIMUM_TEST_BUFFER, TestBuffer);

                /* Let's output the Bluetooth Device Address so that the    */
                /* user knows what the Device Address is.                   */
                if(!qc_drv_ble_GAP_Query_Local_BD_ADDR(qc_api_get_qc_drv_context(), BluetoothStackID, &LocalBD_ADDR))
                {
                    BD_ADDRToStr(LocalBD_ADDR, BluetoothAddress);

                    LOG_INFO("BD_ADDR: %s\n", BluetoothAddress);
                }

                /* Flag that no connection is currently active.             */
                QAPI_BLE_ASSIGN_BD_ADDR(SelectedRemoteBD_ADDR, 0, 0, 0, 0, 0, 0);
                QAPI_BLE_ASSIGN_BD_ADDR(SecurityRemoteBD_ADDR, 0, 0, 0, 0, 0, 0);

                /* Generate some random values for IR and ER (normally would*/
                /* be in flash).                                            */
                GenerateRandomKeys();

                /* Regenerate IRK and DHK from the constant Identity Root   */
                /* Key.                                                     */
                qapi_BLE_GAP_LE_Diversify_Function(BluetoothStackID, (qapi_BLE_Encryption_Key_t *)(&IR), 1,0, &IRK);
                qapi_BLE_GAP_LE_Diversify_Function(BluetoothStackID, (qapi_BLE_Encryption_Key_t *)(&IR), 3, 0, &DHK);

                /* Flag that we have no Key Information in the Key List.    */
                DeviceInfoList = NULL;

                /* Attempt to initialize our persistent storage context.    */
                /* * NOTE * /spinor/ is default mount point for the flash   */
                /*          file system. Unless a different file system is  */
                /*          being used or the mount point is changed, this  */
                /*          directory should be kept in any modifications.  */
                Result = qapi_Persist_Initialize(&PersistHandle, "/spinor/ble", "ble_data", ".bin", NULL, 0);
                if(Result < 0)
                    LOG_WARN("Persistent Storage Initialization Failed: %d\n", Result);

                /* Initialize the GATT Service.                             */
                if((Result = qc_drv_ble_GATT_Initialize(qc_api_get_qc_drv_context(), BluetoothStackID, (QAPI_BLE_GATT_INITIALIZATION_FLAGS_SUPPORT_LE | QAPI_BLE_GATT_INITIALIZATION_FLAGS_DISABLE_SERVICE_CHANGED_CHARACTERISTIC), GATT_Connection_Event_Callback, 0)) == 0)
                {

                    /* Initialize the GAPS Service.                          */
                    Result = qc_drv_ble_GAPS_Initialize_Service(qc_api_get_qc_drv_context(), BluetoothStackID, &ServiceID);
                    if(Result > 0)
                    {
                        /* Save the Instance ID of the GAP Service.           */
                        GAPSInstanceID = (unsigned int)Result;

                        /* Set the GAP Device Name and Device Appearance.     */
                        qc_drv_ble_GAPS_Set_Device_Name(qc_api_get_qc_drv_context(), BluetoothStackID, GAPSInstanceID, DEVICE_FRIENDLY_NAME);
                        qc_drv_ble_GAPS_Set_Device_Appearance(qc_api_get_qc_drv_context(), BluetoothStackID, GAPSInstanceID, QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_GENERIC_COMPUTER);

                        /* Let's enable address resolution in the controller. */
                        /* * NOTE * This function MUST be called to enable the*/
                        /*          use of the resolving list in the          */
                        /*          controller.                               */
                        Result = qc_drv_ble_GAP_LE_Set_Address_Resolution_Enable(qc_api_get_qc_drv_context(), BluetoothStackID, TRUE);
                        if(!Result)
                        {
                            /* Enable the GAPS Central Device Resolution.      */
                            /* * NOTE * This MUST be enabled since the local   */
                            /*          device supports privacy with address   */
                            /*          resolution.  A remote peripheral MUST  */
                            /*          read the Central Address Resolution    */
                            /*          Characteristic to determine if the     */
                            /*          local device supports privacy with     */
                            /*          address resolution before using direct */
                            /*          advertising, where the initiator       */
                            /*          address is a resolvable private address*/
                            /*          (RPA).                                 */
                            qapi_BLE_GAPS_Set_Central_Address_Resolution(BluetoothStackID, GAPSInstanceID, QAPI_BLE_GAR_ENABLED_E);

                            /* Let's set the Resolvable Private Address (RPA)  */
                            /* Timeout to 60 seconds.                          */
                            /* * NOTE * An new RPA will be generated and used  */
                            /*          for a remote device when the timeout   */
                            /*          occurs.                                */
                            Result = qc_drv_ble_GAP_LE_Set_Resolvable_Private_Address_Timeout(qc_api_get_qc_drv_context(), BluetoothStackID, 60);
                            if(Result)
                                LOG_ERR("Error - qapi_BLE_GAP_LE_Set_Resolvable_Private_Address_Timeout() returned %d.\n", Result);
                        }
                        else
                            LOG_ERR("Error - api_BLE_GAP_LE_Set_Address_Resolution_Enable() returned %d.\n", Result);
                    }
                    else
                        DisplayFunctionError("qapi_BLE_GAPS_Initialize_Service()", Result);

                    /* Return success to the caller.                         */
                    ret_val = 0;
                }
                else
                {
                    /* The Stack was NOT initialized successfully, inform the*/
                    /* user and set the return value of the initialization   */
                    /* function to an error.                                 */
                    DisplayFunctionError("qapi_BLE_GATT_Initialize()", Result);

                    /* Shutdown the stack.                                   */
                    qapi_BLE_BSC_Shutdown(BluetoothStackID);

                    BluetoothStackID = 0;

                    ret_val          = -1;
                }
            }
            else
            {
                /* The Stack was NOT initialized successfully, inform the   */
                /* user and set the return value of the initialization      */
                /* function to an error.                                    */
                DisplayFunctionError("qapi_BLE_BSC_Initialize()", Result);

                BluetoothStackID = 0;

                ret_val          = -1;
            }
        }
        else
        {
            /* One or more of the necessary parameters are invalid.        */
            ret_val = -1;
        }
    }
    else
    {
        /* Stack is already opened.                                       */
        ret_val = 0;
    }


    return(ret_val);
}

/* The following function is responsible for closing the SS1         */
/* Bluetooth Protocol Stack.  This function requires that the        */
/* Bluetooth Protocol stack previously have been initialized via the */
/* OpenStack() function.  This function returns zero on successful   */
/* execution and a negative value on all errors.                     */
static int CloseStack(void)
{
    int           ret_val = 0;
    unsigned int  Index;
    DeviceInfo_t *DeviceInfo;

    /* First check to see if the Stack has been opened.                  */
    if(BluetoothStackID)
    {
        /* If there are remote devices connected.                         */
        if(ConnectionCount)
        {
            /* Go ahead and flag that we are no longer connected to any    */
            /* remote devices.                                             */
            ConnectionCount = 0;

            /* Lock the Bluetooth stack.                                   */
            if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
            {
                /* We need to loop through the remote device information    */
                /* entries and disconnect any remote devices that are still */
                /* connected.                                               */
                DeviceInfo = DeviceInfoList;
                while(DeviceInfo)
                {
                    /* If the GATT Connection ID is valid, then we are       */
                    /* connected to the remote device.                       */
                    if(DeviceInfo->ConnectionID)
                    {
                        /* Flag that the remote device is no longer connected.*/
                        DeviceInfo->ConnectionID = 0;

                        /* Send the disconnection request.                    */
                        qc_drv_ble_GAP_LE_Disconnect(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->RemoteAddress);
                    }

                    DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
                }

                /* Un-lock the Bluetooth Stack.                             */
                qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
            }
        }

        /* if scan timer is active stop that.                             */
        if(ScanTimerID)
        {
            /* Stop the timer.                                             */
            qapi_BLE_BSC_StopTimer(BluetoothStackID, ScanTimerID);

            ScanTimerID = 0;
        }

        /* Un-registered AIOS.                                            */
        if(AIOSInstanceID)
        {
            qc_drv_ble_AIOS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, AIOSInstanceID);

            AIOSInstanceID = 0;
        }

        /* Un-register any registered BAS service instances.              */
        for(Index = 0; Index < MAX_SUPPORTED_BATTERY_INSTANCES; Index++)
        {
            /* Check to see if this instance is registered.                */
            if(BASInstanceID[Index])
            {
                qc_drv_ble_BAS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, BASInstanceID[Index]);

                BASInstanceID[Index] = 0;
            }
        }

        /* Cleanup GAP Service Module.                                    */
        if(GAPSInstanceID)
        {
            qapi_BLE_GAPS_Cleanup_Service(BluetoothStackID, GAPSInstanceID);

            GAPSInstanceID = 0;
        }

        /* Cleanup HID Service.                                           */
        if(HIDSInstanceID)
        {
            qc_drv_ble_HIDS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID);

            HIDSInstanceID = 0;
        }

        /* Cleanup the SCPS Service Module.                               */
        if(SCPSInstanceID)
        {
            qc_drv_ble_SCPS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, SCPSInstanceID);

            SCPSInstanceID = 0;
        }

        /* Un-registered SPP LE Service.                                  */
        if(SPPLEServiceID)
        {
            qc_drv_ble_GATT_Un_Register_Service(qc_api_get_qc_drv_context(), BluetoothStackID, SPPLEServiceID);

            SPPLEServiceID = 0;
        }

        /* Release the storage instance.                                  */
        qapi_Persist_Cleanup(PersistHandle);
        PersistHandle = NULL;

        /* Cleanup GATT Module.                                           */
        qapi_BLE_GATT_Cleanup(BluetoothStackID);

        /* Simply close the Stack                                         */
        qapi_BLE_BSC_Shutdown(BluetoothStackID);

        /* Inform the user that the stack has been shut down.             */
        LOG_INFO("Stack Shutdown.\n");

        /* Free all remote device information entries.                    */
        FreeDeviceInfoList(&DeviceInfoList);
        DeviceInfoList   = NULL;

        /* Flag that the Stack is no longer initialized.                  */
        BluetoothStackID = 0;
        RemoteOOBValid   = FALSE;
        LocalOOBValid    = FALSE;

        /* Flag success to the caller.                                    */
        ret_val          = 0;
    }
    else
    {
        /* A valid Stack ID does not exist, inform to user.               */
        ret_val = -1;
    }

    return(ret_val);
}

/******************************************************************************/
/**  RegisterForHCIEvents(void)                                              **/
/******************************************************************************/
/**  Register for HCI Events.                                                **/
/******************************************************************************/
static int RegisterForHCIEvents(void)
{
    int Result;

    if(BluetoothStackID)
    {
        Result = qc_drv_ble_HCI_Register_Event_Callback(qc_api_get_qc_drv_context(), BluetoothStackID, EventCallback, 1);

        if(Result)
            LOG_INFO("HCI Event Registration Successful.\n");
        else
            LOG_ERR("HCI Event Registration Failed.\n");
    }
    else
        LOG_ERR("Stack ID Invalid.\n");

    return(0);
}

/******************************************************************************/
/**  RegisterForACLData(void)                                                **/
/******************************************************************************/
/**  Register for ACL Data.                                                  **/
/******************************************************************************/
static int RegisterForACLData(void)
{
    int Result;

    if(BluetoothStackID)
    {
        Result = qc_drv_ble_HCI_Register_ACL_Data_Callback(qc_api_get_qc_drv_context(), BluetoothStackID, ACLDataCallback, 1);

        if(Result)
            LOG_INFO("ACL Data Callback Registration Successful.\n");
        else
            LOG_ERR("ACL Data Callback Registration Failed.\n");
    }
    else
        LOG_ERR("Stack ID Invalid.\n");

    return(0);
}

/* The following function is used to generate a pattern of data to   */
/* send to the remote device.                                        */
static void GenerateData2Send(unsigned int Length,  uint8_t *Data)
{
    unsigned int         Index;
    static unsigned char Cntr = '0';

    /* Make sure the input parameters are valid.                         */
    if((Length) && (Data))
    {
        for(Index = 0; Index < Length; Index++)
        {
            Data[Index] = Cntr++;

            if((Cntr > '9') && (Cntr < 'A'))
                Cntr = 'A';
            else
            {
                if(Cntr > 'F')
                    Cntr = '0';
            }
        }
    }
}

/* The following callback is the period timer callback that is       */
/* started for periodically transmitting data.                       */
static void Period_Tx_Callback(uint32_t data)
{
    qapi_Status_t         Result;
    unsigned long         Temp;
    static unsigned long  DataIndex = 0;
    qapi_TIMER_set_attr_t Set_Timer_Attr;

    /* Verify that the stack is opened.                                  */
    if(BluetoothStackID != 0)
    {
        /* Verify that a LE Connection Oriented Channel is open for data  */
        /* transfer.                                                      */
        if(CurrentTest == CURRENT_TEST_PERIODIC)
        {
            Temp = MAXIMUM_TEST_BUFFER - DataIndex;

            if(PacketLength <= Temp)
                Temp = PacketLength;

            /* Send the data.                                              */
            SendACLData(Temp, &(TestBuffer[DataIndex]));

            DataIndex += Temp;

            if(DataIndex >= MAXIMUM_TEST_BUFFER)
                DataIndex = 0;
        }
    }

    /* Restart the timer if necessary.                                   */
    if(CurrentTest == CURRENT_TEST_PERIODIC)
    {
        /* Timer restart necessary, so configure according to the saved   */
        /* parameters.                                                    */
        Set_Timer_Attr.time                   = (uint64_t)TransmitPeriod;
        Set_Timer_Attr.reload                 = true;
        Set_Timer_Attr.max_deferrable_timeout = (uint64_t)TransmitPeriod;
        Set_Timer_Attr.unit                   = QAPI_TIMER_UNIT_MSEC;

        Result = qapi_Timer_Set(PeriodicSendTimer, &Set_Timer_Attr);
        if(Result != QAPI_OK)
            Display_Function_Error("qapi_Timer_Set", Result);
    }
    else
        DataIndex = 0;
}

/******************************************************************************/
/**  SendACLData(char *)                                                     **/
/******************************************************************************/
/**  Send ACL Data.                                                          **/
/******************************************************************************/
static int SendACLData(unsigned int Length, unsigned char *Data)
{
    int           Result;
    int           ret_val = 0;
    unsigned long Pass;

    if(BluetoothStackID)
    {
        if((Data) && (Length <= MAXIMUM_TEST_BUFFER))
        {
            if(CurrentTest == CURRENT_TEST_TX_ACL)
                Pass = 0xFFFFFFFF;
            else
                Pass = 1;

            if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
            {
                while((Pass--) && (!ret_val))
                {
                    if(NumberOutstandingACLPackets < NumberACLPackets)
                    {
                        Result = qc_drv_ble_HCI_Send_ACL_Data(qc_api_get_qc_drv_context(), BluetoothStackID,
                                ConnectionHandle,
                                QAPI_BLE_HCI_ACL_FLAGS_PACKET_BOUNDARY_FIRST_PACKET_NON_FLUSHABLE,
                                (uint16_t)Length,
                                Data);

                        if(!Result)
                        {
                            NumberOutstandingACLPackets++;

                            NumberBytes += Length;
                            ret_val      = 0;
                        }
                        else
                        {
                            LOG_ERR("Function Returned %d.\n", Result);

                            ret_val = -4;
                        }
                    }
                    else
                        ret_val = -3;
                }

                qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
            }
        }
        else
            ret_val = -2;
    }
    else
    {
        LOG_ERR("Stack ID Invalid.\n");

        ret_val = -1;
    }

    return(ret_val);
}

static QCLI_Command_Status_t StartTXRXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    uint16_t              _ConnectionHandle;
    qapi_BLE_BD_ADDR_t    BD_ADDR;
    QCLI_Command_Status_t ret_val = QCLI_STATUS_SUCCESS_E;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {

        if((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"transmit") == 0)) {

            if((Parameter_Count >= 2) && (Parameter_List) && (strlen((char *)(Parameter_List[1].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
            {
                /* Convert the parameter to a Bluetooth Device Address.        */
                StrToBD_ADDR((char *)(Parameter_List[1].String_Value), &BD_ADDR);

                PacketLength = 0;

                if((Parameter_Count >= 2) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= 0) && (Parameter_List[2].Integer_Value <= MaxACLPacketSize) && (Parameter_List[2].Integer_Value <= MAXIMUM_TEST_BUFFER))
                    PacketLength = (uint32_t)Parameter_List[2].Integer_Value;
                else
                {
                    if(Parameter_Count == 2)
                        PacketLength = (uint32_t)27;
                }

                if((PacketLength) && (PacketLength <= MaxACLPacketSize))
                {
                    if(CurrentTest == CURRENT_TEST_NONE)
                    {
                        if(!qc_drv_ble_GAP_LE_Query_Connection_Handle(qc_api_get_qc_drv_context(), BluetoothStackID, BD_ADDR, &_ConnectionHandle))
                        {
                            CurrentTest                 = CURRENT_TEST_TX_ACL;
                            StartTime                   = qurt_timer_get_ticks();
                            NumberBytes                 = 0;
                            NumberOutstandingACLPackets = 0;
                            ConnectionHandle            = _ConnectionHandle;

                            LOG_INFO("Starting ACL TX Test with packet size: %u.\n", PacketLength);

                            SendACLData(PacketLength, TestBuffer);
                        }
                        else
                            LOG_WARN("Device is not currently connected.\n");
                    }
                    else
                        LOG_WARN("Test already in progress.\n");

                    /* Flag success to the caller.                              */
                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    LOG_WARN("Data Packet Size must be between 1 and  %u.\n", MaxACLPacketSize);

                    /* One or more of the necessary parameters is/are invalid.  */
                    ret_val = QCLI_STATUS_USAGE_E;
                }
            }
            else
            {
                /* One or more of the necessary parameters is/are invalid.     */
                ret_val = QCLI_STATUS_USAGE_E;
            }
        } else if((Parameter_Count >= 2) && (APP_STRCMP(Parameter_List[0].String_Value,"receive") == 0)) {

            if(CurrentTest == CURRENT_TEST_NONE)
            {
                _ConnectionHandle = QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE;

                /* Note we will treat the RX Test BD_ADDR as optional - we will*/
                /* not display statistics though.                              */
                if((Parameter_Count >= 2) && (Parameter_List) && (strlen((char *)(Parameter_List[1].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
                {
                    /* Convert the parameter to a Bluetooth Device Address.        */
                    StrToBD_ADDR((char *)(Parameter_List[1].String_Value), &BD_ADDR);

                    qc_drv_ble_GAP_LE_Query_Connection_Handle(qc_api_get_qc_drv_context(), BluetoothStackID, BD_ADDR, &_ConnectionHandle);
                }

                StartTime        = 0;
                NumberBytes      = 0;
                CurrentTest      = CURRENT_TEST_RX_ACL;
                ConnectionHandle = _ConnectionHandle;

                ret_val          = QCLI_STATUS_SUCCESS_E;

                LOG_INFO("Waiting to Receive ACL Data.\n");
            }
            else
            {
                LOG_WARN("Test already in progress.\n");
            }

        } else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t StopTXRXTest(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    uint32_t              ElapsedTime;
    uint32_t              Bandwidth;
    QCLI_Command_Status_t ret_val;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        if(CurrentTest != CURRENT_TEST_NONE)
        {
            /* Do not display statistics if an RX Test was specified (with */
            /* no BD_ADDR specified).                                      */
            if(ConnectionHandle != QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE)
            {
                EndTime      = qurt_timer_get_ticks();

                ElapsedTime  = qurt_timer_convert_ticks_to_time(EndTime - StartTime, QURT_TIME_MSEC) / 1000;

                if(ElapsedTime)
                {
                    Bandwidth    = NumberBytes/ElapsedTime;

                    LOG_INFO("Test Time    : %u\n", ElapsedTime);
                    LOG_INFO("Number Bytes : %u\n", NumberBytes);
                    LOG_INFO("Bytes/Second : %u\n", Bandwidth);
                    LOG_INFO("KBytes/Second: %u\n", Bandwidth/1024);
                    LOG_INFO("KBits/Second : %u\n", (Bandwidth*8)/1024);
                }
            }

            LOG_INFO("Test Complete.\n");

            ConnectionHandle            = QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE;
            CurrentTest                 = CURRENT_TEST_NONE;
            NumberOutstandingACLPackets = 0;
        }
        else
            LOG_INFO("No Test in progress.\n");

        /* Flag success to the caller.                                    */
        ret_val = QCLI_STATUS_SUCCESS_E;
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t SetConnectionMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t               ret_val;
    qapi_BLE_GAP_Discoverability_Mode_t DiscoverabilityMode;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        if((Parameter_Count == 2) && (APP_STRCMP(Parameter_List[0].String_Value,"discover") == 0)) {
            /* Make sure that all of the parameters required for this function*/
            /* appear to be at least semi-valid.                              */
            if((Parameter_Count > 1) && (Parameter_List) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= 2))
            {
                /* Parameters appear to be valid, map the specified parameters */
                /* into the API specific parameters.                           */
                if(Parameter_List[1].Integer_Value == 1)
                    DiscoverabilityMode = QAPI_BLE_DM_LIMITED_DISCOVERABLE_MODE_E;
                else
                {
                    if(Parameter_List[1].Integer_Value == 2)
                        DiscoverabilityMode = QAPI_BLE_DM_GENERAL_DISCOVERABLE_MODE_E;
                    else
                        DiscoverabilityMode = QAPI_BLE_DM_NON_DISCOVERABLE_MODE_E;
                }

                /* Set the LE Discoveryability Mode.                           */
                LE_Parameters.DiscoverabilityMode = DiscoverabilityMode;

                /* The Mode was changed successfully.                          */
                LOG_INFO("Discoverability: %s.\n", (DiscoverabilityMode == QAPI_BLE_DM_NON_DISCOVERABLE_MODE_E)?"Non":((DiscoverabilityMode == QAPI_BLE_DM_GENERAL_DISCOVERABLE_MODE_E)?"General":"Limited"));

                /* Flag success to the caller.                                 */
                ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
                /* One or more of the necessary parameters is/are invalid.     */
                ret_val = QCLI_STATUS_USAGE_E;
            }
        } else if ((Parameter_Count == 2) && (APP_STRCMP(Parameter_List[0].String_Value,"connect") == 0)) {

            /* Make sure that all of the parameters required for this function*/
            /* appear to be at least semi-valid.                              */
            if((Parameter_Count > 1) && (Parameter_List) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= QAPI_BLE_LCM_NON_CONNECTABLE_E) && (Parameter_List[1].Integer_Value <= QAPI_BLE_LCM_DIRECT_CONNECTABLE_E))
            {
                /* Parameters appear to be valid, map the specified parameters */
                /* into the API specific parameters.                           */
                /* * NOTE * The Connectability Mode in LE is only applicable   */
                /*          when advertising, if a device is not advertising   */
                /*          it is not connectable.                             */
                if(Parameter_List[1].Integer_Value == QAPI_BLE_LCM_DIRECT_CONNECTABLE_E)
                {
                    /* We CANNOT use Direct Connectable high duty cycle since   */
                    /* advertising will stop after 1.28 ms and it is meant for  */
                    /* fast connections.  Instead we will use low duty cycle to */
                    /* allow the remote device more time to connect.            */
                    LE_Parameters.ConnectableMode = QAPI_BLE_LCM_LOW_DUTY_CYCLE_DIRECT_CONNECTABLE_E;
                }
                else
                    LE_Parameters.ConnectableMode = (qapi_BLE_GAP_LE_Connectability_Mode_t)Parameter_List[1].Integer_Value;

                /* The Mode was changed successfully.                          */
                switch(LE_Parameters.ConnectableMode)
                {
                    case QAPI_BLE_LCM_NON_CONNECTABLE_E:
                        LOG_INFO("Connectability Mode: Non-Connectable.\n");
                        break;
                    case QAPI_BLE_LCM_CONNECTABLE_E:
                        LOG_INFO("Connectability Mode: Connectable.\n");
                        break;
                    case QAPI_BLE_LCM_DIRECT_CONNECTABLE_E:
                        LOG_INFO("Connectability Mode: Direct Connectable (High Duty Cycle).\n");
                        break;
                    case QAPI_BLE_LCM_LOW_DUTY_CYCLE_DIRECT_CONNECTABLE_E:
                        LOG_INFO("Connectability Mode: Direct Connectable (Low Duty Cycle).\n");
                        break;
                    default:
                        LOG_WARN("Connectability Mode: Invalid.\n");
                        break;

                }

                /* Flag success to the caller.                                 */
                ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
                /* One or more of the necessary parameters is/are invalid.     */
                ret_val = QCLI_STATUS_USAGE_E;
            }
        } else
            ret_val = QCLI_STATUS_USAGE_E;

    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for setting the Pairability */
/* Mode of the local device.  This function returns zero on          */
/* successful execution and a negative value on all errors.          */
static QCLI_Command_Status_t SetPairabilityMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                 Result;
    char                               *Mode;
    QCLI_Command_Status_t               ret_val;
    qapi_BLE_GAP_LE_Pairability_Mode_t  PairabilityMode;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Make sure that all of the parameters required for this function*/
        /* appear to be at least semi-valid.                              */
        if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 2))
        {
            /* Parameters appear to be valid, map the specified parameters */
            /* into the API specific parameters.                           */
            if(Parameter_List[0].Integer_Value == 0)
            {
                PairabilityMode = QAPI_BLE_LPM_NON_PAIRABLEMODE_E;
                Mode            = "QAPI_BLE_LPM_NON_PAIRABLEMODE_E";
            }
            else
            {
                if(Parameter_List[0].Integer_Value == 1)
                {
                    PairabilityMode = QAPI_BLE_LPM_PAIRABLE_MODE_E;
                    Mode            = "QAPI_BLE_LPM_PAIRABLE_MODE_E";
                }
                else
                {
                    PairabilityMode = QAPI_BLE_LPM_PAIRABLE_MODE_ENABLE_EXTENDED_EVENTS_E;
                    Mode            = "QAPI_BLE_LPM_PAIRABLE_MODE_ENABLE_EXTENDED_EVENTS_E";
                }
            }

            /* Parameters mapped, now set the Pairability Mode.            */
            Result = qc_drv_ble_GAP_LE_Set_Pairability_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, PairabilityMode);

            /* Next, check the return value to see if the command was      */
            /* issued successfully.                                        */
            if(Result >= 0)
            {
                /* The Mode was changed successfully.                       */
                LOG_INFO("Pairability Mode Changed to %s.\n", Mode);

                /* If Secure Simple Pairing has been enabled, inform the    */
                /* user of the current Secure Simple Pairing parameters.    */
                if(PairabilityMode == QAPI_BLE_LPM_PAIRABLE_MODE_E)
                    DisplayIOCapabilities();

                /* Flag success to the caller.                              */
                ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
                /* There was an error setting the Mode.                     */
                DisplayFunctionError("GAP_Set_Pairability_Mode", Result);

                /* Flag that an error occurred while submitting the command.*/
                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            /* One or more of the necessary parameters is/are invalid.     */
            ret_val = QCLI_STATUS_USAGE_E;
        }
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}


/* The following function is responsible for changing the Secure     */
/* Simple Pairing Parameters that are exchanged during the Pairing   */
/* procedure when Secure Simple Pairing (Security Level 4) is used.  */
/* This function returns zero on successful execution and a negative */
/* value on all errors.                                              */
static QCLI_Command_Status_t ChangePairingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t ret_val;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Make sure that all of the parameters required for this function*/
        /* appear to be at least semi-valid.                              */
        if((Parameter_Count >= 3) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 4))
        {
            /* Parameters appear to be valid, map the specified parameters */
            /* into the API specific parameters.                           */
            if(Parameter_List[0].Integer_Value == 0)
                LE_Parameters.IOCapability = QAPI_BLE_LIC_DISPLAY_ONLY_E;
            else
            {
                if(Parameter_List[0].Integer_Value == 1)
                    LE_Parameters.IOCapability = QAPI_BLE_LIC_DISPLAY_YES_NO_E;
                else
                {
                    if(Parameter_List[0].Integer_Value == 2)
                        LE_Parameters.IOCapability = QAPI_BLE_LIC_KEYBOARD_ONLY_E;
                    else
                    {
                        if(Parameter_List[0].Integer_Value == 3)
                            LE_Parameters.IOCapability = QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E;
                        else
                            LE_Parameters.IOCapability = QAPI_BLE_LIC_KEYBOARD_DISPLAY_E;
                    }
                }
            }

            /* Finally map the Man in the Middle (MITM) Protection valid.  */
            LE_Parameters.MITMProtection    = (boolean_t)(Parameter_List[1].Integer_Value ? TRUE : FALSE);

            /* Also, map the secure connections.                           */
            LE_Parameters.SecureConnections = (boolean_t)(Parameter_List[2].Integer_Value ? TRUE : FALSE);

            /* Inform the user of the New I/O Capabilities.                */
            DisplayIOCapabilities();

            /* Flag success to the caller.                                 */
            ret_val = QCLI_STATUS_SUCCESS_E;
        }
        else
        {
            /* One or more of the necessary parameters is/are invalid.     */
            ret_val = QCLI_STATUS_USAGE_E;
        }
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for issuing a GAP           */
/* Authentication Response with a Pass Key value specified via the   */
/* input parameter.  This function returns zero on successful        */
/* execution and a negative value on all errors.                     */
static QCLI_Command_Status_t LEPassKeyResponse(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                                   Result;
    QCLI_Command_Status_t                                 ret_val;
    qapi_BLE_GAP_LE_Authentication_Response_Information_t GAP_LE_Authentication_Response_Information;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* First, check to see if there is an on-going Pairing operation  */
        /* active.                                                        */
        if(!QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
        {
            /* Make sure that all of the parameters required for this      */
            /* function appear to be at least semi-valid.                  */
            if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].String_Value) && (strlen((char *)(Parameter_List[0].String_Value)) <= QAPI_BLE_GAP_LE_PASSKEY_MAXIMUM_NUMBER_OF_DIGITS))
            {
                /* Parameters appear to be valid, go ahead and populate the */
                /* response structure.                                      */
                GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type  = QAPI_BLE_LAR_PASSKEY_E;
                GAP_LE_Authentication_Response_Information.Authentication_Data_Length  = (uint8_t)(sizeof(uint32_t));
                GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = (uint32_t)(Parameter_List[0].Integer_Value);

                /* Submit the Authentication Response.                      */
                Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, SecurityRemoteBD_ADDR, &GAP_LE_Authentication_Response_Information);

                /* Check the return value for the submitted command for     */
                /* success.                                                 */
                if(!Result)
                {
                    /* Operation was successful, inform the user.            */
                    LOG_INFO("Passkey Response success.\n");

                    /* Flag success to the caller.                           */
                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    /* Inform the user that the Authentication Response was  */
                    /* not successful.                                       */
                    DisplayFunctionError("GAP_LE_Authentication_Response", Result);

                    ret_val = QCLI_STATUS_ERROR_E;
                }

                /* Flag that there is no longer a current Authentication    */
                /* procedure in progress.                                   */
                QAPI_BLE_ASSIGN_BD_ADDR(SecurityRemoteBD_ADDR, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
            }
            else
            {
                /* One or more of the necessary parameters is/are invalid.  */
                ret_val = QCLI_STATUS_USAGE_E;
            }
        }
        else
        {
            /* There is not currently an on-going authentication operation,*/
            /* inform the user of this error condition.                    */
            LOG_WARN("Pass Key Authentication Response: Authentication not in progress.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for querying the Encryption */
/* Mode for an LE Connection.  This function returns zero on         */
/* successful execution and a negative value on all errors.          */
static QCLI_Command_Status_t LEQueryEncryption(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                            Result;
    QCLI_Command_Status_t          ret_val;
    qapi_BLE_GAP_Encryption_Mode_t GAP_Encryption_Mode;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* First, check to see if there is an on-going Pairing operation  */
        /* active.                                                        */
        if(!QAPI_BLE_COMPARE_NULL_BD_ADDR(SelectedRemoteBD_ADDR))
        {
            /* Query the current Encryption Mode for this Connection.      */
            Result = qc_drv_ble_GAP_LE_Query_Encryption_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, SelectedRemoteBD_ADDR, &GAP_Encryption_Mode);
            if(!Result)
            {
                LOG_INFO("Current Encryption Mode: %s.\n", (GAP_Encryption_Mode == QAPI_BLE_EM_ENABLED_E)?"Enabled":"Disabled");

                ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
                LOG_WARN("Error - GAP_LE_Query_Encryption_Mode returned %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            /* There is not currently an on-going authentication operation,*/
            /* inform the user of this error condition.                    */
            LOG_WARN("Not Connected.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for querying the Encryption */
/* Mode for an LE Connection.  This function returns zero on         */
/* successful execution and a negative value on all errors.          */
static QCLI_Command_Status_t LESetPasskey(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    uint32_t              Passkey;
    QCLI_Command_Status_t ret_val;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Make sure that all of the parameters required for this         */
        /* function appear to be at least semi-valid.                     */
        if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) &&  ((Parameter_List[0].Integer_Value == 0) || (Parameter_List[0].Integer_Value == 1)))
        {
            /* Check to see if we are setting or clearing the LE Fixed     */
            /* Passkey.                                                    */
            if(Parameter_List[0].Integer_Value == 1)
            {
                /* We are setting the passkey so make sure it is valid.     */
                if((Parameter_Count >= 2) && (Parameter_List[1].String_Value) && (strlen((char *)(Parameter_List[1].String_Value)) <= QAPI_BLE_GAP_LE_PASSKEY_MAXIMUM_NUMBER_OF_DIGITS))
                {
                    /* Store the passkey.                                    */
                    Passkey = (uint32_t)(Parameter_List[1].String_Value);

                    /* Attempt to set the fixed passkey.                     */
                    Result  = qc_drv_ble_GAP_LE_Set_Fixed_Passkey(qc_api_get_qc_drv_context(), BluetoothStackID, &Passkey);
                    if(!Result)
                    {
                        LOG_INFO("Fixed Passkey set to %06u.\n", (unsigned int)Passkey);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                    {
                        LOG_ERR("Error - GAP_LE_Set_Fixed_Passkey returned %d.\n", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                {
                    LOG_WARN("Error - Invalid Passkey.\n");

                    ret_val = QCLI_STATUS_USAGE_E;
                }
            }
            else
            {
                /* Un-set the fixed passkey that we previously configured.  */
                Result = qc_drv_ble_GAP_LE_Set_Fixed_Passkey(qc_api_get_qc_drv_context(), BluetoothStackID, NULL);
                if(!Result)
                {
                    LOG_INFO("Fixed Passkey no longer configured.\n");

                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    LOG_ERR("Error - GAP_LE_Set_Fixed_Passkey returned %d.\n", Result);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
        }
        else
        {
            /* One or more of the necessary parameters is/are invalid.     */
            ret_val = QCLI_STATUS_USAGE_E;
        }
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for querying the Bluetooth  */
/* Device Address of the local Bluetooth Device.  This function      */
/* returns zero on successful execution and a negative value on all  */
/* errors.                                                           */
static QCLI_Command_Status_t GetLocalAddress(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    BoardStr_t            BoardStr;
    qapi_BLE_BD_ADDR_t    BD_ADDR;
    QCLI_Command_Status_t ret_val;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Attempt to submit the command.                                 */
        Result = qc_drv_ble_GAP_Query_Local_BD_ADDR(qc_api_get_qc_drv_context(), BluetoothStackID, &BD_ADDR);

        /* Check the return value of the submitted command for success.   */
        if(!Result)
        {
            BD_ADDRToStr(BD_ADDR, BoardStr);

            LOG_INFO("BD_ADDR of Local Device is: %s.\n", BoardStr);

            /* Flag success to the caller.                                 */
            ret_val = QCLI_STATUS_SUCCESS_E;
        }
        else
        {
            /* Display a message indicating that an error occurred while   */
            /* attempting to query the Local Device Address.               */
            LOG_ERR("GAP_Query_Local_BD_ADDR() Failure: %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
        }
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for enabling LE             */
/* Advertisements.  This function returns zero on successful         */
/* execution and a negative value on all errors.                     */
/* * NOTE * If SPPLE is registered by the local device, then the     */
/*          local device name (GAPS Device Name), should be set to a */
/*          shorter length than the default name.  Otherwise, the    */
/*          128-bit UUID for SPPLE CANNOT fit in the scan response   */
/*          data.                                                    */
static QCLI_Command_Status_t AdvertiseLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                         Result;
    int                                         Index;
    QCLI_Command_Status_t                       ret_val;
    qapi_BLE_BD_ADDR_t                          BD_ADDR;
    DeviceInfo_t                               *RemoteDevice;
    unsigned int                                Length;
    unsigned int                                UUIDIndex;
    char                                        Name[QAPI_BLE_GAP_MAXIMUM_DEVICE_NAME_LENGTH+1];
    unsigned int                                NameLength;
    uint16_t                                    DeviceAppearance;
    qapi_BLE_GAP_LE_Connectability_Parameters_t ConnectabilityParameters;
    int8_t                                      TransmitPowerLevel;
    union
    {
        qapi_BLE_Advertising_Data_t              AdvertisingData;
        qapi_BLE_Scan_Response_Data_t            ScanResponseData;
    } Advertisement_Data_Buffer;
    enum
    {
        AET_DISABLE_E,
        AET_ENABLE_ALL_E,
        AET_ENABLE_CHANNEL_37_E,
        AET_ENABLE_CHANNEL_38_E,
        AET_ENABLE_CHANNEL_39_E
    };

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Make sure that all of the parameters required for this function*/
        /* appear to be at least semi-valid.                              */
#ifndef V1
        if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= AET_DISABLE_E) && (Parameter_List[0].Integer_Value <= AET_ENABLE_CHANNEL_39_E))
#else
            if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= 1))
#endif
            {
                /* Determine whether to enable or disable Advertising.         */
#ifndef V1
                if(Parameter_List[0].Integer_Value == 0)
#else
                    if(Parameter_List[0].Integer_Value == AET_DISABLE_E)
#endif
                    {
                        /* Disable Advertising.                                     */
                        Result = qc_drv_ble_GAP_LE_Advertising_Disable(qc_api_get_qc_drv_context(), BluetoothStackID);
                        if(!Result)
                        {
                            LOG_INFO("   GAP_LE_Advertising_Disable success.\n");

                            ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                            LOG_ERR("   GAP_LE_Advertising_Disable returned %d.\n", Result);

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        /* Set the Advertising Data.                                */
                        memset(&(Advertisement_Data_Buffer.AdvertisingData), 0, sizeof(qapi_BLE_Advertising_Data_t));

                        /* Reset the length to zero.                                */
                        Length = 0;

                        /* Set the Flags A/D Field (1 byte type and 1 byte Flags.   */
                        Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length]   = 2;
                        Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_FLAGS;
                        Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length+2] = 0;

                        /* Configure the flags field based on the Discoverability   */
                        /* Mode.                                                    */
                        if(LE_Parameters.DiscoverabilityMode == QAPI_BLE_DM_GENERAL_DISCOVERABLE_MODE_E)
                            Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length+2]    = QAPI_BLE_HCI_LE_ADVERTISING_FLAGS_GENERAL_DISCOVERABLE_MODE_FLAGS_BIT_MASK;
                        else
                        {
                            if(LE_Parameters.DiscoverabilityMode == QAPI_BLE_DM_LIMITED_DISCOVERABLE_MODE_E)
                                Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length+2] = QAPI_BLE_HCI_LE_ADVERTISING_FLAGS_LIMITED_DISCOVERABLE_MODE_FLAGS_BIT_MASK;
                        }

                        Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length + 2] |= QAPI_BLE_HCI_LE_ADVERTISING_FLAGS_BR_EDR_NOT_SUPPORTED_FLAGS_BIT_MASK;

                        /* Update the current length of the advertising data.       */
                        /* * NOTE * We MUST add one to account for the length field,*/
                        /*          which does not include itself.                  */
                        Length += (Advertisement_Data_Buffer.AdvertisingData.Advertising_Data[Length] + 1);

                        /* Include the GAPS Device Appearance.                      */
                        if((Result = qc_drv_ble_GAPS_Query_Device_Appearance(qc_api_get_qc_drv_context(), BluetoothStackID, (uint32_t)GAPSInstanceID, &DeviceAppearance)) == 0)
                        {
                            /* Make sure we do not exceed the bounds of the buffer.  */
                            if((Length + (unsigned int)QAPI_BLE_NON_ALIGNED_WORD_SIZE + 2) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                            {
                                ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]   = 3;
                                ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_APPEARANCE;
                                ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+2]), DeviceAppearance);

                                /* Update the current length of the advertising data. */
                                /* * NOTE * We MUST add one to account for the length */
                                /*          field, which does not include itself.     */
                                Length += (((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1);
                            }
                            else
                                LOG_INFO("   The device appearance CANNOT fit in the advertising data.\n", Result);
                        }
                        else
                            LOG_INFO("   qapi_BLE_GAPS_Query_Device_Appearance(dtAdvertising) returned %d.\n", Result);

                        /* Include the Transmit Power Level.                        */
                        if((Result = QueryTxPowerLevel(FALSE, &TransmitPowerLevel)) == 0)
                        {
                            /* Make sure we do not exceed the bounds of the buffer.  */
                            if((Length + (unsigned int)QAPI_BLE_NON_ALIGNED_BYTE_SIZE + 2) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                            {
                                ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]   = 2;
                                ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_TX_POWER_LEVEL;
                                ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+2] = TransmitPowerLevel;

                                /* Update the current length of the advertising data. */
                                /* * NOTE * We MUST add one to account for the length */
                                /*          field, which does not include itself.     */
                                Length += (((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1);
                            }
                            else
                                LOG_INFO("   The transmit power CANNOT fit in the advertising data.\n");
                        }
                        else
                            LOG_INFO("   QueryTxPowerLevel() returned %d.\n", Result);


                        /* Include the 16-bit service UUIDs if the service is       */
                        /* registered.                                              */
                        /* * NOTE * SPPLE is excluded since it has a 128 bit UUID.  */

                        /* Make sure we have room in the buffer.                    */
                        /* * NOTE * We will make sure we have room for at least one */
                        /*          16-bit UUID.                                    */
                        if((Length + (unsigned int)QAPI_BLE_UUID_16_SIZE + 2) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                        {
                            ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]   = 1;
                            ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_COMPLETE;

                            /* Store the UUID Index location.                        */
                            /* * NOTE * We will do this to make the code more        */
                            /*          readable.                                    */
                            UUIDIndex = (Length + 2);

                            /* If AIOS is registered.                                */
                            if(AIOSInstanceID)
                            {
                                /* Make sure we do not exceed the bounds of the       */
                                /* buffer.                                            */
                                /* * NOTE * We MUST add one to account for the length */
                                /*          field, which does not include itself.     */
                                if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                                {
                                    /* Assign the AIOS Service UUID.                   */
                                    QAPI_BLE_AIOS_ASSIGN_AIOS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                                    /* Update the UUID Index.                          */
                                    UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                                    /* Update the advertising report data entry length */
                                    /* since we have added another UUID.               */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] += QAPI_BLE_UUID_16_SIZE;
                                }
                                else
                                {
                                    /* Flag that we could not include all the service  */
                                    /* UUIDs.                                          */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                                }
                            }

                            /* If BAS is registered.                                 */
                            for(Index = 0; Index < MAX_SUPPORTED_BATTERY_INSTANCES; Index ++)
                            {
                                if(BASInstanceID[Index])
                                {
                                    break;
                                }
                            }

                            if(Index < MAX_SUPPORTED_BATTERY_INSTANCES)
                            {
                                /* Make sure we do not exceed the bounds of the       */
                                /* buffer.                                            */
                                /* * NOTE * We MUST add one to account for the length */
                                /*          field, which does not include itself.     */
                                if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                                {
                                    /* Assign the BAS Service UUID.                    */
                                    QAPI_BLE_BAS_ASSIGN_BAS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                                    /* Update the UUID Index.                          */
                                    UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                                    /* Update the advertising report data entry length */
                                    /* since we have added another UUID.               */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]  += QAPI_BLE_UUID_16_SIZE;
                                }
                                else
                                {
                                    /* Flag that we could not include all the service  */
                                    /* UUIDs.                                          */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                                }
                            }

                            /* If DIS is registered.                                 */
                            if(DISInstanceID)
                            {
                                /* Make sure we do not exceed the bounds of the       */
                                /* buffer.                                            */
                                /* * NOTE * We MUST add one to account for the length */
                                /*          field, which does not include itself.     */
                                if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                                {
                                    /* Assign the DIS Service UUID.                    */
                                    QAPI_BLE_DIS_ASSIGN_DIS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                                    /* Update the UUID Index.                          */
                                    UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                                    /* Update the advertising report data entry length */
                                    /* since we have added another UUID.               */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] += QAPI_BLE_UUID_16_SIZE;
                                }
                                else
                                {
                                    /* Flag that we could not include all the service  */
                                    /* UUIDs.                                          */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length + 1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                                }
                            }

                            /* If HOGP is registered.                                */
                            if(HIDSInstanceID)
                            {
                                /* Make sure we do not exceed the bounds of the       */
                                /* buffer.                                            */
                                /* * NOTE * We MUST add one to account for the length */
                                /*          field, which does not include itself.     */
                                if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                                {
                                    /* Assign the HOGP Service UUID.                   */
                                    QAPI_BLE_HIDS_ASSIGN_HIDS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                                    /* Update the UUID Index.                          */
                                    UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                                    /* Update the advertising report data entry length */
                                    /* since we have added another UUID.               */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]  += QAPI_BLE_UUID_16_SIZE;
                                }
                                else
                                {
                                    /* Flag that we could not include all the service  */
                                    /* UUIDs.                                          */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                                }
                            }

                            /* If SCPS is registered.                                */
                            if(SCPSInstanceID)
                            {
                                /* Make sure we do not exceed the bounds of the       */
                                /* buffer.                                            */
                                /* * NOTE * We MUST add one to account for the length */
                                /*          field, which does not include itself.     */
                                if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                                {
                                    /* Assign the SCPS Service UUID.                   */
                                    QAPI_BLE_SCPS_ASSIGN_SCPS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                                    /* Update the UUID Index.                          */
                                    UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                                    /* Update the advertising report data entry length */
                                    /* since we have added another UUID.               */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]  += QAPI_BLE_UUID_16_SIZE;
                                }
                                else
                                {
                                    /* Flag that we could not include all the service  */
                                    /* UUIDs.                                          */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                                }
                            }
                            /* If TPS is registered.                                 */
                            if(TPSInstanceID)
                            {
                                /* Make sure we do not exceed the bounds of the       */
                                /* buffer.                                            */
                                /* * NOTE * We MUST add one to account for the length */
                                /*          field, which does not include itself.     */
                                if((Length + ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1 + QAPI_BLE_UUID_16_SIZE) <= (unsigned int)QAPI_BLE_ADVERTISING_DATA_MAXIMUM_SIZE)
                                {
                                    /* Assign the TPS Service UUID.                    */
                                    QAPI_BLE_TPS_ASSIGN_TPS_SERVICE_UUID_16(&(((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[UUIDIndex]));

                                    /* Update the UUID Index.                          */
                                    UUIDIndex += QAPI_BLE_UUID_16_SIZE;

                                    /* Update the advertising report data entry length */
                                    /* since we have added another UUID.               */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length]  += QAPI_BLE_UUID_16_SIZE;
                                }
                                else
                                {
                                    /* Flag that we could not include all the service  */
                                    /* UUIDs.                                          */
                                    ((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_16_BIT_SERVICE_UUID_PARTIAL;
                                }
                            }

                            /* Update the current length of the advertising data.    */
                            /* * NOTE * We MUST add one to account for the length    */
                            /*          field, which does not include itself.        */
                            Length += (((uint8_t *)&Advertisement_Data_Buffer.AdvertisingData)[Length] + 1);
                        }
                        else
                            LOG_INFO("   The 16-bit service UUID's CANNOT fit in the advertising data.\n");

                        /* Write the advertising data to the chip.                  */
                        Result = qc_drv_ble_GAP_LE_Set_Advertising_Data(qc_api_get_qc_drv_context(), BluetoothStackID, Length, &(Advertisement_Data_Buffer.AdvertisingData));
                        if(!Result)
                        {
                            /* Initialize the scan response data.                    */
                            memset(&(Advertisement_Data_Buffer.ScanResponseData), 0, sizeof(qapi_BLE_Scan_Response_Data_t));

                            /* Reset the length to zero.                             */
                            Length = 0;

                            /* First include the local device name.                  */
                            if((Result = qc_drv_ble_GAPS_Query_Device_Name(qc_api_get_qc_drv_context(), BluetoothStackID, (uint32_t)GAPSInstanceID, Name)) == 0)
                            {
                                /* Get the name length.                               */
                                NameLength = strlen(Name);

                                /* Determine if we need to truncate the device name.  */
                                if(NameLength < ((unsigned int)QAPI_BLE_SCAN_RESPONSE_DATA_MAXIMUM_SIZE - 2))
                                {
                                    /* Format the complete device name into the scan   */
                                    /* response data.                                  */
                                    ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] = (uint8_t)(1 + NameLength);
                                    ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length + 1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_LOCAL_NAME_COMPLETE;
                                }
                                else
                                {
                                    /* Format the truncated device name into the scan  */
                                    /* response data.                                  */
                                    NameLength = ((unsigned int)QAPI_BLE_SCAN_RESPONSE_DATA_MAXIMUM_SIZE - 2);
                                    ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] = (uint8_t)(1 + NameLength);
                                    ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length + 1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_LOCAL_NAME_SHORTENED;
                                }

                                /* Make sure we can fit the device name into the scan */
                                /* response data.                                     */
                                if((Length + NameLength + 2) <= (unsigned int)(QAPI_BLE_SCAN_RESPONSE_DATA_MAXIMUM_SIZE - 2))
                                {
                                    /* Simply copy the name into the scan response     */
                                    /* data.                                           */
                                    memcpy(&(((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length + 2]), Name, NameLength);

                                    /* Update the current length of the scan response  */
                                    /* data.                                           */
                                    /* * NOTE * We MUST add one to account for the     */
                                    /*          length field, which does not include   */
                                    /*          itself.                                */
                                    Length += (((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] + 1);
                                }
                                else
                                    LOG_INFO("   The device name CANNOT fit in the scan response data.\n", Result);
                            }
                            else
                                LOG_INFO("   qapi_BLE_GAPS_Query_Device_Name(dtAdvertising) returned %d.\n", Result);

                            /* Include the 128-bit service UUIDs if the service is   */
                            /* registered.                                           */
                            /* * NOTE * SPPLE is the only 128-bit UUID supported by  */
                            /*          this demo.                                   */

                            /* If SPPLE is registered.                               */
                            if(SPPLEServiceID)
                            {
                                /* Make sure we have room in the buffer.              */
                                if((Length + (unsigned int)QAPI_BLE_UUID_128_SIZE + 2) <= (unsigned int)QAPI_BLE_SCAN_RESPONSE_DATA_MAXIMUM_SIZE)
                                {
                                    ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length]   = 1;
                                    ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length+1] = QAPI_BLE_HCI_LE_ADVERTISING_REPORT_DATA_TYPE_128_BIT_SERVICE_UUID_COMPLETE;

                                    /* Assign the SPPLE Service UUID.                  */
                                    SPPLE_ASSIGN_SPPLE_SERVICE_UUID_128(&(((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length+2]));

                                    /* Update the UUID Index.                          */
                                    UUIDIndex += QAPI_BLE_UUID_128_SIZE;

                                    /* Update the advertising report data entry length */
                                    /* since we have added another UUID.               */
                                    ((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] += QAPI_BLE_UUID_128_SIZE;

                                    /* Update the current length of the advertising    */
                                    /* data.                                           */
                                    /* * NOTE * We MUST add one to account for the     */
                                    /*          length field, which does not include   */
                                    /*          itself.                                */
                                    Length += (((uint8_t *)&Advertisement_Data_Buffer.ScanResponseData)[Length] + 1);
                                }
                                else
                                    LOG_INFO("   The 128-bit SPPLE Service UUID CANNOT fit in the scan response data.\n");
                            }

                            Result = qc_drv_ble_GAP_LE_Set_Scan_Response_Data(qc_api_get_qc_drv_context(), BluetoothStackID, Length, &(Advertisement_Data_Buffer.ScanResponseData));
                            if(!Result)
                            {
                                /* Configure the advertising channel map for the      */
                                /* default advertising parameters.                    */
#ifndef V1
                                BLEParameters.AdvertisingParameters.Advertising_Channel_Map = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_DEFAULT;
#else
                                switch(Parameter_List[0].Integer_Value)
                                {
                                    case AET_ENABLE_ALL_E:
                                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = (QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_37 | QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_38);
                                        break;
                                    case AET_ENABLE_CHANNEL_37_E:
                                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_37;
                                        break;
                                    case AET_ENABLE_CHANNEL_38_E:
                                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_38;
                                        break;
                                    case AET_ENABLE_CHANNEL_39_E:
                                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_39;
                                        break;
                                    default:
                                        /* Enable all channels if the user specified and*/
                                        /* invalid enumeration.                         */
                                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map = (QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_37 | QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_38);
                                        break;
                                }
#endif

                                /* Set up the default advertising parameters if they  */
                                /* have not been configured at the CLI.               */
                                if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID))
                                {
                                    /* Configure the remaining default advertising     */
                                    /* parameters.                                     */
                                    BLEParameters.AdvertisingParameters.Scan_Request_Filter       = QAPI_BLE_FP_NO_FILTER_E;
                                    BLEParameters.AdvertisingParameters.Connect_Request_Filter    = QAPI_BLE_FP_NO_FILTER_E;
                                    BLEParameters.AdvertisingParameters.Advertising_Interval_Min  = 100;
                                    BLEParameters.AdvertisingParameters.Advertising_Interval_Max  = 200;

                                    /* Flag that the parameters are valid so we don't  */
                                    /* set them unnecessarily.                         */
                                    BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID;
                                }

                                /* Configure the Connectability Parameters.           */
                                /* * NOTE * We will ALWAYS advertise                  */
                                ConnectabilityParameters.Connectability_Mode = LE_Parameters.ConnectableMode;
                                ConnectabilityParameters.Own_Address_Type    = QAPI_BLE_LAT_PUBLIC_E;

                                /* If the connectable mode is set for direct          */
                                /* connectable.                                       */
                                if((ConnectabilityParameters.Connectability_Mode == QAPI_BLE_LCM_LOW_DUTY_CYCLE_DIRECT_CONNECTABLE_E) || (ConnectabilityParameters.Connectability_Mode == QAPI_BLE_LCM_DIRECT_CONNECTABLE_E))
                                {
                                    /* We will set our own address type to resolvable  */
                                    /* fallback public.                                */
                                    ConnectabilityParameters.Own_Address_Type = QAPI_BLE_LAT_RESOLVABLE_FALLBACK_PUBLIC_E;
                                }

                                /* Initialize the direct address to zero and the type */
                                /* to public.                                         */
                                /* * NOTE * If the ConnectableMode is set to one of   */
                                /*          the Direct Connectable types, then the    */
                                /*          direct address and type MUST be specified.*/
                                /*          If they are NOT specified, then           */
                                /*          qapi_BLE_GAP_LE_Advertising_Enable() will */
                                /*          fail.                                     */
                                ConnectabilityParameters.Direct_Address_Type   = QAPI_BLE_LAT_PUBLIC_E;
                                QAPI_BLE_ASSIGN_BD_ADDR(ConnectabilityParameters.Direct_Address, 0, 0, 0, 0, 0, 0);

                                /* If the user has supplied the direct address and    */
                                /* direct address type we will store them.            */
                                if((Parameter_Count >= 2) && (strlen((char *)(Parameter_List[1].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
                                {
                                    /* Convert the parameter to a Bluetooth Device     */
                                    /* Address.                                        */
                                    StrToBD_ADDR((char *)(Parameter_List[1].String_Value), &BD_ADDR);

                                    /* We will assume that the user has supplied the   */
                                    /* public address of the remote device for direct  */
                                    /* advertising.                                    */
                                    ConnectabilityParameters.Direct_Address_Type = QAPI_BLE_LAT_PUBLIC_E;
                                    ConnectabilityParameters.Direct_Address      = BD_ADDR;

                                    /* Lock the Bluetooth stack.                       */
                                    if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                                    {
                                        /* Let's attempt to find the remote device      */
                                        /* information for the user specified remote    */
                                        /* device address.                              */
                                        /* * NOTE * We can only use the resolving list  */
                                        /*          in the controller to generate an RPA*/
                                        /*          if we have the identity address     */
                                        /*          information and the IRK that was    */
                                        /*          exchanged during pairing.  This     */
                                        /*          information was used to add the     */
                                        /*          remote device to the resolving list */
                                        /*          so we need to make sure that it is  */
                                        /*          valid                               */
                                        if((RemoteDevice = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
                                        {
                                            /* Make sure the remote device was added to  */
                                            /* the resolving list.                       */
                                            /* * NOTE * If this is set, then the IRK and */
                                            /*          identity information are also    */
                                            /*          valid.                           */
                                            if(RemoteDevice->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST)
                                            {
                                                /* Store the direct address and type.     */
                                                /* * NOTE * The controller will search the*/
                                                /*          resolving list for an entry   */
                                                /*          matching the identity address */
                                                /*          and identity address type.  If*/
                                                /*          an entry is found, the IRK    */
                                                /*          will be used to generate an   */
                                                /*          RPA that will be used as the  */
                                                /*          direct advertising address.   */
                                                ConnectabilityParameters.Direct_Address_Type = RemoteDevice->IdentityAddressType;
                                                ConnectabilityParameters.Direct_Address      = RemoteDevice->IdentityAddressBD_ADDR;
                                            }
                                        }

                                        /* Un-lock the Bluetooth Stack.                 */
                                        qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                                    }
                                }
                                else
                                {
                                    /* If the user did NOT supply the direct address,  */
                                    /* then we need to make sure we are NOT in the a   */
                                    /* direct connectable mode.                        */
                                    if((ConnectabilityParameters.Connectability_Mode == QAPI_BLE_LCM_LOW_DUTY_CYCLE_DIRECT_CONNECTABLE_E) || (ConnectabilityParameters.Connectability_Mode == QAPI_BLE_LCM_DIRECT_CONNECTABLE_E))
                                    {
                                        /* Override the local device's connectable mode.*/
                                        /* * NOTE * If this is NOT done, then           */
                                        /*          qapi_BLE_GAP_LE_Advertising_Enable()*/
                                        /*          will fail.                          */
                                        ConnectabilityParameters.Own_Address_Type    = QAPI_BLE_LAT_PUBLIC_E;
                                        ConnectabilityParameters.Connectability_Mode = QAPI_BLE_LCM_CONNECTABLE_E;

                                        /* Inform the user.                             */
                                        LOG_INFO("Using connectable un-directed advertising with public address.\n");
                                    }
                                }

                                /* Now enable advertising.                         */
                                Result = qc_drv_ble_GAP_LE_Advertising_Enable(qc_api_get_qc_drv_context(), BluetoothStackID, TRUE, &(BLEParameters.AdvertisingParameters), &(ConnectabilityParameters), GAP_LE_Event_Callback, 0);
                                if(!Result)
                                {
                                    LOG_INFO("   GAP_LE_Advertising_Enable success, Advertising Interval Range: %u - %u.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Min, (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Max);

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                {
                                    LOG_ERR("   GAP_LE_Advertising_Enable returned %d.\n", Result);

                                    ret_val = QCLI_STATUS_ERROR_E;
                                }
                            }
                            else
                            {
                                LOG_ERR("   qapi_BLE_GAP_LE_Set_Advertising_Data(dtScanResponse) returned %d.\n", Result);

                                ret_val = QCLI_STATUS_ERROR_E;
                            }

                        }
                        else
                        {
                            LOG_ERR("   qapi_BLE_GAP_LE_Set_Advertising_Data(dtAdvertising) returned %d.\n", Result);

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
            }
            else
            {
                ret_val = QCLI_STATUS_USAGE_E;
            }
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for starting an LE scan     */
/* procedure.  This function returns zero if successful and a        */
/* negative value if an error occurred.                              */
static QCLI_Command_Status_t ScanLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    unsigned int                    Duration;
    QCLI_Command_Status_t           ret_val;
    qapi_BLE_GAP_LE_Filter_Policy_t FilterPolicy;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Verify the command line parameters.                            */
        if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && ((Parameter_List[0].Integer_Value == 0) || (Parameter_List[0].Integer_Value == 1)))
        {
            /* Check to see if we are enabling or disabling scanning.      */
            if(Parameter_List[0].Integer_Value == 0)
            {
                /* Check to see if we are in fact in the process of         */
                /* scanning.                                                */
                if(ScanInProgress)
                {
                    /* Simply stop scanning.                                 */
                    if(!StopScan(BluetoothStackID))
                    {
                        /* Flag that scanning is not in progess.              */
                        ScanInProgress = FALSE;

                        /* Return success to the caller.                      */
                        ret_val        = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                        ret_val = QCLI_STATUS_ERROR_E;
                }
                else
                {
                    LOG_WARN("Scanning is not in progress.\n");

                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
            }
            else
            {
                /* Check to see if scanning is in progress.                 */
                if(!ScanInProgress)
                {
                    /* Determine if the optional filter policy is specified. */
                    if((Parameter_Count >= 2) && (Parameter_List) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= QAPI_BLE_FP_NO_FILTER_E) && (Parameter_List[1].Integer_Value <= QAPI_BLE_FP_WHITE_LIST_DIRECTED_RPA_E))
                    {
                        /* Store the user specified filter policy.            */
                        FilterPolicy = (qapi_BLE_GAP_LE_Filter_Policy_t)Parameter_List[1].Integer_Value;
                    }
                    else
                    {
                        /* Otherwise we will use no filter.                   */
                        FilterPolicy = QAPI_BLE_FP_NO_FILTER_E;
                    }

                    /* Check to see if an optional duration is specified.    */
                    if((Parameter_Count >= 3) && (Parameter_List) && (Parameter_List[2].Integer_Is_Valid))
                        Duration = Parameter_List[2].Integer_Value;
                    else
                        Duration = 0;

                    /* Simply start scanning.                                */
                    if(!StartScan(BluetoothStackID, FilterPolicy, Duration))
                    {
                        /* Flag that scanning is in progess.                  */
                        ScanInProgress = TRUE;

                        /* Return success to the caller.                      */
                        ret_val        = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                        ret_val = QCLI_STATUS_ERROR_E;
                }
                else
                {
                    LOG_INFO("Scan already in progress.\n");

                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t GapLeconnect(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    qapi_BLE_BD_ADDR_t    BD_ADDR;
    QCLI_Command_Status_t ret_val;
    boolean_t             UseWhiteList;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"connect") == 0)) {
            /* Next, make sure that a valid device address exists.            */
            if((Parameter_Count >= 2) && (Parameter_List) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= 1))
            {
                /* Store if the user has requested to use the White List in the*/
                /* controller.                                                 */
                if(Parameter_List[1].Integer_Value == 1)
                    UseWhiteList = TRUE;
                else
                    UseWhiteList = FALSE;

                /* Check to see if scanning is in progress, if so cancel it.   */
                if(ScanInProgress)
                {
                    /* Attempt to stop scanning.                                */
                    if(!StopScan(BluetoothStackID))
                        ScanInProgress = FALSE;

                    LOG_INFO("Scan stopped before making LE Connection\n");
                }

                /* If we are NOT using the White List in the controller, then  */
                /* the local device will send a connection request when a      */
                /* connectable advertisement is received from a remote device  */
                /* in the White List.                                          */
                /* * NOTE * A remote device and address type MUST have         */
                /*          previously been added to the White List in the     */
                /*          controller.                                        */
                if(UseWhiteList)
                {
                    /* Attempt to connect using the White List in the           */
                    /* controller.                                              */
                    /* * NOTE * The remote address and address type are NOT     */
                    /*          used.                                           */
                    if(!ConnectLEDevice(BluetoothStackID, UseWhiteList, NULL, 0))
                        ret_val = QCLI_STATUS_SUCCESS_E;
                    else
                        ret_val = QCLI_STATUS_ERROR_E;
                }
                else
                {
                    /* Make sure the remote address and address type have been  */
                    /* specified.                                               */
                    if((Parameter_Count >= 4) && (Parameter_List[2].String_Value) && (strlen((char *)(Parameter_List[2].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[3].Integer_Is_Valid) && (Parameter_List[3].Integer_Value >= QAPI_BLE_LAT_PUBLIC_E) && (Parameter_List[3].Integer_Value <= QAPI_BLE_LAT_RANDOM_IDENTITY_E))
                    {
                        /* Convert the parameter to a Bluetooth Device Address.  */
                        StrToBD_ADDR((char *)(Parameter_List[2].String_Value), &BD_ADDR);

                        /* Attempt to connect to the specified remote address and*/
                        /* address type.                                         */
                        if(!ConnectLEDevice(BluetoothStackID, UseWhiteList, &BD_ADDR, (qapi_BLE_GAP_LE_Address_Type_t)Parameter_List[3].Integer_Value))
                            ret_val = QCLI_STATUS_SUCCESS_E;
                        else
                            ret_val = QCLI_STATUS_ERROR_E;
                    }
                    else
                        ret_val = QCLI_STATUS_USAGE_E;
                }
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;
        } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"disconnect") == 0)) {
            /* Next, check to make sure we are currently connected.           */
            /* * NOTE * If we are connected, then the a remote device MUST be */
            /*          selected.                                             */
            if(ConnectionCount)
            {
                /* Disconnect the selected remote device.                      */
                ret_val = qc_drv_ble_GAP_LE_Disconnect(qc_api_get_qc_drv_context(), BluetoothStackID, SelectedRemoteBD_ADDR);
                if(!ret_val) {
                    LOG_INFO("Disconnect Request successful.\n");
                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                    LOG_ERR("Unable to disconnect device: %d.\n", ret_val);
                ret_val = QCLI_STATUS_ERROR_E;
            }
            else
            {
                LOG_ERR("Device is not connected.\n");
                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for connecting to a remote  */
/* LE device.  This function returns zero if successful and a        */
/* negative value if an error occurred.                              */
static QCLI_Command_Status_t LEServiceDeactivate(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    QCLI_Command_Status_t ret_val;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Attempt to cancel the connection process.                      */
        Result = qc_drv_ble_GAP_LE_Cancel_Create_Connection(qc_api_get_qc_drv_context(), BluetoothStackID);
        if(!Result) {
            LOG_INFO("cancel LE connection process completed\n");
            ret_val = QCLI_STATUS_SUCCESS_E;
        } else {
            LOG_ERR("Unable to cancel LE connection process: %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is provided to allow a mechanism of        */
/* Pairing (or requesting security if a slave) to the connected      */
/* device or unpair it.                                                           */
static QCLI_Command_Status_t PairLE(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t ret_val;
    DeviceInfo_t *DeviceInfo;
    BoardStr_t    BoardStr;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Next, check to make sure we are currently connected.           */
        /* * NOTE * If we are connected, then the a remote device MUST be */
        /*          selected.                                             */
        if(ConnectionCount)
        {
            /* Verify that the input parameters are semi-valid.            */
            if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value == 0))
            {
                /* Lock the Bluetooth stack.                                */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the remote device.            */
                    if((DeviceInfo = SearchDeviceInfoEntryByConnectionID(&DeviceInfoList, (unsigned int)(Parameter_List[0].Integer_Value))) != NULL)
                    {
                        /* We will simply flag that the LTK key is no longer  */
                        /* valid. This will cause the remote device           */
                        /* information to be deleted when a remote device     */
                        /* disconnects.                                       */
                        DeviceInfo->Flags &= ~((uint8_t)DEVICE_INFO_FLAGS_LTK_VALID);

                        /* Inform the user.                                   */
                        LOG_INFO("\nUnpaired Remote Device:\n");
                        BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
                        LOG_DEBUG("   Address:  %s\n", BoardStr);
                        LOG_DEBUG("   ID:       %u\n", DeviceInfo->ConnectionID);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    } else {
                        LOG_ERR("No device info for the specified GATT Connection ID.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }

                    /* Un-lock the Bluetooth Stack.                          */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                } else {
                    LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            } else if ((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) &&
                    (Parameter_List[0].Integer_Value == 1)) {
                /*PAIR*/
                /* Make sure we are not pairing/re-establishing security with  */
                /* another remote device.                                      */
                if(QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
                {
                    /* Attempt to send the pairing request.                     */
                    if(!SendPairingRequest(SelectedRemoteBD_ADDR, LocalDeviceIsMaster))
                        ret_val = QCLI_STATUS_SUCCESS_E;
                    else
                        ret_val = QCLI_STATUS_ERROR_E;
                } else {
                    /* Inform the user that we cannot pair/re-establish security*/
                    /* at this time.                                            */
                    LOG_INFO("\nSecurity is already in progress with another remote device.\n");
                    ret_val = QCLI_STATUS_ERROR_E;
                }
            } else {
                ret_val = QCLI_STATUS_USAGE_E;
            }
        } else {
            LOG_ERR("Device is not connected.\n");
            /* Flag success to the caller.                                 */
            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t DisplayRemoteDevice(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int           ret_val;
    DeviceInfo_t *DeviceInfo;
    BoardStr_t    BoardStr;
    unsigned int           Index;


    if(Parameter_Count == 1) {
        /* First, check that valid Bluetooth Stack ID exists.                */
        if(BluetoothStackID)
        {
            /* Next, check to make sure we are currently connected.           */
            /* * NOTE * If we are connected, then the a remote device MUST be */
            /*          selected.                                             */
            if(ConnectionCount)
            {
                /* Verify that the input parameters are semi-valid.            */
                if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value > 0))
                {
                    /* Lock the Bluetooth stack.                                */
                    if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                    {
                        /* Get the device info for the remote device.            */
                        if((DeviceInfo = SearchDeviceInfoEntryByConnectionID(&DeviceInfoList, (unsigned int)(Parameter_List[0].Integer_Value))) != NULL)
                        {
                            /* Simply update the address of the selected remote   */
                            /* device.                                            */
                            SelectedRemoteBD_ADDR = DeviceInfo->RemoteAddress;

                            /* Inform the user of the selected remote device.     */
                            LOG_INFO("\nSelected Remote Device:\n");
                            BD_ADDRToStr(SelectedRemoteBD_ADDR, BoardStr);
                            LOG_INFO("   Address:  %s\n", BoardStr);
                            LOG_INFO("   ID:       %u\n", DeviceInfo->ConnectionID);

                            ret_val               = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                            LOG_ERR("No device info for the specified GATT Connection ID.\n");

                            ret_val = QCLI_STATUS_ERROR_E;
                        }

                        /* Un-lock the Bluetooth Stack.                          */
                        qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                    }
                    else
                    {
                        LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                    ret_val = QCLI_STATUS_USAGE_E;
            }
            else
            {
                LOG_INFO("No Connection Established.\n");

                /* Flag success to the caller.                                 */
                ret_val = QCLI_STATUS_SUCCESS_E;
            }
        }
        else
            ret_val = QCLI_STATUS_ERROR_E;
    } else if (Parameter_Count == 0) {
        if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
        {
            /* Loop through the device information list.                      */
            DeviceInfo = DeviceInfoList;
            Index      = 0;
            while(DeviceInfo)
            {
                /* Display the information for the remote device.              */
                LOG_INFO("\nDevice Information Entry (%u):\n", Index++);
                LOG_INFO("   Selected:   %s\n", ((QAPI_BLE_COMPARE_BD_ADDR(SelectedRemoteBD_ADDR, DeviceInfo->RemoteAddress)) ? "Yes" : "No"));
                BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
                LOG_INFO("   Address:    %s\n", BoardStr);
                LOG_INFO("   Type:       ");
                switch(DeviceInfo->RemoteAddressType)
                {
                    case QAPI_BLE_LAT_PUBLIC_E:
                        LOG_INFO("QAPI_BLE_LAT_PUBLIC_E\n");
                        break;
                    case QAPI_BLE_LAT_RANDOM_E:
                        LOG_INFO("QAPI_BLE_LAT_RANDOM_E\n");
                        break;
                    case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                        LOG_INFO("QAPI_BLE_LAT_PUBLIC_IDENTITY_E\n");
                        break;
                    case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                        LOG_INFO("QAPI_BLE_LAT_RANDOM_IDENTITY_E\n");
                        break;
                    default:
                        LOG_WARN("Invalid\n");
                        break;
                }
                LOG_INFO("   Connected:  %s\n", (DeviceInfo->ConnectionID) ? "Yes" : "No");
                LOG_INFO("   ID:         %u\n", DeviceInfo->ConnectionID);
                LOG_INFO("   LTK:        %s\n", (DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_LTK_VALID) ? "Yes" : "No");

                if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_LTK_VALID)
                {
                    LOG_INFO("   LTK:        0x%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n", DeviceInfo->LTK.Long_Term_Key0,
                            DeviceInfo->LTK.Long_Term_Key1,
                            DeviceInfo->LTK.Long_Term_Key2,
                            DeviceInfo->LTK.Long_Term_Key3,
                            DeviceInfo->LTK.Long_Term_Key4,
                            DeviceInfo->LTK.Long_Term_Key5,
                            DeviceInfo->LTK.Long_Term_Key6,
                            DeviceInfo->LTK.Long_Term_Key7,
                            DeviceInfo->LTK.Long_Term_Key8,
                            DeviceInfo->LTK.Long_Term_Key9,
                            DeviceInfo->LTK.Long_Term_Key10,
                            DeviceInfo->LTK.Long_Term_Key11,
                            DeviceInfo->LTK.Long_Term_Key12,
                            DeviceInfo->LTK.Long_Term_Key13,
                            DeviceInfo->LTK.Long_Term_Key14,
                            DeviceInfo->LTK.Long_Term_Key15);


                }

                LOG_INFO("   IRK:        %s\n", (DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_IRK_VALID) ? "Yes" : "No");

                if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_IRK_VALID)
                {
                    BD_ADDRToStr(DeviceInfo->IdentityAddressBD_ADDR, BoardStr);
                    LOG_INFO("   Identity Address:      %s\n", BoardStr);

                    switch(DeviceInfo->IdentityAddressType)
                    {
                        case QAPI_BLE_LAT_PUBLIC_E:
                            LOG_INFO("   Identity Address Type: %s\n", "Public");
                            break;
                        case QAPI_BLE_LAT_RANDOM_E:
                            LOG_INFO("   Identity Address Type: %s\n", "Random");
                            break;
                        case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                            LOG_INFO("   Identity Address Type: %s\n", "Public Identity");
                            break;
                        case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                            LOG_INFO("   Identity Address Type: %s\n", "Random Identity");
                            break;
                        default:
                            LOG_INFO("   Identity Address Type: %s\n", "Default");
                            break;
                    }
                }

                DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
            }

            /* Un-lock the Bluetooth Stack.                                   */
            qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);

            /* Return success to the caller.                                  */
            ret_val = QCLI_STATUS_SUCCESS_E;
        }
        else
        {
            LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;

        }
    } else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t DeviceList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    uint32_t                            RemovedDeviceCount;
    uint32_t                            AddedDeviceCount;
    DeviceInfo_t                       *DeviceInfo;
    qapi_BLE_BD_ADDR_t                  BD_ADDR;
    QCLI_Command_Status_t               ret_val;
    qapi_BLE_GAP_LE_Address_Type_t      AddressType;
    qapi_BLE_GAP_LE_White_List_Entry_t  WhiteListEntry;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Verify that the input parameters are semi-valid.               */
        if((Parameter_Count >= 2) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[1].Integer_Is_Valid) && ((Parameter_List[1].Integer_Value == 255) || ((Parameter_List[1].Integer_Value >= (int32_t)QAPI_BLE_LAT_PUBLIC_E) && (Parameter_List[1].Integer_Value <= (int32_t)QAPI_BLE_LAT_RANDOM_IDENTITY_E))))
        {
            /* Convert the parameter to a Bluetooth Device Address.        */
            StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

            /* Convert the address type.                                   */
            if(Parameter_List[1].Integer_Value == 255)
                AddressType = QAPI_BLE_LAT_ANONYMOUS_E;
            else
                AddressType = (qapi_BLE_GAP_LE_Address_Type_t)Parameter_List[1].Integer_Value;

            /* Initialize the Device Info Pointer.                         */
            DeviceInfo  = NULL;

            /* Lock the Bluetooth stack.                                   */
            if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
            {
                /* Check to see if we are adding anonymous device entry.    */
                if(AddressType != QAPI_BLE_LAT_ANONYMOUS_E)
                {
                    /* Get the device info for the remote device.            */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
                    {
                        /* Make sure the remote device is NOT already in the  */
                        /* white list.                                        */
                        if(!(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST))
                        {
                            /* Format the white list entry.                    */
                            if((DeviceInfo->Flags & (DEVICE_INFO_FLAGS_IRK_VALID | DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST)) == (DEVICE_INFO_FLAGS_IRK_VALID | DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST))
                            {
                                DeviceInfo->WhiteListEntry.Address      = DeviceInfo->IdentityAddressBD_ADDR;
                                DeviceInfo->WhiteListEntry.Address_Type = DeviceInfo->IdentityAddressType;
                            }
                            else
                            {
                                DeviceInfo->WhiteListEntry.Address      = BD_ADDR;
                                DeviceInfo->WhiteListEntry.Address_Type = AddressType;
                            }

#ifdef V2

                            /* Configure as wakeup source.                     */
                            DeviceInfo->WhiteListEntry.WakeOnBLESource = TRUE;

#endif

                            /* Indicate we have been successful so far.        */
                            WhiteListEntry = DeviceInfo->WhiteListEntry;

                            ret_val        = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                            LOG_ERR("Device already in the white list.\n");

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        LOG_ERR("No Device Info.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                {
                    /* Initialize the entry.                                 */
                    WhiteListEntry.Address_Type    = QAPI_BLE_LAT_ANONYMOUS_E;
                    QAPI_BLE_ASSIGN_BD_ADDR(WhiteListEntry.Address, 0, 0, 0, 0, 0, 0);

#ifdef V2
                    WhiteListEntry.WakeOnBLESource = FALSE;
#endif

                    /* Indicate we are ready to send the command.            */
                    ret_val                        = QCLI_STATUS_SUCCESS_E;
                }

                /* Continue only if no error occurred.                      */
                if(ret_val == QCLI_STATUS_SUCCESS_E)
                {
                    /* Let's add the device to the white list in the         */
                    /* controller.                                           */
                    /* * NOTE * We will only add one device, however we could*/
                    /*          add more with this function.                 */
                    ret_val = qc_drv_ble_GAP_LE_Add_Device_To_White_List(qc_api_get_qc_drv_context(), BluetoothStackID, 1, &WhiteListEntry, &AddedDeviceCount);
                    if(!ret_val)
                    {
                        LOG_INFO("   Added devices:  %u.\n", (unsigned int)AddedDeviceCount);

                        /* Flag that the remote device has been added to the  */
                        /* white list.                                        */
                        if(DeviceInfo != NULL)
                            DeviceInfo->Flags |= (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST;

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                    {
                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }

                /* Un-lock the Bluetooth Stack.                             */
                qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
            }
            else
            {
                LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else if((Parameter_Count >= 1) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2))) {
            /* Convert the parameter to a Bluetooth Device Address.        */
            StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

            /* Initialize the local variables.                             */
            DeviceInfo = NULL;

            /* Lock the Bluetooth stack.                                   */
            if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
            {
                /* Check to see if we are removing the anonymous device.    */
                if(!QAPI_BLE_COMPARE_NULL_BD_ADDR(BD_ADDR))
                {
                    /* Get the device info for the remote device.            */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
                    {
                        /* Make sure the remote device has been added to the  */
                        /* white list.                                        */
                        if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST)
                        {
                            /* Use local white list entry structure.           */
                            WhiteListEntry = DeviceInfo->WhiteListEntry;

                            /* Indicate we may send the command now.           */
                            ret_val        = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                            LOG_ERR("Device not in the white list.\n");

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        LOG_ERR("No Device Info.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                {
                    /* Initialize the entry.                                 */
                    WhiteListEntry.Address_Type    = QAPI_BLE_LAT_ANONYMOUS_E;
                    QAPI_BLE_ASSIGN_BD_ADDR(WhiteListEntry.Address, 0, 0, 0, 0, 0, 0);

#ifdef V2
                    WhiteListEntry.WakeOnBLESource = FALSE;
#endif

                    /* Indicate we are ready to send the command.            */
                    ret_val                        = QCLI_STATUS_SUCCESS_E;
                }

                /* Continue only if no error occurred.                      */
                if(ret_val == QCLI_STATUS_SUCCESS_E)
                {
                    /* Let's remove the device from the white list in the    */
                    /* controller.                                           */
                    /* * NOTE * We will only remove one device, however we   */
                    /*          could remove more with this function.        */
                    ret_val = qc_drv_ble_GAP_LE_Remove_Device_From_White_List(qc_api_get_qc_drv_context(), BluetoothStackID, 1, &WhiteListEntry, &RemovedDeviceCount);
                    if(!ret_val)
                    {
                        LOG_INFO("   Removed devices:  %u.\n", (unsigned int)RemovedDeviceCount);

                        /* Flag that the remote device has been removed from  */
                        /* the white list.                                    */
                        if(DeviceInfo != NULL)
                            DeviceInfo->Flags &= ~((uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_WHITE_LIST);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                    {
                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }

                /* Un-lock the Bluetooth Stack.                             */
                qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
            }
            else
            {
                LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t AddRemoveDeviceToResolvingList(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    uint32_t              RemovedDeviceCount;
    uint32_t              AddedDeviceCount;
    DeviceInfo_t         *DeviceInfo;
    qapi_BLE_BD_ADDR_t    BD_ADDR;
    QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Verify that the input parameters are semi-valid.               */
        if ((Parameter_Count >= 2) && (Parameter_List[0].Integer_Value == 1)) {
            if((Parameter_Count >= 2) && (strlen((char *)(Parameter_List[1].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
            {
                /* Convert the parameter to a Bluetooth Device Address.        */
                StrToBD_ADDR((char *)(Parameter_List[1].String_Value), &BD_ADDR);

                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the remote device.               */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
                    {
                        /* Make sure the remote device is NOT already in the     */
                        /* resolving list.                                       */
                        if(!(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST))
                        {
                            /* Make sure the remote device has the IRK, which was */
                            /* exchanged during pairing.                          */
                            /* * NOTE * If we have the IRK for the remote device, */
                            /*          then we also have the Identity            */
                            /*          Information.                              */
                            if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_IRK_VALID)
                            {
                                /* Let's add the device to the resolving list in   */
                                /* the controller.                                 */
                                /* * NOTE * We will only add one device, however we*/
                                /*          could add more with this function.     */
                                ret_val = qc_drv_ble_GAP_LE_Add_Device_To_Resolving_List(qc_api_get_qc_drv_context(), BluetoothStackID, 1, &(DeviceInfo->ResolvingListEntry), &AddedDeviceCount);
                                if(!ret_val)
                                {
                                    LOG_INFO("   Added devices:  %u.\n", (unsigned int)AddedDeviceCount);

                                    /* Flag that the remote device has been added to*/
                                    /* the resolving list.                          */
                                    DeviceInfo->Flags |= (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST;

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                {
                                    LOG_ERR("Error - qapi_BLE_GAP_LE_Add_Device_To_Resolving_List() returned %d.\n", ret_val);

                                    ret_val = QCLI_STATUS_ERROR_E;
                                }
                            }
                            else
                                ret_val = QCLI_STATUS_ERROR_E;
                        }
                        else
                        {
                            LOG_ERR("Device already in the resolving list.\n");

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        LOG_ERR("No Device Info.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                {
                    LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;
        } else if ((Parameter_Count >= 2) && (Parameter_List[0].Integer_Value == 0)) {
            if((Parameter_Count >= 2) && (strlen((char *)(Parameter_List[1].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)))
            {
                /* Convert the parameter to a Bluetooth Device Address.        */
                StrToBD_ADDR((char *)(Parameter_List[1].String_Value), &BD_ADDR);

                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the remote device.               */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BD_ADDR)) != NULL)
                    {
                        /* Make sure the remote device has been added to the     */
                        /* resolving list.                                       */
                        if(DeviceInfo->Flags & (uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST)
                        {
                            /* Let's remove the device from the resolving list in */
                            /* the controller.                                    */
                            /* * NOTE * We will only remove one device, however we*/
                            /*          could remove more with this function.     */
                            ret_val = qc_drv_ble_GAP_LE_Remove_Device_From_Resolving_List(qc_api_get_qc_drv_context(), BluetoothStackID, 1, &(DeviceInfo->ResolvingListEntry), &RemovedDeviceCount);
                            if(!ret_val)
                            {
                                LOG_INFO("qapi_BLE_GAP_LE_Remove_Device_From_Resolving_List() success.\n");
                                LOG_INFO("   Removed devices:  %u.\n", (unsigned int)RemovedDeviceCount);

                                /* Flag that the remote device has been removed    */
                                /* from the resolving list.                        */
                                DeviceInfo->Flags &= ~((uint8_t)DEVICE_INFO_FLAGS_ADDED_TO_RESOLVING_LIST);

                                ret_val = QCLI_STATUS_SUCCESS_E;
                            }
                            else
                            {
                                LOG_ERR("Error - qapi_BLE_GAP_LE_Remove_Device_From_Resolving_List() returned %d.\n", ret_val);

                                ret_val = QCLI_STATUS_ERROR_E;
                            }
                        }
                        else
                        {
                            LOG_ERR("Device not in the resolving list.\n");

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        LOG_ERR("No Device Info.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                {
                    LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;
        } else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for setting the             */
/* authenticated payload timeout.  This function will return zero on */
/* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t SetAuthenticatedPayloadTimeout(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t ret_val;
    qapi_BLE_BD_ADDR_t    BD_ADDR;
    uint16_t              Timeout;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Make sure we are connected.                                    */
        if(ConnectionCount)
        {
            /* Verify that the input parameters are semi-valid.            */
            if((Parameter_Count >= 2) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1))
            {
                /* Convert the parameter to a Bluetooth Device Address.     */
                StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

                /* Store the Timeout.                                       */
                Timeout = (uint16_t)Parameter_List[1].Integer_Value;

                /* Let's set the Authenticated Payload Timeout for the      */
                /* specified remote device.                                 */
                ret_val = qc_drv_ble_GAP_LE_Set_Authenticated_Payload_Timeout(qc_api_get_qc_drv_context(), BluetoothStackID, BD_ADDR, Timeout);
                if(!ret_val)
                {
                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;
        }
        else
        {
            LOG_INFO("No Connection Established.\n");

            /* Flag success to the caller.                                 */
            ret_val = QCLI_STATUS_SUCCESS_E;
        }
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t SetGetScanParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    uint16_t              ScanInterval;
    uint16_t              ScanWindow;
    QCLI_Command_Status_t ret_val = QCLI_STATUS_SUCCESS_E;

    /* First check to see if the parameters required for the execution of*/
    /* this function appear to be semi-valid.                            */
    if(BluetoothStackID)
    {
        /* Next check to see if the parameters required for the execution */
        /* of this function appear to be semi-valid.                      */
        if((Parameter_Count >= 2) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid))
        {
            /* Assign the parameters into temporary variables.             */
            ScanInterval = (uint16_t)Parameter_List[0].Integer_Value;
            ScanWindow   = (uint16_t)Parameter_List[1].Integer_Value;

            /* Next make sure that the Scan Window is less than the Scan   */
            /* Interval.                                                   */
            if(ScanWindow <= ScanInterval)
            {
                /* Next verify the Scan Window against the min and max in   */
                /* the specification.                                       */
                if((ScanWindow >= QAPI_BLE_MINIMUM_LE_SCAN_WINDOW) && (ScanWindow <= QAPI_BLE_MAXIMUM_LE_SCAN_WINDOW))
                {
                    /* Next verify the Scan Interval against the min and max */
                    /* in the specification.                                 */
                    if((ScanInterval >= QAPI_BLE_MINIMUM_LE_SCAN_INTERVAL) && (ScanInterval <= QAPI_BLE_MAXIMUM_LE_SCAN_INTERVAL))
                    {
                        /* Parameters are valid so store them.                */
                        BLEParameters.ScanParameters.ScanWindow   = ScanWindow;
                        BLEParameters.ScanParameters.ScanInterval = ScanInterval;

                        /* Flag that the parameters are valid.                */
                        BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID;

                        /* Print the new parameters.                          */
                        LOG_INFO("Scan Window:   %u ms.\n", (unsigned int)BLEParameters.ScanParameters.ScanWindow);
                        LOG_INFO("Scan Interval: %u ms.\n", (unsigned int)BLEParameters.ScanParameters.ScanInterval);

                        /* Flag that the function was successful.             */
                        ret_val = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                    {
                        LOG_ERR("Scan Interval (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)ScanInterval, (unsigned int)QAPI_BLE_MINIMUM_LE_SCAN_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_LE_SCAN_INTERVAL);

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                {
                    LOG_ERR("Scan Window (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)ScanWindow, (unsigned int)QAPI_BLE_MINIMUM_LE_SCAN_WINDOW, (unsigned int)QAPI_BLE_MAXIMUM_LE_SCAN_WINDOW);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("Scan Window (%u ms) MUST be less than or equal to Scan Interval (%u ms).\n", (unsigned int)ScanWindow, (unsigned int)ScanInterval);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else if (Parameter_Count == 0) {
            if(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID)
            {
                /* Print the new parameters.                                   */
                LOG_INFO("Scan Window:   %u ms.\n", (unsigned int)BLEParameters.ScanParameters.ScanWindow);
                LOG_INFO("Scan Interval: %u ms.\n", (unsigned int)BLEParameters.ScanParameters.ScanInterval);
            }
            else
            {
                LOG_INFO("Scan Parameters have not been configured.\n");
            }
        }
        else
            /* Flag that the function was successful.                         */
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t SetGetAdvertisingParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    uint16_t              AdvIntervalMin;
    uint16_t              AdvIntervalMax;
    QCLI_Command_Status_t ret_val = QCLI_STATUS_SUCCESS_E;

    /* First check to see if the parameters required for the execution of*/
    /* this function appear to be semi-valid.                            */
    if(BluetoothStackID)
    {
        /* Next check to see if the parameters required for the execution */
        /* of this function appear to be semi-valid.                      */
        if((Parameter_Count >= 2) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid))
        {
            /* Assign the parameters into temporary variables.             */
            AdvIntervalMin = (uint16_t)Parameter_List[0].Integer_Value;
            AdvIntervalMax = (uint16_t)Parameter_List[1].Integer_Value;

            /* Next make sure that the Min is less than the Max.           */
            if(AdvIntervalMin <= AdvIntervalMax)
            {
                /* Next verify the Minimum Advertising Interval against the */
                /* min and max in the specification.                        */
                if((AdvIntervalMin >= QAPI_BLE_MINIMUM_ADVERTISING_INTERVAL) && (AdvIntervalMin <= QAPI_BLE_MAXIMUM_ADVERTISING_INTERVAL))
                {
                    /* Next verify the Maximum Advertising Interval against  */
                    /* the min and max in the specification.                 */
                    if((AdvIntervalMax >= QAPI_BLE_MINIMUM_ADVERTISING_INTERVAL) && (AdvIntervalMax <= QAPI_BLE_MAXIMUM_ADVERTISING_INTERVAL))
                    {
                        /* Configure the advertising parameters.              */
#ifndef V1
                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map   = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_DEFAULT;
#else
                        BLEParameters.AdvertisingParameters.Advertising_Channel_Map   = (QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_37 | QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_38);
#endif
                        BLEParameters.AdvertisingParameters.Scan_Request_Filter       = QAPI_BLE_FP_NO_FILTER_E;
                        BLEParameters.AdvertisingParameters.Connect_Request_Filter    = QAPI_BLE_FP_NO_FILTER_E;
                        BLEParameters.AdvertisingParameters.Advertising_Interval_Min  = AdvIntervalMin;
                        BLEParameters.AdvertisingParameters.Advertising_Interval_Max  = AdvIntervalMax;

                        /* Flag that the parameters are valid.                */
                        BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID;

                        /* Print the new parameters.                          */
                        LOG_INFO("Minimum Advertising Interval: %u ms.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Min);
                        LOG_INFO("Maximum Advertising Interval: %u ms.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Max);

                        /* Flag that the function was successful.             */
                        ret_val = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                    {
                        LOG_ERR("Advertising Interval Max (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)AdvIntervalMax, (unsigned int)QAPI_BLE_MINIMUM_ADVERTISING_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_ADVERTISING_INTERVAL);

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                {
                    LOG_ERR("Advertising Interval Min (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)AdvIntervalMin, (unsigned int)QAPI_BLE_MINIMUM_ADVERTISING_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_ADVERTISING_INTERVAL);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("Minimum Advertising Interval (%u ms) MUST be less than or equal to the Maximum Advertising Interval (%u ms).\n", (unsigned int)AdvIntervalMin, (unsigned int)AdvIntervalMax);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else if (Parameter_Count == 0) {
            /* Check to see if the scan parameters are valid.                 */
            if(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_ADVERTISING_PARAMETERS_VALID)
            {
                /* Print the new parameters.                                   */
                LOG_INFO("Minimum Advertising Interval: %u ms.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Min);
                LOG_INFO("Maximum Advertising Interval: %u ms.\n", (unsigned int)BLEParameters.AdvertisingParameters.Advertising_Interval_Max);
            }
            else
            {
                LOG_ERR("Advertising Parameters have not been configured.\n");
                ret_val = QCLI_STATUS_ERROR_E;
            }

        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t SetGetConnectionParameters(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    uint16_t              ConnIntervalMin;
    uint16_t              ConnIntervalMax;
    uint16_t              SlaveLatency;
    QCLI_Command_Status_t ret_val;

    /* First check to see if the parameters required for the execution of*/
    /* this function appear to be semi-valid.                            */
    if(BluetoothStackID)
    {
        /* Next check to see if the parameters required for the execution */
        /* of this function appear to be semi-valid.                      */
        if((Parameter_Count >= 3) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid))
        {
            /* Assign the parameters into temporary variables.             */
            ConnIntervalMin = (uint16_t)Parameter_List[0].Integer_Value;
            ConnIntervalMax = (uint16_t)Parameter_List[1].Integer_Value;
            SlaveLatency    = (uint16_t)Parameter_List[2].Integer_Value;

            /* Next make sure that the Min is less than the Max.           */
            if(ConnIntervalMin <= ConnIntervalMax)
            {
                /* Next verify the Minimum Connection Interval against the  */
                /* min and max in the specification.                        */
                if((ConnIntervalMin >= QAPI_BLE_MINIMUM_MINIMUM_CONNECTION_INTERVAL) && (ConnIntervalMin <= QAPI_BLE_MAXIMUM_MINIMUM_CONNECTION_INTERVAL))
                {
                    /* Next verify the Maximum Connection Interval against   */
                    /* the min and max in the specification.                 */
                    if((ConnIntervalMax >= QAPI_BLE_MINIMUM_MAXIMUM_CONNECTION_INTERVAL) && (ConnIntervalMax <= QAPI_BLE_MAXIMUM_MAXIMUM_CONNECTION_INTERVAL))
                    {
                        /* Finally verify that the Slave Latency value is     */
                        /* valid.                                             */
                        if(SlaveLatency <= QAPI_BLE_MAXIMUM_SLAVE_LATENCY)
                        {
                            /* Configure the Connection parameters.            */
                            BLEParameters.ConnectionParameters.Connection_Interval_Min    = ConnIntervalMin;
                            BLEParameters.ConnectionParameters.Connection_Interval_Max    = ConnIntervalMax;
                            BLEParameters.ConnectionParameters.Minimum_Connection_Length  = 0;
                            BLEParameters.ConnectionParameters.Maximum_Connection_Length  = 10000;
                            BLEParameters.ConnectionParameters.Slave_Latency              = SlaveLatency;
                            BLEParameters.ConnectionParameters.Supervision_Timeout        = 20000;

                            /* Flag that the parameters are valid.             */
                            BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID;

                            /* Print the new parameters.                       */
                            LOG_INFO("Minimum Connection Interval: %u ms.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Min);
                            LOG_INFO("Maximum Connection Interval: %u ms.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Max);
                            LOG_INFO("Slave Latency:               %u connection events.\n", (unsigned int)BLEParameters.ConnectionParameters.Slave_Latency);

                            /* Flag that the function was successful.          */
                            ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                            LOG_ERR("Slave Latency (%u connection events) MUST be in range [%u, %u] connection events.\n", (unsigned int)SlaveLatency, (unsigned int)QAPI_BLE_MINIMUM_SLAVE_LATENCY, (unsigned int)QAPI_BLE_MAXIMUM_SLAVE_LATENCY);

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        LOG_ERR("Connection Interval Max (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)ConnIntervalMax, (unsigned int)QAPI_BLE_MINIMUM_MAXIMUM_CONNECTION_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_MAXIMUM_CONNECTION_INTERVAL);

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                {
                    LOG_ERR("Connection Interval Min (%u ms) MUST be in range [%u, %u] ms.\n", (unsigned int)ConnIntervalMin, (unsigned int)QAPI_BLE_MINIMUM_MINIMUM_CONNECTION_INTERVAL, (unsigned int)QAPI_BLE_MAXIMUM_MINIMUM_CONNECTION_INTERVAL);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("Minimum Connection Interval (%u ms) MUST be less than or equal to the Maximum Connection Interval (%u ms).\n", (unsigned int)ConnIntervalMin, (unsigned int)ConnIntervalMax);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else if (Parameter_Count == 0) {
            /* Check to see if the scan parameters are valid.                 */
            if(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID)
            {
                /* Print the new parameters.                                   */
                LOG_INFO("Minimum Connection Interval: %u ms.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Min);
                LOG_INFO("Maximum Connection Interval: %u ms.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Max);
                LOG_INFO("Slave Latency:               %u connection events.\n", (unsigned int)BLEParameters.ConnectionParameters.Slave_Latency);
            }
            else
            {
                LOG_ERR("Connection Parameters have not been configured.\n");
            }

            /* Flag that the function was successful.                         */
            ret_val = QCLI_STATUS_SUCCESS_E;

        } else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is provided to enable a wakeup period to   */
/* wakeup for data transfer.  This function returns                  */
/* QCLI_STATUS_SUCCESS_E on success or an error enumeration if an    */
/* error occurs.                                                     */
static QCLI_Command_Status_t SetTestDataPeriod(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    uint16_t                 _ConnectionHandle;
    qapi_Status_t            Result;
    qapi_BLE_BD_ADDR_t       BD_ADDR;
    QCLI_Command_Status_t    ret_val;
    qapi_TIMER_set_attr_t    Set_Timer_Attr;
    qapi_TIMER_define_attr_t Create_Timer_Attr;

    /* Next check to see if the parameters required for the execution of */
    /* this function appear to be semi-valid.                            */
    if((Parameter_Count >= 2) && (Parameter_List) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[1].Integer_Is_Valid))
    {
        /* Convert the parameter to a Bluetooth Device Address.           */
        StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &BD_ADDR);

        //      if((Parameter_Count == 2) || ((Parameter_Count >= 3) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= 1) && (Parameter_List[2].Integer_Value <= MaxACLPacketSize)))
        if(((Parameter_Count >= 3) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= 1) && (Parameter_List[2].Integer_Value <= MaxACLPacketSize)))
        {
            if(Parameter_Count == 2)
                PacketLength = 27;
            else
                PacketLength = Parameter_List[2].Integer_Value;

            if(!qc_drv_ble_GAP_LE_Query_Connection_Handle(qc_api_get_qc_drv_context(), BluetoothStackID, BD_ADDR, &_ConnectionHandle))
            {
                /* Check to see if we are starting or stopping the timer.   */
                if(Parameter_List[1].Integer_Value == 0)
                {
                    /* See if the timer is started.                          */
                    if(TransmitPeriod != 0)
                    {
                        /* Stop the timer.                                    */
                        qapi_Timer_Stop(PeriodicSendTimer);

                        /* Clean up the timer.                                */
                        qapi_Timer_Undef(PeriodicSendTimer);

                        TransmitPeriod = 0;

                        LOG_INFO("Timer stopped.\n");
                    }
                    else
                        LOG_WARN("Timer already stopped.\n");

                    CurrentTest      = CURRENT_TEST_NONE;
                    ConnectionHandle = QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE;

                    ret_val          = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    /* Verify that the timer isn't already started.          */
                    if((TransmitPeriod == 0) && (CurrentTest == CURRENT_TEST_NONE))
                    {
                        /* Create the timer.                                  */
                        Create_Timer_Attr.deferrable     = false;
                        Create_Timer_Attr.cb_type        = QAPI_TIMER_FUNC1_CB_TYPE;
                        Create_Timer_Attr.sigs_func_ptr  = (void *)Period_Tx_Callback;
                        Create_Timer_Attr.sigs_mask_data = 0;
                        Result = qapi_Timer_Def(&(PeriodicSendTimer), &Create_Timer_Attr);

                        /* Verify that the timer was started successfully.    */
                        if(Result == QAPI_OK)
                        {
                            /* Start the timer for periodic transmissions.     */
                            Set_Timer_Attr.time                   = (uint64_t)Parameter_List[1].Integer_Value;
                            Set_Timer_Attr.reload                 = true;
                            Set_Timer_Attr.max_deferrable_timeout = (uint64_t)Parameter_List[1].Integer_Value;
                            Set_Timer_Attr.unit                   = QAPI_TIMER_UNIT_MSEC;
                            Result = qapi_Timer_Set(PeriodicSendTimer, &Set_Timer_Attr);

                            /* Start the timer.                                */
                            if(Result == QAPI_OK)
                            {
                                /* Set the timer period.                        */
                                TransmitPeriod = Parameter_List[1].Integer_Value;

                                CurrentTest                 = CURRENT_TEST_PERIODIC;
                                StartTime                   = qurt_timer_get_ticks();
                                NumberBytes                 = 0;
                                NumberOutstandingACLPackets = 0;

                                /* Note the connection Handle.                  */
                                ConnectionHandle            = _ConnectionHandle;

                                LOG_INFO("Timer started with period %u.\n", (unsigned int)TransmitPeriod);

                                LOG_INFO("Starting ACL Periodic TX Test, packet size: %u.\n", PacketLength);

                                ret_val = QCLI_STATUS_SUCCESS_E;
                            }
                            else
                            {
                                /* Clean up the timer.                          */
                                qapi_Timer_Undef(PeriodicSendTimer);

                                Display_Function_Error("qapi_Timer_Set", Result);

                                ret_val = QCLI_STATUS_ERROR_E;
                            }
                        }
                        else
                        {
                            Display_Function_Error("qapi_Timer_Def", Result);

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        if(TransmitPeriod != 0)
                            LOG_INFO("Timer already started with period %u.\n", (unsigned int)TransmitPeriod);
                        else
                            LOG_INFO("Test already in progress.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
            }
            else
            {
                LOG_ERR("Device is not currently connected.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            LOG_ERR("Data Packet Size must be between 1 and  %u.\n", MaxACLPacketSize);

            ret_val = QCLI_STATUS_ERROR_E;
        }
    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is provided to set the suggested Tx Packet */
/* Size for an LE connection.  This function returns                 */
/* QCLI_STATUS_SUCCESS_E on success or an error enumeration if an    */
/* error occurs.                                                     */
static QCLI_Command_Status_t SetDataLength(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    QCLI_Command_Status_t ret_val;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Next, check to make sure we are currently connected.           */
        /* * NOTE * If we are connected, then the a remote device MUST be */
        /*          selected.                                             */
        if(ConnectionCount)
        {
            /* Next check to see if the parameters required for the        */
            /* execution of this function appear to be semi-valid.         */
            if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
            {
                Result = qc_drv_ble_GAP_LE_Set_Data_Length(qc_api_get_qc_drv_context(), BluetoothStackID, SelectedRemoteBD_ADDR, (uint16_t)(Parameter_List[0].Integer_Value), (uint16_t)((8 + 2 + Parameter_List[0].Integer_Value + 4) * 8));
                if(!Result)
                {
                    LOG_INFO("Suggest Tx Packet Size     : %u.\n", (unsigned int)Parameter_List[0].Integer_Value);
                    LOG_INFO("Suggest Tx Packet Time (us): %u.\n", (unsigned int)((8 + 2 + Parameter_List[0].Integer_Value + 4) * 8));

                    /* Flag that the function was successful.                */
                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    LOG_ERR("Error - qapi_BLE_GAP_LE_Set_Data_Length() returned %d.\n", Result);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;
        }
        else
        {
            LOG_ERR("Device is not connected.\n");
            ret_val = QCLI_STATUS_ERROR_E;
        }
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t PersistentDataService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    uint8_t                NumberDevices;
    uint8_t                Index;
    DeviceInfo_t          *DeviceInfo;
    qapi_Status_t          Result;
    PersistentData_t      *PersistentData;
    QCLI_Command_Status_t  ret_val;
    uint32_t               DataSize;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {

        if((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"store") == 0)) {
            /* Now make sure the storage handle is initialized.               */
            if(PersistHandle)
            {
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    DeviceInfo    = DeviceInfoList;
                    NumberDevices = 0;

                    while(DeviceInfo)
                    {
                        ++NumberDevices;
                        DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
                    }

                    if((PersistentData = (PersistentData_t *)malloc(PERSISTENT_DATA_SIZE(NumberDevices))) != NULL)
                    {
                        memset(PersistentData, 0, PERSISTENT_DATA_SIZE(NumberDevices));

                        PersistentData->LocalAddress        = LocalBD_ADDR;
                        PersistentData->NumberRemoteDevices = NumberDevices;

                        DeviceInfo = DeviceInfoList;
                        Index      = 0;

                        while(DeviceInfo)
                        {
                            PersistentData->RemoteDevices[Index].LastAddress     = DeviceInfo->RemoteAddress;
                            PersistentData->RemoteDevices[Index].LastAddressType = DeviceInfo->RemoteAddressType;

                            if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                            {
                                PersistentData->RemoteDevices[Index].Flags             |= PERSISTENT_REMOTE_DEVICE_DATA_FLAG_LTK_VALID;
                                PersistentData->RemoteDevices[Index].EncryptionKeySize  = DeviceInfo->EncryptionKeySize;
                                PersistentData->RemoteDevices[Index].LTK                = DeviceInfo->LTK;
                            }

                            if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_IRK_VALID)
                            {
                                PersistentData->RemoteDevices[Index].Flags               |= PERSISTENT_REMOTE_DEVICE_DATA_FLAG_IDENTITY_VALID;
                                PersistentData->RemoteDevices[Index].IdentityAddress      = DeviceInfo->IdentityAddressBD_ADDR;
                                PersistentData->RemoteDevices[Index].IdentityAddressType  = DeviceInfo->IdentityAddressType;
                                PersistentData->RemoteDevices[Index].IRK                  = DeviceInfo->IRK;
                            }

                            ++Index;
                            DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
                        }

                        Result = qapi_Persist_Put(PersistHandle, PERSISTENT_DATA_SIZE(NumberDevices), (uint8_t *)PersistentData);

                        if(Result == QAPI_OK)
                        {
                            ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                            ret_val = QCLI_STATUS_ERROR_E;
                        }

                        free(PersistentData);
                    }
                    else
                    {
                        LOG_ERR("Unable to allocate memory\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }

                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                {
                    LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("Persistent Storage Not Initialized\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else if((Parameter_Count >= 2) && (APP_STRCMP(Parameter_List[0].String_Value,"load") == 0)) {

            /* Now make sure the storage handle is initialized.               */
            if(PersistHandle)
            {
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Don't proceed if there are devices in the list unless a  */
                    /* "force" was specified"                                   */
                    if(((Parameter_Count >= 2) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value)) || (!DeviceInfoList))
                    {
                        /* Attempt to read the data.                             */
                        Result = qapi_Persist_Get(PersistHandle, &DataSize, (uint8_t **)&PersistentData);

                        if(Result == QAPI_OK)
                        {
                            /* Verify the data and length seem valid.             */
                            if((PersistentData) && (DataSize >= PERSISTENT_DATA_SIZE(0)) && (DataSize >= PERSISTENT_DATA_SIZE(PersistentData->NumberRemoteDevices)))
                            {
                                /* Verify the the local BD_ADDRs match.            */
                                if(QAPI_BLE_COMPARE_BD_ADDR(LocalBD_ADDR, PersistentData->LocalAddress))
                                {
                                    /* Clear the list if it is not empty (user      */
                                    /* specified "force").                          */
                                    if(DeviceInfoList)
                                    {
                                        LOG_WARN("Warning: Device List is not empty. It will be cleared.\n");
                                        FreeDeviceInfoList(&DeviceInfoList);
                                        DeviceInfoList = NULL;
                                    }

                                    /* Data all seems valid, so build the device    */
                                    /* list.                                        */
                                    for(Index=0;Index<PersistentData->NumberRemoteDevices;Index++)
                                    {
                                        /* Attempt to create a new list entry for the*/
                                        /* device.                                   */
                                        if((DeviceInfo = CreateNewDeviceInfoEntry(&DeviceInfoList, PersistentData->RemoteDevices[Index].LastAddress)) != NULL)
                                        {
                                            /* Note the address type of the address   */
                                            /* used to create the entry.              */
                                            DeviceInfo->RemoteAddressType = PersistentData->RemoteDevices[Index].LastAddressType;

                                            /* Note any encryption information if     */
                                            /* valid.                                 */
                                            if(PersistentData->RemoteDevices[Index].Flags & PERSISTENT_REMOTE_DEVICE_DATA_FLAG_LTK_VALID)
                                            {
                                                DeviceInfo->Flags             |= DEVICE_INFO_FLAGS_LTK_VALID;
                                                DeviceInfo->EncryptionKeySize  = PersistentData->RemoteDevices[Index].EncryptionKeySize;
                                                DeviceInfo->LTK                = PersistentData->RemoteDevices[Index].LTK;
                                            }

                                            /* Note any identity information if valid.*/
                                            if(PersistentData->RemoteDevices[Index].Flags & PERSISTENT_REMOTE_DEVICE_DATA_FLAG_IDENTITY_VALID)
                                            {
                                                DeviceInfo->Flags                  |= DEVICE_INFO_FLAGS_IRK_VALID;
                                                DeviceInfo->IdentityAddressBD_ADDR  = PersistentData->RemoteDevices[Index].IdentityAddress;
                                                DeviceInfo->IdentityAddressType     = PersistentData->RemoteDevices[Index].IdentityAddressType;
                                                DeviceInfo->IRK                     = PersistentData->RemoteDevices[Index].IRK;

                                                /* We also need to set up the resolving*/
                                                /* list entry, since this is done in   */
                                                /* the GAP LE Auth callback.           */
                                                DeviceInfo->ResolvingListEntry.Peer_Identity_Address      = DeviceInfo->IdentityAddressBD_ADDR;
                                                DeviceInfo->ResolvingListEntry.Peer_Identity_Address_Type = DeviceInfo->IdentityAddressType;
                                                DeviceInfo->ResolvingListEntry.Peer_IRK                   = DeviceInfo->IRK;
                                                DeviceInfo->ResolvingListEntry.Local_IRK                  = IRK;
                                            }
                                        }
                                        else
                                        {
                                            LOG_INFO("Failed to create device entry\n");
                                        }
                                    }

                                    LOG_INFO("Persistent data loaded\n");

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                {
                                    LOG_ERR("Local BD_ADDR does not match persistent data. The persistent data is invalid.\n");

                                    ret_val = QCLI_STATUS_ERROR_E;
                                }
                            }
                            else
                            {
                                LOG_ERR("Persistent data is invalid\n");

                                ret_val = QCLI_STATUS_ERROR_E;
                            }

                            qapi_Persist_Free(PersistHandle, (uint8_t *)PersistentData);
                        }
                        else
                        {
                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        LOG_ERR("Device List is not empty.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }

                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                {
                    LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("Persistent Storage Not Initialized\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else if((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"delete") == 0)) {

            /* Now make sure the storage handle is initialized.               */
            if(PersistHandle)
            {
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Simply delete the storage.                               */
                    qapi_Persist_Delete(PersistHandle);

                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("Persistent Storage Not Initialized\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function configures how much data to report during  */
/* advertising.                                                      */
static QCLI_Command_Status_t ConfigureAdvReportDisplay(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t ret_val;

    /* Verify the CLI parameters.                                        */
    if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
    {
        if(Parameter_List[0].Integer_Value)
            DisplayAdvertisingEventData = TRUE;
        else
            DisplayAdvertisingEventData = FALSE;

        LOG_INFO("Advertising Display: %s\n", (DisplayAdvertisingEventData ? "Verbose" : "Limited"));

        ret_val = QCLI_STATUS_SUCCESS_E;
    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* Converts a string to a binary blob.  String must be large enough  */
/* to satisfy binary blob length (each byte is 2 binary characters). */
/* This is internal function so no check is done on input parameters.*/
static void StringToBinaryBlob(unsigned int BinaryLength, uint8_t *BinaryBlob, char *HexString)
{
    char         Buffer[5];
    unsigned int Index;
    unsigned int StringIndex;

    Buffer[0] = '0';
    Buffer[1] = 'x';
    Buffer[4] = '\0';

    for(Index=0,StringIndex=0;Index<BinaryLength;Index++,StringIndex+=2)
    {
        Buffer[2]         = HexString[StringIndex];
        Buffer[3]         = HexString[StringIndex+1];
        BinaryBlob[Index] = (uint8_t)StringToUnsignedInteger(Buffer);
    }
}

/* Prints a binary blob to the console.  This is internal function so*/
/* no check is done on input parameters.                             */
static void PrintBinaryBlob(unsigned int BinaryLength, uint8_t *BinaryBlob)
{
    unsigned int Index;

    for(Index=0;Index<BinaryLength;Index++)
        LOG_INFO("%02X", BinaryBlob[Index]);
}

/* The following function queries the local OOB data to send to a    */
/* remote device (sending out of band).                              */
static QCLI_Command_Status_t QueryLocalOOBData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    QCLI_Command_Status_t ret_val;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        Result = qc_drv_ble_GAP_LE_Query_Local_Secure_Connections_OOB_Data(qc_api_get_qc_drv_context(), BluetoothStackID, &LocalOOBRandomizer, &LocalOOBConfirmation);
        if(!Result)
        {
            LOG_INFO("Confirmation     : 0x");
            PrintBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Confirmation_t), (uint8_t *)&LocalOOBConfirmation);
            LOG_INFO("\n");

            LOG_INFO("Randomizer       : 0x");
            PrintBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Randomizer_t), (uint8_t *)&LocalOOBRandomizer);
            LOG_INFO("\n");

            LocalOOBValid = TRUE;

            /* Flag that the function was successful.                */
            ret_val       = QCLI_STATUS_SUCCESS_E;
        }
        else
        {
            LOG_ERR("Error - qapi_BLE_GAP_LE_Query_Local_Secure_Connections_OOB_Data() returned %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
        }
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function sets the remote OOB data received from a   */
/* remote device (received out of band).                             */
static QCLI_Command_Status_t SetRemoteOOOBData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t ret_val;

    /* Verify the CLI parameters.                                        */
    if((Parameter_Count >= 2) && (Parameter_List) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_Secure_Connections_Confirmation_t) * 2)) && (strlen((char *)(Parameter_List[1].String_Value)) == (sizeof(qapi_BLE_Secure_Connections_Randomizer_t) * 2)))
    {
        /* Convert the values.                                            */
        StringToBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Confirmation_t), (uint8_t *)&RemoteOOBConfirmation, Parameter_List[0].String_Value);
        StringToBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Randomizer_t), (uint8_t *)&RemoteOOBRandomizer, Parameter_List[1].String_Value);
        RemoteOOBValid = TRUE;

        /* Print converted values.                                        */
        LOG_INFO("Remote Confirmation     : 0x");
        PrintBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Confirmation_t), (uint8_t *)&RemoteOOBConfirmation);
        LOG_INFO("\n");

        LOG_INFO("Remote Randomizer       : 0x");
        PrintBinaryBlob(sizeof(qapi_BLE_Secure_Connections_Randomizer_t), (uint8_t *)&RemoteOOBRandomizer);
        LOG_INFO("\n");

        /* Flag that the function was successful.                         */
        ret_val = QCLI_STATUS_SUCCESS_E;
    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

#ifndef V1

static QCLI_Command_Status_t LowPowerTransmitOverride(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t ret_val;
    boolean_t             Enable;
    uint16_t              FEM_Ctrl_0_1;
    uint16_t              FEM_Ctrl_2_3;
    uint8_t               Tx_Power;
    int                   Result;

    if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid))
    {
        if(Parameter_List[0].Integer_Value)
            Enable = TRUE;
        else
            Enable = FALSE;

        if(!(Enable) || ((Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= -128) && (Parameter_List[1].Integer_Value <= 127) && (Parameter_List[2].Integer_Is_Valid)))
        {
            if(Enable)
            {
                Tx_Power = (uint8_t)Parameter_List[1].Integer_Value;

                if(Parameter_List[2].Integer_Value)
                {
                    /* Rx Mode Settings.                                     */
                    FEM_Ctrl_0_1 = 0x0000;
                    FEM_Ctrl_2_3 = 0x0000;
                }
                else
                {
                    /* Shutdown Mode Settings.                               */
                    FEM_Ctrl_0_1 = 0x00FF;
                    FEM_Ctrl_2_3 = 0xFF00;
                }
            }
            else
            {
                Tx_Power     = QAPI_BLE_BSC_TX_POWER_REVERT_TO_DEFAULT;
                FEM_Ctrl_0_1 = 0x0000;
                FEM_Ctrl_2_3 = 0x0000;
            }

            if((Result = qc_drv_ble_BSC_SetTxPower(qc_api_get_qc_drv_context(), BluetoothStackID, TRUE, Tx_Power)) == QAPI_OK)
            {
                if((Result = qc_drv_ble_BSC_Set_FEM_Control_Override(qc_api_get_qc_drv_context(), BluetoothStackID, Enable, FEM_Ctrl_0_1, FEM_Ctrl_2_3)) == QAPI_OK)
                {
                    LOG_INFO("Success\n");
                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    LOG_INFO("qapi_BLE_BSC_Set_FEM_Control_Override returned %d\n", Result);

                    /* FEM Control override failed, reset Tx power to don't  */
                    /* care.                                                 */
                    qc_drv_ble_BSC_SetTxPower(qc_api_get_qc_drv_context(), BluetoothStackID, TRUE, 127);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("qapi_BLE_BSC_SetTxPower returned %d\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

#endif

/* Generic Access Profile (GAPLE) helper functions.                  */

/* The following function is responsible for placing the Local       */
/* Bluetooth Device into General Discoverablity Mode.  Once in this  */
/* mode the Device will respond to Inquiry Scans from other Bluetooth*/
/* Devices.  This function requires that a valid Bluetooth Stack ID  */
/* exists before running.  This function returns zero on successful  */
/* execution and a negative value if an error occurred.              */
static int SetDisc(void)
{
    int ret_val = 0;

    /* First, check that a valid Bluetooth Stack ID exists.              */
    if(BluetoothStackID)
    {
        /* * NOTE * Discoverability is only applicable when we are        */
        /*          advertising so save the default Discoverability Mode  */
        /*          for later.                                            */
        LE_Parameters.DiscoverabilityMode = QAPI_BLE_DM_GENERAL_DISCOVERABLE_MODE_E;
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    return(ret_val);
}

/* The following function is responsible for placing the Local       */
/* Bluetooth Device into Connectable Mode.  Once in this mode the    */
/* Device will respond to Page Scans from other Bluetooth Devices.   */
/* This function requires that a valid Bluetooth Stack ID exists     */
/* before running.  This function returns zero on success and a      */
/* negative value if an error occurred.                              */
static int SetConnect(void)
{
    int ret_val = 0;

    /* First, check that a valid Bluetooth Stack ID exists.              */
    if(BluetoothStackID)
    {
        /* * NOTE * Connectability is only an applicable when advertising */
        /*          so we will just save the default connectability for   */
        /*          the next time we enable advertising.                  */
        LE_Parameters.ConnectableMode = QAPI_BLE_LCM_CONNECTABLE_E;
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    return(ret_val);
}

/* The following function is responsible for placing the local       */
/* Bluetooth device into Pairable mode.  Once in this mode the device*/
/* will response to pairing requests from other Bluetooth devices.   */
/* This function returns zero on successful execution and a negative */
/* value on all errors.                                              */
static int SetPairable(void)
{
    int Result;
    int ret_val = 0;

    /* First, check that a valid Bluetooth Stack ID exists.              */
    if(BluetoothStackID)
    {
        /* Attempt to set the attached device to be pairable.             */
        Result = qc_drv_ble_GAP_LE_Set_Pairability_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, QAPI_BLE_LPM_PAIRABLE_MODE_ENABLE_EXTENDED_EVENTS_E);

        /* Next, check the return value of the GAP Set Pairability mode   */
        /* command for successful execution.                              */
        if(!Result)
        {
            /* The device has been set to pairable mode, now register an   */
            /* Authentication Callback to handle the Authentication events */
            /* if required.                                                */
            Result = qc_drv_ble_GAP_LE_Register_Remote_Authentication(qc_api_get_qc_drv_context(), BluetoothStackID, GAP_LE_Event_Callback, (unsigned long)0);

            /* Next, check the return value of the GAP Register Remote     */
            /* Authentication command for successful execution.            */
            if(Result)
            {
                /* An error occurred while trying to execute this function. */
                DisplayFunctionError("GAP_LE_Register_Remote_Authentication", Result);

                ret_val = Result;
            }
        }
        else
        {
            /* An error occurred while trying to make the device pairable. */
            DisplayFunctionError("GAP_LE_Set_Pairability_Mode", Result);

            ret_val = Result;
        }
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    return(ret_val);
}

/* The following function is responsible for starting a scan.        */
static int StartScan(uint32_t BluetoothStackID, qapi_BLE_GAP_LE_Filter_Policy_t FilterPolicy, unsigned int ScanDuration)
{
    int Result;

    /* First, determine if the input parameters appear to be semi-valid. */
    if(BluetoothStackID)
    {
        /* Check to see if we need to configure the default Scan          */
        /* Parameters.                                                    */
        if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID))
        {
            /* Configure the default Scan Window and Scan Interval.        */
            BLEParameters.ScanParameters.ScanWindow   = 50;
            BLEParameters.ScanParameters.ScanInterval = 100;

            /* Flag that the scan parameters are valid so that we do not   */
            /* re-configure the defaults un-necessarily.                   */
            BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID;
        }

        /* See if we should start a timer for this scan.                  */
        if(ScanDuration)
        {
            /* Start a timer for this operation.                           */
            Result = qc_drv_ble_BSC_StartTimer(qc_api_get_qc_drv_context(), BluetoothStackID, (ScanDuration * 1000), BSC_Timer_Callback, ScanDuration);
            if(Result > 0)
            {
                /* Save the scan timer ID.                                  */
                ScanTimerID = (unsigned int)Result;

                Result      = 0;
            }
        }
        else
            Result = 0;

        /* Continue if no error occurred.                                 */
        if(!Result)
        {
            /* Not currently scanning, go ahead and attempt to perform the */
            /* scan.                                                       */
            Result = qc_drv_ble_GAP_LE_Perform_Scan(qc_api_get_qc_drv_context(), BluetoothStackID, QAPI_BLE_ST_ACTIVE_E, BLEParameters.ScanParameters.ScanInterval, BLEParameters.ScanParameters.ScanWindow, QAPI_BLE_LAT_PUBLIC_E, FilterPolicy, TRUE, GAP_LE_Event_Callback, 0);
            if(!Result)
                LOG_INFO("Scan started successfully. Scan Window: %u, Scan Interval: %u.\n", (unsigned int)BLEParameters.ScanParameters.ScanWindow, (unsigned int)BLEParameters.ScanParameters.ScanInterval);
            else
                LOG_WARN("Unable to perform scan: %d\n", Result);
        }
        else
            LOG_WARN("Unable to start scan timer: %d\n", Result);
    }
    else
        Result = -1;

    return(Result);
}

/* The following function is responsible for stopping on on-going    */
/* scan.                                                             */
static int StopScan(uint32_t BluetoothStackID)
{
    int Result;

    /* First, determine if the input parameters appear to be semi-valid. */
    if(BluetoothStackID)
    {
        /* if scan timer is active stop that.                             */
        if(ScanTimerID)
        {
            /* Stop the timer.                                             */
            qapi_BLE_BSC_StopTimer(BluetoothStackID, ScanTimerID);

            ScanTimerID = 0;
        }

        /* Stop the scan.                                                 */
        Result = qc_drv_ble_GAP_LE_Cancel_Scan(qc_api_get_qc_drv_context(), BluetoothStackID);
        if(!Result)
        {
            LOG_INFO("Scan stopped successfully.\n");

            /* Flag that scanning is not in progess.                       */
            ScanInProgress = FALSE;
        }
        else
            LOG_WARN("Unable to stop scan: %d\n", Result);
    }
    else
        Result = -1;

    return(Result);
}

/* The following function is responsible for creating an LE          */
/* connection to the specified Remote Device.                        */
/* * NOTE * If UseWhiteList is TRUE, then the BD_ADDR may be excluded*/
/*          (NULL), and the address type will be ignored.  Otherwise,*/
/*          they MUST be specified.  A remote device address and     */
/*          address type MUST have been added to the White List in   */
/*          the controller to use this functionality.                */
/* * NOTE * If UseWhiteList is FALSE, then this function will perform*/
/*          no checks on the remote addresss or address type.        */
/* * NOTE * If Address Resolution has been enabled in the controller */
/*          and the remote device's identity information has been    */
/*          added to the Resolving List in the controller, then the  */
/*          local controller will generate a resolvable private      */
/*          address (RPA) to send in the connection request.         */
/* * NOTE * If the user wishes to use the White List and the         */
/*          Resolving List in the controller, then the remote device */
/*          address and address type specified for the added White   */
/*          List entry MUST correspond to the identity address and   */
/*          identity address type for the remote device.             */
/* * NOTE * If the user wishes to ONLY use the Resolving List in the */
/*          controller (Not White List), then the remote device      */
/*          address and address type specified to this function MUST */
/*          correspond to the identity address and identity address  */
/*          type for the remote device.                              */
static int ConnectLEDevice(uint32_t BluetoothStackID, boolean_t UseWhiteList, qapi_BLE_BD_ADDR_t *BD_ADDR, qapi_BLE_GAP_LE_Address_Type_t AddressType)
{
    int Result;

    /* First, determine if the input parameters appear to be semi-valid. */
    if(BluetoothStackID)
    {
        /* Check to see if we need to configure the default Scan          */
        /* Parameters.                                                    */
        if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID))
        {
            /* Configure the default Scan Window and Scan Interval.        */
            BLEParameters.ScanParameters.ScanWindow   = 50;
            BLEParameters.ScanParameters.ScanInterval = 100;

            /* Flag that the scan parameters are valid so that we do not   */
            /* re-configure the defaults un-necessarily.                   */
            BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID;
        }

        /* Check to see if we need to configure the default Connection    */
        /* Parameters.                                                    */
        if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID))
        {
            /* Initialize the default connection parameters.               */
            BLEParameters.ConnectionParameters.Connection_Interval_Min    = 50;
            BLEParameters.ConnectionParameters.Connection_Interval_Max    = 200;
            BLEParameters.ConnectionParameters.Minimum_Connection_Length  = 0;
            BLEParameters.ConnectionParameters.Maximum_Connection_Length  = 10000;
            BLEParameters.ConnectionParameters.Slave_Latency              = 0;
            BLEParameters.ConnectionParameters.Supervision_Timeout        = 20000;

            /* Flag that the connection parameters are valid so that we do */
            /* not re-configure the defaults un-necessarily.               */
            BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID;
        }

        /* Everything appears correct, go ahead and attempt to make the   */
        /* connection.                                                    */
        /* * NOTE * Our local address type will ALWAYS be resolvable      */
        /*          fallback public, in case the Resolving List in the    */
        /*          controller is used for connecting.  It is worth noting*/
        /*          that this demo uses its local/public address as the   */
        /*          public identity address for simplicity.               */
        Result = qc_drv_ble_GAP_LE_Create_Connection(qc_api_get_qc_drv_context(), BluetoothStackID, BLEParameters.ScanParameters.ScanInterval, BLEParameters.ScanParameters.ScanWindow, (UseWhiteList ? QAPI_BLE_FP_WHITE_LIST_E : QAPI_BLE_FP_NO_FILTER_E), AddressType, BD_ADDR, QAPI_BLE_LAT_RESOLVABLE_FALLBACK_PUBLIC_E, &(BLEParameters.ConnectionParameters), GAP_LE_Event_Callback, 0);
        if(!Result)
        {
            LOG_INFO("Connection Request successful.\n");
            LOG_INFO("Scan Parameters:       Window %u, Interval %u.\n", (unsigned int)BLEParameters.ScanParameters.ScanWindow,
                    (unsigned int)BLEParameters.ScanParameters.ScanInterval);
            LOG_INFO("Connection Parameters: Interval Range %u - %u, Slave Latency %u.\n", (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Min,
                    (unsigned int)BLEParameters.ConnectionParameters.Connection_Interval_Max,
                    (unsigned int)BLEParameters.ConnectionParameters.Slave_Latency);
            LOG_INFO("Using White List:      %s.\n", (UseWhiteList ? "Yes" : "No"));
        }
        else
        {
            /* Unable to create connection.                                */
            LOG_WARN("Unable to create connection: %d.\n", Result);
        }
    }
    else
        Result = -1;

    return(Result);
}

/* The following function provides a mechanism to configure a        */
/* Pairing Capabilities structure with the application's pairing     */
/* parameters.                                                       */
static void ConfigureCapabilities(qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t *Capabilities)
{
    /* Make sure the Capabilities pointer is semi-valid.                 */
    if(Capabilities)
    {
        /* Initialize the capabilities.                                   */
        memset(Capabilities, 0, QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_SIZE);

        /* Configure the Pairing Capabilities structure.                  */
        Capabilities->Bonding_Type                    = QAPI_BLE_LBT_BONDING_E;
        Capabilities->IO_Capability                   = LE_Parameters.IOCapability;
        Capabilities->Flags                           = 0;

        if(LE_Parameters.MITMProtection)
            Capabilities->Flags |= QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_MITM_REQUESTED;

        if(LE_Parameters.SecureConnections)
            Capabilities->Flags |= QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_SECURE_CONNECTIONS;

        if(RemoteOOBValid)
            Capabilities->Flags |= QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_OOB_DATA_PRESENT;

        if(LocalOOBValid)
        {
            Capabilities->Flags                     |= QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_LOCAL_OOB_DATA_VALID;
            Capabilities->LocalOOBData.Flags         = 0;
            Capabilities->LocalOOBData.Confirmation  = LocalOOBConfirmation;
            Capabilities->LocalOOBData.Randomizer    = LocalOOBRandomizer;
        }

        /* ** NOTE ** This application always requests that we use the    */
        /*            maximum encryption because this feature is not a    */
        /*            very good one, if we set less than the maximum we   */
        /*            will internally in GAP generate a key of the        */
        /*            maximum size (we have to do it this way) and then   */
        /*            we will zero out how ever many of the MSBs          */
        /*            necessary to get the maximum size.  Also as a slave */
        /*            we will have to use Non-Volatile Memory (per device */
        /*            we are paired to) to store the negotiated Key Size. */
        /*            By requesting the maximum (and by not storing the   */
        /*            negotiated key size if less than the maximum) we    */
        /*            allow the slave to power cycle and regenerate the   */
        /*            LTK for each device it is paired to WITHOUT storing */
        /*            any information on the individual devices we are    */
        /*            paired to.                                          */
        Capabilities->Maximum_Encryption_Key_Size        = QAPI_BLE_GAP_LE_MAXIMUM_ENCRYPTION_KEY_SIZE;

        /* This application only demonstrates using the Long Term Key's   */
        /* (LTK) for encryption of a LE Link and the Identity Resolving   */
        /* Key (IRK) for resolving resovable private addresses (RPA's),   */
        /* however we could request and send all possible keys here if we */
        /* wanted to.                                                     */
        Capabilities->Receiving_Keys.Encryption_Key     = TRUE;
        Capabilities->Receiving_Keys.Identification_Key = TRUE;
        Capabilities->Receiving_Keys.Signing_Key        = FALSE;
        Capabilities->Receiving_Keys.Link_Key           = FALSE;

        Capabilities->Sending_Keys.Encryption_Key       = TRUE;
        Capabilities->Sending_Keys.Identification_Key   = TRUE;
        Capabilities->Sending_Keys.Signing_Key          = FALSE;
        Capabilities->Sending_Keys.Link_Key             = FALSE;
    }
}

/* The following function provides a mechanism for sending a pairing */
/* request to a device that is connected on an LE Link.              */
static int SendPairingRequest(qapi_BLE_BD_ADDR_t BD_ADDR, boolean_t ConnectionMaster)
{
    int                                             ret_val;
    BoardStr_t                                      BoardStr;
    qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t ExtendedCapabilities;

    /* Make sure a Bluetooth Stack is open.                              */
    if(BluetoothStackID)
    {
        /* Configure the application pairing parameters.                  */
        ConfigureCapabilities(&ExtendedCapabilities);

        /* Inform the user we are attempting to pair to the remote device.*/
        BD_ADDRToStr(BD_ADDR, BoardStr);
        LOG_INFO("Attempting to Pair to %s.\n", BoardStr);

        DisplayPairingInformation(&ExtendedCapabilities);

        /* Attempt to pair to the remote device.                          */
        if(ConnectionMaster)
        {
            /* Go ahead and store the address of the remote device that we */
            /* are going to attempt to pair.                               */
            /* * NOTE * If this function is called by the                  */
            /*          GAP_LE_Event_Callback() then this will already be  */
            /*          set, however if it is called by PairLE(), then it  */
            /*          will NOT be set.  We MUST only set this if we are  */
            /*          the master of the connection since the master sends*/
            /*          the pairing request.  The slave will set this when */
            /*          the pairing request has been received.             */
            SecurityRemoteBD_ADDR = BD_ADDR;

            /* Start the pairing process.                                  */
            if((ret_val = qapi_BLE_GAP_LE_Extended_Pair_Remote_Device(BluetoothStackID, SecurityRemoteBD_ADDR, &ExtendedCapabilities, GAP_LE_Event_Callback, 0)) == QAPI_BLE_BTPS_ERROR_SECURE_CONNECTIONS_NOT_SUPPORTED)
            {
                /* Since Secure Connections isn't supported go ahead and    */
                /* disable our request for Secure Connections and re-submit */
                /* our request.                                             */
                LOG_WARN("Secure Connections not supported, disabling Secure Connections.\n");

                ExtendedCapabilities.Flags &= ~QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_SECURE_CONNECTIONS;

                /* Try this again.                                          */
                ret_val = qapi_BLE_GAP_LE_Extended_Pair_Remote_Device(BluetoothStackID, SecurityRemoteBD_ADDR, &ExtendedCapabilities, GAP_LE_Event_Callback, 0);
            }

            LOG_INFO("     GAP_LE_Extended_Pair_Remote_Device returned %d.\n", ret_val);
        }
        else
        {
            /* As a slave we can only request that the Master start the    */
            /* pairing process.                                            */
            ret_val = qapi_BLE_GAP_LE_Extended_Request_Security(BluetoothStackID, BD_ADDR, &ExtendedCapabilities, GAP_LE_Event_Callback, 0);

            LOG_INFO("     GAP_LE_Request_Security returned %d.\n", ret_val);
        }
    }
    else
    {
        LOG_WARN("Stack ID Invalid.\n");

        ret_val = -1;
    }

    return(ret_val);
}

/* The following function provides a mechanism of sending a Slave    */
/* Pairing Response to a Master's Pairing Request.                   */
static int SlavePairingRequestResponse(qapi_BLE_BD_ADDR_t BD_ADDR)
{
    int                                                   ret_val;
    BoardStr_t                                            BoardStr;
    qapi_BLE_GAP_LE_Authentication_Response_Information_t AuthenticationResponseData;

    /* Make sure a Bluetooth Stack is open.                              */
    if(BluetoothStackID)
    {
        BD_ADDRToStr(BD_ADDR, BoardStr);
        LOG_INFO("Sending Pairing Response to %s.\n", BoardStr);

        /* We must be the slave if we have received a Pairing Request     */
        /* thus we will respond with our capabilities.                    */
        AuthenticationResponseData.GAP_LE_Authentication_Type = QAPI_BLE_LAR_PAIRING_CAPABILITIES_E;
        AuthenticationResponseData.Authentication_Data_Length = QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_SIZE;

        /* Configure the Application Pairing Parameters.                  */
        ConfigureCapabilities(&(AuthenticationResponseData.Authentication_Data.Extended_Pairing_Capabilities));

        /* Attempt to pair to the remote device.                          */
        if((ret_val = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, BD_ADDR, &AuthenticationResponseData)) == QAPI_BLE_BTPS_ERROR_SECURE_CONNECTIONS_NOT_SUPPORTED)
        {
            /* Since Secure Connections isn't supported go ahead and       */
            /* disable our request for Secure Connections and re-submit our*/
            /* request.                                                    */
            LOG_INFO("Secure Connections not supported, disabling Secure Connections.\n");

            AuthenticationResponseData.Authentication_Data.Extended_Pairing_Capabilities.Flags &= ~QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_SECURE_CONNECTIONS;

            /* Try this again.                                             */
            ret_val = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, BD_ADDR, &AuthenticationResponseData);
        }

        LOG_INFO("GAP_LE_Authentication_Response returned %d.\n", ret_val);
    }
    else
    {
        LOG_WARN("Stack ID Invalid.\n");

        ret_val = -1;
    }

    return(ret_val);
}

/* The following function is provided to allow a mechanism of        */
/* responding to a request for Encryption Information to send to a   */
/* remote device.                                                    */
static int EncryptionInformationRequestResponse(qapi_BLE_BD_ADDR_t BD_ADDR, uint8_t KeySize, qapi_BLE_GAP_LE_Authentication_Response_Information_t *GAP_LE_Authentication_Response_Information)
{
    int      ret_val;
    uint16_t LocalDiv;

    /* Make sure a Bluetooth Stack is open.                              */
    if(BluetoothStackID)
    {
        /* Make sure the input parameters are semi-valid.                 */
        if((!QAPI_BLE_COMPARE_NULL_BD_ADDR(BD_ADDR)) && (GAP_LE_Authentication_Response_Information))
        {
            LOG_INFO("   Calling GAP_LE_Generate_Long_Term_Key.\n");

            /* Generate a new LTK, EDIV and Rand tuple.                    */
            ret_val = qapi_BLE_GAP_LE_Generate_Long_Term_Key(BluetoothStackID, (qapi_BLE_Encryption_Key_t *)(&DHK), (qapi_BLE_Encryption_Key_t *)(&ER), &(GAP_LE_Authentication_Response_Information->Authentication_Data.Encryption_Information.LTK), &LocalDiv, &(GAP_LE_Authentication_Response_Information->Authentication_Data.Encryption_Information.EDIV), &(GAP_LE_Authentication_Response_Information->Authentication_Data.Encryption_Information.Rand));
            if(!ret_val)
            {
                LOG_INFO("   Encryption Information Request Response.\n");

                /* Response to the request with the LTK, EDIV and Rand      */
                /* values.                                                  */
                GAP_LE_Authentication_Response_Information->GAP_LE_Authentication_Type                                     = QAPI_BLE_LAR_ENCRYPTION_INFORMATION_E;
                GAP_LE_Authentication_Response_Information->Authentication_Data_Length                                     = QAPI_BLE_GAP_LE_ENCRYPTION_INFORMATION_DATA_SIZE;
                GAP_LE_Authentication_Response_Information->Authentication_Data.Encryption_Information.Encryption_Key_Size = KeySize;

                ret_val = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, BD_ADDR, GAP_LE_Authentication_Response_Information);
                if(!ret_val)
                {
                    LOG_INFO("   qapi_BLE_GAP_LE_Authentication_Response (larEncryptionInformation) success.\n");
                }
                else
                {
                    LOG_ERR("SM_Generate_Long_Term_Key returned %d.\n", ret_val);
                }
            }
            else
            {
                LOG_ERR("SM_Generate_Long_Term_Key returned %d.\n", ret_val);
            }
        }
        else
        {
            LOG_WARN("Invalid Parameters.\n");

            ret_val = -1;
        }
    }
    else
    {
        LOG_WARN("Stack ID Invalid.\n");

        ret_val = -1;
    }

    return(ret_val);
}

/* Displays the current I/O Capabilities.                            */
static void DisplayIOCapabilities(void)
{
    LOG_DEBUG("I/O Capabilities: %s, MITM: %s. Secure Connections: %s.\n", IOCapabilitiesStrings[(unsigned int)(LE_Parameters.IOCapability - QAPI_BLE_LIC_DISPLAY_ONLY_E)], LE_Parameters.MITMProtection?"TRUE":"FALSE", LE_Parameters.SecureConnections?"TRUE":"FALSE");
}

/* The following function displays the pairing capabilities that is  */
/* passed into this function.                                        */
static void DisplayPairingInformation(qapi_BLE_GAP_LE_Extended_Pairing_Capabilities_t *Pairing_Capabilities)
{
    /* Display the IO Capability.                                        */
    switch(Pairing_Capabilities->IO_Capability)
    {
        case QAPI_BLE_LIC_DISPLAY_ONLY_E:
            LOG_INFO("   IO Capability:       Display Only.\n");
            break;
        case QAPI_BLE_LIC_DISPLAY_YES_NO_E:
            LOG_INFO("   IO Capability:       Display Yes/No.\n");
            break;
        case QAPI_BLE_LIC_KEYBOARD_ONLY_E:
            LOG_INFO("   IO Capability:       Keyboard Only.\n");
            break;
        case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
            LOG_INFO("   IO Capability:       No Input No Output.\n");
            break;
        case QAPI_BLE_LIC_KEYBOARD_DISPLAY_E:
            LOG_INFO("   IO Capability:       Keyboard/Display.\n");
            break;
    }

    LOG_INFO("   Bonding Type:        %s.\n", (Pairing_Capabilities->Bonding_Type == QAPI_BLE_LBT_BONDING_E)?"Bonding":"No Bonding");
    LOG_INFO("   MITM:                %s.\n", (Pairing_Capabilities->Flags & QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_MITM_REQUESTED)?"TRUE":"FALSE");
    LOG_INFO("   Secure Connections:  %s.\n", (Pairing_Capabilities->Flags & QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_SECURE_CONNECTIONS)?"TRUE":"FALSE");
    LOG_INFO("   OOB:                 %s.\n", (Pairing_Capabilities->Flags & QAPI_BLE_GAP_LE_EXTENDED_PAIRING_CAPABILITIES_FLAGS_OOB_DATA_PRESENT)?"OOB":"OOB Not Present");
    LOG_INFO("   Encryption Key Size: %d.\n", Pairing_Capabilities->Maximum_Encryption_Key_Size);
    LOG_INFO("   Sending Keys: \n");
    LOG_INFO("      LTK:              %s.\n", ((Pairing_Capabilities->Sending_Keys.Encryption_Key)?"YES":"NO"));
    LOG_INFO("      IRK:              %s.\n", ((Pairing_Capabilities->Sending_Keys.Identification_Key)?"YES":"NO"));
    LOG_INFO("      CSRK:             %s.\n", ((Pairing_Capabilities->Sending_Keys.Signing_Key)?"YES":"NO"));
    LOG_INFO("      Link Key:         %s.\n", ((Pairing_Capabilities->Sending_Keys.Link_Key)?"YES":"NO"));
    LOG_INFO("   Receiving Keys: \n");
    LOG_INFO("      LTK:              %s.\n", ((Pairing_Capabilities->Receiving_Keys.Encryption_Key)?"YES":"NO"));
    LOG_INFO("      IRK:              %s.\n", ((Pairing_Capabilities->Receiving_Keys.Identification_Key)?"YES":"NO"));
    LOG_INFO("      CSRK:             %s.\n", ((Pairing_Capabilities->Receiving_Keys.Signing_Key)?"YES":"NO"));
    LOG_INFO("      Link Key:         %s.\n", ((Pairing_Capabilities->Receiving_Keys.Link_Key)?"YES":"NO"));
}

/* The following function displays the pairing capabilities that is  */
/* passed into this function.                                        */
static void DisplayLegacyPairingInformation(qapi_BLE_GAP_LE_Pairing_Capabilities_t *Pairing_Capabilities)
{
    /* Display the IO Capability.                                        */
    switch(Pairing_Capabilities->IO_Capability)
    {
        case QAPI_BLE_LIC_DISPLAY_ONLY_E:
            LOG_INFO("   IO Capability:       Display Only.\n");
            break;
        case QAPI_BLE_LIC_DISPLAY_YES_NO_E:
            LOG_INFO("   IO Capability:       Display Yes/No.\n");
            break;
        case QAPI_BLE_LIC_KEYBOARD_ONLY_E:
            LOG_INFO("   IO Capability:       Keyboard Only.\n");
            break;
        case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
            LOG_INFO("   IO Capability:       No Input No Output.\n");
            break;
        case QAPI_BLE_LIC_KEYBOARD_DISPLAY_E:
            LOG_INFO("   IO Capability:       Keyboard/Display.\n");
            break;
    }

    LOG_INFO("   MITM:                %s.\n", (Pairing_Capabilities->MITM)?"TRUE":"FALSE");
    LOG_INFO("   Bonding Type:        %s.\n", (Pairing_Capabilities->Bonding_Type == QAPI_BLE_LBT_BONDING_E)?"Bonding":"No Bonding");
    LOG_INFO("   OOB:                 %s.\n", (Pairing_Capabilities->OOB_Present)?"OOB":"OOB Not Present");
    LOG_INFO("   Encryption Key Size: %d.\n", Pairing_Capabilities->Maximum_Encryption_Key_Size);
    LOG_INFO("   Sending Keys: \n");
    LOG_INFO("      LTK:              %s.\n", ((Pairing_Capabilities->Sending_Keys.Encryption_Key)?"YES":"NO"));
    LOG_INFO("      IRK:              %s.\n", ((Pairing_Capabilities->Sending_Keys.Identification_Key)?"YES":"NO"));
    LOG_INFO("      CSRK:             %s.\n", ((Pairing_Capabilities->Sending_Keys.Signing_Key)?"YES":"NO"));
    LOG_INFO("   Receiving Keys: \n");
    LOG_INFO("      LTK:              %s.\n", ((Pairing_Capabilities->Receiving_Keys.Encryption_Key)?"YES":"NO"));
    LOG_INFO("      IRK:              %s.\n", ((Pairing_Capabilities->Receiving_Keys.Identification_Key)?"YES":"NO"));
    LOG_INFO("      CSRK:             %s.\n", ((Pairing_Capabilities->Receiving_Keys.Signing_Key)?"YES":"NO"));
}

/* The following function is provided to properly print a UUID.      */
static void DisplayUUID(qapi_BLE_GATT_UUID_t *UUID)
{
    if(UUID)
    {
        if(UUID->UUID_Type == QAPI_BLE_GU_UUID_16_E)
            LOG_INFO("%02X%02X\n", UUID->UUID.UUID_16.UUID_Byte1, UUID->UUID.UUID_16.UUID_Byte0);
        else
        {
            if(UUID->UUID_Type == QAPI_BLE_GU_UUID_128_E)
            {
                LOG_INFO("%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n", UUID->UUID.UUID_128.UUID_Byte15, UUID->UUID.UUID_128.UUID_Byte14, UUID->UUID.UUID_128.UUID_Byte13,
                        UUID->UUID.UUID_128.UUID_Byte12, UUID->UUID.UUID_128.UUID_Byte11, UUID->UUID.UUID_128.UUID_Byte10,
                        UUID->UUID.UUID_128.UUID_Byte9,  UUID->UUID.UUID_128.UUID_Byte8,  UUID->UUID.UUID_128.UUID_Byte7,
                        UUID->UUID.UUID_128.UUID_Byte6,  UUID->UUID.UUID_128.UUID_Byte5,  UUID->UUID.UUID_128.UUID_Byte4,
                        UUID->UUID.UUID_128.UUID_Byte3,  UUID->UUID.UUID_128.UUID_Byte2,  UUID->UUID.UUID_128.UUID_Byte1,
                        UUID->UUID.UUID_128.UUID_Byte0);
            }
        }
    }
}

/* Displays a function error message.                                */
static void DisplayFunctionError(char *Function, int Status)
{
    LOG_ERR("%s Failed: %d.\n", Function, Status);
}

/* The following function is a utility function which is used to     */
/* generate random values for the ER and the IR.                     */
static void GenerateRandomKeys(void)
{
    uint8_t                  Status;
    unsigned int             MaxSize;
    qapi_BLE_Random_Number_t RandomNumber;

    /* Initialize the max size.                                          */
    MaxSize = (sizeof(qapi_BLE_Random_Number_t) > (sizeof(qapi_BLE_Encryption_Key_t) / 2)) ? (sizeof(qapi_BLE_Encryption_Key_t) / 2) : sizeof(qapi_BLE_Random_Number_t);

    /* Initialize the ER and IR to random values.                        */
    if((!qapi_BLE_HCI_LE_Rand(BluetoothStackID,  &Status,  &RandomNumber)) && (!Status))
        memcpy(&ER, &RandomNumber, MaxSize);

    if((!qapi_BLE_HCI_LE_Rand(BluetoothStackID,  &Status,  &RandomNumber)) && (!Status))
        memcpy(&(((uint8_t *)&ER)[sizeof(qapi_BLE_Encryption_Key_t) / 2]), &RandomNumber, MaxSize);

    if((!qapi_BLE_HCI_LE_Rand(BluetoothStackID,  &Status,  &RandomNumber)) && (!Status))
        memcpy(&IR, &RandomNumber, MaxSize);

    if((!qapi_BLE_HCI_LE_Rand(BluetoothStackID,  &Status,  &RandomNumber)) && (!Status))
        memcpy(&(((uint8_t *)&IR)[sizeof(qapi_BLE_Encryption_Key_t) / 2]), &RandomNumber, MaxSize);
}

/* Hardware Controller Interface (HCI) QCLI command functions.       */

#ifdef V2

/* The PHY to string mapping table.                                  */
char *PHYMapping[] =
{
    "LE 1M PHY",
    "LE 2M PHY",
    "LE Coded PHY",
    "Unknown PHY"
};

/* The following function converts the PHY to a string for printing. */
char *PHYToString(qapi_BLE_GAP_LE_PHY_Type_t PHY)
{
    if((PHY >= QAPI_BLE_LPT_PHY_LE_1M_E) && (PHY <= QAPI_BLE_LPT_PHY_LE_CODED_E))
        return(PHYMapping[PHY - QAPI_BLE_LPT_PHY_LE_1M_E]);
    else
        return(PHYMapping[3]);
}
/* The following function is responsible for reading the PHY for an  */
/* existing connection. This function will return zero on successful */
/* execution and a negative value on errors.                         */
/* The following function is responsible for setting the PHY for an  */
/* existing connection. This function will return zero on successful */
/* execution and a negative value on errors.                         */
static QCLI_Command_Status_t BLE5PHY(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                        Result;
    BoardStr_t                 BoardStr;
    QCLI_Command_Status_t      ret_val = QCLI_STATUS_SUCCESS_E;
    qapi_BLE_GAP_LE_PHY_Type_t TX_PHY_Result;
    qapi_BLE_GAP_LE_PHY_Type_t RX_PHY_Result;
    uint32_t              TX_PHYS;
    uint32_t              RX_PHYS;

    if (Parameter_Count == 0) {
        /* Verify that there is a connection that is established.            */
        if(ConnectionCount)
        {
            /* Query the connection PHY.                                      */
            Result = qc_drv_ble_GAP_LE_Query_Connection_PHY(qc_api_get_qc_drv_context(), BluetoothStackID, SelectedRemoteBD_ADDR, &TX_PHY_Result, &RX_PHY_Result);
            if(!Result)
            {
                BD_ADDRToStr(SelectedRemoteBD_ADDR, BoardStr);
                LOG_INFO("Remote Device:  %s\n",  BoardStr);
                LOG_INFO("TX PHY:         %s.\n", PHYToString(TX_PHY_Result));
                LOG_INFO("RX PHY:         %s.\n", PHYToString(RX_PHY_Result));
            }
            else
            {
                LOG_ERR("   qapi_BLE_GAP_LE_Query_Connection_PHY() returned error: %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            LOG_WARN("No connection currently connected.\n");

            /* Flag success to the caller.                                    */
            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else if (Parameter_Count == 2) {

        /* Make sure the mandatory parameters are semi-valid.                */
        if((Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid))
        {
            /* Store the parameters.                                          */
            TX_PHYS = (uint32_t)Parameter_List[1].Integer_Value;
            RX_PHYS = (uint32_t)Parameter_List[2].Integer_Value;
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

        /* If an error has not occured.                                      */
        if(!ret_val)
        {
            /* Verify that there is a connection that is established.         */
            if(ConnectionCount)
            {
                /* Simply call the GAP function.                               */
                Result = qc_drv_ble_GAP_LE_Set_Connection_PHY(qc_api_get_qc_drv_context(), BluetoothStackID, SelectedRemoteBD_ADDR, TX_PHYS, RX_PHYS);
                if(!Result)
                {
                    LOG_INFO("   qapi_BLE_GAP_LE_Set_Connection_PHY() success.\n");
                }
                else
                {
                    LOG_ERR("   qapi_BLE_GAP_LE_Set_Connection_PHY() error: %d.\n", Result);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("No connection currently connected.\n");

                /* Flag success to the caller.                                 */
                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
    } else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E ) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);

}

/* The following function is responsible for setting the extended    */
/* advertising parameters. This function will return zero on         */
/* successful execution and a negative value on errors.              */
/* * NOTE * This function currently only allows one advertising set  */
/*          to be configure.                                         */
/* * NOTE * This function does NOT allow direct advertising.         */

/* The following function is responsible for enabling extended       */
/* advertising. This function will return zero on successful         */
/* execution and a negative value on errors.                         */
/* * NOTE * This function currently only allows one advertising set  */
/*          to be enabled.                                           */

static QCLI_Command_Status_t ExtendedAdvertisingParams(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                               Result;
    int8_t                                            SelectedTxPowerResult;
    uint8_t                                           AdvertisingHandle;
    QCLI_Command_Status_t                             ret_val = QCLI_STATUS_SUCCESS_E;
    qapi_BLE_GAP_LE_Extended_Advertising_Parameters_t ExtAdvParameters;

    uint8_t               NumberOfSets;
    uint8_t               MaxExtAdvertisingEvents = 0;
    uint32_t              Duration                = 0;
    boolean_t             Enable;

    if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"set_ext_adv_params") == 0)) {
        /* Make sure the mandatory AdvertisingHandle and                     */
        /* AdvertisingEventProperties parameters are semi-valid.             */
        if((Parameter_Count >= 4) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= 1) &&
                (Parameter_List[2].Integer_Is_Valid) &&
                (Parameter_List[3].Integer_Is_Valid) && (Parameter_List[3].Integer_Value >= -127) && (Parameter_List[3].Integer_Value <= 127))
        {
            /* Store the parameters.                                          */
            AdvertisingHandle                             = (uint8_t)Parameter_List[1].Integer_Value;
            ExtAdvParameters.Advertising_Event_Properties = (uint16_t)Parameter_List[2].Integer_Value;
            ExtAdvParameters.Advertising_Tx_Power         = (int8_t)Parameter_List[3].Integer_Value;
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

        /* If an error has not occured.                                      */
        if(!ret_val)
        {
            /* Set the remaining extended advertising parameters.             */
            /* * NOTE * The PeerAddrType and PeerAddr are set so that direct  */
            /*          advertising CANNOT be used.                           */
            ExtAdvParameters.Primary_Advertising_Interval_Min  = (uint32_t)(100);
            ExtAdvParameters.Primary_Advertising_Interval_Max  = (uint32_t)(200);
            ExtAdvParameters.Primary_Advertising_Channel_Map   = QAPI_BLE_HCI_LE_ADVERTISING_CHANNEL_MAP_DEFAULT;
            ExtAdvParameters.Own_Address_Type                  = QAPI_BLE_LAT_PUBLIC_E;
            ExtAdvParameters.Peer_Address_Type                 = QAPI_BLE_LAT_PUBLIC_E;
            QAPI_BLE_ASSIGN_BD_ADDR(ExtAdvParameters.Peer_Address,  0, 0, 0, 0, 0, 0);
            ExtAdvParameters.Scan_Request_Filter               = QAPI_BLE_FP_NO_FILTER_E;
            ExtAdvParameters.Connect_Request_Filter            = QAPI_BLE_FP_NO_FILTER_E;
            ExtAdvParameters.Primary_Advertising_PHY           = QAPI_BLE_LPT_PHY_LE_1M_E;
            ExtAdvParameters.Secondary_Advertising_Max_Skip    = 0x00;
            ExtAdvParameters.Secondary_Advertising_PHY         = QAPI_BLE_LPT_PHY_LE_1M_E;
            ExtAdvParameters.Advertising_SID                   = 0x00;
            ExtAdvParameters.Scan_Request_Notifications_Enable = TRUE;

            /* Call the GAP function to set the extended advertising          */
            /* parameters.                                                    */
            Result = qc_drv_ble_GAP_LE_Set_Extended_Advertising_Parameters(qc_api_get_qc_drv_context(), BluetoothStackID, AdvertisingHandle, &ExtAdvParameters, &SelectedTxPowerResult);
            if(!Result)
            {
                LOG_INFO("   qapi_BLE_GAP_LE_Set_Extended_Advertising_Parameters() returned success.\n");
                LOG_INFO("      Selected Tx Power Result: %d.\n", (int)SelectedTxPowerResult);
            }
            else
            {
                LOG_INFO("   qapi_BLE_GAP_LE_Set_Extended_Advertising_Parameters() returned error: %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }

    } else if((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"en_ext_adv") == 0)) {

        /* Make sure the mandatory Enable and NumberOfSets parameters are    */
        /* semi-valid.                                                       */
        if((Parameter_Count >= 2) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= 1))
        {
            /* Store the parameters.                                          */
            Enable = (boolean_t)Parameter_List[1].Integer_Value;

            /* If an advertising set is going to be enabled.                  */
            if(Enable)
            {
                /* Make sure the NumberOfSets and AdvertisingHandle parameter  */
                /* is semi-valid.                                              */
                /* * NOTE * NumberOfSets MUST be 1 for this function.          */
                if((Parameter_Count >= 4) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value == 1) &&
                        (Parameter_List[3].Integer_Is_Valid))
                {
                    /* Store the parameters.                                    */
                    NumberOfSets      = (uint8_t)Parameter_List[2].Integer_Value;
                    AdvertisingHandle = (uint8_t)Parameter_List[3].Integer_Value;

                    /* Check if the optional Duration and MaxExtAdvertisingEvent*/
                    /* parameters are specified.                                */
                    if((Parameter_Count == 6) && (Parameter_List[4].Integer_Is_Valid) && (Parameter_List[5].Integer_Is_Valid))
                    {
                        /* Store the optional parameters.                        */
                        Duration                = (uint32_t)Parameter_List[4].Integer_Value;
                        MaxExtAdvertisingEvents = (uint8_t)Parameter_List[5].Integer_Value;
                    }
                }
                else
                    ret_val = QCLI_STATUS_USAGE_E;
            }
            else
            {
                /* Make sure the NumberOfSets parameter is semi-valid.         */
                if((Parameter_Count >= 3) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= 0) && (Parameter_List[2].Integer_Value <= 1))
                {
                    /* Store the parameters.                                    */
                    NumberOfSets = (uint8_t)Parameter_List[2].Integer_Value;

                    /* If we are NOT disabling all sets (NumberOfSets = 0), then*/
                    /* the advertising handle MUST be valid.                    */
                    if(NumberOfSets)
                    {
                        /* Make sure the AdvertisingHandle parameter is valid.   */
                        if((Parameter_Count == 4) && (Parameter_List[3].Integer_Is_Valid))
                        {
                            /* Store the parameter.                               */
                            AdvertisingHandle = (uint8_t)Parameter_List[3].Integer_Value;
                        }
                        else
                            ret_val = QCLI_STATUS_USAGE_E;
                    }
                }
                else
                    ret_val = QCLI_STATUS_USAGE_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

        /* If an error has not occured.                                      */
        if(!ret_val)
        {
            /* Simply call the GAP function.                                  */
            Result = qc_drv_ble_GAP_LE_Enable_Extended_Advertising(qc_api_get_qc_drv_context(), BluetoothStackID, Enable, NumberOfSets, &AdvertisingHandle, &Duration, &MaxExtAdvertisingEvents, GAP_LE_Event_Callback, 0);
            if(!Result)
                LOG_INFO("   qapi_BLE_GAP_LE_Enable_Extended_Advertising() returned success.\n");
            else
            {
                LOG_WARN("   qapi_BLE_GAP_LE_Enable_Extended_Advertising() returned error: %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }

    } else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E ) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();


    return(ret_val);
}

static QCLI_Command_Status_t ExtendedScanParams(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                                Result;
    uint16_t                                           ScanInterval;
    uint16_t                                           ScanWindow;
    boolean_t                                          FilterWhiteList;
    QCLI_Command_Status_t                              ret_val = QCLI_STATUS_SUCCESS_E;
    qapi_BLE_GAP_LE_Address_Type_t                     OwnAddrType;
    qapi_BLE_GAP_LE_Filter_Policy_t                    ScanningFilterPolicy;
    qapi_BLE_GAP_LE_Extended_Scanning_PHY_Parameters_t ScanParameter;

    uint32_t                                               Duration;
    uint32_t                                               Period;
    boolean_t                                              Enable;
    qapi_BLE_GAP_LE_Extended_Scan_Filter_Duplicates_Type_t FilterDuplicates;

    if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"set_ext_scan_params") == 0)) {
        /* Make sure the mandatory parameters are semi-valid.                */
        if((Parameter_Count >= 4) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[3].Integer_Is_Valid))
        {
            /* Store the parameters.                                          */
            ScanInterval    = (uint16_t)Parameter_List[1].Integer_Value;
            ScanWindow      = (uint16_t)Parameter_List[2].Integer_Value;
            FilterWhiteList = (boolean_t)Parameter_List[3].Integer_Value;
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

        /* If an error has not occured.                                      */
        if(!ret_val)
        {
            /* Store the default options.                                     */
            ScanParameter.Scan_PHY      = QAPI_BLE_LPT_PHY_LE_1M_E;
            ScanParameter.Scan_Type     = QAPI_BLE_ST_ACTIVE_E;
            ScanParameter.Scan_Interval = ScanInterval;
            ScanParameter.Scan_Window   = ScanWindow;
            OwnAddrType                 = QAPI_BLE_LAT_PUBLIC_E;

            if(FilterWhiteList)
                ScanningFilterPolicy     = QAPI_BLE_FP_WHITE_LIST_E;
            else
                ScanningFilterPolicy     = QAPI_BLE_FP_NO_FILTER_E;

            Result = qc_drv_ble_GAP_LE_Set_Extended_Scan_Parameters(qc_api_get_qc_drv_context(), BluetoothStackID, OwnAddrType, ScanningFilterPolicy, 1, &ScanParameter);
            if(!Result)
                LOG_INFO("   qapi_BLE_GAP_LE_Set_Extended_Scan_Parameters() returned success.\n");
            else
            {
                LOG_ERR("   qapi_BLE_GAP_LE_Set_Extended_Scan_Parameters() returned error: %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }

    } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"en_ext_scan") == 0)) {

        /* Make sure the mandatory parameters are semi-valid.                */
        if((Parameter_Count >= 2) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= 1))
        {
            /* Store the parameters.                                          */
            Enable           = (boolean_t)Parameter_List[1].Integer_Value;
            FilterDuplicates = QAPI_BLE_FD_DISABLED_E;
            Duration         = 0;
            Period           = 0;
            /* If an advertising set is going to be enabled.                  */
            if(Enable)
            {
                /* Make sure the remaining parameters are valid.               */
                if((Parameter_Count == 4) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[3].Integer_Is_Valid))
                {
                    /* Store the parameter.                                     */
                    FilterDuplicates = QAPI_BLE_FD_ENABLED_E;
                    Duration         = (uint32_t)Parameter_List[2].Integer_Value;
                    Period           = (uint32_t)Parameter_List[3].Integer_Value;
                }
                else
                    ret_val = QCLI_STATUS_USAGE_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

        /* If an error has not occured.                                      */
        if(!ret_val)
        {
            /* Enable extended scanning.                                      */
            Result = qc_drv_ble_GAP_LE_Enable_Extended_Scan(qc_api_get_qc_drv_context(), BluetoothStackID, Enable, FilterDuplicates, Duration, Period, GAP_LE_Event_Callback, 0);
            if(!Result)
                LOG_INFO("   qapi_BLE_GAP_LE_Enable_Extended_Scan() returned success.\n");
            else
            {
                LOG_ERR("   qapi_BLE_GAP_LE_Enable_Extended_Scan() returned error: %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }

    } else
        ret_val = QCLI_STATUS_USAGE_E;
    if ((ret_val == QCLI_STATUS_SUCCESS_E ) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for sending an extended     */
/* connection request to a specified remote device. This function    */
/* will return zero on successful execution and a negative value on  */
/* errors.                                                           */
static QCLI_Command_Status_t ExtendedConnect(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                              Result;
    qapi_BLE_BD_ADDR_t                               PeerAddr;
    QCLI_Command_Status_t                            ret_val = QCLI_STATUS_SUCCESS_E;
    qapi_BLE_GAP_LE_Address_Type_t                   OwnAddrType;
    qapi_BLE_GAP_LE_Address_Type_t                   PeerAddrType;
    qapi_BLE_GAP_LE_Filter_Policy_t                  FilterPolicy;
    qapi_BLE_GAP_LE_Extended_Connection_Parameters_t ConnParameters;

    /* Make sure the remote address and address type have been specified.*/
    if((Parameter_Count == 2) && (Parameter_List[0].String_Value) && (strlen((char *)(Parameter_List[0].String_Value)) == (sizeof(qapi_BLE_BD_ADDR_t) * 2)) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= QAPI_BLE_LAT_PUBLIC_E) && (Parameter_List[1].Integer_Value <= QAPI_BLE_LAT_RANDOM_IDENTITY_E))
    {
        /* Store the mandatory parameters.                                */
        StrToBD_ADDR((char *)(Parameter_List[0].String_Value), &PeerAddr);
        PeerAddrType = (uint8_t)Parameter_List[1].Integer_Value;
    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    /* If an error has not occured.                                      */
    if(!ret_val)
    {
        /* Check to see if we need to configure the default Scan          */
        /* Parameters.                                                    */
        if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID))
        {
            /* Configure the default Scan Window and Scan Interval.        */
            BLEParameters.ScanParameters.ScanWindow   = 50;
            BLEParameters.ScanParameters.ScanInterval = 100;

            /* Flag that the scan parameters are valid so that we do not   */
            /* re-configure the defaults un-necessarily.                   */
            BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_SCAN_PARAMETERS_VALID;
        }

        /* Check to see if we need to configure the default Connection    */
        /* Parameters.                                                    */
        if(!(BLEParameters.Flags & BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID))
        {
            /* Initialize the default connection parameters.               */
            BLEParameters.ConnectionParameters.Connection_Interval_Min    = 50;
            BLEParameters.ConnectionParameters.Connection_Interval_Max    = 200;
            BLEParameters.ConnectionParameters.Minimum_Connection_Length  = 0;
            BLEParameters.ConnectionParameters.Maximum_Connection_Length  = 10000;
            BLEParameters.ConnectionParameters.Slave_Latency              = 0;
            BLEParameters.ConnectionParameters.Supervision_Timeout        = 20000;

            /* Flag that the connection parameters are valid so that we do */
            /* not re-configure the defaults un-necessarily.               */
            BLEParameters.Flags |= BLE_PARAMETERS_FLAGS_CONNECTION_PARAMETERS_VALID;
        }

        /* Format the connection parameters.                              */
        ConnParameters.Initiating_PHY            = QAPI_BLE_LPT_PHY_LE_1M_E;
        ConnParameters.Scan_Interval             = BLEParameters.ScanParameters.ScanInterval;
        ConnParameters.Scan_Window               = BLEParameters.ScanParameters.ScanWindow;
        ConnParameters.Connection_Interval_Min   = BLEParameters.ConnectionParameters.Connection_Interval_Min;
        ConnParameters.Connection_Interval_Max   = BLEParameters.ConnectionParameters.Connection_Interval_Max;
        ConnParameters.Slave_Latency             = BLEParameters.ConnectionParameters.Slave_Latency;
        ConnParameters.Supervision_Timeout       = BLEParameters.ConnectionParameters.Supervision_Timeout;
        ConnParameters.Minimum_Connection_Length = BLEParameters.ConnectionParameters.Minimum_Connection_Length;
        ConnParameters.Maximum_Connection_Length = BLEParameters.ConnectionParameters.Maximum_Connection_Length;

        /* Set the default options.                                       */
        FilterPolicy = QAPI_BLE_FP_NO_FILTER_E;
        OwnAddrType  = QAPI_BLE_LAT_PUBLIC_E;

        /* Simply call the GAP function.                                  */
        Result = qc_drv_ble_GAP_LE_Extended_Create_Connection(qc_api_get_qc_drv_context(), BluetoothStackID, FilterPolicy, PeerAddrType, &PeerAddr, OwnAddrType, 1, &ConnParameters, GAP_LE_Event_Callback, 0);
        if(!Result)
            LOG_INFO("   qapi_BLE_HCI_LE_Extended_Create_Connection returned success.\n");
        else
        {
            LOG_ERR("   qapi_BLE_HCI_LE_Extended_Create_Connection returned error: %d.\n", Result);

            ret_val = QCLI_STATUS_ERROR_E;
        }
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

#endif

/* Generic Attribute Profile (GATT) QCLI command functions.          */

/* The following function is responsible for performing a GATT       */
/* Service Discovery Operation.  This function will return zero on   */
/* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t DiscoverServices(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                     Result;
    DeviceInfo_t                           *DeviceInfo;
    QCLI_Command_Status_t                   ret_val;
    qapi_BLE_GATT_Attribute_Handle_Group_t  DiscoveryHandleRange;

    /* Verify that there is a connection that is established.            */
    if(ConnectionCount)
    {
        /* Lock the Bluetooth stack.                                      */
        if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
        {
            /* Get the device info for the connection device.              */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
                /* Verify that no service discovery is outstanding for this */
                /* device.                                                  */
                if(!(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING))
                {
                    /* Start the service discovery process.                  */
                    if((Parameter_Count >= 2) && (Parameter_List[0].Integer_Value) && (Parameter_List[1].Integer_Value) && (Parameter_List[0].Integer_Value <= Parameter_List[1].Integer_Value))
                    {
                        memset(&DiscoveryHandleRange, 0, sizeof(DiscoveryHandleRange));
                        DiscoveryHandleRange.Starting_Handle = Parameter_List[0].Integer_Value;
                        DiscoveryHandleRange.Ending_Handle   = Parameter_List[1].Integer_Value;

                        Result = qc_drv_ble_GATT_Start_Service_Discovery_Handle_Range(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, &DiscoveryHandleRange, 0, NULL, GATT_Service_Discovery_Event_Callback, 0);
                    }
                    else
                        Result = qc_drv_ble_GATT_Start_Service_Discovery(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, 0, NULL, GATT_Service_Discovery_Event_Callback, 0);

                    if(!Result)
                    {
                        /* Display success message.                           */
                        LOG_INFO("qapi_BLE_GATT_Service_Discovery_Start() success.\n");

                        /* Flag that a Service Discovery Operation is         */
                        /* outstanding.                                       */
                        DeviceInfo->Flags |= DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING;

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                    {
                        /* An error occur so just clean-up.                   */
                        LOG_ERR("Error - GATT_Service_Discovery_Start returned %d.\n", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                {
                    LOG_ERR("Service Discovery Operation Outstanding for Device.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("No Device Info.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }

            /* Un-lock the Bluetooth Stack.                                */
            qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
        }
        else
        {
            LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    }
    else
    {
        LOG_ERR("No Connection Established\n");

        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

static QCLI_Command_Status_t SetGetGATTMTU(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    uint16_t              MTU;
    QCLI_Command_Status_t ret_val;

    /* First, check that valid Bluetooth Stack ID exists.                */
    if(BluetoothStackID)
    {
        /* Bluetooth Stack is initialized, go ahead and check to see if   */
        /* the parameters are valid.                                      */
        if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= QAPI_BLE_ATT_PROTOCOL_MTU_MINIMUM_LE) && (Parameter_List[0].Integer_Value <= QAPI_BLE_ATT_PROTOCOL_MTU_MAXIMUM))
        {
            /* Simply set the Maximum Supported MTU to the GATT layer.     */
            if((Result = qc_drv_ble_GATT_Change_Maximum_Supported_MTU(qc_api_get_qc_drv_context(), BluetoothStackID, (uint16_t)Parameter_List[0].Integer_Value)) == 0)
            {
                LOG_INFO("new GATT Maximum Supported MTU: %u.\n", (unsigned int)Parameter_List[0].Integer_Value);

                ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
                LOG_ERR("qapi_BLE_GATT_Change_Maximum_Supported_MTU() %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else if (Parameter_Count == 0 ) {
            if((Result = qc_drv_ble_GATT_Query_Maximum_Supported_MTU(qc_api_get_qc_drv_context(), BluetoothStackID, &MTU)) == 0)
            {
                LOG_INFO("Maximum GATT MTU: %u.\n", (unsigned int)MTU);

                ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
                LOG_ERR("qapi_BLE_GATT_Query_Maximum_Supported_MTU() %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
    {
        /* No valid Bluetooth Stack ID exists.                            */
        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* Generic Attribute Profile (GATT) helper functions.                */

/* The following function is used to enable/disable notifications on */
/* a specified handle.  This function returns the positive non-zero  */
/* Transaction ID of the Write Request or a negative error code.     */
static int EnableDisableNotificationsIndications(uint16_t ClientConfigurationHandle, uint16_t ClientConfigurationValue, unsigned int ConnectionID, qapi_BLE_GATT_Client_Event_Callback_t ClientEventCallback)
{
    int                       ret_val;
    qapi_BLE_NonAlignedWord_t Buffer;

    /* Verify the input parameters.                                      */
    if((BluetoothStackID) && (ConnectionID) && (ClientConfigurationHandle))
    {
        ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(&Buffer, ClientConfigurationValue);

        ret_val = qc_drv_ble_GATT_Write_Request(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionID, ClientConfigurationHandle, sizeof(Buffer), &Buffer, ClientEventCallback, 0);
    }
    else
        ret_val = QAPI_BLE_BTPS_ERROR_INVALID_PARAMETER;

    return(ret_val);
}

/* Automation IO Service (AIOS) QCLI command functions.              */

/* The following function is responsible for registering AIOS.  This */
/* function will return zero on successful execution and a negative  */
/* value on errors.                                                  */

/* The following function is responsible for unregistering AIOS.     */
/* This function will return zero on successful execution and a      */
/* negative value on errors.                                         */
static QCLI_Command_Status_t AIOSService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t                          ret_val = QCLI_STATUS_SUCCESS_E;
    int                                            Result;
    uint32_t                                       ServiceID;
    qapi_BLE_AIOS_Initialize_Data_t                InitializeData;
    unsigned int                                   Index;
    unsigned int                                   Index2;
    qapi_BLE_AIOS_Characteristic_Type_t            Type;
    AIOP_Server_Characteristic_Data_t             *CharacteristicDataPtr;
    AIOP_Server_Instance_Data_t                   *InstanceDataPtr;
    qapi_BLE_AIOS_Characteristic_Entry_t          *CharacteristicEntryPtr;
    qapi_BLE_AIOS_Characteristic_Instance_Entry_t *InstanceEntryPtr;

    /* Verify that there is no active connection.                        */
    if(!ConnectionCount)
    {
        if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"register") == 0)) {
            /* Register for the service is one is not already registered.     */
            if(!AIOSInstanceID)
            {
                /* Configure the AIOS Server.                                  */
                /* * NOTE * This function will initialize all default          */
                /*          Characteristic properties, descriptors, and        */
                /*          descriptor properties.  This function will set     */
                /*          default data values for Characteristics and        */
                /*          descriptors.                                       */
                ConfigureAIOSServer();

                /* Initialize the AIOS InitializeData structure so we do not   */
                /* have any unexpected behaviour.                              */
                memset(&InitializeData, 0, QAPI_BLE_AIOS_INITIALIZE_DATA_SIZE);

                /* Set the InitializeData fields based on the AIOS Server      */
                /* information that we initialized previously.                 */
                /* * NOTE * This demo does not support the Aggregate           */
                /*          Characteristic.                                    */
                InitializeData.Number_Of_Entries        = (uint8_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS;
                InitializeData.Aggregate_Supported      = FALSE;
                InitializeData.Aggregate_Property_Flags = 0;

                /* We need to allocate memory for the Entries field.           */
                if((InitializeData.Entries = (qapi_BLE_AIOS_Characteristic_Entry_t *)malloc(QAPI_BLE_AIOS_CHARACTERISTIC_ENTRY_SIZE * InitializeData.Number_Of_Entries)) != NULL)
                {
                    /* We will loop through each AIOS Characteristic Entry.     */
                    for(Index = 0; Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS; Index++)
                    {
                        /* The Index will be used to indicate the AIOS           */
                        /* Characteristic type.                                  */
                        Type = (qapi_BLE_AIOS_Characteristic_Type_t)Index;

                        /* Store a pointer to the Characteristic Entry           */
                        /* information in InitializeData.                        */
                        CharacteristicEntryPtr = &(InitializeData.Entries[Type]);

                        /* Store a pointer to the Characteristic information on  */
                        /* the AIOS Server.                                      */
                        CharacteristicDataPtr = &(AIOSServerInfo.Characteristic[Type]);

                        /* Simply copy the Characteristic Entry information we   */
                        /* initialized earlier in the AIOS Server information.   */
                        /* * NOTE * The Instances field has not be set since each*/
                        /*          instance on the AIOS Server will hold its    */
                        /*          Characteristic Instance Entry information.   */
                        /*          Whereas the                                  */
                        /*          qapi_BLE_AIOS_Characteristic_Entry_t has this*/
                        /*          information stored contiguously.             */
                        *CharacteristicEntryPtr = CharacteristicDataPtr->Characteristic_Entry;

                        /* We need to allocate memory of the Instances field     */
                        /* since it has not been set.                            */
                        if((CharacteristicEntryPtr->Instances = (qapi_BLE_AIOS_Characteristic_Instance_Entry_t *)malloc(QAPI_BLE_AIOS_CHARACTERISTIC_ENTRY_SIZE * CharacteristicEntryPtr->Number_Of_Instances)) != NULL)
                        {
                            /* We will loop through each AIOS Characteristic      */
                            /* Instance Entry.                                    */
                            for(Index2 = 0; Index2 < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES; Index2++)
                            {
                                /* Store a pointer to the Characteristic Instance  */
                                /* Entry information in InitializeData, in the     */
                                /* Entries field based on the AIOS Characteristic  */
                                /* type.                                           */
                                InstanceEntryPtr = &(CharacteristicEntryPtr->Instances[Index2]);

                                /* Store a pointer to the Characteristic instance  */
                                /* information.                                    */
                                /* * NOTE * The Index2 will be used to identify the*/
                                /*          AIOS Characteristic instance.  This    */
                                /*          also directly corresponds to the ID    */
                                /*          field that the service will use for the*/
                                /*          qapi_BLE_AIOS_Characteristic_Info_t    */
                                /*          structure.                             */
                                InstanceDataPtr = &(CharacteristicDataPtr->Instances[Index2]);

                                /* Simply copy the Characteristic Instance Entry   */
                                /* information we configured earlier in the AIOS   */
                                /* Server information.                             */
                                *InstanceEntryPtr = InstanceDataPtr->Instance_Entry;
                            }
                        }
                        else
                        {
                            LOG_ERR("Unable to allocate memory for the AIOS Characteristic instances.\n");

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                }
                else
                {
                    LOG_ERR("Unable to allocate memory for the AIOS Characteristics.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }

                /* If an error has not occured.                                */
                if(!ret_val)
                {
                    /* Register AIOS with GATT.                                 */
                    Result = qc_drv_ble_AIOS_Initialize_Service(qc_api_get_qc_drv_context(), BluetoothStackID, QAPI_BLE_AIOS_SERVICE_FLAGS_LE, &InitializeData, AIOS_EventCallback, 0, &ServiceID);
                    if((Result > 0) && (ServiceID > 0))
                    {
                        /* Display success message.                              */
                        LOG_INFO("Successfully registered AIOS Service, InstanceID = %u.\n", Result);

                        /* Save the instance ID of the registered service.       */
                        AIOSInstanceID = (unsigned int)Result;
                    }
                    else
                    {
                        DisplayFunctionError("qapi_BLE_AIOS_Initialize_Service", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }

                /* Free the memory for the InitializeData structure if it was  */
                /* allocated.                                                  */
                /* * NOTE * The AIOS Server retains a copy of this information */
                /*          for future use.                                    */
                for(Index = 0; Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS; Index++)
                {
                    if((InitializeData.Entries[Index].Number_Of_Instances) && (InitializeData.Entries[Index].Instances))
                    {
                        /* Free the Characteristic instance entries.             */
                        free(InitializeData.Entries[Index].Instances);
                        InitializeData.Entries[Index].Instances           = NULL;
                        InitializeData.Entries[Index].Number_Of_Instances = 0;
                    }
                }

                /* Free the Characteristic entries.                            */
                if((InitializeData.Number_Of_Entries) && (InitializeData.Entries))
                {
                    free(InitializeData.Entries);
                    InitializeData.Entries           = NULL;
                    InitializeData.Number_Of_Entries = 0;
                }
            }
            else
            {
                LOG_ERR("AIOS is already registered.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }

        } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"unregister") == 0)) {
            /* Verify that a service is registered.                           */
            if(AIOSInstanceID)
            {
                /* Unregister the AIOS Service with GATT.                      */
                Result = qc_drv_ble_AIOS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, AIOSInstanceID);
                if(Result == 0)
                {
                    /* Display success message.                                 */
                    LOG_INFO("Successfully unregistered AIOS: InstanceID %u.\n", AIOSInstanceID);

                    /* Clear the instance ID.                                   */
                    AIOSInstanceID = 0;

                    /* Return success to the caller.                            */
                    ret_val        = QCLI_STATUS_SUCCESS_E;
                }
                else
                    DisplayFunctionError("qapi_BLE_AIOS_Cleanup_Service", Result);
            }
            else
            {
                LOG_ERR("AIOS is not registered.\n");
                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
    {
        LOG_WARN("Connection currently active.\n");

        ret_val = QCLI_STATUS_ERROR_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for allowing an AIOS Client */
/* to configure an AIOS Digital or Analog Client Characteristic      */
/* Configuration Descriptor (CCCD) on the AIOS Server for            */
/* notifications.  This function will return zero on successful      */
/* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ConfigureRemoteAIOS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t               ret_val = QCLI_STATUS_ERROR_E;
    int                                 Result;
    DeviceInfo_t                       *DeviceInfo;
    qapi_BLE_AIOS_Characteristic_Type_t Type;
    uint16_t                            ID;
    AIOP_Client_Instance_Info_t        *InstanceInfoPtr;

    /* Verify that we are connected to a remote device.                  */
    if(ConnectionCount)
    {
        /* Verify that the input parameters are semi-valid.               */
        if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[2].Integer_Is_Valid))
        {
            /* Store the parameters.                                       */
            Type = (qapi_BLE_AIOS_Characteristic_Type_t)Parameter_List[0].Integer_Value;
            ID   = (uint16_t)Parameter_List[1].Integer_Value;

            /* Lock the Bluetooth stack.                                   */
            if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
            {
                /* Get the device info for the selected remote device.      */
                if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                {
                    LOG_INFO("Attempting to configure CCCDs...\n");

                    /* Get a pointer to the instance information that has    */
                    /* been specified by the user.                           */
                    InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[Type].Instances[ID]);

                    /* Make sure the characteristic instance has been        */
                    /* discovered.                                           */
                    if(InstanceInfoPtr->Valid)
                    {
                        /* Make sure the AIOS Client has discovered the CCCD. */
                        if(InstanceInfoPtr->CCCD_Handle)
                        {
                            Result = EnableDisableNotificationsIndications(InstanceInfoPtr->CCCD_Handle, (Parameter_List[2].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_AIOS);
                            if(Result > 0)
                            {
                                ret_val = QCLI_STATUS_SUCCESS_E;
                            }
                        }
                        else
                            LOG_ERR("AIOS characteristic CC not found on this device.\n");
                    }
                    else
                        LOG_INFO("Characteristic instance has not been discovered.\n");
                }
                else
                    LOG_INFO("No Device Info.\n");

                /* Un-lock the Bluetooth Stack.                             */
                qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
            }
            else
                LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        LOG_WARN("No Connection Established.\n");

    return(ret_val);
}

/* The following function is responsible for allowing an AIOS Client */
/* to read an AIOS Digital or Analog Characteristic Value on the AIOS*/
/* Server.  This function will return zero on successful execution   */
/* and a negative value on errors.                                   */

/* The following function is responsible for allowing an AIOS Client */
/* to read an AIOS Digital or Analog Presentation Format Descriptor  */
/* on the AIOS Server.  This function will return zero on successful */
/* execution and a negative value on errors.                         */

/* The following function is responsible for allowing an AIOS Client */
/* to read an AIOS Digital Characteristic's Number of Digitals       */
/* descriptor on the AIOS Server.  This function will return zero on */
/* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t AIOSRead(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t               ret_val = QCLI_STATUS_ERROR_E;
    int                                 Result;
    DeviceInfo_t                       *DeviceInfo;
    qapi_BLE_AIOS_Characteristic_Type_t Type;
    qapi_BLE_AIOS_Characteristic_Info_t  Info;
    qapi_BLE_AIOS_Characteristic_Data_t  Data;
    uint16_t                            ID;
    AIOP_Client_Instance_Info_t        *InstanceInfoPtr;
    AIOP_Server_Instance_Data_t 		*InstanceDataPtr;
    uint16_t                            AttributeHandle;

    /* Verify that we are connected to a remote device.                  */
    if(ConnectionCount)
    {
        if ((Parameter_Count >= 3) && (APP_STRCMP(Parameter_List[0].String_Value,"ReadChar") == 0)) {
            /* Verify that the input parameters are semi-valid.               */
            if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= 0) && (Parameter_List[2].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES))
            {
                /* Store the parameters.                                       */
                Type = (qapi_BLE_AIOS_Characteristic_Type_t)Parameter_List[1].Integer_Value;
                ID   = (uint16_t)Parameter_List[2].Integer_Value;

                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the selected remote device.      */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Get a pointer to the instance information that has    */
                        /* been specified by the user.                           */
                        InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[Type].Instances[ID]);

                        /* Make sure the characteristic instance has been        */
                        /* discovered.                                           */
                        if(InstanceInfoPtr->Valid)
                        {
                            /* Determine the attribute handle based on the        */
                            /* specified AIOS Characteristic type.                */
                            if(Type == QAPI_BLE_ACT_DIGITAL_E)
                                AttributeHandle = InstanceInfoPtr->Digital_Characteristic_Handle;
                            else
                                AttributeHandle = InstanceInfoPtr->Analog_Charactersitic_Handle;

                            /* Make sure the AIOS Client has discovered the       */
                            /* Characteristic.                                    */
                            if(AttributeHandle)
                            {
                                /* Store the request information so we can handle  */
                                /* the response.                                   */
                                DeviceInfo->AIOPClientInfo.Client_Request_Info.AttributeHandleType = ahtCharacteristic;
                                DeviceInfo->AIOPClientInfo.Client_Request_Info.Type                = Type;
                                DeviceInfo->AIOPClientInfo.Client_Request_Info.ID                  = ID;

                                /* Finally, submit a readrequest to the server    */
                                if((Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, AttributeHandle, GATT_ClientEventCallback_AIOS, AttributeHandle)) > 0)
                                {
                                    LOG_INFO("AIOS Characteristic Request sent, Transaction ID = %u", Result);

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                    DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                            }
                            else
                                LOG_INFO("   Error - AIOS Characteristic not found on this device.\n");
                        }
                        else
                            LOG_INFO("Characteristic instance has not been discovered.\n");
                    }
                    else
                        LOG_WARN("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;
        } else if ((Parameter_Count >= 3) && (APP_STRCMP(Parameter_List[0].String_Value,"ReadPresent") == 0)) {

            /* Verify that the input parameters are semi-valid.               */
            if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= 0) && (Parameter_List[2].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES))
            {
                /* Store the parameters.                                       */
                Type = (qapi_BLE_AIOS_Characteristic_Type_t)Parameter_List[1].Integer_Value;
                ID   = (uint16_t)Parameter_List[2].Integer_Value;

                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the selected remote device.      */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Get a pointer to the instance information that has    */
                        /* been specified by the user.                           */
                        InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[Type].Instances[ID]);

                        /* Make sure the characteristic instance has been        */
                        /* discovered.                                           */
                        if(InstanceInfoPtr->Valid)
                        {
                            /* Make sure the AIOS Client has discovered the       */
                            /* Presentation Format Descriptor.                    */
                            if(InstanceInfoPtr->Presentation_Format_Handle)
                            {
                                /* Store the request information so we can handle  */
                                /* the response.                                   */
                                DeviceInfo->AIOPClientInfo.Client_Request_Info.AttributeHandleType = ahtPresentationFormat;
                                DeviceInfo->AIOPClientInfo.Client_Request_Info.Type                = Type;
                                DeviceInfo->AIOPClientInfo.Client_Request_Info.ID                  = ID;

                                /* Finally, submit a read request to the server    */
                                if((Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, InstanceInfoPtr->Presentation_Format_Handle, GATT_ClientEventCallback_AIOS, InstanceInfoPtr->Presentation_Format_Handle)) > 0)
                                {
                                    LOG_INFO("AIOS Presentation Format Descriptor Request sent, Transaction ID = %u", Result);

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                    DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                            }
                            else
                                LOG_ERR("AIOS Presentation Format Descriptor not found on this device.\n");
                        }
                        else
                            LOG_WARN("Characteristic instance has not been discovered.\n");
                    }
                    else
                        LOG_WARN("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;

        } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"ReadNumber") == 0)) {

            /* Verify that the input parameters are semi-valid.               */
            if((Parameter_List) && (Parameter_Count >= 2) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES))
            {
                /* Store the parameters.                                       */
                ID = (uint16_t)Parameter_List[1].Integer_Value;

                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the selected remote device.      */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Get a pointer to the instance information that has    */
                        /* been specified by the user.                           */
                        InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_DIGITAL_E].Instances[ID]);

                        /* Make sure the characteristic instance has been        */
                        /* discovered.                                           */
                        if(InstanceInfoPtr->Valid)
                        {
                            /* Make sure the AIOS Client has discovered the Number*/
                            /* Of Digitals Descriptor.                            */
                            if(InstanceInfoPtr->Number_Of_Digitals_Handle)
                            {
                                /* Store the request information so we can handle  */
                                /* the response.                                   */
                                DeviceInfo->AIOPClientInfo.Client_Request_Info.AttributeHandleType = ahtNumberOfDigitals;
                                DeviceInfo->AIOPClientInfo.Client_Request_Info.Type                = QAPI_BLE_ACT_DIGITAL_E;
                                DeviceInfo->AIOPClientInfo.Client_Request_Info.ID                  = ID;

                                /* Finally, submit a read request to the server    */
                                if((Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, InstanceInfoPtr->Number_Of_Digitals_Handle, GATT_ClientEventCallback_AIOS, InstanceInfoPtr->Number_Of_Digitals_Handle)) > 0)
                                {
                                    LOG_INFO("AIOS Number Of Digitals Descriptor Request sent, Transaction ID = %u", Result);

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                    DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                            }
                            else
                                LOG_WARN("   Error - AIOS Number Of Digitals Descriptor not found on this device.\n");
                        }
                        else
                            LOG_WARN("Characteristic instance has not been discovered.\n");
                    }
                    else
                        LOG_WARN("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;

        } else if ((Parameter_Count >= 3) && (APP_STRCMP(Parameter_List[0].String_Value,"NotifyAIOSChar") == 0)) {
            /* Verify that the input parameters are semi-valid.               */
            if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[2].Integer_Value >= 0) && (Parameter_List[2].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES))
            {
                /* Store the parameters.                                       */
                Type = (qapi_BLE_AIOS_Characteristic_Type_t)Parameter_List[1].Integer_Value;
                ID   = (uint16_t)Parameter_List[2].Integer_Value;

                /* Make sure we are the AIOS Server.                           */
                if(AIOSInstanceID)
                {
                    /* Lock the Bluetooth stack.                                */
                    if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                    {
                        /* Get the device info for the selected remote device.   */
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                        {
                            /* Get a pointer to the instance data that has been   */
                            /* specified by the user.                             */
                            InstanceDataPtr = &(AIOSServerInfo.Characteristic[Type].Instances[ID]);

                            /* Make sure the AIOS Client has configured the       */
                            /* specified characteristic for notifications.        */
                            if(DeviceInfo->AIOPServerConfiguration == QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                            {
                                /* Determine the attribute handle based on the     */
                                /* specified AIOS Characteristic type.             */
                                if(Type == QAPI_BLE_ACT_DIGITAL_E)
                                {
                                    /* Format the characteristic information.       */
                                    Info.ID     = ID;
                                    Info.Type   = Type;
                                    Info.IOType = InstanceDataPtr->Instance_Entry.IO_Type;

                                    /* Format the notification.                     */
                                    Data.Digital.Buffer = InstanceDataPtr->Data.Digital;
                                    Data.Digital.Length = 2;

                                    /* Finally, send the notification.              */
                                    if((Result = qc_drv_ble_AIOS_Notify_Characteristic(qc_api_get_qc_drv_context(), BluetoothStackID, AIOSInstanceID, DeviceInfo->ConnectionID, &Info, &Data)) > 0)
                                    {
                                        LOG_INFO("AIOS Characteristic Notification sent, Length = %u", Result);

                                        ret_val = QCLI_STATUS_SUCCESS_E;
                                    }
                                    else
                                        DisplayFunctionError("qapi_BLE_AIOS_Notify_Characteristic", Result);
                                }
                                else
                                {
                                    /* Format the characteristic information.       */
                                    Info.ID     = ID;
                                    Info.Type   = Type;
                                    Info.IOType = InstanceDataPtr->Instance_Entry.IO_Type;

                                    /* Format the notification.                     */
                                    Data.Digital.Buffer = (uint8_t *)&(InstanceDataPtr->Data.Analog);
                                    Data.Digital.Length = 2;

                                    /* Finally, send the notification.              */
                                    if((Result = qc_drv_ble_AIOS_Notify_Characteristic(qc_api_get_qc_drv_context(), BluetoothStackID, AIOSInstanceID, DeviceInfo->ConnectionID, &Info, &Data)) > 0)
                                    {
                                        LOG_INFO("AIOS Characteristic Notification sent, Length = %u", Result);

                                        ret_val = QCLI_STATUS_SUCCESS_E;
                                    }
                                    else
                                        DisplayFunctionError("qapi_BLE_AIOS_Notify_Characteristic", Result);
                                }
                            }
                            else
                                LOG_INFO("   Error - The AIOS Client has not configured the CCCD for notifications.\n");
                        }
                        else
                            LOG_INFO("No Device Info.\n");

                        /* Un-lock the Bluetooth Stack.                          */
                        qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                    }
                    else
                        LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
                }
                else
                    LOG_ERR("Only the AIOS Server may send a notification.\n");
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;


        }else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        LOG_INFO("No Connection Established.\n");

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for allowing an AIOS Client */
/* or AIOS Server to write an AIOS Digital Output Characteristic.    */
/* This function will return zero on successful execution and a      */
/* negative value on errors.                                         */

/* The following function is responsible for allowing an AIOS Client */
/* or AIOS Server to write an AIOS Analog Output Characteristic.     */
/* This function will return zero on successful execution and a      */
/* negative value on errors.                                         */

/* The following function is responsible for allowing an AIOS Server */
/* to set an AIOS Digital Input Characteristic.  This function will  */
/* return zero on successful execution and a negative value on       */
/* errors.                                                           */

/* The following function is responsible for allowing an AIOS Server */
/* to set an AIOS Analog Input Characteristic.  This function will   */
/* return zero on successful execution and a negative value on       */
/* errors.                                                           */
static QCLI_Command_Status_t AIOSWrite(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t        ret_val = QCLI_STATUS_ERROR_E;
    int                          Result;
    DeviceInfo_t                *DeviceInfo;
    uint16_t                     ID;
    AIOP_Server_Instance_Data_t *InstanceDataPtr;
    AIOP_Client_Instance_Info_t *InstanceInfoPtr;
    qapi_BLE_NonAlignedWord_t    Buffer;
    uint16_t                     AnalogValue;
    uint8_t                      DigitalValue[2];

    if ((Parameter_Count >= 4) && (APP_STRCMP(Parameter_List[0].String_Value,"WriteDigOutput") == 0)) {
        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count >= 4) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[3].Integer_Is_Valid))
        {
            /* Store the parameters.                                          */
            ID              = (uint16_t)Parameter_List[1].Integer_Value;
            DigitalValue[0] = (uint8_t)Parameter_List[2].Integer_Value;
            DigitalValue[1] = (uint8_t)Parameter_List[3].Integer_Value;

            /* If this is the AIOS Server, then we will update the digital    */
            /* output value.  Otherwise, we will send a GATT Write request to */
            /* update the digital output value on the AIOS Server.            */
            if(AIOSInstanceID)
            {
                /* Get a pointer to the instance data that has been specified  */
                /* by the user.                                                */
                InstanceDataPtr = &(AIOSServerInfo.Characteristic[QAPI_BLE_ACT_DIGITAL_E].Instances[ID]);

                /* Make sure the Digital Characteristic is an output.          */
                if(InstanceDataPtr->Instance_Entry.IO_Type == QAPI_BLE_IO_OUTOUT_E)
                {
                    /* Update the value.                                        */
                    InstanceDataPtr->Data.Digital[0] = DigitalValue[0];
                    InstanceDataPtr->Data.Digital[1] = DigitalValue[1];
                }
                else
                    LOG_ERR("AIOS Digital Input Characteristic CANNOT be written.\n");
            }
            else
            {
                /* Verify that we are connected to a remote device.            */
                if(ConnectionCount)
                {
                    /* Lock the Bluetooth stack.                                */
                    if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                    {
                        /* Get the device info for the selected remote device.   */
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                        {
                            /* Get a pointer to the instance information that has */
                            /* been specified by the user.                        */
                            InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_DIGITAL_E].Instances[ID]);

                            /* Make sure the characteristic instance has been     */
                            /* discovered.                                        */
                            if(InstanceInfoPtr->Valid)
                            {
                                /* Make sure the AIOS Client has discovered the    */
                                /* Digital Characteristic.                         */
                                if(InstanceInfoPtr->Digital_Characteristic_Handle)
                                {
                                    /* Make sure the Digital Characteristic is an   */
                                    /* output.                                      */
                                    if(InstanceInfoPtr->IOType == QAPI_BLE_IO_OUTOUT_E)
                                    {
                                        /* Finally, submit a read request to the     */
                                        /* server                                    */
                                        if((Result = qc_drv_ble_GATT_Write_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, InstanceInfoPtr->Digital_Characteristic_Handle, 2, DigitalValue, GATT_ClientEventCallback_AIOS, InstanceInfoPtr->Digital_Characteristic_Handle)) > 0)
                                        {
                                            LOG_INFO("AIOS Digital Characteristic Request sent, Transaction ID = %u", Result);

                                            ret_val = QCLI_STATUS_SUCCESS_E;
                                        }
                                        else
                                            DisplayFunctionError("qapi_BLE_GATT_Write_Request", Result);
                                    }
                                    else
                                        LOG_ERR("AIOS Digital Input Characteristic CANNOT be written.\n");
                                }
                                else
                                    LOG_ERR("AIOS Digital Characteristic not found on this device.\n");
                            }
                            else
                                LOG_WARN("Characteristic instance has not been discovered.\n");
                        }
                        else
                            LOG_WARN("No Device Info.\n");

                        /* Un-lock the Bluetooth Stack.                          */
                        qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                    }
                    else
                        LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
                }
                else
                    LOG_WARN("No Connection Established.\n");
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    } else if ((Parameter_Count >= 3) && (APP_STRCMP(Parameter_List[0].String_Value,"WriteAnOutput") == 0)) {

        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[2].Integer_Is_Valid))
        {
            /* Store the parameters.                                          */
            ID          = (uint16_t)Parameter_List[1].Integer_Value;
            AnalogValue = (uint16_t)Parameter_List[2].Integer_Value;

            /* If this is the AIOS Server, then we will update the digital    */
            /* output value.  Otherwise, we will send a GATT Write request to */
            /* update the digital output value on the AIOS Server.            */
            if(AIOSInstanceID)
            {
                /* Get a pointer to the instance data that has been specified  */
                /* by the user.                                                */
                InstanceDataPtr = &(AIOSServerInfo.Characteristic[QAPI_BLE_ACT_ANALOG_E].Instances[ID]);

                /* Make sure the Digital Characteristic is an output.          */
                if(InstanceDataPtr->Instance_Entry.IO_Type == QAPI_BLE_IO_OUTOUT_E)
                {
                    /* Update the value.                                        */
                    InstanceDataPtr->Data.Analog = AnalogValue;
                }
                else
                    LOG_WARN("   Error - AIOS Analog Input Characteristic CANNOT be written.\n");
            }
            else
            {
                /* Verify that we are connected to a remote device.            */
                if(ConnectionCount)
                {
                    /* Lock the Bluetooth stack.                                */
                    if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                    {
                        /* Get the device info for the selected remote device.   */
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                        {
                            /* Get a pointer to the instance information that has */
                            /* been specified by the user.                        */
                            InstanceInfoPtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_ANALOG_E].Instances[ID]);

                            /* Make sure the characteristic instance has been     */
                            /* discovered.                                        */
                            if(InstanceInfoPtr->Valid)
                            {
                                /* Make sure the AIOS Client has discovered the    */
                                /* Analog Characteristic.                          */
                                if(InstanceInfoPtr->Analog_Charactersitic_Handle)
                                {
                                    /* Make sure the Analog Characteristic is an    */
                                    /* output.                                      */
                                    if(InstanceInfoPtr->IOType == QAPI_BLE_IO_OUTOUT_E)
                                    {
                                        /* Format the buffer.                        */
                                        ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(&Buffer, AnalogValue);

                                        /* Finally, submit a read request to the     */
                                        /* server                                    */
                                        if((Result = qc_drv_ble_GATT_Write_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, InstanceInfoPtr->Analog_Charactersitic_Handle, 2, &Buffer, GATT_ClientEventCallback_AIOS, InstanceInfoPtr->Analog_Charactersitic_Handle)) > 0)
                                        {
                                            LOG_INFO("AIOS Analog Characteristic Request sent, Transaction ID = %u", Result);

                                            ret_val = QCLI_STATUS_SUCCESS_E;
                                        }
                                        else
                                            DisplayFunctionError("qapi_BLE_GATT_Write_Request", Result);
                                    }
                                    else
                                        LOG_ERR("AIOS Analog Input Characteristic CANNOT be written.\n");
                                }
                                else
                                    LOG_ERR("AIOS Analog Characteristic not found on this device.\n");
                            }
                            else
                                LOG_ERR("Characteristic instance has not been discovered.\n");
                        }
                        else
                            LOG_ERR("No Device Info.\n");

                        /* Un-lock the Bluetooth Stack.                          */
                        qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                    }
                    else
                        LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
                }
                else
                    LOG_WARN("No Connection Established.\n");
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    } else if ((Parameter_Count >= 4) && (APP_STRCMP(Parameter_List[0].String_Value,"SetDigOutput") == 0)) {

        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count >= 4) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[3].Integer_Is_Valid))
        {
            /* Store the parameters.                                          */
            ID              = (uint16_t)Parameter_List[1].Integer_Value;
            DigitalValue[0] = (uint8_t)Parameter_List[2].Integer_Value;
            DigitalValue[1] = (uint8_t)Parameter_List[3].Integer_Value;

            /* If this is the AIOS Server, then we will update the digital    */
            /* output value.  Otherwise, we will send a GATT Write request to */
            /* update the digital output value on the AIOS Server.            */
            if(AIOSInstanceID)
            {
                /* Get a pointer to the instance data that has been specified  */
                /* by the user.                                                */
                InstanceDataPtr = &(AIOSServerInfo.Characteristic[QAPI_BLE_ACT_DIGITAL_E].Instances[ID]);

                /* Make sure the Digital Characteristic is an output.          */
                if(InstanceDataPtr->Instance_Entry.IO_Type == QAPI_BLE_IO_INPUT_E)
                {
                    /* Update the value.                                        */
                    InstanceDataPtr->Data.Digital[0] = DigitalValue[0];
                    InstanceDataPtr->Data.Digital[1] = DigitalValue[1];
                }
                else
                    LOG_ERR("AIOS Digital Output Characteristic CANNOT be set.\n");
            }
            else
                LOG_ERR("Only the AIOS Server may set the Digital Input Characteristic.\n");
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    } else if ((Parameter_Count >= 3) && (APP_STRCMP(Parameter_List[0].String_Value,"SetAnOutput") == 0)) {
        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= (int32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES) && (Parameter_List[2].Integer_Is_Valid))
        {
            /* Store the parameters.                                          */
            ID          = (uint16_t)Parameter_List[1].Integer_Value;
            AnalogValue = (uint16_t)Parameter_List[2].Integer_Value;

            /* Make sure we are the AIOS Server.                              */
            if(AIOSInstanceID)
            {
                /* Get a pointer to the instance data that has been specified  */
                /* by the user.                                                */
                InstanceDataPtr = &(AIOSServerInfo.Characteristic[QAPI_BLE_ACT_ANALOG_E].Instances[ID]);

                /* Make sure the Digital Characteristic is an output.          */
                if(InstanceDataPtr->Instance_Entry.IO_Type == QAPI_BLE_IO_INPUT_E)
                {
                    /* Update the value.                                        */
                    InstanceDataPtr->Data.Analog = AnalogValue;
                }
                else
                    LOG_ERR("AIOS Analog Output Characteristic CANNOT be set.\n");
            }
            else
                LOG_ERR("Only the AIOS Server may set the Analog Input Characteristic.\n");
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    }else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}


/* The following function is responsible for allowing an AIOS Server */
/* to notify the specify AIOS Characteristic to a remote AIOS Client.*/
/* This function will return zero on successful execution and a      */
/* negative value on errors.                                         */
/* The following function will configure the AIOS Server before it is*/
/* initialized by a call to qapi_BLE_AIOS_Initialize_Service().      */
static void ConfigureAIOSServer(void)
{
    unsigned int                         Index;
    unsigned int                         Index2;
    qapi_BLE_AIOS_Characteristic_Type_t  Type;
    AIOP_Server_Characteristic_Data_t   *CharacteristicDataPtr;
    AIOP_Server_Instance_Data_t         *InstanceDataPtr;

    /* Initialize the AIOS Server information.                           */
    memset(&AIOSServerInfo, 0, AIOP_SERVER_INFORMATION_DATA_SIZE);

    /* Loop to initialize the AIOS Characteristic's information that will*/
    /* be used for all AIOS Characteristic instances.                    */
    for(Index = 0; Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_CHARACTERISTICS; Index++)
    {
        /* The Index will be used to indicate the AIOS Characteristic     */
        /* type.                                                          */
        Type = (qapi_BLE_AIOS_Characteristic_Type_t)Index;

        /* Store a pointer to the Characteristic information.             */
        CharacteristicDataPtr = &(AIOSServerInfo.Characteristic[Type]);

        /* Let's go ahead and initialize the Characteristic's information.*/
        /* * NOTE * We will not set the Instances field since it will not */
        /*          be used for the AIOS Server.  It will be set for the  */
        /*          qapi_BLE_AIOS_Initialize_Data_t structure we when copy*/
        /*          this information to it.                               */
        CharacteristicDataPtr->Characteristic_Entry.Type                = (qapi_BLE_AIOS_Characteristic_Type_t)Index;
        CharacteristicDataPtr->Characteristic_Entry.Number_Of_Instances = (uint16_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES;
        CharacteristicDataPtr->Characteristic_Entry.Instances           = NULL;

        /* Loop to initialize all AIOS Characteristic instance's          */
        /* information for this Characteristic type.                      */
        for(Index2 = 0; Index2 < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES; Index2++)
        {
            /* Store a pointer to the Characteristic instance information. */
            /* * NOTE * The Index2 will be used to identify the AIOS       */
            /*          Characteristic instance.  This also directly       */
            /*          corresponds to the ID field that the service will  */
            /*          use for the AIOS_Characteristic_Info_t structure.  */
            InstanceDataPtr = &(CharacteristicDataPtr->Instances[Index2]);

            /* Let's go ahead and initialize the instances IO Type.        */
            /* * NOTE * We will make even indexes inputs and odd indexes   */
            /*          outputs.                                           */
            InstanceDataPtr->Instance_Entry.IO_Type = (Index2 % 2 == 0) ? QAPI_BLE_IO_INPUT_E : QAPI_BLE_IO_OUTOUT_E;

            /* We will go ahead and initiailze the fields that depend on   */
            /* the IOType.                                                 */
            switch(InstanceDataPtr->Instance_Entry.IO_Type)
            {
                case QAPI_BLE_IO_INPUT_E:
                    InstanceDataPtr->Instance_Entry.Characteristic_Property_Flags = (uint8_t)AIOP_DEFAULT_INPUT_CHARACTERISTIC_PROPERTY_FLAGS;

                    /* ** NOTE ** Inputs will automatically be given the read*/
                    /*            property since it is mandatory.  However,  */
                    /*            since we are going to retain the           */
                    /*            Instance_Entry on AIOS Server we will go   */
                    /*            ahead and flag this property.              */
                    /*            qapi_BLE_AIOS_Initialize_Service() will NOT*/
                    /*            FAIL if this flag is set (even though it is*/
                    /*            not required for inputs), since it is a    */
                    /*            valid property for inputs.  This will also */
                    /*            allow the AIOS Server to not have to check */
                    /*            if the AIOS Characteristic is an input or  */
                    /*            it has the read property.  We can simply   */
                    /*            check if it has the read property.         */
                    InstanceDataPtr->Instance_Entry.Characteristic_Property_Flags |= (uint8_t)QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ;
                    break;
                case QAPI_BLE_IO_OUTOUT_E:
                    InstanceDataPtr->Instance_Entry.Characteristic_Property_Flags = (uint8_t)AIOP_DEFAULT_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS;
                    break;
                default:
                    /* Prevent compiler warnings.                            */
                    break;
            }

            /* We will use a custom trigger by default.  This means that we*/
            /* do NOT support the Value Trigger or Time Trigger            */
            /* Characteristic Descriptors.  See qapi_ble_aios.h for more   */
            /* information.                                                */
            InstanceDataPtr->Instance_Entry.Use_Custom_Trigger = TRUE;

            /* Now they we have set up the instance entry that will be     */
            /* needed to initialize the Characteristic instance with a call*/
            /* to qapi_BLE_AIOS_Initialize_Service(), we will setup initial*/
            /* values for the instance's data.                             */
            /* * NOTE * If we do not initialize a field below, then it     */
            /*          already has been initialized to zero.              */

            /* Initialize the Presentation Format data.                    */
            /* * NOTE * The Description field use to identify the AIOS     */
            /*          Characteristic instance is always 1 greater than   */
            /*          the ID (Index2) that we use to identify it.        */
            if(Type == QAPI_BLE_ACT_DIGITAL_E)
                InstanceDataPtr->Presentation_Format.Format   = (uint8_t)QAPI_BLE_AIOS_DIGITAL_PRESENTATION_FORMAT_STRUCT;
            else
                InstanceDataPtr->Presentation_Format.Format   = (uint8_t)QAPI_BLE_AIOS_ANALOG_PRESENTATION_FORMAT_UINT16;
            InstanceDataPtr->Presentation_Format.Exponent    = 0;
            InstanceDataPtr->Presentation_Format.Unit        = 0;
            InstanceDataPtr->Presentation_Format.NameSpace   = (uint8_t)QAPI_BLE_AIOS_PRESENTATION_FORMAT_NAMESPACE_BT_SIG;
            InstanceDataPtr->Presentation_Format.Description = (uint16_t)(Index2 + 1);

            /* Initialize the Number Of Digitals descriptor.               */
            /* * NOTE * This demo supports 8 digital signals for each      */
            /*          Digital Characteristic instance.                   */
            InstanceDataPtr->Number_Of_Digitals = 8;
        }
    }
}

/* The following function is responsible for getting a pointer to the*/
/* AIOS Server Characteristic instance information based on the      */
/* CharacteristicInfo parameter.  If this function is successful a   */
/* pointer to the instance will be returned.  Otherwise NULL will be */
/* returned.                                                         */
/* * NOTE * This function should NOT be used for the Aggregate       */
/*          Characteristic.                                          */
static AIOP_Server_Instance_Data_t *GetAIOSServerInstanceInfoPtr(qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo)
{
    AIOP_Server_Instance_Data_t *ret_val = NULL;

    /* Make sure the parameters are semi-valid.                          */
    if(CharacteristicInfo)
    {
        /* Make sure the Characteristic type is valid.                    */
        if((CharacteristicInfo->Type >= QAPI_BLE_ACT_DIGITAL_E) && (CharacteristicInfo->Type <= QAPI_BLE_ACT_ANALOG_E))
        {
            /* Make sure the ID is less than the number of supported       */
            /* instances.                                                  */
            /* * NOTE * This demo only supports two instances for each AIOS*/
            /*          Characteristic.                                    */
            if(CharacteristicInfo->ID < (uint32_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES)
            {
                /* Since we have the type and instance identifier we can use*/
                /* these values to index the AIOS Server Characteristic     */
                /* instance information.                                    */
                ret_val = &(AIOSServerInfo.Characteristic[CharacteristicInfo->Type].Instances[CharacteristicInfo->ID]);
            }
            else
                LOG_WARN("\nWarning - Invalid Characteristic instance ID.\n");
        }
        else
            LOG_WARN("\nWarning - Invalid Characteristic type.\n");
    }
    else
        LOG_WARN("\nWarning - Characteristic information invalid.\n");

    return (ret_val);
}

/* The following function is responsible for getting a pointer to the*/
/* AIOSS Client Characteristic instance's information based on the   */
/* DeviceInfo parameter.  If this function is successful a pointer to*/
/* the AIOS Client's instance information will be returned.          */
/* Otherwise NULL will be returned.                                  */
/* * NOTE * This function should NOT be used for the Aggregate       */
/*          Characteristic.                                          */
static AIOP_Client_Instance_Info_t *GetAIOSClientInstanceInfoPtr(AIOP_Client_Information_t *ClientInfo)
{
    AIOP_Client_Instance_Info_t         *ret_val = NULL;
    qapi_BLE_AIOS_Characteristic_Type_t  Type;
    unsigned int                         ID;

    /* Make sure the parameters are semi-valid.                          */
    if(ClientInfo)
    {
        /* Store the Type and ID to make the code more readable.          */
        Type = ClientInfo->Client_Request_Info.Type;
        ID   = ClientInfo->Client_Request_Info.ID;

        /* Make sure the type is valid.                                   */
        if((Type >= QAPI_BLE_ACT_DIGITAL_E) && (Type <= QAPI_BLE_ACT_ANALOG_E))
        {
            /* Make sure the ID is less than the number of attribute handle*/
            /* information entries.                                        */
            /* * NOTE * This should directly correspond to the number of   */
            /*          instances of an AIOS Characteristic Type we        */
            /*          discovered.                                        */
            if(ID < (uint16_t)AIOP_NUMBER_OF_SUPPORTED_INSTANCES)
            {
                /* Since we have the type and instance identifier we can use*/
                /* these values to index the AIOS Client Attribute Handle   */
                /* information and get the correct instance.                */
                ret_val = &(ClientInfo->Characteristics[Type].Instances[ID]);
            }
            else
                LOG_WARN("\nWarning - Invalid Characteristic instance ID.\n");
        }
        else
            LOG_WARN("\nWarning - Invalid Characteristic type.\n");
    }
    else
        LOG_WARN("\nWarning - Device information invalid.\n");

    return (ret_val);
}

/* The following function is a utility function that provides a      */
/* mechanism of populating a AIOS Client Information structure with  */
/* the information discovered from a AIOS Discovery operation.       */
/* * NOTE * We will only store characteristc attribute handles that  */
/*          are supported by this demo.                              */
static void AIOSPopulateHandles(AIOP_Client_Information_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
    unsigned int                                           Index;
    unsigned int                                           Index2;
    qapi_BLE_GATT_Characteristic_Information_t            *CharacteristicInfoPtr;
    AIOP_Client_Instance_Info_t                           *InstanceInfoPtr;

    /* Verify that the input parameters are semi-valid.                  */
    if((ClientInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_AIOS_COMPARE_AIOS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
    {
        /* Loop through all characteristics discovered in the service and  */
        /* populate the correct entry.                                     */
        CharacteristicInfoPtr = ServiceDiscoveryData->CharacteristicInformationList;
        if(CharacteristicInfoPtr)
        {
            /* Let's loop through the AIOS Characteristic and store their   */
            /* information.                                                 */
            for(Index = 0; Index < ServiceDiscoveryData->NumberOfCharacteristics; Index++)
            {
                /* All AIOS UUIDs are defined to be 16 bit UUIDs.            */
                if(CharacteristicInfoPtr[Index].Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                {
                    /* If this is a Digital Characteristic.                   */
                    if(QAPI_BLE_AIOS_COMPARE_DIGITAL_CHARACTERISTIC_UUID_TO_UUID_16(CharacteristicInfoPtr[Index].Characteristic_UUID.UUID.UUID_16))
                    {
                        /* Find an empty AIOP Client Instance Information      */
                        /* structure to store this attribute handle            */
                        /* information.                                        */
                        for(Index2 = 0; Index2 < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES; Index2++)
                        {
                            /* Store a pointer to the Attribute Handle instance */
                            /* to aid in readability.                           */
                            InstanceInfoPtr = &(ClientInfo->Characteristics[QAPI_BLE_ACT_DIGITAL_E].Instances[Index2]);

                            /* Make sure this is an instance that has not been  */
                            /* used yet.                                        */
                            /* * NOTE * This demo will only store               */
                            /*          AIOP_NUMBER_OF_SUPPORTED_INSTANCES.     */
                            if(InstanceInfoPtr->Valid == FALSE)
                            {
                                /* Flag that the instance information is valid.  */
                                InstanceInfoPtr->Valid = TRUE;

                                /* Store the properties.                         */
                                InstanceInfoPtr->Properties = CharacteristicInfoPtr[Index].Characteristic_Properties;

                                /* Check the Digital Characteristic properties to*/
                                /* determine information that needs to be stored.*/
                                if((InstanceInfoPtr->Properties & (QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE | QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE_WITHOUT_RESPONSE)))
                                {
                                    /* Store the IO Type.                         */
                                    InstanceInfoPtr->IOType = QAPI_BLE_IO_OUTOUT_E;
                                }
                                else
                                {
                                    /* * NOTE * It is impossible to determine if  */
                                    /*          this is an error, but we will     */
                                    /*          assume that since Write or Write  */
                                    /*          without response is not supported */
                                    /*          this MUST be an input             */
                                    /*          Characteristic.                   */

                                    /* This MUST be a Digital Characteristic input*/
                                    /* so lets check for Mandatory read property. */
                                    if(InstanceInfoPtr->Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ)
                                    {
                                        //* Store the IO Type.                                */
                                        InstanceInfoPtr->IOType = QAPI_BLE_IO_INPUT_E;
                                    }
                                    else
                                        LOG_WARN("Invalid properties for the Digital Characteristic instance!\n");
                                }

                                /* Store the attribute handle information for    */
                                /* this Digital Characteristic.                  */
                                InstanceInfoPtr->Digital_Characteristic_Handle = CharacteristicInfoPtr[Index].Characteristic_Handle;

                                /* Call the helper function to populate the      */
                                /* descriptor handles for this attribute handle  */
                                /* entry.                                        */
                                StoreDescriptorHandles(InstanceInfoPtr, &(CharacteristicInfoPtr[Index]));

                                /* We do not want to populate another instance so*/
                                /* we are done.                                  */
                                break;
                            }
                        }

                        /* Continue since we found the AIOS Characteristic     */
                        /* type.                                               */
                        continue;
                    }

                    /* If this is a Analog Characteristic.                    */
                    if(QAPI_BLE_AIOS_COMPARE_ANALOG_CHARACTERISTIC_UUID_TO_UUID_16(CharacteristicInfoPtr[Index].Characteristic_UUID.UUID.UUID_16))
                    {
                        /* Find an empty AIOP Client Instance Information      */
                        /* structure to store this attribute handle            */
                        /* information.                                        */
                        for(Index2 = 0; Index2 < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES; Index2++)
                        {
                            /* Store a pointer to the Attribute Handle instance */
                            /* to aid in readability.                           */
                            InstanceInfoPtr = &(ClientInfo->Characteristics[QAPI_BLE_ACT_ANALOG_E].Instances[Index2]);

                            /* Make sure this is an instance that has not been  */
                            /* used yet.                                        */
                            /* * NOTE * This demo will only store               */
                            /*          AIOP_NUMBER_OF_SUPPORTED_INSTANCES.     */
                            if(InstanceInfoPtr->Valid == FALSE)
                            {
                                /* Flag that the instance information is valid.  */
                                InstanceInfoPtr->Valid = TRUE;

                                /* Store the properties.                         */
                                InstanceInfoPtr->Properties = CharacteristicInfoPtr[Index].Characteristic_Properties;

                                /* Check the Analog Characteristic properties to */
                                /* determine information that needs to be stored.*/
                                if((InstanceInfoPtr->Properties & (QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE | QAPI_BLE_AIOS_OUTPUT_CHARACTERISTIC_PROPERTY_FLAGS_WRITE_WITHOUT_RESPONSE)))
                                {
                                    /* Store the IO Type.                         */
                                    InstanceInfoPtr->IOType = QAPI_BLE_IO_OUTOUT_E;
                                }
                                else
                                {
                                    /* * NOTE * It is impossible to determine if  */
                                    /*          this is an error, but we will     */
                                    /*          assume that since Write or Write  */
                                    /*          without response is not supported */
                                    /*          this MUST be an input             */
                                    /*          Characteristic.                   */

                                    /* This MUST be a Analog Characteristic input */
                                    /* so lets check for Mandatory read property. */
                                    if(InstanceInfoPtr->Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ)
                                    {
                                        //* Store the IO Type.                     */
                                        InstanceInfoPtr->IOType = QAPI_BLE_IO_INPUT_E;
                                    }
                                    else
                                        LOG_WARN("Invalid properties for the Analog Characteristic instance!\n");
                                }

                                /* Store the attribute handle information for    */
                                /* this Analog Characteristic.                   */
                                InstanceInfoPtr->Analog_Charactersitic_Handle = CharacteristicInfoPtr[Index].Characteristic_Handle;

                                /* Call the helper function to populate the      */
                                /* descriptor handles for this attribute handle  */
                                /* entry.                                        */
                                StoreDescriptorHandles(InstanceInfoPtr, &(CharacteristicInfoPtr[Index]));

                                /* We do not want to populate another instance so*/
                                /* we are done.                                  */
                                break;
                            }
                        }

                        /* Continue since we found the AIOS Characteristic     */
                        /* type.                                               */
                        continue;
                    }

                    /* Always print warnings for unknown characteristics.     */
                    LOG_INFO("\nUnknown Characteristic:\n");
                    LOG_INFO("   Handle:        0x%04X\n", CharacteristicInfoPtr[Index].Characteristic_Handle);
                    LOG_INFO("   Properties:    0x%02X\n", CharacteristicInfoPtr[Index].Characteristic_Properties);
                    LOG_INFO("   UUID:          0x");
                    DisplayUUID(&(CharacteristicInfoPtr[Index].Characteristic_UUID));
                }
                else
                    LOG_WARN("\nWarning - UUID not 16-bit.\n");
            }
        }
    }
}

/* The following function is a helper function for                   */
/* StoreAttributeHandles() to populate the descriptor handles for an */
/* AIOS Characteristic instance.                                     */
/* * NOTE * We will only store descriptor attribute handles that are */
/*          supported by this demo.                                  */
static void StoreDescriptorHandles(AIOP_Client_Instance_Info_t *InstanceInfoPtr, qapi_BLE_GATT_Characteristic_Information_t *CharacteristicInfoPtr)
{
    unsigned int                                           Index;
    qapi_BLE_GATT_Characteristic_Descriptor_Information_t *DescriptorInfoPtr;

    /* Store a pointer to the Descriptor information.                    */
    DescriptorInfoPtr = CharacteristicInfoPtr->DescriptorList;

    /* Loop through the descriptor information and store the descriptor  */
    /* handles.                                                          */
    for(Index = 0; Index < CharacteristicInfoPtr->NumberOfDescriptors; Index++)
    {
        /* Make sure the Descriptor UUID is 16-bit.                       */
        if(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
        {
            /* Check for the CCCD.                                         */
            if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID.UUID.UUID_16))
            {
                /* Store the handle.                                        */
                InstanceInfoPtr->CCCD_Handle = DescriptorInfoPtr[Index].Characteristic_Descriptor_Handle;
                continue;
            }

            /* Check for the Presentation Format descriptor.               */
            if(QAPI_BLE_GATT_COMPARE_CHARACTERISTIC_PRESENTATION_FORMAT_ATTRIBUTE_TYPE_TO_UUID_16(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID.UUID.UUID_16))
            {
                /* Store the handle.                                        */
                InstanceInfoPtr->Presentation_Format_Handle = DescriptorInfoPtr[Index].Characteristic_Descriptor_Handle;
                continue;
            }

            /* Check for the Number Of Digitals descriptor.                */
            /* * NOTE * This should ONLY be received for Digital           */
            /*          Characteristics, however we will not check this    */
            /*          here.                                              */
            if(QAPI_BLE_AIOS_COMPARE_NUMBER_OF_DIGITALS_CD_UUID_TO_UUID_16(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID.UUID.UUID_16))
            {
                /* Store the handle.                                        */
                InstanceInfoPtr->Number_Of_Digitals_Handle = DescriptorInfoPtr[Index].Characteristic_Descriptor_Handle;
                continue;
            }
        }

        /* Always print warnings for unknown characteristic descriptors.  */
        LOG_WARN("\nUnknown Descriptor:\n");
        LOG_WARN("   Handle:  0x%04X\n", DescriptorInfoPtr[Index].Characteristic_Descriptor_Handle);
        LOG_WARN("   UUID:    0x");
        DisplayUUID(&(DescriptorInfoPtr[Index].Characteristic_Descriptor_UUID));
    }
}

/* The following function is responsible for displaying the          */
/* characteristic info in AIOS Events.                               */
static void DisplayAIOSCharacteristicInfo(qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo)
{
    /* Make sure the parameters are semi-valid.                          */
    if(CharacteristicInfo)
    {
        LOG_INFO("   Characteristic Info:\n");
        LOG_INFO("      Type:              ");
        switch(CharacteristicInfo->Type)
        {
            case QAPI_BLE_ACT_DIGITAL_E:
                LOG_INFO("Digital.\n");
                break;
            case QAPI_BLE_ACT_ANALOG_E:
                LOG_INFO("Analog.\n");
                break;
            default:
                LOG_INFO("Invalid(%u).\n", CharacteristicInfo->Type);
        }
        LOG_INFO("      IOType:            ");
        switch(CharacteristicInfo->IOType)
        {
            case QAPI_BLE_IO_INPUT_E:
                LOG_INFO("Input.\n");
                break;
            case QAPI_BLE_IO_OUTOUT_E:
                LOG_INFO("Output.\n");
                break;
            default:
                LOG_INFO("Invalid(%u).\n", CharacteristicInfo->Type);
        }
        LOG_INFO("      ID:                %u\n", CharacteristicInfo->ID);
    }
}

/* The following function is responsible for displaying a Digital    */
/* Characteristic.                                                   */
static void DisplayDigitalCharacteristic(qapi_BLE_AIOS_Digital_Characteristic_Data_t *DigitalData, uint32_t ID)
{
    unsigned int Index;
    unsigned int Index2;
    uint8_t      DigitalPosition;
    uint8_t      DigitalByte;
    uint8_t      DigitalCtr = 0;

    /* Make sure the parameter is semi-valid.                            */
    if(DigitalData)
    {
        /* Display the Characteristic type.                               */
        LOG_INFO("\nDigital Characteristic (ID = %u):\n", ID);

        for(Index = 0; Index < (unsigned int)(DigitalData->Length); Index++)
        {
            /* Only 4 digital signals in a byte.  We will update the       */
            /* digital position after each iteration.                      */
            /* * NOTE * We start the digital at 0x03 or the lowest two bits*/
            /*          positions.  Shift left by two each iteration for   */
            /*          the next two bits.                                 */
            for(Index2 = 0, DigitalPosition = 0x03; Index2 < 4; Index2++, DigitalPosition <<= 2)
            {
                /* Print the digital signal number.                         */
                LOG_INFO("   (%u). Digital: ", DigitalCtr++);

                /* Store a copy of the byte so we don't modify it.          */
                DigitalByte       = DigitalData->Buffer[Index];

                /* Get the state for the digital by using the position.     */
                DigitalByte      &= DigitalPosition;

                /* Shift the digital signal value to the two lowest bits.   */
                /* The number of right shifts will be (Index2*2).  This may */
                /* be zero for the first digital signal, which should       */
                /* already be at the lowest two bits.  This must be done so */
                /* we can print the value correctly.                        */
                DigitalByte     >>= (Index2*2);

                /* Print the digital byte.                                  */
                DisplayDigitalByte(DigitalByte);
            }
        }
    }
}

/* Display the digital signal.  This is included so we don't have to */
/* print this statement multiple times in the above function.        */
static void DisplayDigitalByte(uint8_t DigitalByte)
{
    /* Simply print the state in string format.                          */
    switch(DigitalByte)
    {
        case QAPI_BLE_AIOS_DIGITAL_CHARACTERISTIC_STATE_INACTIVE:
            LOG_INFO("Inactive State.\n");
            break;
        case QAPI_BLE_AIOS_DIGITAL_CHARACTERISTIC_STATE_ACTIVE:
            LOG_INFO("Active State.\n");
            break;
        case QAPI_BLE_AIOS_DIGITAL_CHARACTERISTIC_STATE_TRI_STATE:
            LOG_INFO("Tri State.\n");
            break;
        case QAPI_BLE_AIOS_DIGITAL_CHARACTERISTIC_STATE_UNKNOWN:
            LOG_INFO("Unknown State.\n");
            break;
        default:
            /* Can't occur, but here for compiler warnings.                */
            break;
    }
}

/* The following function is responsible for displaying an Analog    */
/* Characteristic.                                                   */
static void DisplayAnalogCharacteristic(uint16_t AnalogData, uint32_t ID)
{
    /* Display the Analog Characteristic.                                */
    LOG_INFO("\nAnalog Characteristic (ID = %u):\n", ID);
    LOG_INFO("   Value:   0x%04X\n", AnalogData);
}

/* The following function is responsible for displaying the          */
/* presentation format data received in a GATT Read response.        */
static void DisplayAIOSPresentationFormatData(qapi_BLE_AIOS_Presentation_Format_Data_t *PresentationFormatData)
{
    /* Make sure the data is semi-valid.                                 */
    if(PresentationFormatData)
    {
        LOG_INFO("\nPresentation Format Data:\n");
        LOG_INFO("   Format:       0x%02X\n", PresentationFormatData->Format);
        LOG_INFO("   Exponent:     0x%02X\n", PresentationFormatData->Exponent);
        LOG_INFO("   Unit:         0x%04X\n", PresentationFormatData->Unit);
        LOG_INFO("   NameSpace:    0x%02X\n", PresentationFormatData->NameSpace);
        LOG_INFO("   Description:  0x%04X\n", PresentationFormatData->Description);
    }
}

/* The following function displays received digtal characteristic    */
/* data.                                                             */
static void DecodeDisplayDigitalCharacteristic(uint16_t ValueLength, uint8_t *Value, uint32_t ID)
{
    qapi_BLE_AIOS_Digital_Characteristic_Data_t DigitalData;

    DigitalData.Length = ValueLength;
    DigitalData.Buffer = Value;

    /* Display the Digital Characteristic.                               */
    DisplayDigitalCharacteristic(&DigitalData, ID);
}

/* The following function displays the received analog characteristic*/
/* data.                                                             */
static void DecodeDisplayAnalogCharacteristic(uint16_t ValueLength, uint8_t *Value, uint32_t ID)
{
    uint16_t AnalogData;

    /* Verify the length.                                                */
    if(ValueLength >= (uint16_t)QAPI_BLE_NON_ALIGNED_WORD_SIZE)
    {
        AnalogData = READ_UNALIGNED_WORD_LITTLE_ENDIAN(Value);

        /* Display the Analog Characteristic.                             */
        DisplayAnalogCharacteristic(AnalogData, ID);
    }
    else
        LOG_WARN("\nAnalog Characteristic has an invalid length.\n");
}

/* Battery Alert Service (BAS) QCLI command functions.               */

/* The following function is responsible for registering a BAS       */
/* Service.  This function will return zero on successful execution  */
/* and a negative value on errors.
*/
static QCLI_Command_Status_t RegUnregBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                     Index;
    int                                     Result;
    uint32_t                                ServiceID;
    QCLI_Command_Status_t                   ret_val = QCLI_STATUS_SUCCESS_E;
    qapi_BLE_BAS_Presentation_Format_Data_t BatteryLevelPresentationFormat;

    /* Verify that there is no active connection.                        */
    if(!ConnectionCount)
    {
        if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"register") == 0)) {

            /* Verify that the Service is not already registered.             */
            for(Index = 0; ((Index < MAX_SUPPORTED_BATTERY_INSTANCES) && (BASInstanceID[Index])); Index++)
                ;

            /* Register for the service is one is not already registered.     */
            if(Index != MAX_SUPPORTED_BATTERY_INSTANCES)
            {
                /* Register the BAS Service with GATT.                         */
                Result = qc_drv_ble_BAS_Initialize_Service(qc_api_get_qc_drv_context(), BluetoothStackID, BAS_EventCallback, 0, &ServiceID);
                if((Result > 0) && (ServiceID > 0))
                {
                    /* Display success message.                                 */
                    LOG_INFO("Successfully registered BAS Service, InstanceID = %u.\n", Result);

                    /* Save the ServiceID of the registered service.            */
                    BASInstanceID[Index]                       = (unsigned int)Result;

                    /* Initialize internal BAS variables                        */
                    BatteryLevelPresentationFormat.Format      = 0;
                    BatteryLevelPresentationFormat.Exponent    = 0;
                    BatteryLevelPresentationFormat.Unit        = 0;
                    BatteryLevelPresentationFormat.NameSpace   = 1;
                    BatteryLevelPresentationFormat.Description = (uint16_t)(Result);

                    qc_drv_ble_BAS_Set_Characteristic_Presentation_Format(qc_api_get_qc_drv_context(), BluetoothStackID, BASInstanceID[Index], &BatteryLevelPresentationFormat);
                } else {
                    DisplayFunctionError("qapi_BLE_BAS_Initialize_Service", Result);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            } else {
                LOG_INFO("Maximum number of BAS instances have been registered.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }


        } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"unregister") == 0)) {
            /* Verify that a service is registered.                           */
            for(Index = MAX_SUPPORTED_BATTERY_INSTANCES - 1; ((Index >= 0) && (!BASInstanceID[Index])); Index--)
                ;

            if(Index >= 0)
            {
                /* Unregister the BAS Service with GATT.                       */
                Result = qc_drv_ble_BAS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, BASInstanceID[Index]);
                if(Result == 0)
                {
                    /* Display success message.                                 */
                    LOG_INFO("Successfully unregistered BAS Service InstanceID %u.\n", BASInstanceID[Index]);

                    /* Clear the ServiceID of the registered service.           */
                    BASInstanceID[Index] = 0;

                    /* Return success to the caller.                            */
                    ret_val = QCLI_STATUS_SUCCESS_E;
                } else
                    DisplayFunctionError("qapi_BLE_BAS_Cleanup_Service", Result);
            } else
                LOG_INFO("BAS Service not registered.\n");

        } else {
            /*Usage*/
            ret_val = QCLI_STATUS_USAGE_E;
        }
    } else {
        LOG_INFO("Connection currently active.\n");

        ret_val = QCLI_STATUS_ERROR_E;
    }

    if (ret_val == QCLI_STATUS_SUCCESS_E)
        LOG_AT_OK();
    else if (ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);

}

/* The following function is responsible for configure a BAS Service */
/* on a remote device.  This function will return zero on successful */
/* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ConfigureRemoteBAS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                    Result;
    unsigned int           InstanceID;
    DeviceInfo_t          *DeviceInfo;
    QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

    if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
        InstanceID = (Parameter_List[1].Integer_Value - 1);
    else
        ret_val = QCLI_STATUS_USAGE_E;

#else

    /* Verify that the input parameters are semi-valid.                  */
    if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid))
        InstanceID = 0;
    else
        ret_val = QCLI_STATUS_USAGE_E;

#endif

    if(ret_val != QCLI_STATUS_USAGE_E)
    {
        /* Verify that we are not configured as a server                  */
        if(!BASInstanceID[0])
        {
            /* Verify that there is a connection that is established.      */
            if(ConnectionCount)
            {
                /* Lock the Bluetooth stack.                                */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the connection device.        */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        LOG_INFO("Attempting to configure CCCDs...\n");

                        /* Determine if Battery Level Client Configuration is */
                        /* supported (mandatory).                             */
                        if(DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Client_Configuration)
                            Result = EnableDisableNotificationsIndications(DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Client_Configuration, (Parameter_List[0].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_BAS);
                        else
                        {
                            LOG_ERR("Battery Level Client Configuration not found on this device.\n");

                            Result = 0;
                        }

                        /* Check for CC Configuration success                 */
                        if(Result > 0)
                        {
                            LOG_INFO("CCCD Configuration Success.\n");

                            ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                            /* CC Configuration failed, check to see if it was */
                            /* from a call to SetNotification                  */
                            if(Result < 0)
                                DisplayFunctionError("SetNotification", ret_val);

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                        LOG_INFO("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                          */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                LOG_WARN("No Connection Established.\n");
        }
        else
            LOG_ERR("Cannot configure remote BAS Services when registered as a service.\n");
    }

    if (ret_val == QCLI_STATUS_SUCCESS_E)
        LOG_AT_OK();
    else if (ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();
    return(ret_val);
}

/* The following function is responsible for reading the battery     */
/* level. It can be executed by a server or a client with an open    */
/* connection to a remote server.  If executed as a client, a GATT   */
/* read request will be generated, and the results will be returned  */
/* as a response in the GATT client event callback.  This function   */
/* will return zero on successful execution and a negative value on  */
/* errors.               */
static QCLI_Command_Status_t GetSetBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int           Result;
    unsigned int  InstanceID;
    uint8_t               Level;
    QCLI_Command_Status_t ret_val = QCLI_STATUS_ERROR_E;
    DeviceInfo_t *DeviceInfo;

    if ((Parameter_List) && (Parameter_Count >= 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value == 0)) {
#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)
        if ((Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
            InstanceID = Parameter_List[1].Integer_Value - 1;
        else
            ret_val = QCLI_STATUS_USAGE_E;
#else
        InstanceID = 0;
#endif

        if(ret_val != QCLI_STATUS_USAGE_E)
        {
            /* Lock the Bluetooth stack.                                      */
            if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
            {
                /* First check for a registered BAS Server                     */
                if(BASInstanceID[0])
                {
                    /* Verify that this server instance has been initialized.   */
                    if(BASInstanceID[InstanceID])
                    {
                        LOG_INFO("Battery Level: %u%%.\n", (uint16_t)BatteryLevel[InstanceID]);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                        ret_val = QCLI_STATUS_ERROR_E;
                } else {
                    /* Check to see if we are configured as a client with an    */
                    /* active connection                                        */
                    if(ConnectionCount)
                    {
                        /* Get the device info for the connection device.        */
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                        {
                            /* Verify that the client has received a valid Battery*/
                            /* Level Attribute Handle.                            */
                            if(DeviceInfo->BASClientInfo[InstanceID].Battery_Level != 0)
                            {
                                /* Finally, submit a read request to the server    */
                                if((Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->BASClientInfo[InstanceID].Battery_Level, GATT_ClientEventCallback_BAS, DeviceInfo->BASClientInfo[InstanceID].Battery_Level)) > 0)
                                {
                                    LOG_INFO("GetBatteryLevel Request sent, Transaction ID = %u", Result);

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                } else
                                    DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                            } else
                                LOG_INFO("Battery Level not supported on remote service.\n");
                        } else
                            LOG_INFO("No Device Info.\n");
                    } else
                        LOG_INFO("Either a BAS server must be registered or a BAS client must be connected.\n");
                }

                /* Un-lock the Bluetooth Stack.                                */
                qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
            } else
                LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
        }
    } else if ((Parameter_List) && (Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value == 1)) {
#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

        if((Parameter_List[2].Integer_Is_Valid) && (QAPI_BLE_BAS_VALID_BATTERY_LEVEL(Parameter_List[1].Integer_Value)) && (Parameter_List[2].Integer_Value >= 1) && (Parameter_List[2].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
        {
            InstanceID = Parameter_List[2].Integer_Value - 1;
            Level      = (uint8_t)Parameter_List[1].Integer_Value;
        } else
            ret_val = QCLI_STATUS_USAGE_E;

#else
        if((QAPI_BLE_BAS_VALID_BATTERY_LEVEL(Parameter_List[1].Integer_Value)))
        {
            InstanceID = 0;
            Level      = (uint8_t)Parameter_List[1].Integer_Value;
        } else
            ret_val = QCLI_STATUS_USAGE_E;
#endif

        if(ret_val != QCLI_STATUS_USAGE_E)
        {
            /* First check for a registered BAS Server                        */
            if(BASInstanceID[0])
            {
                /* Verify that this server instance has been initialized.      */
                if(BASInstanceID[InstanceID])
                {
                    BatteryLevel[InstanceID] = Level;
                    ret_val = QCLI_STATUS_SUCCESS_E;

                    LOG_INFO("Battery Level set.\n");
                }
            } else {
                if(ConnectionCount)
                    LOG_ERR("Error - Only a server can set battery level.\n");
                else
                    LOG_ERR("Error - BAS server not registered\n");
            }
        }
    } else
        ret_val = QCLI_STATUS_USAGE_E;

    if (ret_val == QCLI_STATUS_SUCCESS_E)
        LOG_AT_OK();
    else if (ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);

}

/* The following function is responsible for notifying a battery     */
/* level to a connected remote device. This function will return     */
/* zero on successful execution and a negative value on errors.      */
static QCLI_Command_Status_t NotifyBatteryLevel(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                    Result;
    uint8_t                Level;
    unsigned int           InstanceID;
    DeviceInfo_t          *DeviceInfo;
    QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)
    if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid) && (QAPI_BLE_BAS_VALID_BATTERY_LEVEL(Parameter_List[0].Integer_Value)) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
    {
        InstanceID = Parameter_List[1].Integer_Value - 1;
        Level      = (uint8_t)Parameter_List[0].Integer_Value;
    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

#else

    if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid) && (QAPI_BLE_BAS_VALID_BATTERY_LEVEL(Parameter_List[0].Integer_Value)))
    {
        InstanceID = 0;
        Level      = (uint8_t)Parameter_List[0].Integer_Value;
    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

#endif

    if(ret_val != QCLI_STATUS_USAGE_E)
    {
        /* First, check that valid Bluetooth Stack ID exists.             */
        if(BluetoothStackID)
        {
            /* Verify that we have an open server and a connection.        */
            if(BASInstanceID[InstanceID])
            {
                if(ConnectionCount)
                {
                    /* Lock the Bluetooth stack.                             */
                    if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                    {
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                        {
                            if(DeviceInfo->BASServerInfo[InstanceID].Battery_Level_Client_Configuration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                            {
                                /* Go ahead and send the Battery Level          */
                                /* Notification                                 */
                                if((Result = qc_drv_ble_BAS_Notify_Battery_Level(qc_api_get_qc_drv_context(), BluetoothStackID, BASInstanceID[InstanceID], DeviceInfo->ConnectionID, Level)) == 0)
                                {
                                    LOG_INFO("Battery Level Notification success.\n");

                                    BatteryLevel[InstanceID] = Level;

                                    ret_val                  = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                    DisplayFunctionError("qapi_BLE_BAS_Notify_Battery_Level", Result);
                            }
                            else
                            {
                                LOG_INFO("Client has not registered for Battery Level notifications.\n");

                                ret_val = QCLI_STATUS_SUCCESS_E;
                            }
                        }
                        else
                            LOG_ERR("Error - Unknown Client.\n");

                        /* Un-lock the Bluetooth Stack.                       */
                        qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                    }
                    else
                        LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
                }
                else
                    LOG_INFO("Connection not established.\n");
            }
            else
            {
                if(ConnectionCount)
                    LOG_ERR("Error - Only a server can notify.\n");
                else
                    LOG_ERR("Error - BAS server not registered\n");
            }
        }
    }

    if (ret_val == QCLI_STATUS_SUCCESS_E)
        LOG_AT_OK();
    else if (ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();
    return(ret_val);
}

/* The following function is responsible for reading the battery     */
/* level presentation format. It can be executed by a server or a    */
/* client with an open connection to a remote server.  If executed   */
/* as a client, a GATT read request will be generated, and the       */
/* results will be returned as a response in the GATT client event   */
/* callback.  This function will return zero on successful execution */
/* and a negative value on errors.                                   */


static QCLI_Command_Status_t GetSetBatteryLevelPresentationFormat(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                      Result;
    DeviceInfo_t                            *DeviceInfo;
    unsigned int                             InstanceID;
    QCLI_Command_Status_t                    ret_val = QCLI_STATUS_ERROR_E;
    qapi_BLE_BAS_Presentation_Format_Data_t  BatteryLevelFormat;
    uint8_t                                  Namespace;
    uint16_t                                 Description;

    if((Parameter_List) && (Parameter_Count >= 1) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value == 0)) {

#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)
        if ((Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
            InstanceID = (Parameter_List[1].Integer_Value - 1);
        else
            ret_val = QCLI_STATUS_USAGE_E;

#else
        InstanceID = 0;
#endif

        if(ret_val != QCLI_STATUS_USAGE_E)
        {
            /* First check for a registered BAS Server                        */
            if(BASInstanceID[0])
            {
                /* Verify that this server instance has been initialized.      */
                if(BASInstanceID[InstanceID])
                {
                    Result = qc_drv_ble_BAS_Query_Characteristic_Presentation_Format(qc_api_get_qc_drv_context(), BluetoothStackID, BASInstanceID[InstanceID], &BatteryLevelFormat);
                    if(Result == 0)
                    {
                        LOG_INFO("\nBattery Level Presentation Format\n");
                        LOG_INFO("\n   NameSpace:   0x%02X\n", BatteryLevelFormat.NameSpace);
                        LOG_INFO("\n   Description: 0x%04X\n", BatteryLevelFormat.Description);

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    } else {
                        DisplayFunctionError("qapi_BLE_BAS_Query_Characteristic_Presentation_Format", Result);

                        if(Result == QAPI_BLE_BTPS_ERROR_FEATURE_NOT_AVAILABLE)
                            LOG_INFO("Command Not Supported.\n");
                    }
                }
            } else {
                /* Check to see if we are configured as a client with an active*/
                /* connection                                                  */
                if(ConnectionCount)
                {
                    /* Lock the Bluetooth stack.                                */
                    if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                    {
                        /* Get the device info for the connection device.        */
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                        {
                            /* Verify that the client has received a valid Battery*/
                            /* Level Presentation Format Attribute Handle.        */
                            if(DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Presentation_Format != 0)
                            {
                                /* Finally, submit a read request to the server    */
                                if((Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Presentation_Format, GATT_ClientEventCallback_BAS, DeviceInfo->BASClientInfo[InstanceID].Battery_Level_Presentation_Format)) > 0)
                                {
                                    LOG_INFO("Battery_Level_Presentation_Format Request sent, Transaction ID = %u", Result);

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                } else
                                    DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);
                            } else
                                LOG_WARN("Battery Level presentation format not supported on remote service.\n");
                        } else
                            LOG_WARN("No Device Info.\n");

                        /* Un-lock the Bluetooth Stack.                          */
                        qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                    } else
                        LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
                } else
                    LOG_WARN("Either a BAS server must be registered or a BAS client must be connected.\n");
            }
        }
    } else if((Parameter_List) && (Parameter_Count >= 3) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value == 1)) {
#if(MAX_SUPPORTED_BATTERY_INSTANCES > 1)

        if((Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[3].Integer_Is_Valid) && (Parameter_List[3].Integer_Value >= 1) && (Parameter_List[3].Integer_Value <= MAX_SUPPORTED_BATTERY_INSTANCES))
        {
            Namespace   = (uint8_t)Parameter_List[1].Integer_Value;
            Description = (uint16_t)Parameter_List[2].Integer_Value;
            InstanceID  = Parameter_List[3].Integer_Value - 1;
        } else
            ret_val = QCLI_STATUS_USAGE_E;
#else

        if((Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid))
        {
            Namespace   = Parameter_List[1].Integer_Value;
            Description = Parameter_List[2].Integer_Value;
            InstanceID  = 0;
        } else
            ret_val = QCLI_STATUS_USAGE_E;

#endif
        /* Verify that no usage error occurred.                              */
        if(ret_val != QCLI_STATUS_USAGE_E)
        {
            /* Verify that the selected instance is registered.               */
            if(BASInstanceID[InstanceID])
            {
                /* As per the spec, only Namespace/description need to be      */
                /* configured in presentation format descriptor.  Any 16bit    */
                /* unsigned number will be a valid description for battery     */
                /* level presentation format                                   */
                BatteryLevelFormat.Format      = 0;
                BatteryLevelFormat.Exponent    = 0;
                BatteryLevelFormat.Unit        = 0;
                BatteryLevelFormat.NameSpace   = Namespace;
                BatteryLevelFormat.Description = Description;

                /* Set the presentation format.                                */
                if((Result = qc_drv_ble_BAS_Set_Characteristic_Presentation_Format(qc_api_get_qc_drv_context(), BluetoothStackID, BASInstanceID[InstanceID], &BatteryLevelFormat)) == 0)
                {
                    LOG_INFO("Description of Battery Level Presentation Format successfully set.\n");

                    ret_val = QCLI_STATUS_SUCCESS_E;
                } else {
                    DisplayFunctionError("qapi_BLE_BAS_Set_Characteristic_Presentation_Format", Result);
                    if(Result == QAPI_BLE_BTPS_ERROR_FEATURE_NOT_AVAILABLE)
                        LOG_INFO("Command Not Supported.\n");
                }
            } else {
                if(ConnectionCount)
                    LOG_INFO("Cannot write to battery level presentation format as a client.\n");
                else
                    LOG_WARN("BAS server not registered\n");
            }
        }
    } else
        ret_val = QCLI_STATUS_USAGE_E;

    if (ret_val == QCLI_STATUS_SUCCESS_E)
        LOG_AT_OK();
    else if (ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* Battery Alert Service (BAS) helper functions.                     */

/* The following function is a utility function that provides a      */
/* mechanism of populating a BAS Client Information structure with   */
/* the information discovered from a GDIS Discovery operation.       */
static void BASPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
    unsigned int                                           Index1;
    unsigned int                                           Index2;
    qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
    qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

    /* Verify that the input parameters are semi-valid.                  */
    if((DeviceInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_BAS_COMPARE_BAS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
    {
        /* Loop through all characteristics discovered in the service     */
        /* and populate the correct entry.                                */
        CurrentCharacteristic = ServiceDiscoveryData->CharacteristicInformationList;
        if(CurrentCharacteristic)
        {
            for(Index1 = 0; Index1 < ServiceDiscoveryData->NumberOfCharacteristics; Index1++, CurrentCharacteristic++)
            {
                if(QAPI_BLE_BAS_COMPARE_BATTERY_LEVEL_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                {
                    /* All BAS UUIDs are defined to be 16 bit UUIDs.         */
                    if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                    {
                        DeviceInfo->BASClientInfo[BASInstanceIDIndex].Battery_Level = CurrentCharacteristic->Characteristic_Handle;

                        /* Loop through the Descriptor List.                  */
                        CurrentDescriptor = CurrentCharacteristic->DescriptorList;
                        for(Index2 = 0; Index2 < CurrentCharacteristic->NumberOfDescriptors; Index2++)
                        {
                            if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                            {
                                if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_UUID.UUID.UUID_16))
                                    DeviceInfo->BASClientInfo[BASInstanceIDIndex].Battery_Level_Client_Configuration = CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_Handle;
                                else
                                {
                                    if(QAPI_BLE_GATT_COMPARE_CHARACTERISTIC_PRESENTATION_FORMAT_ATTRIBUTE_TYPE_TO_UUID_16(CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_UUID.UUID.UUID_16))
                                        DeviceInfo->BASClientInfo[BASInstanceIDIndex].Battery_Level_Presentation_Format = CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_Handle;
                                }
                            }
                        }
                    }
                }
            }

            /* Increment the index to save the handles of other service    */
            /* instances to DeviceInfo->ClientInfo[] array during          */
            /* etGDIS_Service_Discovery_Indication                         */
            ++BASInstanceIDIndex;
            if(BASInstanceIDIndex == MAX_SUPPORTED_BATTERY_INSTANCES)
            {
                /* Reset the index to ZERO once Discovery indication is done*/
                /* for all the service instances                            */
                BASInstanceIDIndex = 0;
            }
        }
    }
}

/* The following function is a utility function that checks if a     */
/* given handle is a Handle of Battery Level characteristic. This    */
/* function returns TRUE if handle matches with Battery Level        */
/* characteristic of any of the Service Instance else returns FALSE  */
static boolean_t IsBatteryLevelHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo)
{
    boolean_t    ret_val = FALSE;
    unsigned int Index;

    for(Index = 0;((Index < MAX_SUPPORTED_BATTERY_INSTANCES) && (!ret_val)); ++Index)
    {
        if(Handle == DeviceInfo->BASClientInfo[Index].Battery_Level)
            ret_val = TRUE;
    }

    return(ret_val);
}

/* The following function is a utility function that checks if a     */
/* given handle is a Handle of Battery Level Presentation Format     */
/* characteristic. This function returns TRUE if handle matches      */
/* with Battery Level Presentation Format characteristic of any of   */
/* the Service Instance else returns FALSE                           */
static boolean_t IsBatteryLevelPresentationFormatHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo)
{
    boolean_t    ret_val = FALSE;
    unsigned int Index;

    for(Index = 0;((Index < MAX_SUPPORTED_BATTERY_INSTANCES) && (!ret_val)); ++Index)
    {
        if(Handle == DeviceInfo->BASClientInfo[Index].Battery_Level_Presentation_Format)
            ret_val = TRUE;
    }

    return(ret_val);
}

/* The following function is a utility function that checks if a     */
/* given handle is a Handle of Battery Level Client Configuration    */
/* characteristic. This function returns TRUE if handle matches with */
/* Battery Level Client Configuration characteristic of any of the   */
/* Service Instance else returns FALSE                               */
static boolean_t IsBASClientConfigurationHandle(uint16_t Handle, DeviceInfo_t *DeviceInfo)
{
    boolean_t    ret_val = FALSE;
    unsigned int Index;

    for(Index = 0;((Index < MAX_SUPPORTED_BATTERY_INSTANCES) && (!ret_val)); ++Index)
    {
        if(Handle == DeviceInfo->BASClientInfo[Index].Battery_Level_Client_Configuration)
            ret_val = TRUE;
    }

    return(ret_val);
}

/* Generic Access Profile Service (GAPS) QCLI command functions.     */

/* The following function is responsible for reading the current     */
/* Local Device Name.  This function will return zero on successful  */
/* execution and a negative value on errors.                         */
static QCLI_Command_Status_t ReadSetLocalName(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    char                  NameBuffer[248+1];
    QCLI_Command_Status_t ret_val;

    /*SET*/
    /* Verify that the input parameters are semi-valid.                  */
    if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].String_Value) && (strlen((char *)(Parameter_List[0].String_Value)) > 0) && (strlen((char *)(Parameter_List[0].String_Value)) <= 248))
    {
        /* Verify that the GAP Service is registered.                     */
        if(GAPSInstanceID)
        {
            /* Query the Local Name.                                       */
            Result = qc_drv_ble_GAPS_Set_Device_Name(qc_api_get_qc_drv_context(), BluetoothStackID, GAPSInstanceID, (char *)(Parameter_List[0].String_Value));
            if(!Result)
            {
                LOG_INFO("qapi_BLE_GAPS_Set_Device_Name success.\n");

                ret_val = QCLI_STATUS_SUCCESS_E;
            } else {
                LOG_ERR("Error - qapi_BLE_GAPS_Query_Device_Name returned %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else {
            LOG_ERR("GAP Service not registered.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else {

        /* Verify that the GAP Service is registered.                        */
        if(GAPSInstanceID)
        {
            /* Initialize the Name Buffer to all zeros.                       */
            memset(NameBuffer, 0, sizeof(NameBuffer));

            /* Query the Local Name.                                          */
            Result = qc_drv_ble_GAPS_Query_Device_Name(qc_api_get_qc_drv_context(), BluetoothStackID, GAPSInstanceID, NameBuffer);
            if(!Result)
            {
                LOG_INFO("Device Name: %s.\n", NameBuffer);

                ret_val = QCLI_STATUS_SUCCESS_E;
            } else {
                LOG_ERR("Error - qapi_BLE_GAPS_Query_Device_Name returned %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else {
            LOG_ERR("GAP Service not registered.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    }

    if (ret_val == QCLI_STATUS_SUCCESS_E)
        LOG_AT_OK();
    else if (ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);

}


/* The following function is responsible for reading the Device Name */
/* for the currently connected remote device.  This function will    */
/* return zero on successful execution and a negative value on       */
/* errors.                                                           */
static QCLI_Command_Status_t ReadRemoteNameApp(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                    Result;
    DeviceInfo_t          *DeviceInfo;
    QCLI_Command_Status_t  ret_val;

    /*READ NAME*/
    /* Verify that there is a connection that is established.            */
    if(ConnectionCount)
    {
        /* Lock the Bluetooth stack.                                      */
        if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
        {
            /* Get the device info for the connection device.              */
            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
            {
                /* Verify that we discovered the Device Name Handle.        */
                if(DeviceInfo->GAPSClientInfo.DeviceNameHandle)
                {
                    /* Attempt to read the remote device name.               */
                    Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->GAPSClientInfo.DeviceNameHandle, GATT_ClientEventCallback_GAPS, (unsigned long)DeviceInfo->GAPSClientInfo.DeviceNameHandle);
                    if(Result > 0)
                    {
                        LOG_INFO("Attempting to read Remote Device Name.\n");

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    } else {
                        LOG_ERR("Error - GATT_Read_Value_Request returned %d.\n", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                } else {
                    LOG_INFO("GAP Service Device Name Handle not discovered.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }

                if(DeviceInfo->GAPSClientInfo.DeviceAppearanceHandle)
                {
                    /* Attempt to read the remote device appearance.               */
                    Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->GAPSClientInfo.DeviceAppearanceHandle, GATT_ClientEventCallback_GAPS, (unsigned long)DeviceInfo->GAPSClientInfo.DeviceAppearanceHandle);
                    if(Result > 0)
                    {
                        LOG_INFO("Attempting to read Remote Device Appearance.\n");

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    } else {
                        LOG_ERR("Error - GATT_Read_Value_Request returned %d.\n", Result);

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                } else {
                    LOG_ERR("GAP Service Device Appearance Handle not discovered.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            } else {
                LOG_ERR("No Device Info.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }

            /* Un-lock the Bluetooth Stack.                                */
            qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
        } else {
            LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else {
        LOG_ERR("No Connection Established\n");

        ret_val = QCLI_STATUS_ERROR_E;
    }

    if (ret_val == QCLI_STATUS_SUCCESS_E)
        LOG_AT_OK();
    else if (ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return ret_val;
}

/* The following function is responsible for setting the Local Device*/
/* Appearance value.  This function will return zero on successful   */
/* execution and a negative value on errors.                         */


static QCLI_Command_Status_t ReadSetLocalAppearance(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    uint16_t              Appearance;
    char                  *AppearanceString;
    QCLI_Command_Status_t ret_val;

    /*SET*/
    /* Verify that the input parameters are semi-valid.                  */
    if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value >= 0) && (Parameter_List[0].Integer_Value < NUMBER_OF_APPEARANCE_MAPPINGS))
    {
        /* Verify that the GAP Service is registered.                     */
        if(GAPSInstanceID)
        {
            /* Map the Appearance Index to the GAP Appearance Value.       */
            if(AppearanceIndexToAppearance(Parameter_List[0].Integer_Value, &Appearance))
            {
                /* Set the Local Appearance.                                */
                Result = qc_drv_ble_GAPS_Set_Device_Appearance(qc_api_get_qc_drv_context(), BluetoothStackID, GAPSInstanceID, Appearance);
                if(!Result)
                {
                    LOG_INFO("qapi_BLE_GAPS_Set_Device_Appearance success.\n");

                    ret_val = QCLI_STATUS_SUCCESS_E;
                } else {
                    LOG_ERR("Error - qapi_BLE_GAPS_Set_Device_Appearance returned %d.\n", Result);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            } else {
                LOG_ERR("Invalid Appearance Index.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else {
            LOG_ERR("GAP Service not registered.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else {
        /* Verify that the GAP Service is registered.                        */
        if(GAPSInstanceID)
        {
            /* Query the Local Name.                                          */
            Result = qc_drv_ble_GAPS_Query_Device_Appearance(qc_api_get_qc_drv_context(), BluetoothStackID, GAPSInstanceID, &Appearance);
            if(!Result)
            {
                /* Map the Appearance to a String.                             */
                if(AppearanceToString(Appearance, &AppearanceString))
                    LOG_INFO("Device Appearance: %s(%u).\n", AppearanceString, Appearance);
                else
                    LOG_INFO("Device Appearance: Unknown(%u).\n", Appearance);

                ret_val = QCLI_STATUS_SUCCESS_E;
            } else {
                LOG_ERR("Error - qapi_BLE_GAPS_Query_Device_Appearance returned %d.\n", Result);

                ret_val = QCLI_STATUS_ERROR_E;
            }
        } else {
            LOG_INFO("GAP Service not registered.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    }

        LOG_INFO("Appearance Index = \n");
        DumpAppearanceMappings();

    if (ret_val == QCLI_STATUS_SUCCESS_E)
        LOG_AT_OK();
    else if (ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();
    return(ret_val);
}

/* Generic Access Profile Service (GAPS) helper functions.           */

/* The following function is a utility function that provides a      */
/* mechanism of populating discovered GAP Service Handles.           */
static void GAPSPopulateHandles(GAPS_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceInfo)
{
    unsigned int                                Index1;
    qapi_BLE_GATT_Characteristic_Information_t *CurrentCharacteristic;

    /* Verify that the input parameters are semi-valid.                  */
    if((ClientInfo) && (ServiceInfo) && (ServiceInfo->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_GAP_COMPARE_GAP_SERVICE_UUID_TO_UUID_16(ServiceInfo->ServiceInformation.UUID.UUID.UUID_16)))
    {
        /* Loop through all characteristics discovered in the service     */
        /* and populate the correct entry.                                */
        CurrentCharacteristic = ServiceInfo->CharacteristicInformationList;
        if(CurrentCharacteristic)
        {
            for(Index1=0;Index1<ServiceInfo->NumberOfCharacteristics;Index1++,CurrentCharacteristic++)
            {
                /* All GAP Service UUIDs are defined to be 16 bit UUIDs.    */
                if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                {
                    /* Determine which characteristic this is.               */
                    if(!QAPI_BLE_GAP_COMPARE_GAP_DEVICE_NAME_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                    {
                        if(!QAPI_BLE_GAP_COMPARE_GAP_DEVICE_APPEARANCE_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                            continue;
                        else
                        {
                            ClientInfo->DeviceAppearanceHandle = CurrentCharacteristic->Characteristic_Handle;
                            continue;
                        }
                    }
                    else
                    {
                        ClientInfo->DeviceNameHandle = CurrentCharacteristic->Characteristic_Handle;
                        continue;
                    }
                }
            }
        }
    }
}

/* The following function is a utility function that is used to dump */
/* the Appearance to String Mapping Table.                           */
static void DumpAppearanceMappings(void)
{
    unsigned int Index;

    for(Index=0;Index<NUMBER_OF_APPEARANCE_MAPPINGS;++Index)
        LOG_INFO("   %u = %s.\n", Index, AppearanceMappings[Index].String);
}

/* The following function is used to map a Appearance Value to it's  */
/* string representation.  This function returns TRUE on success or  */
/* FALSE otherwise.                                                  */
static boolean_t AppearanceToString(uint16_t Appearance, char **String)
{
    boolean_t    ret_val;
    unsigned int Index;

    /* Verify that the input parameters are semi-valid.                  */
    if(String)
    {
        for(Index=0,ret_val=FALSE;Index<NUMBER_OF_APPEARANCE_MAPPINGS;++Index)
        {
            if(AppearanceMappings[Index].Appearance == Appearance)
            {
                *String = AppearanceMappings[Index].String;
                ret_val = TRUE;
                break;
            }
        }
    }
    else
        ret_val = FALSE;

    return(ret_val);
}

/* The following function is used to map an Index into the Appearance*/
/* Mapping table to it's Appearance Value.  This function returns    */
/* TRUE on success or FALSE otherwise.                               */
static boolean_t AppearanceIndexToAppearance(unsigned int Index, uint16_t *Appearance)
{
    boolean_t ret_val;

    if((Index < NUMBER_OF_APPEARANCE_MAPPINGS) && (Appearance))
    {
        *Appearance = AppearanceMappings[Index].Appearance;
        ret_val     = TRUE;
    }
    else
        ret_val = FALSE;

    return(ret_val);
}
/* HID over GATT Service (HIDS) QCLI command functions.              */

/* The following function is responsible for registering a HIDS      */
/* Service.  This function will return zero on successful execution  */
/* and a negative value on errors.                                   */

/* The following function is responsible for unregistering a HIDS    */
/* Service.  This function will return zero on successful execution  */
/* and a negative value on errors.                                   */

/* The following function is responsible for configuring a HID       */
/* Service on a remote device. This function will return zero on     */
/* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t HIDSService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t                  ret_val = QCLI_STATUS_ERROR_E;
    int                                   Result;
    uint8_t                               ServiceFlags;
    uint32_t                              ServiceID;
    DeviceInfo_t         	          *DeviceInfo;
    qapi_BLE_GATT_UUID_t                  ReferenceUUID[1];
    qapi_BLE_HIDS_HID_Information_Data_t  HIDInformation;
    qapi_BLE_HIDS_Report_Reference_Data_t ReportReferenceData[3];
    qapi_BLE_GAP_Encryption_Mode_t  GAPEncryptionMode;
    unsigned int                    InstanceID;
    unsigned int                           Index;

    if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"register") == 0)) {
        /* Verify that there is no active connection.                        */
        if(!ConnectionCount)
        {
            /* Verify that the Service is not already registered.             */
            if(!HIDSInstanceID)
            {
                /* Configure the HID Information value.                        */
                HIDInformation.CountryCode = QAPI_BLE_HIDS_HID_LOCALIZATION_BYTE_NO_LOCALIZATION;
                HIDInformation.Flags       = QAPI_BLE_HIDS_HID_INFORMATION_FLAGS_NORMALLY_CONNECTABLE;
                HIDInformation.Version     = QAPI_BLE_HIDS_HID_VERSION_NUMBER;

                /* Configure the Report Reference structures.  Note that since */
                /* we have only 1 report of a type (Input,Output,Feature) we   */
                /* do not need to have a unique Reference ID and therefore we  */
                /* use a Report ID of ZERO.                                    */
                ReportReferenceData[0].ReportID   = HID_KEYBOARD_INPUT_REPORT_ID;
                ReportReferenceData[0].ReportType = (QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT | QAPI_BLE_HIDS_REPORT_REFERENCE_SUPPORT_INPUT_WRITE_FEATURE);
                ReportReferenceData[1].ReportID   = HID_KEYBOARD_OUTPUT_REPORT_ID;
                ReportReferenceData[1].ReportType = QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT;
                ReportReferenceData[2].ReportID   = HID_MOUSE_INPUT_REPORT_ID;
                ReportReferenceData[2].ReportType = (QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT | QAPI_BLE_HIDS_REPORT_REFERENCE_SUPPORT_INPUT_WRITE_FEATURE);

                /* Assign the external report reference values.                */
                ReferenceUUID[0].UUID_Type = QAPI_BLE_GU_UUID_16_E;
                QAPI_BLE_ASSIGN_BLUETOOTH_UUID_16(ReferenceUUID[0].UUID.UUID_16, 0x00, 0x00);

                /* Assign the service flags.                                   */
                ServiceFlags = (QAPI_BLE_HIDS_FLAGS_SUPPORT_KEYBOARD | QAPI_BLE_HIDS_FLAGS_SUPPORT_MOUSE | QAPI_BLE_HIDS_FLAGS_BOOT_KEYBOARD_INPUT_REPORT_WRITABLE | QAPI_BLE_HIDS_FLAGS_BOOT_MOUSE_INPUT_REPORT_WRITABLE);

                /* Initialize the HID Service.                                 */
                Result = qc_drv_ble_HIDS_Initialize_Service(qc_api_get_qc_drv_context(), BluetoothStackID, ServiceFlags, &HIDInformation, 0, NULL, (sizeof(ReferenceUUID)/sizeof(qapi_BLE_GATT_UUID_t)), ReferenceUUID, (sizeof(ReportReferenceData)/sizeof(qapi_BLE_HIDS_Report_Reference_Data_t)), ReportReferenceData, HIDS_Event_Callback, 0, &ServiceID);
                if(Result > 0)
                {
                    /* Save the ServiceID of the registered service.            */
                    HIDSInstanceID = (unsigned int)Result;

                    LOG_INFO("Successfully registered HIDS Service, InstanceID = %u.\n", Result);

                    ret_val        = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    DisplayFunctionError("qapi_BLE_HIDS_Initialize_Service", Result);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_INFO("HIDS Service already registered.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            LOG_INFO("Connection currently active.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"unregister") == 0)) {

        /* Verify that there is no active connection.                        */
        if(!ConnectionCount)
        {
            /* Verify that a service is registered.                           */
            if(HIDSInstanceID)
            {
                /* Unregister the HIDS Service with GATT.                      */
                Result = qc_drv_ble_HIDS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID);
                if(Result == 0)
                {
                    /* Display success message.                                 */
                    LOG_INFO("Successfully unregistered HIDS: InstanceID %u.\n", HIDSInstanceID);

                    /* Clear the instance ID.                                   */
                    HIDSInstanceID = 0;

                    /* Return success to the caller.                            */
                    ret_val        = QCLI_STATUS_SUCCESS_E;
                }
                else
                    DisplayFunctionError("qapi_BLE_HIDS_Cleanup_Service", Result);
            }
            else
                LOG_WARN("HIDS is not registered.\n");
        }
        else
            LOG_WARN("Connection currently active.\n");

    } else if ((Parameter_Count >= 3) && (APP_STRCMP(Parameter_List[0].String_Value,"configure") == 0)) {

        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count > 2) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
        {
            /* Verify that there is a connection that is established.         */
            if(ConnectionCount)
            {
                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the connection device.           */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Make sure encryption is enabled.                      */
                        if((qc_drv_ble_GAP_LE_Query_Encryption_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, SelectedRemoteBD_ADDR, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                        {
                            /* Set the Instance ID.                               */
                            InstanceID = (Parameter_List[1].Integer_Value - 1);
                            ret_val    = QCLI_STATUS_SUCCESS_E;

                            LOG_INFO("Attempting to configure CCCDs...\n");

                            /* Determine if Boot Keyboard Input Report is         */
                            /* supported.                                         */
                            if(DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD)
                            {
                                /* Enable Notifications on the proper              */
                                /* characteristics.                                */
                                Result = EnableDisableNotificationsIndications(DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD, (Parameter_List[2].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_HIDS);

                                /* Check for CC Configuration success              */
                                if(Result > 0)
                                    LOG_INFO("CCCD Configuration Success.\n");
                                else
                                {
                                    /* CC Configuration failed, check to see if it  */
                                    /* was from a call to                           */
                                    /* EnableDisableNotificationsIndications        */
                                    if(Result < 0)
                                        DisplayFunctionError("EnableDisableNotificationsIndications", Result);

                                    ret_val = QCLI_STATUS_ERROR_E;
                                }
                            }

                            /* Determine if Boot Mouse Input Report is supported. */
                            if((ret_val == QCLI_STATUS_SUCCESS_E) && (DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD))
                            {
                                /* Enable Notifications on the proper              */
                                /* characteristics.                                */
                                Result = EnableDisableNotificationsIndications(DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD, (Parameter_List[2].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_HIDS);

                                /* Check for CC Configuration success              */
                                if(Result > 0)
                                    LOG_INFO("CCCD Configuration Success.\n");
                                else
                                {
                                    /* CC Configuration failed, check to see if it  */
                                    /* was from a call to                           */
                                    /* EnableDisableNotificationsIndications        */
                                    if(Result < 0)
                                        DisplayFunctionError("EnableDisableNotificationsIndications", Result);

                                    ret_val = QCLI_STATUS_ERROR_E;
                                }
                            }

                            for(Index=0;((Index < HIDS_MAXIMUM_NUMBER_REPORTS) && (ret_val == QCLI_STATUS_SUCCESS_E)); Index++)
                            {
                                if(DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle)
                                {
                                    /* Enable Notifications on the proper           */
                                    /* characteristics.                             */
                                    Result = EnableDisableNotificationsIndications(DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle, (Parameter_List[2].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_HIDS);

                                    /* Check for CC Configuration success           */
                                    if(Result > 0)
                                        LOG_INFO("CCCD Configuration Success.\n");
                                    else
                                    {
                                        /* CC Configuration failed, check to see if  */
                                        /* it was from a call to                     */
                                        /* EnableDisableNotificationsIndications     */
                                        if(Result < 0)
                                            DisplayFunctionError("EnableDisableNotificationsIndications", Result);

                                        ret_val = QCLI_STATUS_ERROR_E;
                                    }
                                }
                            }
                        }
                        else
                            LOG_INFO("Must be paired with this device to use HIDS.\n");
                    }
                    else
                        LOG_WARN("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                LOG_WARN("No Connection Established.\n");
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    } else if ((Parameter_Count >= 2) && (APP_STRCMP(Parameter_List[0].String_Value,"ReadHIDSconfig") == 0)) {

        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
        {
            /* Verify that there is a connection that is established.         */
            if(ConnectionCount)
            {
                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the connection device.           */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Make sure encryption is enabled.                      */
                        if((qc_drv_ble_GAP_LE_Query_Encryption_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, SelectedRemoteBD_ADDR, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                        {
                            /* Set the Instance ID.                               */
                            InstanceID = (Parameter_List[1].Integer_Value - 1);
                            ret_val    = QCLI_STATUS_SUCCESS_E;

                            LOG_INFO("Attempting to read CCCDs...\n");

                            /* Determine if Boot Keyboard Input Report is         */
                            /* supported.                                         */
                            if(DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD)
                            {
                                /* Read the CCD.                                   */
                                Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD, GATT_ClientEventCallback_HIDS, DeviceInfo->HIDSClientInfo[InstanceID].BootKeyboardInputReport_CCCD);

                                /* Check for CC Read success                       */
                                if(Result > 0)
                                    LOG_INFO("CCCD Read Success.\n");
                                else
                                {
                                    /* CC Read failed, display an error.            */
                                    if(Result < 0)
                                        DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);

                                    ret_val = QCLI_STATUS_ERROR_E;
                                }
                            }

                            /* Determine if Boot Mouse Input Report is supported. */
                            if((ret_val == QCLI_STATUS_SUCCESS_E) && (DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD))
                            {
                                /* Read the CCD.                                   */
                                Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD, GATT_ClientEventCallback_HIDS, DeviceInfo->HIDSClientInfo[InstanceID].BootMouseInputReport_CCCD);

                                /* Check for CC Read success                       */
                                if(Result > 0)
                                    LOG_INFO("CCCD Read Success.\n");
                                else
                                {
                                    /* CC Read failed, display an error.            */
                                    if(Result < 0)
                                        DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);

                                    ret_val = QCLI_STATUS_ERROR_E;
                                }
                            }

                            for(Index=0;((Index < HIDS_MAXIMUM_NUMBER_REPORTS) && (ret_val == QCLI_STATUS_SUCCESS_E)); Index++)
                            {
                                if(DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle)
                                {
                                    /* Read the CCD.                                */
                                    Result = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle, GATT_ClientEventCallback_HIDS, DeviceInfo->HIDSClientInfo[InstanceID].Reports[Index].CCCDHandle);

                                    /* Check for CC Read success                    */
                                    if(Result > 0)
                                        LOG_INFO("CCCD Read Success.\n");
                                    else
                                    {
                                        /* CC Read failed, display an error.         */
                                        if(Result < 0)
                                            DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", Result);

                                        ret_val = QCLI_STATUS_ERROR_E;
                                    }
                                }
                            }

                        }
                        else
                            LOG_WARN("Must be paired with this device to use HIDS.\n");
                    }
                    else
                        LOG_WARN("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");

            }
            else
                LOG_WARN("No Connection Established.\n");
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return ret_val;
}


/* The following function is responsible for reading a HID Service   */
/* configuration on a remote device. This function will return zero  */
/* on successful execution and a negative value on errors.           */
/* The following function is responsible for getting a report on a   */
/* HID service of a remote device. This function will return zero on */
/* successful execution and a negative value on errors.              */

/* The following function is responsible for setting a report on a   */
/* HID service of a remote device. This function will return zero on */
/* successful execution and a negative value on errors.              */

/* The following function is responsiblfor sending a key button.     */
/* This includes both a key-down and key-up report.                  */

static QCLI_Command_Status_t HIDSReport(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                    Result;
    uint8_t               *Report;
    boolean_t              ResponseExpected;
    DeviceInfo_t          *DeviceInfo;
    unsigned int           InstanceID;
    unsigned int           ReportLength;
    uint8_t                                  InputReport[HID_KEYBOARD_INPUT_REPORT_SIZE];
    qapi_BLE_HIDS_Report_Type_t              ReportType;
    qapi_BLE_GAP_Encryption_Mode_t           GAPEncryptionMode;
    qapi_BLE_HIDS_Report_Reference_Data_t    ReportReferenceData;
    qapi_BLE_HIDS_Report_Reference_Data_t   *ReportReferenceDataPtr;
    QCLI_Command_Status_t  ret_val = QCLI_STATUS_ERROR_E;

    if ((Parameter_Count >= 4) && (APP_STRCMP(Parameter_List[0].String_Value,"Get") == 0)) {
        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count >= 4) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[3].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
        {
            /* Verify that there is a connection that is established.         */
            if(ConnectionCount)
            {
                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the connection device.           */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Set the Instance ID.                                  */
                        InstanceID = (Parameter_List[1].Integer_Value - 1);

                        /* Get the HIDS report.                                  */
                        if((Result = HIDSGetReport(DeviceInfo->ConnectionID, &(DeviceInfo->HIDSClientInfo[InstanceID]), Parameter_List[2].Integer_Value, Parameter_List[3].Integer_Value)) > 0)
                        {
                            LOG_INFO("HIDSGetReport() Success: Transaction ID = %d.\n", Result);

                            ret_val = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                            DisplayFunctionError("HIDSGetReport", Result);
                    }
                    else
                        LOG_INFO("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                LOG_WARN("No Connection Established.\n");
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"Set") == 0)) {

        /* Verify that the input parameters are semi-valid.                  */

        if((Parameter_List) && (Parameter_Count >= 6) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[3].Integer_Is_Valid) && (Parameter_List[4].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
        {
            /* Verify that there is a connection that is established.         */
            if(ConnectionCount)
            {
                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the connection device.           */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Set the Instance ID.                                  */
                        InstanceID = (Parameter_List[1].Integer_Value - 1);

                        /* Attempt to get the Report Data.                       */
                        ReportLength = ExtractHexString(Parameter_List[5].String_Value, &Report);
                        if((ReportLength) && (Report))
                        {
                            ResponseExpected = (boolean_t)Parameter_List[4].Integer_Value;

                            /* Set the HIDS report.                               */
                            if((Result = HIDSSetReport(DeviceInfo->ConnectionID , &(DeviceInfo->HIDSClientInfo[InstanceID]), Parameter_List[2].Integer_Value, Parameter_List[3].Integer_Value, Report, ReportLength, ResponseExpected)) > 0)
                            {
                                LOG_INFO("HIDSSetReport() Success: %d.\n", Result);

                                ret_val = QCLI_STATUS_SUCCESS_E;
                            }
                            else
                                DisplayFunctionError("HIDSSetReport", Result);

                            /* Free the memory allocated for the buffer.          */
                            free(Report);
                        }
                        else
                            LOG_WARN("Failed to parse the report data.\n");
                    }
                    else
                        LOG_WARN("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                LOG_WARN("No Connection Established.\n");
        }
        else
        {
            /* Due to a QCLI limitation we will display the usage here.       */
            LOG_INFO("[InstanceID] [ReportType] [ReportID (0 = None] [Response Expected (0 = False, 1 = True)] [Value (Hex String)]\n");
            LOG_INFO("   Where ReportType is = \n");
            LOG_INFO(" Input                 = 1\n");
            LOG_INFO(" Output                = 2\n");
            LOG_INFO(" Feature               = 3\n");
            LOG_INFO(" Boot Keyboard Input   = 4\n");
            LOG_INFO(" Boot Keyboard Output  = 5\n");
            LOG_INFO(" Boot Mouse Input      = 6\n");
            LOG_INFO("\nSet specified report data.\n");

            ret_val = QCLI_STATUS_SUCCESS_E;
        }
    } else if ((Parameter_Count >= 3) && (APP_STRCMP(Parameter_List[0].String_Value,"send") == 0)) {

        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 0) && (Parameter_List[1].Integer_Value <= 1))
        {
            /* Search for the device info structure for this device.          */
            if(HIDSInstanceID)
            {
                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Find the device info.                                    */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Check that we are encrypted.                          */
                        if((qc_drv_ble_GAP_LE_Query_Encryption_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, SelectedRemoteBD_ADDR, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                        {
                            /* Make sure the client has subscribed to             */
                            /* notifications for the given report type and current*/
                            /* protocol mode.                                     */
                            if(((Parameter_List[1].Integer_Value == 0) && (((HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) && (DeviceInfo->HIDSServerInfo.BootKeyboardInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)) || ((HIDS_Protocol_Mode == QAPI_BLE_PM_REPORT_E) && (DeviceInfo->HIDSServerInfo.ReportKeyboardInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)))) || ((Parameter_List[1].Integer_Value == 1) && (((HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) && (DeviceInfo->HIDSServerInfo.BootMouseInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)) || ((HIDS_Protocol_Mode == QAPI_BLE_PM_REPORT_E) && (DeviceInfo->HIDSServerInfo.ReportMouseInputConfiguration & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)))))
                            {
                                /* Check to see what characteristic should be      */
                                /* notified based on the operating mode.           */
                                if(HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E)
                                {
                                    if(Parameter_List[1].Integer_Value == 0)
                                        ReportType = QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E;
                                    else
                                        ReportType = QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT;

                                    ReportReferenceDataPtr = NULL;
                                }
                                else
                                {
                                    ReportType = QAPI_BLE_PM_REPORT_E;

                                    if(Parameter_List[1].Integer_Value == 0)
                                        ReportReferenceData.ReportID = HID_KEYBOARD_INPUT_REPORT_ID;
                                    else
                                        ReportReferenceData.ReportID = HID_MOUSE_INPUT_REPORT_ID;

                                    ReportReferenceData.ReportType = QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT;

                                    ReportReferenceDataPtr         = &ReportReferenceData;
                                }

                                memset(InputReport, 0, sizeof(InputReport));

                                /* Send the Boot Input Report notification.        */
                                if(Parameter_List[1].Integer_Value == 0)
                                {
                                    InputReport[2] = 0x04;

                                    Result = qc_drv_ble_HIDS_Notify_Input_Report(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID, DeviceInfo->ConnectionID, ReportType, ReportReferenceDataPtr, HID_KEYBOARD_INPUT_REPORT_SIZE, InputReport);

                                    if(Result == HID_KEYBOARD_INPUT_REPORT_SIZE)
                                    {
                                        InputReport[2] = 0;
                                        Result = qc_drv_ble_HIDS_Notify_Input_Report(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID, DeviceInfo->ConnectionID, ReportType, ReportReferenceDataPtr, HID_KEYBOARD_INPUT_REPORT_SIZE, InputReport);
                                    }

                                    /* Check to see if any error occurred.          */
                                    if(Result == HID_KEYBOARD_INPUT_REPORT_SIZE)
                                    {
                                        LOG_INFO("Report sent to remote device\n");

                                        ret_val = QCLI_STATUS_SUCCESS_E;
                                    }
                                    else
                                    {
                                        LOG_ERR("Error - qapi_BLE_HIDS_Notify_Input_Report() returned %d for %s mode.\n", Result, (HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) ? "Boot" : "Keyboard");

                                        ret_val = QCLI_STATUS_ERROR_E;
                                    }
                                }
                                else
                                {
                                    Result = qc_drv_ble_HIDS_Notify_Input_Report(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID, DeviceInfo->ConnectionID, ReportType, ReportReferenceDataPtr, HID_MOUSE_INPUT_REPORT_SIZE, InputReport);

                                    /* Check to see if any error occurred.          */
                                    if(Result == HID_MOUSE_INPUT_REPORT_SIZE)
                                    {
                                        LOG_INFO("Report sent to remote device\n");

                                        ret_val = QCLI_STATUS_SUCCESS_E;
                                    }
                                    else
                                    {
                                        LOG_ERR("Error - qc_drv_ble_HIDS_Notify_Input_Report(qc_api_get_qc_drv_context(), ) returned %d for %s mode.\n", Result, (HIDS_Protocol_Mode == QAPI_BLE_PM_BOOT_E) ? "Boot" : "Mouse");

                                        ret_val = QCLI_STATUS_ERROR_E;
                                    }
                                }
                            }
                            else
                            {
                                LOG_ERR("Client has not registered for HID notifications.\n");

                                ret_val = QCLI_STATUS_ERROR_E;
                            }
                        }
                        else
                        {
                            LOG_ERR("Error: Connection not encrypted\n");

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        LOG_ERR("Unable to find device structure.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                {
                    LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
                ret_val = QCLI_STATUS_ERROR_E;
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    } else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);

}

/* The following function is responsible for setting the suspend     */
/* mode of a HID service on a remote device. This function will      */
/* return zero on successful execution and a negative value on       */
/* errors.                                                           */

/* The following function is responsible for setting the protocol    */
/* mode of a HID service on a remote device. This function will      */
/* return zero on successful execution and a negative value on       */
/* errors.                                                           */
static QCLI_Command_Status_t HIDSMode(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                    Result;
    uint8_t                                Buffer[QAPI_BLE_HIDS_CONTROL_POINT_VALUE_LENGTH];
    DeviceInfo_t                          *DeviceInfo;
    unsigned int                           InstanceID;
    QCLI_Command_Status_t                  ret_val = QCLI_STATUS_ERROR_E;
    qapi_BLE_HIDS_Control_Point_Command_t  Command;
    qapi_BLE_HIDS_Protocol_Mode_t  ProtocolMode;

    if ((Parameter_Count >= 3) && (APP_STRCMP(Parameter_List[0].String_Value,"Suspend") == 0)) {
        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
        {
            /* Verify that there is a connection that is established.         */
            if(ConnectionCount)
            {
                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the connection device.           */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Set the Instance ID.                                  */
                        InstanceID = (Parameter_List[1].Integer_Value - 1);

                        /* Determine if Boot Mouse Input Report is supported.    */
                        if(DeviceInfo->HIDSClientInfo[InstanceID].ControlPoint)
                        {
                            /* Format the Set Suspend Mode command.               */
                            Command = (Parameter_List[2].Integer_Value ? QAPI_BLE_PC_SUSPEND_E : QAPI_BLE_PC_EXIT_SUSPEND_E);

                            if((Result = qc_drv_ble_HIDS_Format_Control_Point_Command(qc_api_get_qc_drv_context(), Command, sizeof(Buffer), Buffer)) == 0)
                            {
                                /* Perform the Write Without Response.             */
                                Result = qc_drv_ble_GATT_Write_Without_Response_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].ControlPoint, sizeof(Buffer), Buffer);

                                /* Check for GATT Write success                    */
                                if(Result > 0)
                                {
                                    LOG_INFO("Set Suspend Mode Success: %s.\n", (Parameter_List[2].Integer_Value ? "Suspend" : "Exit Suspend"));

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                {
                                    /* Set suspend mode failed, check to see if it  */
                                    /* was from a call to                           */
                                    /* GATT_Write_Without_Response_Request          */
                                    if(Result < 0)
                                        DisplayFunctionError("qapi_BLE_GATT_Write_Without_Response_Request", Result);
                                }
                            }
                            else
                                DisplayFunctionError("qapi_BLE_HIDS_Format_Control_Point_Command", Result);
                        }
                        else
                            LOG_WARN("Control point not supported.\n");
                    }
                    else
                        LOG_WARN("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                LOG_WARN("No Connection Established.\n");
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    } else if ((Parameter_Count >= 3) && (APP_STRCMP(Parameter_List[0].String_Value,"Protocol") == 0)) {
        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[1].Integer_Is_Valid) && (Parameter_List[2].Integer_Is_Valid) && (Parameter_List[1].Integer_Value >= 1) && (Parameter_List[1].Integer_Value <= MAX_SUPPORTED_HID_INSTANCES))
        {
            /* Verify that there is a connection that is established.         */
            if(ConnectionCount)
            {
                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the connection device.           */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Set the Instance ID.                                  */
                        InstanceID = (Parameter_List[1].Integer_Value - 1);

                        /* Determine if Boot Mouse Input Report is supported.    */
                        if(DeviceInfo->HIDSClientInfo[InstanceID].ProtocolModeHandle)
                        {
                            /* Format the Set Protocol Mode command.              */
                            ProtocolMode = (Parameter_List[2].Integer_Value ? QAPI_BLE_PM_REPORT_E : QAPI_BLE_PM_BOOT_E);

                            if((Result = qc_drv_ble_HIDS_Format_Protocol_Mode(qc_api_get_qc_drv_context(), ProtocolMode, sizeof(Buffer), Buffer)) == 0)
                            {
                                /* Perform the Write Without Response.             */
                                Result = qc_drv_ble_GATT_Write_Without_Response_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->HIDSClientInfo[InstanceID].ProtocolModeHandle, sizeof(Buffer), Buffer);

                                /* Check for GATT Write success                    */
                                if(Result > 0)
                                {
                                    LOG_INFO("Set Protocol Mode Success: %s Mode.\n", (Parameter_List[2].Integer_Value ? "Report" : "Boot"));

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                {
                                    /* Set protocol mode failed, check to see if it */
                                    /* was from a call to                           */
                                    /* GATT_Write_Without_Response_Request          */
                                    if(Result < 0)
                                        DisplayFunctionError("qapi_BLE_GATT_Write_Without_Response_Request", Result);
                                }
                            }
                            else
                                DisplayFunctionError("qapi_BLE_HIDS_Format_Protocol_Mode", Result);
                        }
                        else
                            LOG_WARN("Protocol Mode Characteristic not supported.\n");
                    }
                    else
                        LOG_WARN("No Device Info.\n");

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                LOG_WARN("No Connection Established.\n");
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* HID over GATT Service (HIDS) helper functions.                    */

/* The following function is a utility function that provides a      */
/* mechanism of populating a HIDS Client Information structure with  */
/* the information discovered from a GATT Discovery operation.       */
static void HIDSPopulateHandles(HIDS_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
    uint16_t                                              *ClientConfigurationHandle;
    uint16_t                                              *ReportReferenceHandle = NULL;
    unsigned int                                           Index1;
    unsigned int                                           Index2;
    unsigned int                                           Index3;
    qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
    qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

    /* Verify that the input parameters are semi-valid.                  */
    if((ClientInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_HIDS_COMPARE_HIDS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
    {
        /* Store the starting and ending attribute handles for HIDS.      */
        ClientInfo->ServiceHandleRange.Starting_Handle = ServiceDiscoveryData->ServiceInformation.Service_Handle;
        ClientInfo->ServiceHandleRange.Ending_Handle   = ServiceDiscoveryData->ServiceInformation.End_Group_Handle;

        /* Clear the NULL UUID used for comparison.                       */
        memset(&NULL_UUID_128,  0,  sizeof(NULL_UUID_128));

        /* Loop through all characteristics discovered in the service and */
        /* populate the correct entry.                                    */
        CurrentCharacteristic = ServiceDiscoveryData->CharacteristicInformationList;
        if(CurrentCharacteristic)
        {
            for(Index1 = 0; Index1 < ServiceDiscoveryData->NumberOfCharacteristics; Index1++, CurrentCharacteristic++)
            {
                /* All HIDS UUIDs are defined to be 16 bit UUIDs.           */
                if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                {
                    /* Clear the client configuration handle.                */
                    ClientConfigurationHandle = NULL;

                    /* Determine which characteristic this is.               */
                    if(!QAPI_BLE_HIDS_COMPARE_HIDS_PROTOCOL_MODE_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                    {
                        if(!QAPI_BLE_HIDS_COMPARE_HIDS_REPORT_MAP_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                        {
                            if(!QAPI_BLE_HIDS_COMPARE_HIDS_REPORT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                            {
                                if(!QAPI_BLE_HIDS_COMPARE_HIDS_BOOT_KEYBOARD_INPUT_REPORT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                                {
                                    if(!QAPI_BLE_HIDS_COMPARE_HIDS_BOOT_KEYBOARD_OUTPUT_REPORT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                                    {
                                        if(!QAPI_BLE_HIDS_COMPARE_HIDS_BOOT_MOUSE_INPUT_REPORT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                                        {
                                            if(!QAPI_BLE_HIDS_COMPARE_HIDS_HID_INFORMATION_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                                            {
                                                if(!QAPI_BLE_HIDS_COMPARE_HIDS_HID_CONTROL_POINT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                                                    continue;
                                                else
                                                {
                                                    ClientInfo->ControlPoint = CurrentCharacteristic->Characteristic_Handle;
                                                    continue;
                                                }
                                            }
                                            else
                                            {
                                                ClientInfo->HIDSInformationHandle = CurrentCharacteristic->Characteristic_Handle;
                                                continue;
                                            }
                                        }
                                        else
                                        {
                                            ClientInfo->BootMouseInputReport = CurrentCharacteristic->Characteristic_Handle;
                                            ClientConfigurationHandle       = &(ClientInfo->BootMouseInputReport_CCCD);
                                        }
                                    }
                                    else
                                    {
                                        ClientInfo->BootKeyboardOutputReport = CurrentCharacteristic->Characteristic_Handle;
                                        continue;
                                    }
                                }
                                else
                                {
                                    ClientInfo->BootKeyboardInputReport = CurrentCharacteristic->Characteristic_Handle;
                                    ClientConfigurationHandle          = &(ClientInfo->BootKeyboardInputReport_CCCD);
                                }
                            }
                            else
                            {
                                /* Loop through the reports and make sure to    */
                                /* overwrite if the same handle was previously  */
                                /* saved.                                       */
                                for(Index2=0; Index2 < HIDS_MAXIMUM_NUMBER_REPORTS; Index2++)
                                {
                                    if((ClientInfo->Reports[Index2].Handle == CurrentCharacteristic->Characteristic_Handle) || (!(ClientInfo->Reports[Index2].Handle)))
                                    {
                                        ClientInfo->Reports[Index2].Handle = CurrentCharacteristic->Characteristic_Handle;
                                        ClientConfigurationHandle          = &(ClientInfo->Reports[Index2].CCCDHandle);
                                        ReportReferenceHandle              = &(ClientInfo->Reports[Index2].ReportReferenceHandle);
                                        break;
                                    }
                                }
                            }
                        }
                        else
                            ClientInfo->ReportMapHandle = CurrentCharacteristic->Characteristic_Handle;
                    }
                    else
                    {
                        ClientInfo->ProtocolModeHandle = CurrentCharacteristic->Characteristic_Handle;
                        continue;
                    }

                    /* Loop through the Descriptor List.                     */
                    CurrentDescriptor = CurrentCharacteristic->DescriptorList;
                    if((CurrentDescriptor))
                    {
                        for(Index2 = 0; Index2 < CurrentCharacteristic->NumberOfDescriptors; Index2++, CurrentDescriptor++)
                        {
                            if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                            {
                                /* Get the Client Characteristic Configure      */
                                /* Descriptor.                                  */
                                if((ClientConfigurationHandle) && (QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16)))
                                    *ClientConfigurationHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                                else
                                {
                                    /* Get the Report Reference Descriptor.      */
                                    if((ReportReferenceHandle) && (QAPI_BLE_HIDS_COMPARE_REPORT_REFERENCE_DESCRIPTOR_UUID_TO_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16)))
                                        *ReportReferenceHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                                    else
                                    {
                                        /* Get the External Report Reference      */
                                        /* Descriptor(s).                         */
                                        if(QAPI_BLE_HIDS_COMPARE_EXTERNAL_REPORT_REFERENCE_DESCRIPTOR_UUID_TO_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16))
                                        {
                                            /* Loop through the external report    */
                                            /* reference list.                     */
                                            for(Index3=0; Index3 < HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES; Index3++)
                                            {
                                                /* Make sure to overwrite if this   */
                                                /* handle was previously discovered */
                                                /* and its value found.             */
                                                if((!(ClientInfo->ExternalReportReferences[Index3].ExternalReportReferenceHandle)) || ((ClientInfo->ExternalReportReferences[Index3].ExternalReportReferenceHandle) && (!(QAPI_BLE_COMPARE_UUID_128(NULL_UUID_128, ClientInfo->ExternalReportReferences[Index3].ExternalReportReference.UUID.UUID_128)))))
                                                {
                                                    ClientInfo->ExternalReportReferences[Index3].ExternalReportReferenceHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            /* Increment the index to save the handles of other service    */
            /* instances to DeviceInfo->ClientInfo[] array during          */
            /* etGDIS_Service_Discovery_Indication                         */
            ++HIDSInstanceIDIndex;
            if(HIDSInstanceIDIndex == MAX_SUPPORTED_HID_INSTANCES)
            {
                /* Reset the index to ZERO once Discovery indication is     */
                /* done for all the service instances                       */
                HIDSInstanceIDIndex = 0;
            }
        }
    }
}

/* The following function is responsible for reading the values of a */
/* remote HID service. This function will return zero on successful  */
/* execution and a negative value on errors.                         */
static void ReadHIDSInfo(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo)
{
    int           ret_val;
    unsigned int  Index;

    /* Read the protocol mode if it exists.                              */
    if(ClientInfo->ProtocolModeHandle)
    {
        ret_val = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionID, ClientInfo->ProtocolModeHandle, GATT_ClientEventCallback_HIDS, ClientInfo->ProtocolModeHandle);
        if(ret_val < 0)
        {
            /* Reading the protocol mode failed.                           */
            DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
        }
    }

    /* Read the HID information if it exists.                            */
    if(ClientInfo->HIDSInformationHandle)
    {
        ret_val = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionID, ClientInfo->HIDSInformationHandle, GATT_ClientEventCallback_HIDS, ClientInfo->HIDSInformationHandle);
        if(ret_val < 0)
        {
            /* Reading the HID information failed.                         */
            DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
        }
    }
    else
        LOG_ERR("HID Information handle not found on this device.\n");

    for(Index=0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
    {
        if((ClientInfo->Reports[Index].Handle) && (ClientInfo->Reports[Index].ReportReferenceHandle))
        {
            ret_val = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionID, ClientInfo->Reports[Index].ReportReferenceHandle, GATT_ClientEventCallback_HIDS, ClientInfo->Reports[Index].ReportReferenceHandle);
            if(ret_val < 0)
            {
                /* Reading the HID report information failed.               */
                DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
            }
        }
        else
            break;
    }

    for(Index=0; Index < HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES; Index++)
    {
        if(ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle)
        {
            ret_val = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionID, ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle, GATT_ClientEventCallback_HIDS, ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle);
            if(ret_val < 0)
            {
                /* Reading the HID external report reference information    */
                /* failed.                                                  */
                DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
            }
        }
        else
            break;
    }

    /* Read the report map if it exists.                                 */
    if(ClientInfo->ReportMapHandle)
    {
        ret_val = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionID, ClientInfo->ReportMapHandle, GATT_ClientEventCallback_HIDS, ClientInfo->ReportMapHandle);
        if(ret_val < 0)
        {
            /* Reading the report map failed.                              */
            DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
        }
    }
    else
        LOG_ERR("Report Map handle not found on this device.\n");
}

/* This function performs a GET_REPORT request for a specific Report */
/* Type and ID.                                                      */
static int HIDSGetReport(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo, uint8_t ReportType, uint8_t ReportID)
{
    int          ret_val;
    uint16_t     Handle;
    unsigned int Index;

    /* Check the input parameters.                                       */
    if(ClientInfo)
    {
        /* Initialize the handle to 0.                                    */
        Handle = 0;

        /* Switch through by report type.                                 */
        switch(ReportType)
        {
            case hrtHIDSInputReport:
                /* Get the Input Report Handle.                             */
                for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                {
                    if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT))
                    {
                        Handle = ClientInfo->Reports[Index].Handle;
                        break;
                    }
                }
                break;
            case hrtHIDSOutputReport:
                /* Get the Output Report Handle.                            */
                for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                {
                    if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT))
                    {
                        Handle = ClientInfo->Reports[Index].Handle;
                        break;
                    }
                }
                break;
            case hrtHIDSFeatureReport:
                /* Get the Feature Report Handle.                           */
                for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                {
                    if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_FEATURE_REPORT))
                    {
                        Handle = ClientInfo->Reports[Index].Handle;
                        break;
                    }
                }
                break;
            case hrtHIDSBootKeyboardInputReport:
                /* Get the Boot Keyboard Input Handle.                      */
                if(ClientInfo->BootKeyboardInputReport)
                    Handle = ClientInfo->BootKeyboardInputReport;
                break;
            case hrtHIDSBootKeyboardOuputReport:
                /* Get the Boot Keyboard Output Handle.                     */
                if(ClientInfo->BootKeyboardOutputReport)
                    Handle = ClientInfo->BootKeyboardOutputReport;
                break;
            case hrtHIDSBootMouseInputReport:
                /* Get the Boot Mouse Input Handle.                         */
                if(ClientInfo->BootMouseInputReport)
                    Handle = ClientInfo->BootMouseInputReport;
                break;
            default:
                break;
        }

        /* Make sure the handle was found.                                */
        if(Handle)
        {
            /* Perform the GATT Read.                                      */
            ret_val = qc_drv_ble_GATT_Read_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionID, Handle, GATT_ClientEventCallback_HIDS, Handle);

            /* Check for GATT Read success                                 */
            if(ret_val > 0)
                LOG_INFO("Get Report Success.\n");
            else
            {
                /* Get report failed, check to see if it was from a call to */
                /* GATT_Read_Value_Request                                  */
                if(ret_val <= 0)
                    DisplayFunctionError("qapi_BLE_GATT_Read_Value_Request", ret_val);
            }
        }
        else
            ret_val = QAPI_BLE_BTPS_ERROR_INVALID_PARAMETER;
    }

    return(ret_val);
}

/* This function performs a GET_REPORT request for a specific Report */
/* Type and ID.                                                      */
static int HIDSSetReport(uint32_t ConnectionID, HIDS_Client_Info_t *ClientInfo, uint8_t ReportType, uint8_t ReportID, uint8_t *Value, unsigned int ValueLength, boolean_t ResponseExpected)
{
    int          ret_val;
    uint16_t     Handle;
    unsigned int Index;

    /* Check the input parameters.                                       */
    if((ClientInfo) && (Value))
    {
        /* Initialize the handle to 0.                                    */
        Handle = 0;

        /* Switch through by report type.                                 */
        switch(ReportType)
        {
            case hrtHIDSInputReport:
                /* Get the Input Report Handle.                             */
                for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                {
                    if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT))
                    {
                        Handle = ClientInfo->Reports[Index].Handle;
                        break;
                    }
                }
                break;
            case hrtHIDSOutputReport:
                /* Get the Output Report Handle.                            */
                for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                {
                    if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT))
                    {
                        Handle = ClientInfo->Reports[Index].Handle;
                        break;
                    }
                }
                break;
            case hrtHIDSFeatureReport:
                /* Get the Feature Report Handle.                           */
                for(Index = 0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                {
                    if((ClientInfo->Reports[Index].ReportReferenceData.ReportID == ReportID) && (ClientInfo->Reports[Index].ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_FEATURE_REPORT))
                    {
                        Handle = ClientInfo->Reports[Index].Handle;
                        break;
                    }
                }
                break;
            case hrtHIDSBootKeyboardInputReport:
                /* Get the Boot Keyboard Input Handle.                      */
                if(ClientInfo->BootKeyboardInputReport)
                    Handle = ClientInfo->BootKeyboardInputReport;
                break;
            case hrtHIDSBootKeyboardOuputReport:
                /* Get the Boot Keyboard Output Handle.                     */
                if(ClientInfo->BootKeyboardOutputReport)
                    Handle = ClientInfo->BootKeyboardOutputReport;
                break;
            case hrtHIDSBootMouseInputReport:
                /* Get the Boot Mouse Input Handle.                         */
                if(ClientInfo->BootMouseInputReport)
                    Handle = ClientInfo->BootMouseInputReport;
                break;
            default:
                break;
        }

        /* Make sure the handle was found.                                */
        if(Handle)
        {
            /* Send the appropriate GATT Write Request.                    */
            if(ResponseExpected)
                ret_val = qc_drv_ble_GATT_Write_Request(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionID, Handle, ValueLength, Value, GATT_ClientEventCallback_HIDS, Handle);
            else
                ret_val = qc_drv_ble_GATT_Write_Without_Response_Request(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionID, Handle, ValueLength, Value);
        }
        else
            ret_val = QAPI_BLE_BTPS_ERROR_INVALID_PARAMETER;
    }

    return(ret_val);
}

/* The following function is provided to allow a mechanism of        */
/* parsing a hex string.  The second parameter will be pointed to an */
/* allocated buffer that holds the parsed data (which the caller     */
/* MUST free when finished) and the return value will hold the       */
/* number of bytes that were parsed into the Buffer.                 */
static unsigned int ExtractHexString(char *String, uint8_t **Buffer)
{
    char          ch;
    char         *BufPtr;
    char         *ParseBuffer;
    unsigned int  StringLength;
    unsigned int  ret_val = 0;

    /* Verify that the input parameters are valid.                       */
    if((String) && (Buffer))
    {
        *Buffer      = NULL;
        StringLength = strlen(String);
        if((ParseBuffer = malloc(StringLength)) != NULL)
        {
            /* Set the return pointer to the start of the parse buffer.    */
            *Buffer = (uint8_t *)ParseBuffer;

            /* Parse the string until the parse buffer while their are     */
            /* characters remaining.                                       */
            BufPtr = String;

            /* Advance past the leading " if necessary.                    */
            if(*BufPtr == '"')
            {
                (void)*(BufPtr++);
                --StringLength;
            }

            while(StringLength--)
            {
                ch = *(BufPtr++);
                if(ch == '"')
                    break;

                /* Check to see if \x or 0x are specified.                  */
                if(((ch == '\\') || (ch == '0')) && ((char)(*BufPtr | ' ')  == 'x'))
                {
                    if(StringLength >= 3)
                    {
                        ch            = (char)((ToInt(BufPtr[1]) << 4) + ToInt(BufPtr[2]));
                        StringLength -= 3;
                        BufPtr       += 3;
                    }
                    else
                        break;
                }
                else
                {
                    if(StringLength >= 1)
                    {
                        ch            = (char)((ToInt(ch) << 4) + ToInt(BufPtr[0]));
                        StringLength -= 1;
                        BufPtr       += 1;
                    }
                    else
                        break;
                }

                *(ParseBuffer++) = ch;
                ++ret_val;
            }

            /* If we were unable to parse any bytes into the parse buffer  */
            /* we will free the allocated memory.                          */
            if(!ret_val)
            {
                free(*Buffer);
                *Buffer = NULL;
            }
        }
    }

    return(ret_val);
}


/* Heart Rate Service (HRS) QCLI command functions.                  */

/* The following function is responsible for configuring an HRS      */
/* Service on a remote device. This function will return zero on     */
/* successful execution and a negative value on errors.              */
/* * NOTE * This function will NOT check if we are an HRS Server,    */
/*          since this demo does NOT support running as the HRS      */
/*          Server.                                                  */
static QCLI_Command_Status_t ConfigureRemoteHRS(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                    Result;
    DeviceInfo_t          *DeviceInfo;
    QCLI_Command_Status_t  ret_val = QCLI_STATUS_SUCCESS_E;

    /* Verify that the input parameters are semi-valid.                  */
    if((Parameter_List) && (Parameter_Count > 0) && (Parameter_List[0].Integer_Is_Valid))
    {
        /* Verify that there is a connection that is established.         */
        if(ConnectionCount)
        {
            /* Lock the Bluetooth stack.                                   */
            if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
            {
                /* Get the device info for the connection device.           */
                if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                {
                    LOG_INFO("Attempting to configure CCCDs...\n");

                    /* Initialize the result to 0.                           */
                    Result = 0;

                    /* Determine if HRS Measurement CC is supported (only if */
                    /* HRS Measurement characteristic is supported(optional))*/
                    if(DeviceInfo->HRSClientInfo.Heart_Rate_Measurement)
                    {
                        /* Make sure a CCCD has been discovered for the remote*/
                        /* device's HRS Measurement Characteristic.           */
                        if(DeviceInfo->HRSClientInfo.Heart_Rate_Measurement_Client_Configuration)
                        {
                            Result = EnableDisableNotificationsIndications(DeviceInfo->HRSClientInfo.Heart_Rate_Measurement_Client_Configuration, (Parameter_List[0].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_HRS);

                            /* Check for CC Configuration success              */
                            if(Result > 0)
                            {
                                LOG_INFO("CCCD Configuration Success.\n");

                                ret_val = QCLI_STATUS_SUCCESS_E;
                            }
                            else
                            {
                                /* CC Configuration failed, check to see if it  */
                                /* was from a call to                           */
                                /* EnableDisableNotificationsIndications        */
                                if(Result < 0)
                                    DisplayFunctionError("EnableDisableNotificationsIndications", Result);
                            }
                        }
                        else
                            LOG_ERR("Error - HRS Measurement CC not found on this device.\n");
                    }
                    else
                        LOG_ERR("HRS Measurement Characteristics not supported.\n");
                }
                else
                    LOG_INFO("No Device Info.\n");

                /* Un-lock the Bluetooth Stack.                             */
                qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
            }
            else
                LOG_INFO("Unable to acquire Bluetooth Stack Lock.\n");
        }
        else
            LOG_WARN("No Connection Established.\n");
    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E ) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();
    return(ret_val);
}

static QCLI_Command_Status_t ConfigureDisService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                    Result;
    QCLI_Command_Status_t  ret_val = QCLI_STATUS_SUCCESS_E;
    uint32_t               ServiceID;
    DeviceInfo_t *DeviceInfo;

    if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value == 1)) {
        if (BluetoothStackID) {
            /* Initialize the DIS Service.                           */
            Result = qc_drv_ble_DIS_Initialize_Service(qc_api_get_qc_drv_context(), BluetoothStackID, &ServiceID);
            if(Result > 0)
            {
                /* Save the DIS Instance ID.                          */
                DISInstanceID = (unsigned int)Result;
                /* Set the default device information for DIS.        */
                qc_drv_ble_DIS_Set_Manufacturer_Name(qc_api_get_qc_drv_context(), BluetoothStackID, DISInstanceID, "Qualcomm Technologies, Inc");
                qc_drv_ble_DIS_Set_Model_Number(qc_api_get_qc_drv_context(), BluetoothStackID, DISInstanceID, "4.2.1.1");
                qc_drv_ble_DIS_Set_Software_Revision(qc_api_get_qc_drv_context(), BluetoothStackID, DISInstanceID, "4.2");
                qc_drv_ble_DIS_Set_Hardware_Revision(qc_api_get_qc_drv_context(), BluetoothStackID, DISInstanceID, "4.2");
                qc_drv_ble_DIS_Set_Firmware_Revision(qc_api_get_qc_drv_context(), BluetoothStackID, DISInstanceID, "1.0");
            }
            else
                DisplayFunctionError("DIS_Initialize_Service()", Result);

        } else {

            LOG_ERR("Bluetooth stack is not initialized.");
            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value == 0)) {
        if (BluetoothStackID) {

            /* If there are remote devices connected.                         */
            if(ConnectionCount)
            {
                /* Go ahead and flag that we are no longer connected to any    */
                /* remote devices.                                             */
                ConnectionCount = 0;

                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* We need to loop through the remote device information    */
                    /* entries and disconnect any remote devices that are still */
                    /* connected.                                               */
                    DeviceInfo = DeviceInfoList;
                    while(DeviceInfo)
                    {
                        /* If the GATT Connection ID is valid, then we are       */
                        /* connected to the remote device.                       */
                        if(DeviceInfo->ConnectionID)
                        {
                            /* Flag that the remote device is no longer connected.*/
                            DeviceInfo->ConnectionID = 0;

                            /* Send the disconnection request.                    */
                            qc_drv_ble_GAP_LE_Disconnect(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->RemoteAddress);
                        }

                        DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
                    }

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
            }

            /*Cleanup DIS Service.                                          */
            if(DISInstanceID)
            {
                qc_drv_ble_DIS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, DISInstanceID);

                DISInstanceID = 0;
            }

        } else {
            LOG_ERR("Bluetooth stack is not initialized.");
            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else {
        ret_val = QCLI_STATUS_USAGE_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E ) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();


    return(ret_val);
}

static QCLI_Command_Status_t ConfigureTpsService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t  ret_val = QCLI_STATUS_SUCCESS_E;
    int                    Result;
    int8_t                 TxPowerLevel;
    uint32_t               ServiceID;
    DeviceInfo_t *DeviceInfo;


    if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value == 1)) {

        if (BluetoothStackID) {
            /* Initialize the TPS Service.                           */
            Result = qc_drv_ble_TPS_Initialize_Service(qc_api_get_qc_drv_context(), BluetoothStackID, &ServiceID);
            if(Result > 0)
            {
                /* Save the Instance ID of the TPS Service.           */
                TPSInstanceID = (unsigned int)Result;

                /* Attempt to query the default connection Tx Power   */
                /* Level.                                             */
                if(QueryTxPowerLevel(TRUE, &TxPowerLevel))
                {
                    /* Set the connection Tx Power Level.              */
                    qc_drv_ble_TPS_Set_Tx_Power_Level(qc_api_get_qc_drv_context(), BluetoothStackID, TPSInstanceID, TxPowerLevel);
                }
            }
            else
                DisplayFunctionError("qapi_BLE_TPS_Initialize_Service()", Result);
        } else {
            LOG_ERR("Bluetooth stack is not initialized.");
            ret_val = QCLI_STATUS_ERROR_E;
        }

    } else if((Parameter_Count > 0) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value == 0)) {
        if (BluetoothStackID) {

            /* If there are remote devices connected.                         */
            if(ConnectionCount)
            {
                /* Go ahead and flag that we are no longer connected to any    */
                /* remote devices.                                             */
                ConnectionCount = 0;

                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* We need to loop through the remote device information    */
                    /* entries and disconnect any remote devices that are still */
                    /* connected.                                               */
                    DeviceInfo = DeviceInfoList;
                    while(DeviceInfo)
                    {
                        /* If the GATT Connection ID is valid, then we are       */
                        /* connected to the remote device.                       */
                        if(DeviceInfo->ConnectionID)
                        {
                            /* Flag that the remote device is no longer connected.*/
                            DeviceInfo->ConnectionID = 0;

                            /* Send the disconnection request.                    */
                            qc_drv_ble_GAP_LE_Disconnect(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->RemoteAddress);
                        }

                        DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
                    }

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
            }

            /* Cleanup the TPS Service Module.                                */
            if(TPSInstanceID)
            {
                qc_drv_ble_TPS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, TPSInstanceID);

                TPSInstanceID = 0;
            }

        } else {
            LOG_ERR("Bluetooth stack is not initialized.");
            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else {
        ret_val = QCLI_STATUS_USAGE_E;
    }

    if ((ret_val == QCLI_STATUS_SUCCESS_E ) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();
    return(ret_val);
}

/* Heart Rate Service (HRS) helper functions.                        */

/* The following function is a utility function that provides a      */
/* mechanism of populating a HRS Client Information structure with   */
/* the information discovered from a GATT Discovery operation.       */
static void HRSPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
    uint16_t                                              *ClientConfigurationHandle;
    unsigned int                                           Index1;
    unsigned int                                           Index2;
    qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
    qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

    /* Verify that the input parameters are semi-valid.                  */
    if((DeviceInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_HRS_COMPARE_HRS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
    {
        /* Loop through all characteristics discovered in the service     */
        /* and populate the correct entry.                                */
        CurrentCharacteristic = ServiceDiscoveryData->CharacteristicInformationList;
        if(CurrentCharacteristic)
        {
            for(Index1 = 0; Index1 < ServiceDiscoveryData->NumberOfCharacteristics; Index1++, CurrentCharacteristic++)
            {
                /* All HRS UUIDs are defined to be 16 bit UUIDs.            */
                if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                {
                    ClientConfigurationHandle = NULL;

                    /* Determine which characteristic this is.               */
                    if(!QAPI_BLE_HRS_COMPARE_HRS_HEART_RATE_MEASUREMENT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                    {
                        if(!QAPI_BLE_HRS_COMPARE_HRS_BODY_SENSOR_LOCATION_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                        {
                            if(!QAPI_BLE_HRS_COMPARE_HRS_HEART_RATE_CONTROL_POINT_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                            {
                                continue;
                            }
                            else
                            {
                                DeviceInfo->HRSClientInfo.Heart_Rate_Control_Point = CurrentCharacteristic->Characteristic_Handle;

                                /* Verify that write is supported.              */
                                if(!(CurrentCharacteristic->Characteristic_Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE))
                                    LOG_WARN("Mandatory write property of Heart Rate Control Point characteristic not supported!\n");

                                continue;
                            }
                        }
                        else
                        {
                            DeviceInfo->HRSClientInfo.Body_Sensor_Location = CurrentCharacteristic->Characteristic_Handle;

                            /* Verify that read is supported.                  */
                            if(!(CurrentCharacteristic->Characteristic_Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ))
                                LOG_WARN("Mandatory read property of Body Sensor Location characteristic not supported!\n");

                            continue;
                        }
                    }
                    else
                    {
                        DeviceInfo->HRSClientInfo.Heart_Rate_Measurement = CurrentCharacteristic->Characteristic_Handle;
                        ClientConfigurationHandle     = &(DeviceInfo->HRSClientInfo.Heart_Rate_Measurement_Client_Configuration);

                        /* Verify that notify is supported.                   */
                        if(!(CurrentCharacteristic->Characteristic_Properties & QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_NOTIFY))
                            LOG_WARN("Mandatory notify property of Heart Rate Measurement characteristic not supported!\n");
                    }

                    /* Loop through the Descriptor List.                     */
                    CurrentDescriptor = CurrentCharacteristic->DescriptorList;
                    if((CurrentDescriptor) && (ClientConfigurationHandle))
                    {
                        for(Index2 = 0; Index2 < CurrentCharacteristic->NumberOfDescriptors; Index2++, CurrentDescriptor++)
                        {
                            if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                            {
                                if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16))
                                {
                                    *ClientConfigurationHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/* The following function is used to decode and display a Heart Rate */
/* measurement from a notification event.  The first parameter       */
/* provides the buffer length of the data to be decoded, the second  */
/* parameter provides the data packet to be decoded, and the final   */
/* parameter is a boolean value that determines whether the decoded  */
/* data will be printed to the terminal.  This function returns a    */
/* pointer to a an allocated Heart Rate measurement structure with   */
/* the decoded data on success and NULL on failure.  If this function*/
/* succeeds, the allocated buffer will need to be freed when it is   */
/* done being used.                                                  */
static qapi_BLE_HRS_Heart_Rate_Measurement_Data_t *DecodeDisplayHeartRate(unsigned int ValueLength, uint8_t *Value, boolean_t PrintData)
{
    qapi_BLE_HRS_Heart_Rate_Measurement_Data_t *ret_val = NULL;
    qapi_BLE_HRS_Heart_Rate_Measurement_Data_t  Heart_Rate_Measurement;
    uint16_t                                    Index;
    int                                         Result;

    /* Verify that the input parameters seem semi-valid.                 */
    if((ValueLength) && (Value))
    {
        /* Initialize the Heart Rate Structure.                           */
        memset(&Heart_Rate_Measurement, 0, sizeof(qapi_BLE_HRS_Heart_Rate_Measurement_Data_t));

        /* Decode the Heart Rate Measurement.                             */
        Result = qc_drv_ble_HRS_Decode_Heart_Rate_Measurement(qc_api_get_qc_drv_context(), ValueLength, Value, &Heart_Rate_Measurement);
        if(!Result)
        {
            /* Print out the information parsed from the Heart Rate        */
            /* Measurement.                                                */
            if(PrintData)
            {
                LOG_INFO("      \nFlags:             0x%02X\n", Heart_Rate_Measurement.Flags);
                LOG_INFO("      Heart Rate:        %u\n", Heart_Rate_Measurement.Heart_Rate);

                if(Heart_Rate_Measurement.Flags & QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_FLAGS_ENERGY_EXPENDED_PRESENT)
                    LOG_INFO("      Energy Expended:   %u\n", Heart_Rate_Measurement.Energy_Expended);

                LOG_INFO("      Sensor Contact:    ");

                if(Heart_Rate_Measurement.Flags & QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_FLAGS_SENSOR_CONTACT_STATUS_SUPPORTED)
                {
                    if(Heart_Rate_Measurement.Flags & QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_FLAGS_SENSOR_CONTACT_STATUS_DETECTED)
                        LOG_INFO("Detected");
                    else
                        LOG_WARN("Not Detected");
                }
                else
                    LOG_WARN("Not Supported");

                LOG_INFO("\n");
            }

            /* Allocate the required memory for the RR Intervals.          */
            if((ret_val = (qapi_BLE_HRS_Heart_Rate_Measurement_Data_t *)malloc(QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_DATA_SIZE(Heart_Rate_Measurement.Number_Of_RR_Intervals))) != NULL)
            {
                /* If there are RR Intervals, then allocate memory to hold  */
                /* them and parse them out of the notification.             */
                if(Heart_Rate_Measurement.Number_Of_RR_Intervals)
                {
                    ret_val->Number_Of_RR_Intervals = Heart_Rate_Measurement.Number_Of_RR_Intervals;

                    /* Decode the Heart Rate Measurement.                    */
                    Result = qapi_BLE_HRS_Decode_Heart_Rate_Measurement(ValueLength, Value, ret_val);
                    if(!Result)
                    {
                        if(PrintData)
                        {
                            if(ret_val->Flags & QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_FLAGS_RR_INTERVAL_PRESENT)
                            {
                                LOG_INFO("      Num. RR Intervals: %u\n", ret_val->Number_Of_RR_Intervals);

                                if(ret_val->Number_Of_RR_Intervals != 0)
                                {
                                    LOG_INFO("      RR Intervals:      { ");

                                    for(Index = 0; Index < (ret_val->Number_Of_RR_Intervals - 1); Index++)
                                        LOG_INFO("%d, ", ret_val->RR_Intervals[Index]);

                                    LOG_INFO("%d }\n", ret_val->RR_Intervals[Index]);
                                }
                            }
                        }
                    }
                    else
                        DisplayFunctionError("HRS_Decode_Heart_Rate_Measurement", Result);
                }
                else
                {
                    /* Just copy over the data                               */
                    memcpy(ret_val, &Heart_Rate_Measurement, QAPI_BLE_HRS_HEART_RATE_MEASUREMENT_DATA_SIZE(Heart_Rate_Measurement.Number_Of_RR_Intervals));
                }

                free(ret_val);
                ret_val = NULL;
            }
        }
        else
            DisplayFunctionError("qapi_BLE_HRS_Decode_Heart_Rate_Measurement", Result);
    }

    return(ret_val);
}

/* Scan Parameter Service (SCPS) QCLI command functions.             */

/* The following function is responsible for registering a SCPS      */
/* Service.  This function will return zero on successful execution  */
/* and a negative value on errors.                                   */

/* The following function is responsible for unregistering a SCPS    */
/* Service.  This function will return zero on successful execution  */
/* and a negative value on errors.                                   */

/* The following function is responsible for configure a SCPS Service*/
/* on a remote device.  This function will return zero on successful */
/* execution and a negative value on errors.                         */
static QCLI_Command_Status_t SCPSService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                   Result;
    uint32_t              ServiceID;
    QCLI_Command_Status_t                ret_val         = QCLI_STATUS_SUCCESS_E;
    DeviceInfo_t          *DeviceInfo;

    if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"register") == 0)) {
        /* Verify that there is no active connection.                        */
        if(!ConnectionCount)
        {
            /* Verify that the Service is not already registered.             */
            if(!SCPSInstanceID)
            {
                /* Register the SCPS Service with GATT.                        */
                Result = qc_drv_ble_SCPS_Initialize_Service(qc_api_get_qc_drv_context(), BluetoothStackID, SCPS_EventCallback, 0, &ServiceID);
                if(Result > 0)
                {
                    /* Display success message.                                 */
                    LOG_INFO("Successfully registered SCPS Service, InstanceID = %u.\n", Result);

                    /* Save the ServiceID of the registered service.            */
                    SCPSInstanceID = (unsigned int)Result;

                    /* Return success to the caller.                            */
                    ret_val        = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    LOG_ERR("Error - qapi_BLE_SCPS_Initialize_Service() returned %d.\n", Result);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_WARN("SCPS Service already registered.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            LOG_ERR("BLE connection(s) currently active.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"unregister") == 0)) {

        /* Verify that there is no active connection.                        */
        if(!ConnectionCount)
        {
            /* Verify that a service is registered.                           */
            if(SCPSInstanceID)
            {
                /* Unregister the SCPS Service with GATT.                      */
                Result = qc_drv_ble_SCPS_Cleanup_Service(qc_api_get_qc_drv_context(), BluetoothStackID, SCPSInstanceID);
                if(Result == 0)
                {
                    /* Display success message.                                 */
                    LOG_INFO("Successfully unregistered SCPS Service.\n");

                    /* Clear the ServiceID of the registered service.           */
                    SCPSInstanceID = 0;

                    /* Return success to the caller.                            */
                    ret_val        = QCLI_STATUS_SUCCESS_E;
                }
                else
                    DisplayFunctionError("qapi_BLE_SCPS_Cleanup_Service", Result);
            }
            else
                LOG_WARN("SCPS Service not registered.\n");
        }
        else
            LOG_INFO("BLE connection(s) currently active.\n");

    } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"configure") == 0)) {

        /* Verify that the input parameters are semi-valid.                  */
        if((Parameter_List) && (Parameter_Count > 1) && (Parameter_List[1].Integer_Is_Valid))
        {
            /* Verify that we are not configured as a server                  */
            if(!SCPSInstanceID)
            {
                /* Verify that there is a connection that is established.      */
                if(ConnectionCount)
                {
                    /* Lock the Bluetooth stack.                                */
                    if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                    {
                        /* Get the device info for the connection device.        */
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                        {
                            LOG_INFO("Attempting to configure CCCDs...\n");

                            /* Initialize the result to 0.                        */
                            Result = 0;

                            /* Determine if Scan Refresh CC is supported (only if */
                            /* Scan Refresh characteristic is supported(optional))*/
                            if(DeviceInfo->SCPSClientInfo.Scan_Refresh)
                            {
                                /* Make sure a CCCD has been discovered for the    */
                                /* remote device's Scan Refresh characteristic.    */
                                if(DeviceInfo->SCPSClientInfo.Scan_Refresh_Client_Configuration)
                                    Result = EnableDisableNotificationsIndications(DeviceInfo->SCPSClientInfo.Scan_Refresh_Client_Configuration, (Parameter_List[1].Integer_Value ? QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE : 0), DeviceInfo->ConnectionID, GATT_ClientEventCallback_SCPS);
                                else
                                    LOG_ERR("Scan Refresh CC not found on this device.\n");
                            }
                            else
                                LOG_ERR("Scan Refresh Characteristics not supported.\n");

                            /* Check for CC Configuration success                 */
                            if(Result > 0)
                            {
                                LOG_INFO("CCCD Configuration Success.\n");

                                ret_val = QCLI_STATUS_SUCCESS_E;
                            }
                            else
                            {
                                /* CC Configuration failed, check to see if it was */
                                /* from a call to                                  */
                                /* EnableDisableNotificationsIndications           */
                                if(Result < 0)
                                    DisplayFunctionError("EnableDisableNotificationsIndications", Result);
                            }
                        }
                        else
                            LOG_INFO("No Device Info.\n");

                        /* Un-lock the Bluetooth Stack.                          */
                        qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                    }
                    else
                        LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
                }
                else
                    LOG_WARN("No Connection Established.\n");
            }
            else
                LOG_WARN("Cannot configure remote SCPS Services when registered as a service.\n");
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;

    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);

}


/* The following function is responsible for writing the Scan        */
/* Interval Window to connected remote device. It can be executed    */
/* only by a client. This function will return zero on successful    */
/* execution and a negative value on errors                          */
static QCLI_Command_Status_t SetScanIntervalWindow(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    int                                        Result;
    uint8_t                                    Buffer[QAPI_BLE_SCPS_SCAN_INTERVAL_WINDOW_SIZE];
    DeviceInfo_t                              *DeviceInfo;
    QCLI_Command_Status_t                      ret_val = QCLI_STATUS_ERROR_E;
    qapi_BLE_SCPS_Scan_Interval_Window_Data_t  ScanIntervalWindow;

    /* Verify that the input parameters are semi-valid.                  */
    if((Parameter_List) && (Parameter_Count >= 2) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[1].Integer_Is_Valid))
    {
        /* Set the scan interval/window.                                  */
        ScanIntervalWindow.LE_Scan_Interval = (uint16_t)Parameter_List[0].Integer_Value;
        ScanIntervalWindow.LE_Scan_Window   = (uint16_t)Parameter_List[1].Integer_Value;

        /* Verify that we are not configured as a server                  */
        if(!SCPSInstanceID)
        {
            /* Verify that there is a valid connection                     */
            if(ConnectionCount)
            {
                /* Lock the Bluetooth stack.                                */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Get the device info for the connection device.        */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                    {
                        /* Verify that the client has received a valid Scan   */
                        /* Interval Window Attribute Handle.                  */
                        if(DeviceInfo->SCPSClientInfo.Scan_Interval_Window != 0)
                        {
                            /* Format the command                              */
                            if((Result = qc_drv_ble_SCPS_Format_Scan_Interval_Window(qc_api_get_qc_drv_context(), &ScanIntervalWindow, QAPI_BLE_SCPS_SCAN_INTERVAL_WINDOW_SIZE, Buffer)) == 0)
                            {
                                /* Finally, submit a write without response     */
                                /* request to the server.                       */
                                if((Result = qc_drv_ble_GATT_Write_Without_Response_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->SCPSClientInfo.Scan_Interval_Window, QAPI_BLE_SCPS_SCAN_INTERVAL_WINDOW_SIZE, ((void *)Buffer))) > 0)
                                {
                                    LOG_INFO("Number of Bytes written: %d", Result);

                                    ret_val = QCLI_STATUS_SUCCESS_E;
                                }
                                else
                                    DisplayFunctionError("qapi_BLE_GATT_Write_Without_Response_Request", Result);
                            }
                            else
                                DisplayFunctionError("qapi_BLE_SCPS_Format_Scan_Interval_Window", Result);
                        }
                        else
                            LOG_ERR("Error - Scan Interval Window not supported on remote service!\n");
                    }
                    else
                        LOG_ERR("Error getting device info.\n");

                    /* Un-lock the Bluetooth Stack.                          */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                    LOG_WARN("Unable to acquire Bluetooth Stack Lock.\n");
            }
            else
                LOG_WARN("Connection is not established.\n");
        }
        else
            LOG_WARN("Cannot Set Scan Interval Window when registered as a service.\n");
    }
    else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* Scan Parameter Service (SCPS) helper functions.                   */

/* The following function is a utility function that provides a      */
/* mechanism of populating a SCPS Client Information structure with  */
/* the information discovered from a GATT Discovery operation.       */
static void SCPSPopulateHandles(DeviceInfo_t *DeviceInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceDiscoveryData)
{
    unsigned int                                           Index1;
    unsigned int                                           Index2;
    qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
    qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

    /* Verify that the input parameters are semi-valid.                  */
    if((DeviceInfo) && (ServiceDiscoveryData) && (ServiceDiscoveryData->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E) && (QAPI_BLE_SCPS_COMPARE_SCPS_SERVICE_UUID_TO_UUID_16(ServiceDiscoveryData->ServiceInformation.UUID.UUID.UUID_16)))
    {
        /* Loop through all characteristics discovered in the service     */
        /* and populate the correct entry.                                */
        CurrentCharacteristic = ServiceDiscoveryData->CharacteristicInformationList;
        if(CurrentCharacteristic)
        {
            for(Index1 = 0; Index1 < ServiceDiscoveryData->NumberOfCharacteristics; Index1++, CurrentCharacteristic++)
            {
                if(QAPI_BLE_SCPS_COMPARE_SCAN_INTERVAL_WINDOW_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                {
                    /* All SCPS UUIDs are defined to be 16 bit UUIDs.        */
                    if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                        DeviceInfo->SCPSClientInfo.Scan_Interval_Window = CurrentCharacteristic->Characteristic_Handle;
                }
                else
                {
                    if(QAPI_BLE_SCPS_COMPARE_SCAN_REFRESH_UUID_TO_UUID_16(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_16))
                    {
                        DeviceInfo->SCPSClientInfo.Scan_Refresh = CurrentCharacteristic->Characteristic_Handle;

                        /* Loop through the Descriptor List.                  */
                        CurrentDescriptor = CurrentCharacteristic->DescriptorList;
                        for(Index2 = 0; Index2 < CurrentCharacteristic->NumberOfDescriptors; Index2++)
                        {
                            if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                            {
                                if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_UUID.UUID.UUID_16))
                                    DeviceInfo->SCPSClientInfo.Scan_Refresh_Client_Configuration = CurrentCharacteristic->DescriptorList[Index2].Characteristic_Descriptor_Handle;
                            }
                        }
                    }
                }
            }
        }
    }
}

/* Serial Port over LE (SPPLE) QCLI command functions.               */

/* The following function is responsible for registering a SPPLE     */
/* Service.  This function will return zero on successful execution  */
/* and a negative value on errors.                                   */

/* The following function is responsible for unregistering a SPPLE   */
/* Service.  This function will return zero on successful execution  */
/* and a negative value on errors.                                   */

/* The following function is responsible for configure a SPPLE       */
/* Service on a remote device.  This function will return zero on    */
/* successful execution and a negative value on errors.              */
static QCLI_Command_Status_t SPPLEService(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    DeviceInfo_t       				   *DeviceInfo;
    int                                    Result;
    QCLI_Command_Status_t                  ret_val;
    qapi_BLE_GATT_Attribute_Handle_Group_t ServiceHandleGroup;

    if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"register") == 0)) {
        /* Verify that there is no active connection.                        */
        if(!ConnectionCount)
        {
            /* Verify that the Service is not already registered.             */
            if(!SPPLEServiceID)
            {
                /* Initialize the Service Handle Group to 0 since we do not    */
                /* require a specific location in the service table.           */
                ServiceHandleGroup.Starting_Handle = 0;
                ServiceHandleGroup.Ending_Handle   = 0;

                /* Register the SPPLE Service.                                 */
                Result = qc_drv_ble_GATT_Register_Service(qc_api_get_qc_drv_context(), BluetoothStackID, SPPLE_SERVICE_FLAGS, SPPLE_SERVICE_ATTRIBUTE_COUNT, (qapi_BLE_GATT_Service_Attribute_Entry_t *)SPPLE_Service, &ServiceHandleGroup, GATT_ServerEventCallback_SPPLE, 0);
                if(Result > 0)
                {
                    /* Display success message.                                 */
                    LOG_INFO("Successfully registered SPPLE Service, ServiceID = %u.\n", Result);

                    /* Save the ServiceID of the registered service.            */
                    SPPLEServiceID = (unsigned int)Result;

                    /* Return success to the caller.                            */
                    ret_val        = QCLI_STATUS_SUCCESS_E;
                }
                else
                {
                    LOG_ERR("qapi_BLE_GATT_Register_Service() returned %d.\n", Result);

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("SPPLE Service already registered.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            LOG_ERR("Connection currently active.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"unregister") == 0)) {

        /* Verify that there is no active connection.                        */
        if(!ConnectionCount)
        {
            /* Verify that the Service is not already registered.             */
            if(SPPLEServiceID)
            {
                /* Un-registered SPP LE Service.                               */
                qc_drv_ble_GATT_Un_Register_Service(qc_api_get_qc_drv_context(), BluetoothStackID, SPPLEServiceID);

                /* Display success message.                                    */
                LOG_INFO("Successfully unregistered SPPLE Service.\n");

                /* Save the ServiceID of the registered service.               */
                SPPLEServiceID = 0;

                /* Return success to the caller.                               */
                ret_val        = QCLI_STATUS_SUCCESS_E;
            }
            else
            {
                LOG_INFO("SPPLE Service not registered.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            LOG_INFO("Connection currently active.\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }
    } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"configure") == 0)) {

        /* Verify that there is a connection that is established.            */
        if(ConnectionCount)
        {
            /* Lock the Bluetooth stack.                                      */
            if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
            {
                /* Get the device info for the connection device.              */
                if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                {
                    /* Verify that we are not already acting as a Server.       */
                    if(!(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_SERVER))
                    {
                        /* Determine if a service discovery operation has been   */
                        /* previously done.                                      */
                        if(SPPLE_CLIENT_INFORMATION_VALID(DeviceInfo->ClientInfo))
                        {
                            LOG_INFO("SPPLE Service found on remote device, attempting to read Transmit Credits, and configured CCCDs.\n");

                            /* Send the Initial Credits to the remote device.     */
                            SendCredits(DeviceInfo, DeviceInfo->ReceiveBuffer.BytesFree);

                            /* Enable Notifications on the proper characteristics.*/
                            EnableDisableNotificationsIndications(DeviceInfo->ClientInfo.Rx_Credit_Client_Configuration_Descriptor, QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE, DeviceInfo->ConnectionID, GATT_ClientEventCallback_SPPLE);
                            EnableDisableNotificationsIndications(DeviceInfo->ClientInfo.Tx_Client_Configuration_Descriptor, QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE, DeviceInfo->ConnectionID, GATT_ClientEventCallback_SPPLE);

                            /* Flag that we are an SPPLE Client.                  */
                            DeviceInfo->Flags |= DEVICE_INFO_FLAGS_SPPLE_CLIENT;

                            ret_val            = QCLI_STATUS_SUCCESS_E;
                        }
                        else
                        {
                            LOG_INFO("No SPPLE Service discovered on device.\n");

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        LOG_ERR("Already operating as a Server\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                {
                    LOG_ERR("No Device Info.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }

                /* Un-lock the Bluetooth Stack.                                */
                qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
            }
            else
            {
                LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            LOG_ERR("No Connection Established\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }

    } else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);

}

/* The following function is responsible for sending a number of     */
/* characters to a remote device to which a connection exists.  The  */
/* function receives a parameter that indicates the number of byte to*/
/* be transferred.  This function will return zero on successful     */
/* execution and a negative value on errors.                         */

/* The following function is responsible for reading data sent by a  */
/* remote device to which a connection exists.  This function will   */
/* return zero on successful execution and a negative value on       */
/* errors.                                                           */
static QCLI_Command_Status_t SPPLEData(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    DeviceInfo_t          *DeviceInfo;
    QCLI_Command_Status_t  ret_val;
    unsigned int           Temp;
    boolean_t              Done;
    uint8_t               *Ptr;

    if (Parameter_Count == 1) {
        /* Make sure that all of the parameters required for this function   */
        /* appear to be at least semi-valid.                                 */
        if((Parameter_Count >= 1) && (Parameter_List) && (Parameter_List[0].Integer_Is_Valid) && (Parameter_List[0].Integer_Value > 0))
        {
            /* Verify that there is a connection that is established.         */
            if(ConnectionCount)
            {
                /* Lock the Bluetooth stack.                                   */
                if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
                {
                    /* Check to see if we are sending to another port.          */
                    if(!SendInfo.BytesToSend)
                    {
                        /* Get the device info for the connection device.        */
                        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                        {
                            /* Verify that we are a Client or Server.             */
                            if(DeviceInfo->Flags & (DEVICE_INFO_FLAGS_SPPLE_CLIENT | DEVICE_INFO_FLAGS_SPPLE_SERVER))
                            {
                                /* Get the count of the number of bytes to send.   */
                                SendInfo.BytesToSend  = (uint32_t)Parameter_List[0].Integer_Value;
                                SendInfo.BytesSent    = 0;

                                /* Kick start the send process.                    */
                                SendProcess(DeviceInfo);

                                ret_val = QCLI_STATUS_SUCCESS_E;
                            }
                            else
                            {
                                LOG_ERR("SPPLE has not been configured\n");

                                ret_val = QCLI_STATUS_ERROR_E;
                            }
                        }
                        else
                        {
                            LOG_WARN("No Device Info.\n");

                            ret_val = QCLI_STATUS_ERROR_E;
                        }
                    }
                    else
                    {
                        LOG_WARN("Send Currently in progress.\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }

                    /* Un-lock the Bluetooth Stack.                             */
                    qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
                }
                else
                {
                    LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }
            }
            else
            {
                LOG_ERR("No Connection Established\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    } else if (Parameter_Count == 0) {

        /* Verify that there is a connection that is established.            */
        if(ConnectionCount)
        {
            /* Lock the Bluetooth stack.                                      */
            if(!qc_drv_ble_BSC_LockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID))
            {
                /* Get the device info for the connection device.              */
                if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                {
                    /* Verify that we are a Client or Server.                   */
                    if(DeviceInfo->Flags & (DEVICE_INFO_FLAGS_SPPLE_CLIENT | DEVICE_INFO_FLAGS_SPPLE_SERVER))
                    {
                        /* Determine the number of bytes we are going to read.   */
                        Temp = DeviceInfo->ReceiveBuffer.BufferSize - DeviceInfo->ReceiveBuffer.BytesFree;

                        LOG_INFO("Read: %u bytes.\n", Temp);
                        LOG_INFO("Read: Data: ");

                        /* Loop and read all of the data.                        */
                        Done = FALSE;
                        while(!Done)
                        {
                            /* Read the data.                                     */
                            Temp = ReadData(DeviceInfo, SPPLE_DATA_BUFFER_LENGTH, SPPLEBuffer);
                            if(Temp > 0)
                            {
                                /* Display the data.                               */
                                Ptr = SPPLEBuffer;

                                while(Temp > 0)
                                {
                                    LOG_INFO("0x%02X ", *Ptr);
                                    Ptr++;
                                    Temp--;
                                }
                            }
                            else
                                Done = TRUE;
                        }

                        LOG_INFO("\n");

                        ret_val = QCLI_STATUS_SUCCESS_E;
                    }
                    else
                    {
                        LOG_ERR("SPPLE has not been configured\n");

                        ret_val = QCLI_STATUS_ERROR_E;
                    }
                }
                else
                {
                    LOG_ERR("No Device Info.\n");

                    ret_val = QCLI_STATUS_ERROR_E;
                }

                /* Un-lock the Bluetooth Stack.                                */
                qc_drv_ble_BSC_UnLockBluetoothStack(qc_api_get_qc_drv_context(), BluetoothStackID);
            }
            else
            {
                LOG_ERR("Unable to acquire Bluetooth Stack Lock.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
        {
            LOG_ERR("No Connection Established\n");

            ret_val = QCLI_STATUS_ERROR_E;
        }

    } else
        ret_val = QCLI_STATUS_USAGE_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for setting the application */
/* state to support loopback mode.  This function will return zero on*/
/* successful execution and a negative value on errors.              */

/* The following function is responsible for setting the application */
/* state to support displaying Raw Data.  This function will return  */
/* zero on successful execution and a negative value on errors.      */

/* The following function is responsible for setting the application */
/* state to support Automatically reading all data that is received  */
/* through SPP.  This function will return zero on successful        */
/* execution and a negative value on errors.                         */
static QCLI_Command_Status_t SPPLEext(uint32_t Parameter_Count, QCLI_Parameter_t *Parameter_List)
{
    QCLI_Command_Status_t ret_val;

    /* First check to see if the parameters required for the execution of*/
    /* this function appear to be semi-valid.                            */
    if(BluetoothStackID)
    {
        if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"Loopback") == 0)) {

            /* Next check to see if the parameters required for the execution */
            /* of this function appear to be semi-valid.                      */
            if((Parameter_Count > 1) && (Parameter_List) && (Parameter_List[1].Integer_Is_Valid))
            {
                /* Set the Loopback Active field.                              */
                if(Parameter_List[1].Integer_Value)
                    LoopbackActive = TRUE;
                else
                    LoopbackActive = FALSE;

                /* Finally output the current Loopback state.                  */
                LOG_INFO("Current Loopback Mode set to: %s.\n", LoopbackActive?"ACTIVE":"INACTIVE");

                /* Flag success.                                               */
                ret_val = QCLI_STATUS_SUCCESS_E;
            }
            else
                ret_val = QCLI_STATUS_USAGE_E;

        } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"DispRawData") == 0)) {
            /* Check to see if Loopback is active.  If it is then we will not */
            /* process this command (and we will inform the user).            */
            if(!LoopbackActive)
            {
                /* Next check to see if the parameters required for the        */
                /* execution of this function appear to be semi-valid.         */
                if((Parameter_Count > 1) && (Parameter_List) && (Parameter_List[1].Integer_Is_Valid))
                {
                    /* Set the Display Raw Data flag.                           */
                    if(Parameter_List[1].Integer_Value)
                        DisplayRawData = TRUE;
                    else
                        DisplayRawData = FALSE;

                    /* Output the current Raw Data Display Mode state.          */
                    LOG_INFO("Current Raw Data Display Mode set to: %s.\n", DisplayRawData?"ACTIVE":"INACTIVE");

                    /* Flag that the function was successful.                   */
                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                    ret_val = QCLI_STATUS_USAGE_E;
            }
            else
            {
                LOG_WARN("Unable to process Raw Mode Display Request when operating in Loopback Mode.\n");

                ret_val = QCLI_STATUS_ERROR_E;

            }
        } else if ((Parameter_Count >= 1) && (APP_STRCMP(Parameter_List[0].String_Value,"AutoReadMode") == 0)) {
            /* Check to see if Loopback is active.  If it is then we will not */
            /* process this command (and we will inform the user).            */
            if(!LoopbackActive)
            {
                /* Next check to see if the parameters required for the        */
                /* execution of this function appear to be semi-valid.         */
                if((Parameter_Count > 1) && (Parameter_List) && (Parameter_List[1].Integer_Is_Valid))
                {
                    /* Set the Automatic Read Active flag flag.                 */
                    if(Parameter_List[1].Integer_Value)
                        AutomaticReadActive = TRUE;
                    else
                        AutomaticReadActive = FALSE;

                    /* Output the current Automatic Read Mode state.            */
                    LOG_INFO("Current Automatic Read Mode set to: %s.\n", AutomaticReadActive?"ACTIVE":"INACTIVE");

                    /* Flag that the function was successful.                   */
                    ret_val = QCLI_STATUS_SUCCESS_E;
                }
                else
                    ret_val = QCLI_STATUS_USAGE_E;
            }
            else
            {
                LOG_ERR("Unable to process Automatic Read Mode Request when operating in Loopback Mode.\n");

                ret_val = QCLI_STATUS_ERROR_E;
            }
        }
        else
            ret_val = QCLI_STATUS_USAGE_E;
    }
    else
        ret_val = QCLI_STATUS_ERROR_E;

    if ((ret_val == QCLI_STATUS_SUCCESS_E) || (ret_val == QCLI_STATUS_USAGE_E))
        LOG_AT_OK();
    else if(ret_val == QCLI_STATUS_ERROR_E)
        LOG_AT_ERROR();

    return(ret_val);
}

/* The following function is responsible for timing the throughput of*/
/* an SPPLE Service.  This function will return zero on successful   */
/* execution and a negative value on errors.                         */
static void DisplayThroughput(DeviceInfo_t *DeviceInfo)
{
    char        DiffTime[16];
    uint64_t    Throughput;
    uint64_t    Diff;
    BoardStr_t  BoardStr;
    XferInfo_t *XferInfo;

    if(DeviceInfo->ThroughputModeActive)
    {
        BD_ADDRToStr(SelectedRemoteBD_ADDR, BoardStr);

        XferInfo = &DeviceInfo->XferInfo;

        Diff = XferInfo->LastTime - XferInfo->FirstTime;
        if (Diff)
        {
            /* Get bits per second.                                        */
            Throughput = (XferInfo->RxCount * 8) / Diff;

            /* Convert the difference to a string in HH:MM:SS format.      */
            SecondsToString((Diff), sizeof(DiffTime), DiffTime);
            LOG_INFO("Remote Device: %s\n", BoardStr);
            LOG_INFO("   Throughput: %d.", Throughput / 1000);
            LOG_INFO("%03d Kbps\n", Throughput % 1000);
            LOG_INFO("     Rx Bytes: %d\n", XferInfo->RxCount);
            LOG_INFO(" Elapsed Time: %s\n", DiffTime);
        }
        else
        {
            LOG_INFO("Remote Device: %s\n", BoardStr);
            LOG_INFO("   Throughput: Unknown\n");
            LOG_INFO("     Rx Bytes: %d\n", XferInfo->RxCount);
            LOG_INFO("         Diff: None\n");
        }
    }
}

/* The following function is used to convert seconds into a string of*/
/* the following formats: HH:MM:SS, MM:SS.                           */
static char *SecondsToString(uint32_t Seconds, uint8_t BufferLength, char *Buffer)
{
    char     *ret_val;
    uint32_t  Hours;
    uint32_t  Minutes;
    uint32_t  Offset;

    if ((BufferLength > 0) && (Buffer != NULL))
    {
        Hours = Seconds / (60 * 60);
        Minutes = (Seconds / 60) % 60;
        Seconds = Seconds % 60;

        /* Initialize the return value to the input buffer. This will be  */
        /* overwritten to NULL if there is an error.                      */
        ret_val = Buffer;

        /* Display the hours only if non-zero.                            */
        if (Hours != 0)
        {
            Offset = snprintf(Buffer, BufferLength, "%d:", (unsigned int)Hours);

            if ((Offset + 1) < BufferLength)
            {
                Buffer += Offset;
                BufferLength -= Offset;
            }
            else
                BufferLength = 0;
        }

        /* Display the minutes.                                           */
        if (BufferLength > 0)
        {
            /* Pad the minutes to two characters if hours are present.     */
            if (Hours != 0)
                Offset = snprintf(Buffer, BufferLength, "%02d:", (unsigned int)Minutes);
            else
                Offset = snprintf(Buffer, BufferLength, "%d:", (unsigned int)Minutes);

            if ((Offset + 1) < BufferLength)
            {
                Buffer += Offset;
                BufferLength -= Offset;

                /* Display the seconds.                                     */
                Offset = snprintf(Buffer, BufferLength, "%02d", (unsigned int)Seconds);

                if ((Offset + 1) >= BufferLength)
                    ret_val = "";
            }
            else
                ret_val = "";
        }
        else
            ret_val = "";
    }
    else
        ret_val = "";

    return(ret_val);
}

/* Serial Port over LE (SPPLE) helper functions.                     */

/* The following function is a utility function that provides a      */
/* mechanism of populating a BRSM Client Information structure with  */
/* the information discovered from a GATT Discovery operation.       */
static void SPPLEPopulateHandles(SPPLE_Client_Info_t *ClientInfo, qapi_BLE_GATT_Service_Discovery_Indication_Data_t *ServiceInfo)
{
    uint16_t                                              *ClientConfigurationHandle;
    unsigned int                                           Index1;
    unsigned int                                           Index2;
    qapi_BLE_GATT_Characteristic_Information_t            *CurrentCharacteristic;
    qapi_BLE_GATT_Characteristic_Descriptor_Information_t *CurrentDescriptor;

    /* Verify that the input parameters are semi-valid.                  */
    if((ClientInfo) && (ServiceInfo) && (ServiceInfo->ServiceInformation.UUID.UUID_Type == QAPI_BLE_GU_UUID_128_E) && (SPPLE_COMPARE_SPPLE_SERVICE_UUID_TO_UUID_128(ServiceInfo->ServiceInformation.UUID.UUID.UUID_128)))
    {
        /* Loop through all characteristics discovered in the service     */
        /* and populate the correct entry.                                */
        CurrentCharacteristic = ServiceInfo->CharacteristicInformationList;
        if(CurrentCharacteristic)
        {
            for(Index1=0;Index1<ServiceInfo->NumberOfCharacteristics;Index1++,CurrentCharacteristic++)
            {
                /* All SPPLE UUIDs are defined to be 128 bit UUIDs.         */
                if(CurrentCharacteristic->Characteristic_UUID.UUID_Type == QAPI_BLE_GU_UUID_128_E)
                {
                    ClientConfigurationHandle = NULL;

                    /* Determine which characteristic this is.               */
                    if(!SPPLE_COMPARE_SPPLE_TX_UUID_TO_UUID_128(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_128))
                    {
                        if(!SPPLE_COMPARE_SPPLE_TX_CREDITS_UUID_TO_UUID_128(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_128))
                        {
                            if(!SPPLE_COMPARE_SPPLE_RX_UUID_TO_UUID_128(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_128))
                            {
                                if(!SPPLE_COMPARE_SPPLE_RX_CREDITS_UUID_TO_UUID_128(CurrentCharacteristic->Characteristic_UUID.UUID.UUID_128))
                                    continue;
                                else
                                {
                                    ClientInfo->Rx_Credit_Characteristic = CurrentCharacteristic->Characteristic_Handle;
                                    ClientConfigurationHandle            = &(ClientInfo->Rx_Credit_Client_Configuration_Descriptor);
                                }
                            }
                            else
                            {
                                ClientInfo->Rx_Characteristic = CurrentCharacteristic->Characteristic_Handle;
                                continue;
                            }
                        }
                        else
                        {
                            ClientInfo->Tx_Credit_Characteristic = CurrentCharacteristic->Characteristic_Handle;
                            continue;
                        }
                    }
                    else
                    {
                        ClientInfo->Tx_Characteristic = CurrentCharacteristic->Characteristic_Handle;
                        ClientConfigurationHandle     = &(ClientInfo->Tx_Client_Configuration_Descriptor);
                    }

                    /* Loop through the Descriptor List.                     */
                    CurrentDescriptor = CurrentCharacteristic->DescriptorList;
                    if((CurrentDescriptor) && (ClientConfigurationHandle))
                    {
                        for(Index2=0;Index2<CurrentCharacteristic->NumberOfDescriptors;Index2++,CurrentDescriptor++)
                        {
                            if(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID_Type == QAPI_BLE_GU_UUID_16_E)
                            {
                                if(QAPI_BLE_GATT_COMPARE_CLIENT_CHARACTERISTIC_CONFIGURATION_ATTRIBUTE_TYPE_TO_BLUETOOTH_UUID_16(CurrentDescriptor->Characteristic_Descriptor_UUID.UUID.UUID_16))
                                {
                                    *ClientConfigurationHandle = CurrentDescriptor->Characteristic_Descriptor_Handle;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/* The following function is a utility function that is used to add  */
/* data (using InIndex as the buffer index) from the buffer specified*/
/* by the DataBuffer parameter.  The second and third parameters     */
/* specified the length of the data to add and the pointer to the    */
/* data to add to the buffer.  This function returns the actual      */
/* number of bytes that were added to the buffer (or 0 if none were  */
/* added).                                                           */
static unsigned int AddDataToBuffer(SPPLE_Data_Buffer_t *DataBuffer, unsigned int DataLength, uint8_t *Data)
{
    unsigned int BytesAdded = 0;
    unsigned int Count;

    /* Verify that the input parameters are valid.                       */
    if((DataBuffer) && (DataLength) && (Data))
    {
        /* Loop while we have data AND space in the buffer.               */
        while(DataLength)
        {
            /* Get the number of bytes that can be placed in the buffer    */
            /* until it wraps.                                             */
            Count = DataBuffer->BufferSize - DataBuffer->InIndex;

            /* Determine if the number of bytes free is less than the      */
            /* number of bytes till we wrap and choose the smaller of the  */
            /* numbers.                                                    */
            Count = (DataBuffer->BytesFree < Count)?DataBuffer->BytesFree:Count;

            /* Cap the Count that we add to buffer to the length of the    */
            /* data provided by the caller.                                */
            Count = (Count > DataLength)?DataLength:Count;

            if(Count)
            {
                /* Copy the data into the buffer.                           */
                memcpy(&DataBuffer->Buffer[DataBuffer->InIndex], Data, Count);

                /* Update the counts.                                       */
                DataBuffer->InIndex   += Count;
                DataBuffer->BytesFree -= Count;
                DataLength            -= Count;
                BytesAdded            += Count;
                Data                  += Count;

                /* Wrap the InIndex if necessary.                           */
                if(DataBuffer->InIndex >= DataBuffer->BufferSize)
                    DataBuffer->InIndex = 0;
            }
            else
                break;
        }
    }

    return(BytesAdded);
}

/* The following function is a utility function that is used to      */
/* removed data (using OutIndex as the buffer index) from the buffer */
/* specified by the DataBuffer parameter The second parameter        */
/* specifies the length of the Buffer that is pointed to by the third*/
/* parameter.  This function returns the actual number of bytes that */
/* were removed from the DataBuffer (or 0 if none were added).       */
/* * NOTE * Buffer is optional and if not specified up to            */
/*          BufferLength bytes will be deleted from the Buffer.      */
static unsigned int RemoveDataFromBuffer(SPPLE_Data_Buffer_t *DataBuffer, unsigned int BufferLength, uint8_t *Buffer)
{
    unsigned int Count;
    unsigned int BytesRemoved = 0;
    unsigned int MaxRemove;

    /* Verify that the input parameters are valid.                       */
    if((DataBuffer) && (BufferLength))
    {
        /* Loop while we have data to remove and space in the buffer to   */
        /* place it.                                                      */
        while(BufferLength)
        {
            /* Determine the number of bytes that are present in the       */
            /* buffer.                                                     */
            Count = DataBuffer->BufferSize - DataBuffer->BytesFree;
            if(Count)
            {
                /* Calculate the maximum number of bytes that I can remove  */
                /* from the buffer before it wraps.                         */
                MaxRemove = DataBuffer->BufferSize - DataBuffer->OutIndex;

                /* Cap max we can remove at the BufferLength of the caller's*/
                /* buffer.                                                  */
                MaxRemove = (MaxRemove > BufferLength)?BufferLength:MaxRemove;

                /* Cap the number of bytes I will remove in this iteration  */
                /* at the maximum I can remove or the number of bytes that  */
                /* are in the buffer.                                       */
                Count = (Count > MaxRemove)?MaxRemove:Count;

                /* Copy the data into the caller's buffer (If specified).   */
                if(Buffer)
                {
                    memcpy(Buffer, &DataBuffer->Buffer[DataBuffer->OutIndex], Count);
                    Buffer += Count;
                }

                /* Update the counts.                                       */
                DataBuffer->OutIndex  += Count;
                DataBuffer->BytesFree += Count;
                BytesRemoved          += Count;
                BufferLength          -= Count;

                /* Wrap the OutIndex if necessary.                          */
                if(DataBuffer->OutIndex >= DataBuffer->BufferSize)
                    DataBuffer->OutIndex = 0;
            }
            else
                break;
        }
    }

    return(BytesRemoved);
}

/* The following function is used to initialize the specified buffer */
/* to the defaults.                                                  */
static void InitializeBuffer(SPPLE_Data_Buffer_t *DataBuffer)
{
    /* Verify that the input parameters are valid.                       */
    if(DataBuffer)
    {
        DataBuffer->BufferSize = SPPLE_DATA_CREDITS;
        DataBuffer->BytesFree  = SPPLE_DATA_CREDITS;
        DataBuffer->InIndex    = 0;
        DataBuffer->OutIndex   = 0;
    }
}

/* The following function is a utility function that exists to fill  */
/* the specified buffer with the DataStr that is used to send data.  */
/* This function will fill from the CurrentBufferLength up to Max    */
/* Length in Buffer.  CurrentBufferLength is used to return the total*/
/* length of the buffer.  The first parameter specifies the          */
/* DeviceInfo which is used to fill any remainder of the string so   */
/* that there are no breaks in the pattern.  This function returns   */
/* the number of bytes added to the transmit buffer of the specified */
/* device.                                                           */
static unsigned int FillBufferWithString(SPPLE_Data_Buffer_t *DataBuffer, unsigned *CurrentBufferLength, unsigned int MaxLength, uint8_t *Buffer)
{
    unsigned int DataCount;
    unsigned int Length;
    unsigned int Added2Buffer = 0;

    /* Verify that the input parameter is semi-valid.                    */
    if((DataBuffer) && (CurrentBufferLength) && (MaxLength) && (Buffer))
    {
        /* Copy as much of the DataStr into the Transmit buffer as is     */
        /* possible.                                                      */
        while(*CurrentBufferLength < MaxLength)
        {
            /* Cap the data to copy at the maximum of the string length and*/
            /* the remaining amount that can be placed in the buffer.      */
            DataCount = (DataStrLen > (MaxLength-*CurrentBufferLength))?(MaxLength-*CurrentBufferLength):DataStrLen;

            /* Build the data string into the SPPLEBuffer.                 */
            memcpy(&Buffer[*CurrentBufferLength], DataStr, DataCount);

            /* Increment the index.                                        */
            *CurrentBufferLength += DataCount;

            /* Add whatever bytes remaining in the DataStr into the        */
            /* transmit buffer to keep the pattern consistent.             */
            Length = DataStrLen-DataCount;
            if(Length)
            {
                /* Add the bytes remaining in the string.                   */
                Added2Buffer += AddDataToBuffer(DataBuffer, Length, (uint8_t *)&DataStr[DataCount]);
            }
        }
    }

    return(Added2Buffer);
}

/* The following function is responsible for handling a Send Process.*/
static void SendProcess(DeviceInfo_t *DeviceInfo)
{
    int          Result;
    boolean_t    Done = FALSE;
    unsigned int TransmitIndex;
    unsigned int DataCount;
    unsigned int MaxLength;
    unsigned int SPPLEBufferLength;
    unsigned int Added2Buffer;

    /* Verify that the input parameter is semi-valid.                    */
    if(DeviceInfo)
    {
        /* Loop while we have data to send and we have not used up all    */
        /* Transmit Credits.                                              */
        TransmitIndex     = 0;
        SPPLEBufferLength = 0;
        Added2Buffer      = 0;
        while((SendInfo.BytesToSend) && (DeviceInfo->TransmitCredits) && (!Done))
        {
            /* Get the maximum length of what we can send in this          */
            /* transaction.                                                */
            MaxLength = (SendInfo.BytesToSend > DeviceInfo->TransmitCredits)?DeviceInfo->TransmitCredits:SendInfo.BytesToSend;
            MaxLength = (MaxLength > SPPLE_DATA_BUFFER_LENGTH)?SPPLE_DATA_BUFFER_LENGTH:MaxLength;

            /* If we do not have any outstanding data get some more data.  */
            if(!SPPLEBufferLength)
            {
                /* Send any buffered data first.                            */
                if(DeviceInfo->TransmitBuffer.BytesFree != DeviceInfo->TransmitBuffer.BufferSize)
                {
                    /* Remove the queued data from the Transmit Buffer.      */
                    SPPLEBufferLength = RemoveDataFromBuffer(&(DeviceInfo->TransmitBuffer), MaxLength, SPPLEBuffer);

                    /* If we added some data to the transmit buffer decrement*/
                    /* what we just removed.                                 */
                    if(Added2Buffer)
                        Added2Buffer -= SPPLEBufferLength;
                }

                /* Fill up the rest of the buffer with the data string.     */
                Added2Buffer     += FillBufferWithString(&(DeviceInfo->TransmitBuffer), &SPPLEBufferLength, MaxLength, SPPLEBuffer);

                /* Set the count of data that we can send.                  */
                DataCount         = SPPLEBufferLength;

                /* Reset the Transmit Index to 0.                           */
                TransmitIndex     = 0;
            }
            else
            {
                /* Move the data that to the beginning of the buffer.       */
                memmove(SPPLEBuffer, &SPPLEBuffer[TransmitIndex], SPPLEBufferLength);

                /* Send any buffered data first.                            */
                if(DeviceInfo->TransmitBuffer.BytesFree != DeviceInfo->TransmitBuffer.BufferSize)
                {
                    /* Remove the queued data from the Transmit Buffer.      */
                    TransmitIndex = RemoveDataFromBuffer(&(DeviceInfo->TransmitBuffer), MaxLength-SPPLEBufferLength, &SPPLEBuffer[SPPLEBufferLength]);

                    /* If we added some data to the transmit buffer decrement*/
                    /* what we just removed.                                 */
                    if(Added2Buffer)
                        Added2Buffer -= TransmitIndex;

                    /* Increment the buffer length.                          */
                    SPPLEBufferLength += TransmitIndex;
                }

                /* Reset the Transmit Index to 0.                           */
                TransmitIndex     = 0;

                /* Fill up the rest of the buffer with the data string.     */
                Added2Buffer += FillBufferWithString(&(DeviceInfo->TransmitBuffer), &SPPLEBufferLength, MaxLength, SPPLEBuffer);

                /* We have data to send so cap it at the maximum that can be*/
                /* transmitted.                                             */
                DataCount     = (SPPLEBufferLength > MaxLength)?MaxLength:SPPLEBufferLength;
            }

            /* Use the correct API based on device role for SPPLE.         */
            if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_SERVER)
            {
                /* We are acting as SPPLE Server, so notify the Tx          */
                /* Characteristic.                                          */
                if(DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor == QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                    Result = qc_drv_ble_GATT_Handle_Value_Notification(qc_api_get_qc_drv_context(), BluetoothStackID, SPPLEServiceID, DeviceInfo->ConnectionID, SPPLE_TX_CHARACTERISTIC_ATTRIBUTE_OFFSET, (uint16_t)DataCount, SPPLEBuffer);
                else
                {
                    /* Not configured for notifications so exit the loop.    */
                    Done = TRUE;
                }
            }
            else
            {
                /* We are acting as SPPLE Client, so write to the Rx        */
                /* Characteristic.                                          */
                if(DeviceInfo->ClientInfo.Tx_Characteristic)
                    Result = qc_drv_ble_GATT_Write_Without_Response_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->ClientInfo.Rx_Characteristic, (uint16_t)DataCount, SPPLEBuffer);
                else
                {
                    /* We have not discovered the Tx Characteristic, so exit */
                    /* the loop.                                             */
                    Done = TRUE;
                }
            }

            /* Check to see if any data was written.                       */
            if(!Done)
            {
                /* Check to see if the data was written successfully.       */
                if(Result >= 0)
                {
                    /* Adjust the counters.                                  */
                    SendInfo.BytesToSend        -= (unsigned int)Result;
                    SendInfo.BytesSent          += (unsigned int)Result;
                    TransmitIndex               += (unsigned int)Result;
                    SPPLEBufferLength           -= (unsigned int)Result;
                    DeviceInfo->TransmitCredits -= (unsigned int)Result;

                    /* If we have no more remaining Tx Credits AND we have   */
                    /* data built up to send, we need to queue this in the Tx*/
                    /* Buffer.                                               */
                    if((!(DeviceInfo->TransmitCredits)) && (SPPLEBufferLength))
                    {
                        /* Add the remaining data to the transmit buffer.     */
                        AddDataToBuffer(&(DeviceInfo->TransmitBuffer), SPPLEBufferLength, &SPPLEBuffer[TransmitIndex]);

                        SPPLEBufferLength = 0;
                    }
                }
                else
                {
                    LOG_AT_EVT("EVT_BLE: SEND failed with error %d\n", Result);

                    SendInfo.BytesToSend  = 0;
                }
            }
        }

        /* If we have added more bytes to the transmit buffer than we can */
        /* send in this process remove the extra.                         */
        if(Added2Buffer > SendInfo.BytesToSend)
            RemoveDataFromBuffer(&(DeviceInfo->TransmitBuffer), Added2Buffer-SendInfo.BytesToSend, NULL);

        /* Display a message if we have sent all required data.           */
        if((!SendInfo.BytesToSend) && (SendInfo.BytesSent))
        {
            LOG_INFO("\n");
            LOG_INFO("Send Complete, Sent %u.\n", (unsigned int)SendInfo.BytesSent);

            SendInfo.BytesSent = 0;
        }
    }
}

/* The following function is responsible for transmitting the        */
/* specified number of credits to the remote device.                 */
static void SendCredits(DeviceInfo_t *DeviceInfo, unsigned int DataLength)
{
    qapi_BLE_NonAlignedWord_t Credits;

    /* Verify that the input parameters are semi-valid.                  */
    if((DeviceInfo) && (DataLength))
    {
        /* Format the credit packet.                                      */
        ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(&Credits, DataLength);

        /* Determine how to send credits based on the role.               */
        if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_SERVER)
        {
            /* We are acting as a server so notify the Rx Credits          */
            /* characteristic.                                             */
            if(DeviceInfo->ServerInfo.Rx_Credit_Client_Configuration_Descriptor == QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                qc_drv_ble_GATT_Handle_Value_Notification(qc_api_get_qc_drv_context(), BluetoothStackID, SPPLEServiceID, DeviceInfo->ConnectionID, SPPLE_RX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET, sizeof(Credits), (uint8_t *)&Credits);
        }
        else
        {
            /* We are acting as a client so send a Write Without Response  */
            /* packet to the Tx Credit Characteristic.                     */
            if(DeviceInfo->ClientInfo.Tx_Credit_Characteristic)
                qc_drv_ble_GATT_Write_Without_Response_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->ClientInfo.Tx_Credit_Characteristic, sizeof(Credits), &Credits);
        }
    }
}

/* The following function is responsible for handling a received     */
/* credit, event.                                                    */
static boolean_t ReceiveCreditEvent(DeviceInfo_t *DeviceInfo, unsigned int Credits)
{
    boolean_t ret_val;

    /* Verify that the input parameters are semi-valid.                  */
    if(DeviceInfo)
    {
        /* If this is a real credit event store the number of credits.    */
        DeviceInfo->TransmitCredits += Credits;

        /* Handle any active send process.                                */
        SendProcess(DeviceInfo);

        /* Send all queued data.                                          */
        SendData(DeviceInfo, 0, NULL);

        /* It is possible that we have received data queued, so call the  */
        /* Data Indication Event to handle this.                          */
        ret_val = DataIndicationEvent(DeviceInfo, 0, NULL);
    }
    else
        ret_val = false;

    return(ret_val);
}

/* The following function sends the specified data to the specified  */
/* data.  This function will queue any of the data that does not go  */
/* out.  This function returns TRUE if all the data was sent, or     */
/* FALSE.                                                            */
/* * NOTE * If DataLength is 0 and Data is NULL then all queued data */
/*          will be sent.                                            */
static boolean_t SendData(DeviceInfo_t *DeviceInfo, unsigned int DataLength, uint8_t *Data)
{
    int          Result;
    boolean_t    DataSent = FALSE;
    boolean_t    Done;
    unsigned int DataCount;
    unsigned int MaxLength;
    unsigned int TransmitIndex;
    unsigned int SPPLEBufferLength;

    /* Verify that the input parameters are semi-valid.                  */
    if(DeviceInfo)
    {
        /* Loop while we have data to send and we can send it.            */
        Done              = FALSE;
        TransmitIndex     = 0;
        SPPLEBufferLength = 0;
        while(!Done)
        {
            /* Check to see if we have credits to use to transmit the data.*/
            if(DeviceInfo->TransmitCredits)
            {
                /* Get the maximum length of what we can send in this       */
                /* transaction.                                             */
                MaxLength = (SPPLE_DATA_BUFFER_LENGTH > DeviceInfo->TransmitCredits)?DeviceInfo->TransmitCredits:SPPLE_DATA_BUFFER_LENGTH;

                /* If we do not have any outstanding data get some more     */
                /* data.                                                    */
                if(!SPPLEBufferLength)
                {
                    /* Send any buffered data first.                         */
                    if(DeviceInfo->TransmitBuffer.BytesFree != DeviceInfo->TransmitBuffer.BufferSize)
                    {
                        /* Remove the queued data from the Transmit Buffer.   */
                        SPPLEBufferLength = RemoveDataFromBuffer(&(DeviceInfo->TransmitBuffer), MaxLength, SPPLEBuffer);
                    }
                    else
                    {
                        /* Check to see if we have data to send.              */
                        if((DataLength) && (Data))
                        {
                            /* Copy the data to send into the SPPLEBuffer.     */
                            SPPLEBufferLength = (DataLength > MaxLength)?MaxLength:DataLength;
                            memcpy(SPPLEBuffer, Data, SPPLEBufferLength);

                            DataLength -= SPPLEBufferLength;
                            Data       += SPPLEBufferLength;
                        }
                        else
                        {
                            /* No data queued or data left to send so exit the */
                            /* loop.                                           */
                            Done = TRUE;
                        }
                    }

                    /* Set the count of data that we can send.               */
                    DataCount         = SPPLEBufferLength;

                    /* Reset the Transmit Index to 0.                        */
                    TransmitIndex     = 0;
                }
                else
                {
                    /* We have data to send so cap it at the maximum that can*/
                    /* be transmitted.                                       */
                    DataCount = (SPPLEBufferLength > MaxLength)?MaxLength:SPPLEBufferLength;
                }

                /* Try to write data if not exiting the loop.               */
                if(!Done)
                {
                    /* Use the correct API based on device role for SPPLE.   */
                    if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_SERVER)
                    {
                        /* We are acting as SPPLE Server, so notify the Tx    */
                        /* Characteristic.                                    */
                        if(DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor == QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                            Result = qc_drv_ble_GATT_Handle_Value_Notification(qc_api_get_qc_drv_context(), BluetoothStackID, SPPLEServiceID, DeviceInfo->ConnectionID, SPPLE_TX_CHARACTERISTIC_ATTRIBUTE_OFFSET, (uint16_t)DataCount, &SPPLEBuffer[TransmitIndex]);
                        else
                        {
                            /* Not configured for notifications so exit the    */
                            /* loop.                                           */
                            Done = TRUE;
                        }
                    }
                    else
                    {
                        /* We are acting as SPPLE Client, so write to the Rx  */
                        /* Characteristic.                                    */
                        if(DeviceInfo->ClientInfo.Tx_Characteristic)
                            Result = qc_drv_ble_GATT_Write_Without_Response_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, DeviceInfo->ClientInfo.Rx_Characteristic, (uint16_t)DataCount, &SPPLEBuffer[TransmitIndex]);
                        else
                        {
                            /* We have not discovered the Tx Characteristic, so*/
                            /* exit the loop.                                  */
                            Done = TRUE;
                        }
                    }

                    /* Check to see if any data was written.                 */
                    if(!Done)
                    {
                        /* Check to see if the data was written successfully. */
                        if(Result >= 0)
                        {
                            /* Adjust the counters.                            */
                            TransmitIndex               += (unsigned int)Result;
                            SPPLEBufferLength           -= (unsigned int)Result;
                            DeviceInfo->TransmitCredits -= (unsigned int)Result;

                            /* Flag that data was sent.                        */
                            DataSent                     = TRUE;

                            /* If we have no more remaining Tx Credits AND we  */
                            /* have data built up to send, we need to queue    */
                            /* this in the Tx Buffer.                          */
                            if((!(DeviceInfo->TransmitCredits)) && (SPPLEBufferLength))
                            {
                                /* Add the remaining data to the transmit       */
                                /* buffer.                                      */
                                AddDataToBuffer(&(DeviceInfo->TransmitBuffer), SPPLEBufferLength, &SPPLEBuffer[TransmitIndex]);

                                SPPLEBufferLength = 0;
                            }
                        }
                        else
                        {
                            LOG_AT_EVT("EVT_BLE: SEND failed with error %d\n", Result);

                            DataSent  = FALSE;
                        }
                    }
                }
            }
            else
            {
                /* We have no transmit credits, so buffer the data.         */
                DataCount = AddDataToBuffer(&(DeviceInfo->TransmitBuffer), DataLength, Data);
                if(DataCount == DataLength)
                    DataSent = TRUE;
                else
                    DataSent = FALSE;

                /* Exit the loop.                                           */
                Done = TRUE;
            }
        }
    }

    return(DataSent);
}

/* The following function is responsible for handling a data         */
/* indication event.                                                 */
static boolean_t DataIndicationEvent(DeviceInfo_t *DeviceInfo, unsigned int DataLength, uint8_t *Data)
{
    uint64_t     CurrentTime;
    boolean_t    ret_val;
    boolean_t    Done;
    unsigned int ReadLength;
    unsigned int Length;

    ret_val = false;

    /* Verify that the input parameters are semi-valid.                  */
    if(DeviceInfo)
    {
        /* Throughput mode calcuations are active.                        */
        if(DeviceInfo->ThroughputModeActive)
        {
            /* Save the current time which will be the starting time or the*/
            /* latest time the device has received a notification.         */
            CurrentTime = (uint64_t)qurt_timer_convert_ticks_to_time(qurt_timer_get_ticks(), QURT_TIME_MSEC) / 1000;

            /* Determine if this is the first time a transfer has occurred */
            /* with the remote device since starting throughput            */
            /* calculations.                                               */
            if (DeviceInfo->XferInfo.TimingStarted == FALSE)
            {
                DeviceInfo->XferInfo.TimingStarted = TRUE;
                DeviceInfo->XferInfo.FirstTime = CurrentTime;
            }

            DeviceInfo->XferInfo.LastTime = CurrentTime;
            DeviceInfo->XferInfo.RxCount += DataLength;
        }

        /* If we are automatically reading the data, go ahead and credit  */
        /* what we just received, as well as reading everything in the    */
        /* buffer.                                                        */
        if((AutomaticReadActive) || (LoopbackActive))
        {
            /* Loop until we read all of the data queued.                  */
            Done = FALSE;
            while(!Done)
            {
                /* If in loopback mode cap what we remove at the max of what*/
                /* we can send or queue.                                    */
                if(LoopbackActive)
                    ReadLength = (SPPLE_DATA_BUFFER_LENGTH > (DeviceInfo->TransmitCredits + DeviceInfo->TransmitBuffer.BytesFree))?(DeviceInfo->TransmitCredits + DeviceInfo->TransmitBuffer.BytesFree):SPPLE_DATA_BUFFER_LENGTH;
                else
                    ReadLength = SPPLE_DATA_BUFFER_LENGTH;

                /* Read all queued data.                                    */
                Length = ReadData(DeviceInfo, ReadLength, SPPLEBuffer);
                if(Length > 0)
                {
                    /* If loopback is active, loopback the data.             */
                    if(LoopbackActive)
                        SendData(DeviceInfo, Length, SPPLEBuffer);

                    /* If we are displaying the data then do that here.      */
                    if(DisplayRawData)
                    {
                        SPPLEBuffer[Length] = '\0';
                        LOG_INFO("%s", (char *)SPPLEBuffer);
                        ret_val = true;
                    }
                }
                else
                    Done = TRUE;
            }

            /* Only send/display data just received if any is specified in */
            /* the call to this function.                                  */
            if((DataLength) && (Data))
            {
                /* If loopback is active, loopback the data just received.  */
                if((AutomaticReadActive) || (LoopbackActive))
                {
                    /* If we are displaying the data then do that here.      */
                    if(DisplayRawData)
                    {
                        memcpy(SPPLEBuffer, Data, DataLength);
                        SPPLEBuffer[DataLength] = '\0';
                        LOG_INFO("%s", (char *)SPPLEBuffer);
                        ret_val = true;
                    }

                    /* Check to see if Loopback is active, if it is we will  */
                    /* loopback the data we just received.                   */
                    if(LoopbackActive)
                    {
                        /* Only queue the data in the receive buffer that we  */
                        /* cannot send.                                       */
                        ReadLength = (DataLength > (DeviceInfo->TransmitCredits + DeviceInfo->TransmitBuffer.BytesFree))?(DeviceInfo->TransmitCredits + DeviceInfo->TransmitBuffer.BytesFree):DataLength;

                        /* Send the data.                                     */
                        if(SendData(DeviceInfo, ReadLength, Data))
                        {
                            /* Credit the data we just sent.                   */
                            SendCredits(DeviceInfo, ReadLength);

                            /* Increment what was just sent.                   */
                            DataLength -= ReadLength;
                            Data       += ReadLength;
                        }
                    }
                    else
                    {
                        /* Loopback is not active so just credit back the data*/
                        /* we just received.                                  */
                        SendCredits(DeviceInfo, DataLength);

                        DataLength = 0;
                    }

                    /* If we have data left that cannot be sent, queue this  */
                    /* in the receive buffer.                                */
                    if((DataLength) && (Data))
                    {
                        /* We are not in Loopback or Automatic Read Mode so   */
                        /* just buffer all the data.                          */
                        Length = AddDataToBuffer(&(DeviceInfo->ReceiveBuffer), DataLength, Data);
                        if(Length != DataLength)
                        {
                            LOG_INFO("Receive Buffer Overflow of %u bytes", DataLength - Length);
                            ret_val = true;
                        }
                    }
                }

                /* If we are displaying the data then do that here.         */
                if(DisplayRawData)
                {
                    memcpy(SPPLEBuffer, Data, DataLength);
                    SPPLEBuffer[DataLength] = '\0';
                    LOG_INFO("%s", (char *)SPPLEBuffer);
                    ret_val = true;
                }
            }
        }
        else
        {
            if((DataLength) && (Data))
            {
                /* Display a Data indication event.                         */
                LOG_INFO("Data Indication Event, Connection ID %u, Received %u bytes.\n", DeviceInfo->ConnectionID, DataLength);

                /* We are not in Loopback or Automatic Read Mode so just    */
                /* buffer all the data.                                     */
                Length = AddDataToBuffer(&(DeviceInfo->ReceiveBuffer), DataLength, Data);
                if(Length != DataLength)
                    LOG_INFO("Receive Buffer Overflow of %u bytes.\n", DataLength - Length);

                ret_val = true;
            }
        }
    }

    return(ret_val);
}

/* The following function is used to read data from the specified    */
/* device.  The final two parameters specify the BufferLength and the*/
/* Buffer to read the data into.  On success this function returns   */
/* the number of bytes read.  If an error occurs this will return a  */
/* negative error code.                                              */
static int ReadData(DeviceInfo_t *DeviceInfo, unsigned int BufferLength, uint8_t *Buffer)
{
    int          ret_val;
    boolean_t    Done;
    unsigned int Length;
    unsigned int TotalLength;

    /* Verify that the input parameters are semi-valid.                  */
    if((DeviceInfo) && (BufferLength) && (Buffer))
    {
        Done        = FALSE;
        TotalLength = 0;
        while(!Done)
        {
            Length = RemoveDataFromBuffer(&(DeviceInfo->ReceiveBuffer), BufferLength, Buffer);
            if(Length > 0)
            {
                BufferLength -= Length;
                Buffer       += Length;
                TotalLength   = Length;
            }
            else
                Done = TRUE;
        }

        /* Credit what we read.                                           */
        SendCredits(DeviceInfo, TotalLength);

        /* Return the total number of bytes read.                         */
        ret_val = (int)TotalLength;
    }
    else
        ret_val = QAPI_BLE_BTPS_ERROR_INVALID_PARAMETER;

    return(ret_val);
}

/* Tx Power Service (TPS) helper functions.                          */

/* The following function queries the Connection Tx Power Level.     */
/* This function returns TRUE if successful or FALSE otherwise.      */
static boolean_t QueryTxPowerLevel(boolean_t ConnectionTxPower, int8_t *TxPowerLevel)
{
    int       Result;
    boolean_t ret_val = FALSE;

    /* Verify the input parameters.                                      */
    if((BluetoothStackID) && (TxPowerLevel))
    {
        /* Call the power to get the power level.                         */
#ifdef V2
        if((Result = qc_drv_ble_BSC_GetTxPower(qc_api_get_qc_drv_context(), BluetoothStackID, ConnectionTxPower, TxPowerLevel)) == 0)
#else
            if((Result = qapi_BLE_BSC_Query_Default_Tx_Power(BluetoothStackID, ConnectionTxPower, TxPowerLevel)) == 0)
#endif
            {
                /* Print the Tx Power to the console.                          */
                LOG_INFO("%s Tx Power: %d.\n", (ConnectionTxPower?"Connection":"Advertising Channel"), (int)*TxPowerLevel);
            }
            else
                DisplayFunctionError("qapi_BLE_HCI_Send_Raw_Command()", Result);
    }

    /* Return the result to the caller.                                  */
    return(ret_val);
}


/* ***************************************************************** */
/*                         Event Callbacks                           */
/* ***************************************************************** */

/* BSC Timer Callback function prototype.                            */
void BSC_Timer_Callback(uint32_t BluetoothStackID, uint32_t TimerID, uint32_t CallbackParameter)
{
    /* Verify the input parameters.                                      */
    if(BluetoothStackID)
    {
        LOG_AT_EVT("EVT_BLE: Stopping scan after scanning for %u seconds.\n", CallbackParameter);

        /* Clear the Scan Timer ID.                                       */
        ScanTimerID = 0;

        /* Stop scanning.                                                 */
        StopScan(BluetoothStackID);
    }
}

/* The following function is for the GAP LE Event Receive Data       */
/* Callback.  This function will be called whenever a Callback has   */
/* been registered for the specified GAP LE Action that is associated*/
/* with the Bluetooth Stack.  This function passes to the caller the */
/* GAP LE Event Data of the specified Event and the GAP LE Event     */
/* Callback Parameter that was specified when this Callback was      */
/* installed.  The caller is free to use the contents of the GAP LE  */
/* Event Data ONLY in the context of this callback.  If the caller   */
/* requires the Data for a longer period of time, then the callback  */
/* function MUST copy the data into another Data Buffer.  This       */
/* function is guaranteed NOT to be invoked more than once           */
/* simultaneously for the specified installed callback (i.e.  this   */
/* function DOES NOT have be reentrant).  It Needs to be noted       */
/* however, that if the same Callback is installed more than once,   */
/* then the callbacks will be called serially.  Because of this, the */
/* processing in this function should be as efficient as possible.   */
/* It should also be noted that this function is called in the Thread*/
/* Context of a Thread that the User does NOT own.  Therefore,       */
/* processing in this function should be as efficient as possible    */
/* (this argument holds anyway because other GAP Events will not be  */
/* processed while this function call is outstanding).               */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GAP_LE_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GAP_LE_Event_Data_t *GAP_LE_Event_Data, uint32_t CallbackParameter)
{
    boolean_t                                              DisplayPrompt;
    int                                                    Result;
    uint16_t                                               EDIV;
    BoardStr_t                                             BoardStr;
    unsigned int                                           Index;
    DeviceInfo_t                                          *DeviceInfo;
    qapi_BLE_Random_Number_t                               RandomNumber;
    qapi_BLE_Long_Term_Key_t                               GeneratedLTK;
    qapi_BLE_GAP_LE_Security_Information_t                 GAP_LE_Security_Information;
    qapi_BLE_GAP_LE_Connection_Parameters_t                ConnectionParams;
    qapi_BLE_GAP_LE_Advertising_Report_Data_t             *DeviceEntryPtr;
    qapi_BLE_GAP_LE_Authentication_Event_Data_t           *Authentication_Event_Data;
    qapi_BLE_GAP_LE_Direct_Advertising_Report_Data_t      *DirectDeviceEntryPtr;
#ifdef V2
    qapi_BLE_GAP_LE_Extended_Advertising_Report_Data_t    *ExtDeviceEntryPtr;
#endif
    qapi_BLE_GAP_LE_Authentication_Response_Information_t  GAP_LE_Authentication_Response_Information;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GAP_LE_Event_Data))
    {
        DisplayPrompt = true;

        switch(GAP_LE_Event_Data->Event_Data_Type)
        {
#ifdef V2
            case QAPI_BLE_ET_LE_SCAN_TIMEOUT_E:
                LOG_AT_EVT("EVT_BLE: etLE_Scan_Timeout with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);
                break;
            case QAPI_BLE_ET_LE_PHY_UPDATE_COMPLETE_E:
                LOG_AT_EVT("EVT_BLE: etLE_PHY_Update_Complete with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

                LOG_AT_EVT("EVT_BLE:   Status:  %d.\n", (int)(GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->Status));
                LOG_AT_EVT("EVT_BLE:   Address: 0x%02X%02X%02X%02X%02X%02X.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR5,
                        GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR4,
                        GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR3,
                        GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR2,
                        GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR1,
                        GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->BD_ADDR.BD_ADDR0);
                LOG_AT_EVT("EVT_BLE:   Tx PHY:  %s.\n", PHYToString(GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->TX_PHY));
                LOG_AT_EVT("EVT_BLE:   Rx PHY:  %s.\n", PHYToString(GAP_LE_Event_Data->Event_Data.GAP_LE_Phy_Update_Complete_Event_Data->RX_PHY));

                break;
            case QAPI_BLE_ET_LE_ADVERTISING_SET_TERMINATED_E:
                LOG_AT_EVT("EVT_BLE: etLE_Advertising_Set_Terminated with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

                LOG_AT_EVT("EVT_BLE:   Status:                                  %d.\n", (int)(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Status));
                LOG_AT_EVT("EVT_BLE:   Advertising Handle:                      %u.\n", (unsigned int)(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Advertising_Handle));
                LOG_AT_EVT("EVT_BLE:   Number of Completed Advertising Events:  %u.\n", (unsigned int)(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Num_Completed_Ext_Advertising_Events));

                if(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Status == QAPI_BLE_HCI_ERROR_CODE_SUCCESS)
                {
                    /* Display the Address Type.                             */
                    switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Connection_Address_Type)
                    {
                        case QAPI_BLE_LAT_PUBLIC_E:
                            LOG_AT_EVT("EVT_BLE:   Connection Address Type:                 %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_E:
                            LOG_AT_EVT("EVT_BLE:   Connection Address Type:                 %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                            break;
                        case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:   Connection Address Type:                 %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:   Connection Address Type:                 %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                            break;
                        default:
                            LOG_AT_EVT("EVT_BLE:   Connection Address Type:                 Invalid.\n");
                            break;
                    }

                    BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Set_Terminated_Event_Data->Connection_Address, BoardStr);
                    LOG_AT_EVT("EVT_BLE:   Connection Address:                      %s.\n", BoardStr);
                }
                break;
            case QAPI_BLE_ET_LE_SCAN_REQUEST_RECEIVED_E:
                LOG_AT_EVT("EVT_BLE: etLE_Scan_Request_Received with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

                LOG_AT_EVT("EVT_BLE:   Advertising Handle:          %d.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Scan_Request_Received_Event_Data->Advertising_Handle);

                /* Display the Address Type.                                */
                switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Scan_Request_Received_Event_Data->Scanner_Address_Type)
                {
                    case QAPI_BLE_LAT_PUBLIC_E:
                        LOG_AT_EVT("EVT_BLE:   Scanner Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                        break;
                    case QAPI_BLE_LAT_RANDOM_E:
                        LOG_AT_EVT("EVT_BLE:   Scanner Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                        break;
                    case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                        LOG_AT_EVT("EVT_BLE:   Scanner Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                        break;
                    case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                        LOG_AT_EVT("EVT_BLE:   Scanner Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                        break;
                    default:
                        LOG_AT_EVT("EVT_BLE:   Scanner Address Type:        Invalid.\n");
                        break;
                }

                BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Scan_Request_Received_Event_Data->Scanner_Address, BoardStr);
                LOG_AT_EVT("EVT_BLE:   Scanner Address:             %s.\n", BoardStr);
                break;
            case QAPI_BLE_ET_LE_CHANNEL_SELECTION_ALGORITHM_UPDATE_E:
                LOG_AT_EVT("EVT_BLE: etLE_Channel_Selection_Algorithm_Update with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);

                /* Display the new CSA.                                     */
                switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Channel_Selection_Algorithm_Update_Event_Data->Channel_Selection_Algorithm)
                {
                    case QAPI_BLE_SA_ALGORITHM_NUM1_E:
                        LOG_AT_EVT("EVT_BLE:   Channel Selection Algorithm:        %s.\n", "CSA #1");
                        break;
                    case QAPI_BLE_SA_ALGORITHM_NUM2_E:
                        LOG_AT_EVT("EVT_BLE:   Channel Selection Algorithm:        %s.\n", "CSA #2");
                        break;
                    default:
                        LOG_AT_EVT("EVT_BLE:   Channel Selection Algorithm:        %s.\n", "CSA Unkown");
                        break;
                }

                /* Display the Address Type.                                */
                switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Channel_Selection_Algorithm_Update_Event_Data->Connection_Address_Type)
                {
                    case QAPI_BLE_LAT_PUBLIC_E:
                        LOG_AT_EVT("EVT_BLE:   Connection Address Type:            %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                        break;
                    case QAPI_BLE_LAT_RANDOM_E:
                        LOG_AT_EVT("EVT_BLE:   Connection Address Type:            %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                        break;
                    case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                        LOG_AT_EVT("EVT_BLE:   Connection Address Type:            %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                        break;
                    case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                        LOG_AT_EVT("EVT_BLE:   Connection Address Type:            %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                        break;
                    default:
                        LOG_AT_EVT("EVT_BLE:   Connection Address Type:            Invalid.\n");
                        break;
                }

                BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Channel_Selection_Algorithm_Update_Event_Data->Connection_Address, BoardStr);
                LOG_AT_EVT("EVT_BLE:   Connection Address:                 %s.\n", BoardStr);
                break;
            case QAPI_BLE_ET_LE_EXTENDED_ADVERTISING_REPORT_E:
                LOG_AT_EVT("EVT_BLE: etLE_Extended_Advertising_Report with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);
                LOG_AT_EVT("EVT_BLE: %d Responses.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Extended_Advertising_Report_Event_Data->Number_Device_Entries);

                for(Index = 0; Index < GAP_LE_Event_Data->Event_Data.GAP_LE_Extended_Advertising_Report_Event_Data->Number_Device_Entries; Index++)
                {
                    ExtDeviceEntryPtr = &(GAP_LE_Event_Data->Event_Data.GAP_LE_Extended_Advertising_Report_Event_Data->Extended_Advertising_Data[Index]);

                    /* Display the Address Type.                             */
                    switch(ExtDeviceEntryPtr->Address_Type)
                    {
                        case QAPI_BLE_LAT_PUBLIC_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type:     %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type:     %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                            break;
                        case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type:     %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type:     %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                            break;
                        case QAPI_BLE_LAT_ANONYMOUS_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type:     %s.\n", "Anonymous");
                            break;
                        default:
                            LOG_AT_EVT("EVT_BLE:   Address Type:     Invalid.\n");
                            break;
                    }

                    LOG_AT_EVT("EVT_BLE:   Address:          0x%02X%02X%02X%02X%02X%02X.\n", ExtDeviceEntryPtr->BD_ADDR.BD_ADDR5, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR4, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR3, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR2, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR1, ExtDeviceEntryPtr->BD_ADDR.BD_ADDR0);

                    if(DisplayAdvertisingEventData)
                    {
                        LOG_AT_EVT("EVT_BLE:   Event Type Flags: 0x%08X.\n", ExtDeviceEntryPtr->Event_Type_Flags);
                        LOG_AT_EVT("EVT_BLE:   Tx Power:         %d.\n", (int)ExtDeviceEntryPtr->Tx_Power);
                        LOG_AT_EVT("EVT_BLE:   RSSI:             %d.\n", (int)ExtDeviceEntryPtr->RSSI);
                        LOG_AT_EVT("EVT_BLE:   Advertising SID:  %d.\n", (int)ExtDeviceEntryPtr->Advertising_SID);
                        LOG_AT_EVT("EVT_BLE:   Primary PHY:      %s.\n", PHYToString(ExtDeviceEntryPtr->Primary_PHY));

                        switch(ExtDeviceEntryPtr->Data_Status)
                        {
                            case QAPI_BLE_DS_COMPLETE_E:
                                LOG_AT_EVT("EVT_BLE:   Data Status:      %s.\n", "Complete");
                                break;
                            case QAPI_BLE_DS_INCOMPLETE_DATA_PENDING_E:
                                LOG_AT_EVT("EVT_BLE:   Data Status:      %s.\n", "Incomplete - More data pending");
                                break;
                            default:
                            case QAPI_BLE_DS_INCOMPLETE_DATA_TRUNCATED_E:
                                LOG_AT_EVT("EVT_BLE:   Data Status:      %s.\n", "Incomplete - data truncated");
                                break;
                        }

                        if(ExtDeviceEntryPtr->Event_Type_Flags & GAP_LE_EXTENDED_ADVERTISING_EVENT_TYPE_SECONDARY_PHY_VALID)
                            LOG_AT_EVT("EVT_BLE:   Secondary PHY:    %s.\n", PHYToString(ExtDeviceEntryPtr->Secondary_PHY));

                        LOG_AT_EVT("EVT_BLE:   Data Length:      %u.\n", (unsigned int)ExtDeviceEntryPtr->Raw_Report_Length);
                    }
                }
                break;
#endif

            case QAPI_BLE_ET_LE_DATA_LENGTH_CHANGE_E:
                LOG_AT_EVT("EVT_BLE: etLE_Data_Length_Change with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);

                BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->BD_ADDR, BoardStr);
                LOG_AT_EVT("EVT_BLE: Connection Address:                 %s.\n", BoardStr);
                LOG_AT_EVT("EVT_BLE:   Max Tx Octets:                      %u.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->MaxTxOctets);
                LOG_AT_EVT("EVT_BLE:   Max Tx Time:                        %u.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->MaxTxTime);
                LOG_AT_EVT("EVT_BLE:   Max Rx Octets:                      %u.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->MaxRxOctets);
                LOG_AT_EVT("EVT_BLE:   Max Rx Time:                        %u.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Data_Length_Change_Event_Data->MaxRxTime);
                break;
            case QAPI_BLE_ET_LE_ADVERTISING_REPORT_E:
                LOG_AT_EVT("EVT_BLE: etLE_Advertising_Report with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);
                LOG_AT_EVT("EVT_BLE: %d Responses.\n",GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Report_Event_Data->Number_Device_Entries);

                for(Index = 0; Index < GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Report_Event_Data->Number_Device_Entries; Index++)
                {
                    DeviceEntryPtr = &(GAP_LE_Event_Data->Event_Data.GAP_LE_Advertising_Report_Event_Data->Advertising_Data[Index]);

                    /* Display the Address Type.                             */
                    switch(DeviceEntryPtr->Address_Type)
                    {
                        case QAPI_BLE_LAT_PUBLIC_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                            break;
                        case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                            break;
                        default:
                            LOG_AT_EVT("EVT_BLE:   Address Type:        Invalid.\n");
                            break;
                    }

                    /* Display the Device Address.                           */
                    LOG_AT_EVT("EVT_BLE:   Address: 0x%02X%02X%02X%02X%02X%02X.\n", DeviceEntryPtr->BD_ADDR.BD_ADDR5, DeviceEntryPtr->BD_ADDR.BD_ADDR4, DeviceEntryPtr->BD_ADDR.BD_ADDR3, DeviceEntryPtr->BD_ADDR.BD_ADDR2, DeviceEntryPtr->BD_ADDR.BD_ADDR1, DeviceEntryPtr->BD_ADDR.BD_ADDR0);

                    if(DisplayAdvertisingEventData)
                    {
                        /* Display the packet type for the device             */
                        switch(DeviceEntryPtr->Advertising_Report_Type)
                        {
                            case QAPI_BLE_RT_CONNECTABLE_UNDIRECTED_E:
                                LOG_AT_EVT("EVT_BLE:   Advertising Type: %s.\n", "QAPI_BLE_RT_CONNECTABLE_UNDIRECTED_E");
                                break;
                            case QAPI_BLE_RT_CONNECTABLE_DIRECTED_E:
                                LOG_AT_EVT("EVT_BLE:   Advertising Type: %s.\n", "QAPI_BLE_RT_CONNECTABLE_DIRECTED_E");
                                break;
                            case QAPI_BLE_RT_SCANNABLE_UNDIRECTED_E:
                                LOG_AT_EVT("EVT_BLE:   Advertising Type: %s.\n", "QAPI_BLE_RT_SCANNABLE_UNDIRECTED_E");
                                break;
                            case QAPI_BLE_RT_NON_CONNECTABLE_UNDIRECTED_E:
                                LOG_AT_EVT("EVT_BLE:   Advertising Type: %s.\n", "QAPI_BLE_RT_NON_CONNECTABLE_UNDIRECTED_E");
                                break;
                            case QAPI_BLE_RT_SCAN_RESPONSE_E:
                                LOG_AT_EVT("EVT_BLE:   Advertising Type: %s.\n", "QAPI_BLE_RT_SCAN_RESPONSE_E");
                                break;
                        }

                        LOG_AT_EVT("EVT_BLE:   RSSI: %d.\n", (int)(DeviceEntryPtr->RSSI));
                        LOG_AT_EVT("EVT_BLE:   Data Length: %d.\n", DeviceEntryPtr->Raw_Report_Length);
                    }
                }
                break;
            case QAPI_BLE_ET_LE_CONNECTION_COMPLETE_E:
                LOG_AT_EVT("EVT_BLE: etLE_Connection_Complete with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

                if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data)
                {
                    BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address, BoardStr);

                    LOG_AT_EVT("EVT_BLE: Status:              0x%02X.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Status);
                    LOG_AT_EVT("EVT_BLE: Role:                %s.\n", (GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Master)?"Master":"Slave");
                    switch(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type)
                    {
                        case QAPI_BLE_LAT_PUBLIC_E:
                            LOG_AT_EVT("EVT_BLE:    Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_E:
                            LOG_AT_EVT("EVT_BLE:    Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                            break;
                        case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:    Address Type:        %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:    Address Type:        %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                            break;
                        default:
                            LOG_AT_EVT("EVT_BLE:    Address Type:        Invalid.\n");
                            break;
                    }
                    LOG_AT_EVT("EVT_BLE:    BD_ADDR:             %s.\n", BoardStr);

                    if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Status == QAPI_BLE_HCI_ERROR_CODE_NO_ERROR)
                    {
                        LOG_AT_EVT("EVT_BLE:    Connection Interval: %u.\n", (unsigned int)GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Current_Connection_Parameters.Connection_Interval);
                        LOG_AT_EVT("EVT_BLE:    Slave Latency:       %u.\n", (unsigned int)GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Current_Connection_Parameters.Slave_Latency);

                        /* Store the GAP LE Connection information that needs */
                        /* to be stored for the remote device.                */
                        /* * NOTE * These are temporary globals that will hold*/
                        /*          information that needs to be stored for   */
                        /*          the remote device that just connected.    */
                        /* * NOTE * For consistency, this information will NOT*/
                        /*          be stored until the GATT Connection       */
                        /*          Complete event has been received.  This   */
                        /*          event ALWAYS follows the GAP LE Connection*/
                        /*          Complete event.                           */
                        LocalDeviceIsMaster =  GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Master;
                        RemoteAddressType   = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type;

                        /* Attempt to find the entry via the address and      */
                        /* address type.  This function will update the entry */
                        /* if it is found to already exist and resolution is  */
                        /* now being done in the controller.                  */
                        if((DeviceInfo = SearchDeviceInfoEntryTypeAddress(&DeviceInfoList, GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type, GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address)) != NULL)
                        {
                            uint8_t            Peer_Identity_Address_Type;
                            uint8_t            StatusResult;
                            qapi_BLE_BD_ADDR_t Peer_Identity_Address;
                            qapi_BLE_BD_ADDR_t Local_Resolvable_Address;

                            if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type == QAPI_BLE_LAT_PUBLIC_IDENTITY_E)
                                Peer_Identity_Address_Type = 0x00;
                            else if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address_Type == QAPI_BLE_LAT_RANDOM_IDENTITY_E)
                                Peer_Identity_Address_Type = 0x01;
                            else
                                Peer_Identity_Address_Type = 0x02;

                            if(Peer_Identity_Address_Type != 0x02)
                            {
                                Peer_Identity_Address = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address;

                                if(!qapi_BLE_HCI_LE_Read_Local_Resolvable_Address(BluetoothStackID, Peer_Identity_Address_Type, Peer_Identity_Address, &StatusResult, &Local_Resolvable_Address))
                                {
                                    LOG_AT_EVT("EVT_BLE:    qapi_BLE_HCI_LE_Read_Local_Resolvable_Address(): 0x%02X.\n", StatusResult);
                                    if(!StatusResult)
                                    {
                                        BD_ADDRToStr(Local_Resolvable_Address, BoardStr);
                                        LOG_AT_EVT("EVT_BLE:    Local RPA:           %s.\n", BoardStr);
                                    }
                                }
                            }

                            /* If we have previously connected and bonded with */
                            /* the remote device, then the remote device       */
                            /* information MUST exist and we can attempt to    */
                            /* re-establish security using the LTK if we are   */
                            /* the master.                                     */
                            /* * NOTE * If the LTK was NOT valid on            */
                            /*          disconnection, then the remote device  */
                            /*          information will be deleted.           */
                            if(LocalDeviceIsMaster)
                            {
                                /* Make sure the LTK is valid for this remote   */
                                /* device.                                      */
                                if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                                {
                                    /* Re-Establish Security with this LTK.      */
                                    LOG_AT_EVT("EVT_BLE: Attempting to Re-Establish Security.\n");

                                    /* Attempt to re-establish security to this  */
                                    /* device.                                   */
                                    GAP_LE_Security_Information.Local_Device_Is_Master                                      = TRUE;
                                    memcpy(&(GAP_LE_Security_Information.Security_Information.Master_Information.LTK), &(DeviceInfo->LTK), sizeof(DeviceInfo->LTK));
                                    GAP_LE_Security_Information.Security_Information.Master_Information.EDIV                = DeviceInfo->EDIV;
                                    memcpy(&(GAP_LE_Security_Information.Security_Information.Master_Information.Rand), &(DeviceInfo->Rand), sizeof(DeviceInfo->Rand));
                                    GAP_LE_Security_Information.Security_Information.Master_Information.Encryption_Key_Size = DeviceInfo->EncryptionKeySize;

                                    Result = qc_drv_ble_GAP_LE_Reestablish_Security(qc_api_get_qc_drv_context(), BluetoothStackID, GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Complete_Event_Data->Peer_Address, &GAP_LE_Security_Information, GAP_LE_Event_Callback, 0);
                                    if(Result)
                                        LOG_AT_EVT("EVT_BLE: GAP_LE_Reestablish_Security returned %d.\n", Result);
                                }
                                else
                                {
                                    /* This shouldn't occur, but we will inform  */
                                    /* the user if it does.                      */
                                    LOG_AT_EVT("EVT_BLE: Can't re-establish security: LTK is missing.\n");
                                }
                            }
                        }
                    }
                }
                break;
            case QAPI_BLE_ET_LE_DISCONNECTION_COMPLETE_E:
                LOG_AT_EVT("EVT_BLE: etLE_Disconnection_Complete with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);

                if(GAP_LE_Event_Data->Event_Data.GAP_LE_Disconnection_Complete_Event_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Status: 0x%02X.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Disconnection_Complete_Event_Data->Status);
                    LOG_AT_EVT("EVT_BLE: Reason: 0x%02X.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Disconnection_Complete_Event_Data->Reason);

                    BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Disconnection_Complete_Event_Data->Peer_Address, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    BD_ADDR: %s.\n", BoardStr);

                    /* Clear the Send Information.                           */
                    SendInfo.BytesToSend = 0;
                    SendInfo.BytesSent   = 0;
                }
                break;
            case QAPI_BLE_ET_LE_CONNECTION_PARAMETER_UPDATE_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: etLE_Connection_Parameter_Update_Request with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

                if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data)
                {
                    BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->BD_ADDR, BoardStr);
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:                     %s\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Connection Interval Minimum: %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Interval_Min);
                    LOG_AT_EVT("EVT_BLE:    Connection Interval Maximum: %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Interval_Max);
                    LOG_AT_EVT("EVT_BLE:    Slave Latency:               %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Slave_Latency);
                    LOG_AT_EVT("EVT_BLE:    Supervision Timeout:         %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Supervision_Timeout);

                    ConnectionParams.Connection_Interval_Min    = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Interval_Min;
                    ConnectionParams.Connection_Interval_Max    = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Interval_Max;
                    ConnectionParams.Slave_Latency              = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Slave_Latency;
                    ConnectionParams.Supervision_Timeout        = GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->Conn_Supervision_Timeout;
                    ConnectionParams.Minimum_Connection_Length  = 0;
                    ConnectionParams.Maximum_Connection_Length  = 10000;

                    qapi_BLE_GAP_LE_Connection_Parameter_Update_Response(BluetoothStackID, GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Update_Request_Event_Data->BD_ADDR, TRUE, &ConnectionParams);
                }
                break;
            case QAPI_BLE_ET_LE_CONNECTION_PARAMETER_UPDATED_E:
                LOG_AT_EVT("EVT_BLE: etLE_Connection_Parameter_Updated with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);

                if(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data)
                {
                    BD_ADDRToStr(GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->BD_ADDR, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    BD_ADDR:             %s\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Status:              %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->Status);
                    LOG_AT_EVT("EVT_BLE:    Connection Interval: %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->Current_Connection_Parameters.Connection_Interval);
                    LOG_AT_EVT("EVT_BLE:    Slave Latency:       %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->Current_Connection_Parameters.Slave_Latency);
                    LOG_AT_EVT("EVT_BLE:    Supervision Timeout: %d\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Connection_Parameter_Updated_Event_Data->Current_Connection_Parameters.Supervision_Timeout);
                }
                break;
            case QAPI_BLE_ET_LE_ENCRYPTION_CHANGE_E:
                LOG_AT_EVT("EVT_BLE: etLE_Encryption_Change with size %d.\n",(int)GAP_LE_Event_Data->Event_Data_Size);
                break;
            case QAPI_BLE_ET_LE_ENCRYPTION_REFRESH_COMPLETE_E:
                LOG_AT_EVT("EVT_BLE: etLE_Encryption_Refresh_Complete with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);
                break;
            case QAPI_BLE_ET_LE_AUTHENTICATION_E:
                LOG_AT_EVT("EVT_BLE: etLE_Authentication with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);

                /* Make sure the authentication event data is valid before  */
                /* continuing.                                              */
                if((Authentication_Event_Data = GAP_LE_Event_Data->Event_Data.GAP_LE_Authentication_Event_Data) != NULL)
                {
                    BD_ADDRToStr(Authentication_Event_Data->BD_ADDR, BoardStr);

                    switch(Authentication_Event_Data->GAP_LE_Authentication_Event_Type)
                    {
                        case QAPI_BLE_LAT_LONG_TERM_KEY_REQUEST_E:
                            LOG_AT_EVT("EVT_BLE:     latKeyRequest: \n");
                            LOG_AT_EVT("EVT_BLE:       BD_ADDR: %s.\n", BoardStr);

                            /* Initialize the authentication response data to  */
                            /* indicate no LTK present (if we find or          */
                            /* re-generate the LTK we will update this         */
                            /* structure accordingly).                         */
                            GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_LONG_TERM_KEY_E;
                            GAP_LE_Authentication_Response_Information.Authentication_Data_Length = 0;

                            /* Initialize some variables to determine if this  */
                            /* is a request for a Long Term Key generated via  */
                            /* Secure Connections (which we must store and can */
                            /* NOT re-generate).                               */
                            memset(&RandomNumber, 0, sizeof(RandomNumber));
                            EDIV = 0;

                            /* Check to see if this is a request for a SC      */
                            /* generated Long Term Key.                        */
                            if((Authentication_Event_Data->Authentication_Event_Data.Long_Term_Key_Request.EDIV == EDIV) && (QAPI_BLE_COMPARE_RANDOM_NUMBER(Authentication_Event_Data->Authentication_Event_Data.Long_Term_Key_Request.Rand, RandomNumber)))
                            {
                                /* Search for the entry for this slave to store */
                                /* the information into.                        */
                                if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                                {
                                    /* Check to see if the LTK is valid.         */
                                    if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                                    {
                                        /* Respond with the stored Long Term Key. */
                                        GAP_LE_Authentication_Response_Information.Authentication_Data_Length                                        = QAPI_BLE_GAP_LE_LONG_TERM_KEY_INFORMATION_DATA_SIZE;
                                        GAP_LE_Authentication_Response_Information.Authentication_Data.Long_Term_Key_Information.Encryption_Key_Size = DeviceInfo->EncryptionKeySize;

                                        memcpy(&(GAP_LE_Authentication_Response_Information.Authentication_Data.Long_Term_Key_Information.Long_Term_Key), &(DeviceInfo->LTK), QAPI_BLE_LONG_TERM_KEY_SIZE);
                                    }
                                }
                            }
                            else
                            {
                                /* The other side of a connection is requesting */
                                /* that we start encryption.  Thus we should    */
                                /* regenerate LTK for this connection and send  */
                                /* it to the chip.                              */
                                Result = qc_drv_ble_GAP_LE_Regenerate_Long_Term_Key(qc_api_get_qc_drv_context(), BluetoothStackID, (qapi_BLE_Encryption_Key_t *)(&DHK), (qapi_BLE_Encryption_Key_t *)(&ER), Authentication_Event_Data->Authentication_Event_Data.Long_Term_Key_Request.EDIV, &(Authentication_Event_Data->Authentication_Event_Data.Long_Term_Key_Request.Rand), &GeneratedLTK);
                                if(!Result)
                                {
                                    LOG_AT_EVT("EVT_BLE:       GAP_LE_Regenerate_Long_Term_Key Success.\n");

                                    /* Respond with the Re-Generated Long Term   */
                                    /* Key.                                      */
                                    GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type                                        = QAPI_BLE_LAR_LONG_TERM_KEY_E;
                                    GAP_LE_Authentication_Response_Information.Authentication_Data_Length                                        = QAPI_BLE_GAP_LE_LONG_TERM_KEY_INFORMATION_DATA_SIZE;
                                    GAP_LE_Authentication_Response_Information.Authentication_Data.Long_Term_Key_Information.Encryption_Key_Size = QAPI_BLE_GAP_LE_MAXIMUM_ENCRYPTION_KEY_SIZE;
                                    GAP_LE_Authentication_Response_Information.Authentication_Data.Long_Term_Key_Information.Long_Term_Key       = GeneratedLTK;
                                }
                                else
                                {
                                    LOG_AT_EVT("EVT_BLE:       GAP_LE_Regenerate_Long_Term_Key returned %d.\n",Result);
                                }
                            }

                            /* Send the Authentication Response.               */
                            Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                            if(Result)
                            {
                                LOG_AT_EVT("EVT_BLE:       GAP_LE_Authentication_Response returned %d.\n",Result);
                            }
                            break;
                        case QAPI_BLE_LAT_SECURITY_REQUEST_E:
                            /* Display the data for this event.                */
                            /* * NOTE * This is only sent from Slave to Master.*/
                            /*          Thus we must be the Master in this     */
                            /*          connection.                            */
                            LOG_AT_EVT("EVT_BLE:     latSecurityRequest:.\n");
                            LOG_AT_EVT("EVT_BLE:       BD_ADDR: %s.\n", BoardStr);
                            LOG_AT_EVT("EVT_BLE:       Bonding Type: %s.\n", ((Authentication_Event_Data->Authentication_Event_Data.Security_Request.Bonding_Type == QAPI_BLE_LBT_BONDING_E)?"Bonding":"No Bonding"));
                            LOG_AT_EVT("EVT_BLE:       MITM: %s.\n", ((Authentication_Event_Data->Authentication_Event_Data.Security_Request.MITM)?"YES":"NO"));

                            /* Make sure we are NOT pairing or re-establishing */
                            /* security with another remote device.            */
                            if(QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
                            {
                                /* Go ahead and store the address of the remote */
                                /* device we are currently pairing or           */
                                /* re-establishing security with.               */
                                SecurityRemoteBD_ADDR = Authentication_Event_Data->BD_ADDR;

                                /* Determine if we have previously paired with  */
                                /* the device.  If we have paired we will       */
                                /* attempt to re-establish security using a     */
                                /* previously exchanged LTK.                    */
                                if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                                {
                                    /* Determine if a Valid Long Term Key is     */
                                    /* stored for this device.                   */
                                    if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                                    {
                                        LOG_AT_EVT("EVT_BLE: Attempting to Re-Establish Security.\n");

                                        /* Attempt to re-establish security to    */
                                        /* this device.                           */
                                        GAP_LE_Security_Information.Local_Device_Is_Master                                      = TRUE;
                                        memcpy(&(GAP_LE_Security_Information.Security_Information.Master_Information.LTK), &(DeviceInfo->LTK), sizeof(DeviceInfo->LTK));
                                        GAP_LE_Security_Information.Security_Information.Master_Information.EDIV                = DeviceInfo->EDIV;
                                        memcpy(&(GAP_LE_Security_Information.Security_Information.Master_Information.Rand), &(DeviceInfo->Rand), sizeof(DeviceInfo->Rand));
                                        GAP_LE_Security_Information.Security_Information.Master_Information.Encryption_Key_Size = DeviceInfo->EncryptionKeySize;

                                        Result = qc_drv_ble_GAP_LE_Reestablish_Security(qc_api_get_qc_drv_context(), BluetoothStackID, SecurityRemoteBD_ADDR, &GAP_LE_Security_Information, GAP_LE_Event_Callback, 0);
                                        if(Result)
                                        {
                                            LOG_AT_EVT("EVT_BLE: GAP_LE_Reestablish_Security returned %d.\n", Result);
                                        }
                                    }
                                    else
                                    {
                                        /* We do not have a stored Link Key for   */
                                        /* this device so go ahead and pair to    */
                                        /* this device.                           */
                                        SendPairingRequest(SecurityRemoteBD_ADDR, TRUE);
                                    }
                                }
                                else
                                {
                                    /* There is no Key Info Entry for this device*/
                                    /* so we will just treat this as a slave     */
                                    /* request and initiate pairing.             */
                                    SendPairingRequest(SecurityRemoteBD_ADDR, TRUE);
                                }
                            }
                            else
                            {
                                /* Inform the user that we cannot accept the    */
                                /* request at this time.                        */
                                LOG_AT_EVT("EVT_BLE: \nSecurity is already in progress with another remote device.\n");

                                /* We are currently pairing/re-establishing     */
                                /* security with another remote device so we    */
                                /* should send the negative authentication      */
                                /* response.                                    */
                                GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_ERROR_E;
                                GAP_LE_Authentication_Response_Information.Authentication_Data_Length = 0;

                                /* Submit the Authentication Response.          */
                                if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                    DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                            }
                            break;
                        case QAPI_BLE_LAT_PAIRING_REQUEST_E:
                            LOG_AT_EVT("EVT_BLE: Pairing Request: %s.\n", BoardStr);
                            DisplayLegacyPairingInformation(&Authentication_Event_Data->Authentication_Event_Data.Pairing_Request);

                            /* Make sure we are NOT pairing or re-establishing */
                            /* security with another remote device.            */
                            if(QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
                            {
                                /* Go ahead and store the address of the remote */
                                /* device we are currently pairing or           */
                                /* re-establishing security with.               */
                                SecurityRemoteBD_ADDR = Authentication_Event_Data->BD_ADDR;

                                /* This is a pairing request.  Respond with a   */
                                /* Pairing Response.                            */
                                /* * NOTE * This is only sent from Master to    */
                                /*          Slave.  Thus we must be the Slave in*/
                                /*          this connection.                    */

                                /* Send the Pairing Response.                   */
                                SlavePairingRequestResponse(SecurityRemoteBD_ADDR);
                            }
                            else
                            {
                                /* Inform the user that we cannot accept the    */
                                /* request at this time.                        */
                                LOG_AT_EVT("EVT_BLE: \nSecurity is already in progress with another remote device.\n");

                                /* We are currently pairing/re-establishing     */
                                /* security with another remote device so we    */
                                /* should send the negative authentication      */
                                /* response.                                    */
                                GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_ERROR_E;
                                GAP_LE_Authentication_Response_Information.Authentication_Data_Length = 0;

                                /* Submit the Authentication Response.          */
                                if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                    DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                            }
                            break;
                        case QAPI_BLE_LAT_EXTENDED_PAIRING_REQUEST_E:
                            LOG_AT_EVT("EVT_BLE: Extended Pairing Request: %s.\n", BoardStr);
                            DisplayPairingInformation(&(Authentication_Event_Data->Authentication_Event_Data.Extended_Pairing_Request));

                            /* Make sure we are NOT pairing or re-establishing */
                            /* security with another remote device.            */
                            if(QAPI_BLE_COMPARE_NULL_BD_ADDR(SecurityRemoteBD_ADDR))
                            {
                                /* Go ahead and store the address of the remote */
                                /* device we are currently pairing or           */
                                /* re-establishing security with.               */
                                SecurityRemoteBD_ADDR = Authentication_Event_Data->BD_ADDR;

                                /* This is a pairing request.  Respond with a   */
                                /* Pairing Response.                            */
                                /* * NOTE * This is only sent from Master to    */
                                /*          Slave.  Thus we must be the Slave in*/
                                /*          this connection.                    */

                                /* Send the Pairing Response.                   */
                                SlavePairingRequestResponse(Authentication_Event_Data->BD_ADDR);
                            }
                            else
                            {
                                /* Inform the user that we cannot accept the    */
                                /* request at this time.                        */
                                LOG_AT_EVT("EVT_BLE: \nSecurity is already in progress with another remote device.\n");

                                /* We are currently pairing/re-establishing     */
                                /* security with another remote device so we    */
                                /* should send the negative authentication      */
                                /* response.                                    */
                                GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_ERROR_E;
                                GAP_LE_Authentication_Response_Information.Authentication_Data_Length = 0;

                                /* Submit the Authentication Response.          */
                                if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                    DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                            }
                            break;
                        case QAPI_BLE_LAT_CONFIRMATION_REQUEST_E:
                            LOG_AT_EVT("EVT_BLE: latConfirmationRequest.\n");

                            /* Check to see what type of confirmation request  */
                            /* this is.                                        */
                            switch(Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Request_Type)
                            {
                                case QAPI_BLE_CRT_NONE_E:
                                    /* Handle the just works request.            */
                                    GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_CONFIRMATION_E;

                                    /* By setting the Authentication_Data_Length */
                                    /* to any NON-ZERO value we are informing the*/
                                    /* GAP LE Layer that we are accepting Just   */
                                    /* Works Pairing.                            */
                                    GAP_LE_Authentication_Response_Information.Authentication_Data_Length = sizeof(uint32_t);

                                    /* Handle this differently based on the local*/
                                    /* IO Caps.                                  */
                                    switch(LE_Parameters.IOCapability)
                                    {
                                        case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
                                            LOG_AT_EVT("EVT_BLE: Invoking Just Works.\n");

                                            /* By setting the                      */
                                            /* Authentication_Data_Length to any   */
                                            /* NON-ZERO value we are informing the */
                                            /* GAP LE Layer that we are accepting  */
                                            /* Just Works Pairing.                 */

                                            Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                                            if(Result)
                                            {
                                                LOG_AT_EVT("EVT_BLE: qapi_BLE_GAP_LE_Authentication_Response returned %d.\n", Result);
                                            }
                                            break;
                                        case QAPI_BLE_LIC_DISPLAY_ONLY_E:
                                            LOG_AT_EVT("EVT_BLE: Confirmation of Pairing.\n");

                                            GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Display_Passkey;

                                            /* Submit the Authentication Response. */
                                            if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                                DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                            break;
                                        default:
                                            LOG_AT_EVT("EVT_BLE: Confirmation of Pairing.\n");

                                            /* Submit the Authentication Response. */
                                            if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                                DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                            break;
                                    }
                                    break;
                                case QAPI_BLE_CRT_PASSKEY_E:
                                    /* Inform the user to call the appropriate   */
                                    /* command.                                  */
                                    LOG_AT_EVT("EVT_BLE: Call LEPasskeyResponse [PASSCODE].\n");
                                    break;
                                case QAPI_BLE_CRT_DISPLAY_E:
                                    LOG_AT_EVT("EVT_BLE: Passkey: %06u.\n", (unsigned int)(Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Display_Passkey));
                                    break;
                                default:
                                    /* This application doesn't support OOB and  */
                                    /* Secure Connections request types will be  */
                                    /* handled by the ExtendedConfirmationRequest*/
                                    /* event.  So we will simply inform the user.*/
                                    LOG_AT_EVT("EVT_BLE: Authentication method not supported.\n");
                                    break;
                            }
                            break;
                        case QAPI_BLE_LAT_EXTENDED_CONFIRMATION_REQUEST_E:
                            LOG_AT_EVT("EVT_BLE: latExtendedConfirmationRequest.\n");

                            LOG_AT_EVT("EVT_BLE:    Secure Connections:     %s.\n", (Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Flags & QAPI_BLE_GAP_LE_EXTENDED_CONFIRMATION_REQUEST_FLAGS_SECURE_CONNECTIONS)?"YES":"NO");
                            LOG_AT_EVT("EVT_BLE:    Just Works Pairing:     %s.\n", (Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Flags & QAPI_BLE_GAP_LE_EXTENDED_CONFIRMATION_REQUEST_FLAGS_JUST_WORKS_PAIRING)?"YES":"NO");
                            LOG_AT_EVT("EVT_BLE:    Keypress Notifications: %s.\n", (Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Flags & QAPI_BLE_GAP_LE_EXTENDED_CONFIRMATION_REQUEST_FLAGS_KEYPRESS_NOTIFICATIONS_REQUESTED)?"YES":"NO");

                            /* Check to see what type of confirmation request  */
                            /* this is.                                        */
                            switch(Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Request_Type)
                            {
                                case QAPI_BLE_CRT_NONE_E:
                                    /* Handle the just works request.            */
                                    GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_CONFIRMATION_E;

                                    /* By setting the Authentication_Data_Length */
                                    /* to any NON-ZERO value we are informing the*/
                                    /* GAP LE Layer that we are accepting Just   */
                                    /* Works Pairing.                            */
                                    GAP_LE_Authentication_Response_Information.Authentication_Data_Length = sizeof(uint32_t);

                                    /* Handle this differently based on the local*/
                                    /* IO Caps.                                  */
                                    switch(LE_Parameters.IOCapability)
                                    {
                                        case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
                                            LOG_AT_EVT("EVT_BLE: Invoking Just Works.\n");

                                            /* Just Accept Just Works Pairing.     */
                                            Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                                            if(Result)
                                            {
                                                LOG_AT_EVT("EVT_BLE: qapi_BLE_GAP_LE_Authentication_Response returned %d.\n", Result);
                                            }
                                            break;
                                        case QAPI_BLE_LIC_DISPLAY_ONLY_E:
                                            LOG_AT_EVT("EVT_BLE: Confirmation of Pairing.\n");

                                            GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Display_Passkey;

                                            /* Submit the Authentication Response. */
                                            if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                                DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                            break;
                                        default:
                                            LOG_AT_EVT("EVT_BLE: Confirmation of Pairing.\n");

                                            /* Submit the Authentication Response. */
                                            if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                                DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                            break;
                                    }
                                    break;
                                case QAPI_BLE_CRT_PASSKEY_E:
                                    /* Inform the user to call the appropriate   */
                                    /* command.                                  */
                                    LOG_AT_EVT("EVT_BLE: Call LEPasskeyResponse [PASSKEY].\n");
                                    break;
                                case QAPI_BLE_CRT_DISPLAY_E:
                                    LOG_AT_EVT("EVT_BLE: Passkey: %06u.\n", Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Display_Passkey);

                                    GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type  = QAPI_BLE_LAR_PASSKEY_E;
                                    GAP_LE_Authentication_Response_Information.Authentication_Data_Length  = (uint8_t)(sizeof(uint32_t));
                                    GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Display_Passkey;

                                    /* Since this is in an extended confirmation */
                                    /* request we need to respond to the display */
                                    /* request.                                  */
                                    if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                        DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                    break;
                                case QAPI_BLE_CRT_DISPLAY_YES_NO_E:
                                    /* Handle the Display Yes/No request.        */
                                    GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_CONFIRMATION_E;

                                    /* By setting the Authentication_Data_Length */
                                    /* to any NON-ZERO value we are informing the*/
                                    /* GAP LE Layer that we are accepting Just   */
                                    /* Works Pairing.                            */
                                    GAP_LE_Authentication_Response_Information.Authentication_Data_Length = sizeof(uint32_t);

                                    /* Check to see if this is Just Works or     */
                                    /* Numeric Comparison.                       */
                                    if(Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Flags & QAPI_BLE_GAP_LE_EXTENDED_CONFIRMATION_REQUEST_FLAGS_JUST_WORKS_PAIRING)
                                    {
                                        /* Handle this differently based on the   */
                                        /* local IO Caps.                         */
                                        switch(LE_Parameters.IOCapability)
                                        {
                                            case QAPI_BLE_LIC_NO_INPUT_NO_OUTPUT_E:
                                                LOG_AT_EVT("EVT_BLE: Invoking Just Works.\n");

                                                /* Just Accept Just Works Pairing.  */
                                                Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                                                if(Result)
                                                {
                                                    LOG_AT_EVT("EVT_BLE: qapi_BLE_GAP_LE_Authentication_Response returned %d.\n", Result);
                                                }
                                                break;
                                            case QAPI_BLE_LIC_DISPLAY_ONLY_E:
                                                LOG_AT_EVT("EVT_BLE: Confirmation of Pairing.\n");

                                                GAP_LE_Authentication_Response_Information.Authentication_Data.Passkey = Authentication_Event_Data->Authentication_Event_Data.Confirmation_Request.Display_Passkey;

                                                /* Submit the Authentication        */
                                                /* Response.                        */
                                                if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                                    DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                                break;
                                            default:
                                                LOG_AT_EVT("EVT_BLE: Confirmation of Pairing.\n");

                                                /* Submit the Authentication        */
                                                /* Response.                        */
                                                if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                                    DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                                break;
                                        }
                                    }
                                    else
                                    {
                                        /* This is numeric comparison so go ahead */
                                        /* and display the numeric value to       */
                                        /* confirm.                               */
                                        LOG_AT_EVT("EVT_BLE: Confirmation Value: %ld\n", (unsigned long)Authentication_Event_Data->Authentication_Event_Data.Extended_Confirmation_Request.Display_Passkey);

                                        /* Submit the Authentication Response.    */
                                        if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                            DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                        break;
                                    }
                                    break;
                                case QAPI_BLE_CRT_OOB_SECURE_CONNECTIONS_E:
                                    LOG_AT_EVT("EVT_BLE: OOB Data Request.\n");

                                    /* Format the response.                      */
                                    GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type = QAPI_BLE_LAR_OUT_OF_BAND_DATA_E;
                                    GAP_LE_Authentication_Response_Information.Authentication_Data_Length = QAPI_BLE_GAP_LE_SECURE_CONNECTIONS_OOB_DATA_SIZE;

                                    /* Check to see if we have remote OOB data.  */
                                    if(RemoteOOBValid)
                                    {
                                        GAP_LE_Authentication_Response_Information.Authentication_Data.Secure_Connections_OOB_Data.Flags        = 0;
                                        GAP_LE_Authentication_Response_Information.Authentication_Data.Secure_Connections_OOB_Data.Confirmation = RemoteOOBConfirmation;
                                        GAP_LE_Authentication_Response_Information.Authentication_Data.Secure_Connections_OOB_Data.Randomizer   = RemoteOOBRandomizer;
                                    }
                                    else
                                        GAP_LE_Authentication_Response_Information.Authentication_Data.Secure_Connections_OOB_Data.Flags = QAPI_BLE_GAP_LE_SECURE_CONNECTIONS_OOB_DATA_FLAGS_OOB_NOT_RECEIVED;

                                    /* Submit the Authentication Response.       */
                                    if((Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information)) != 0)
                                        DisplayFunctionError("qapi_BLE_GAP_LE_Authentication_Response", Result);
                                    break;
                                default:
                                    /* This application doesn't support OOB so we*/
                                    /* will simply inform the user.              */
                                    LOG_AT_EVT("EVT_BLE: Authentication method not supported.\n");
                                    break;
                            }
                            break;
                        case QAPI_BLE_LAT_SECURITY_ESTABLISHMENT_COMPLETE_E:
                            LOG_AT_EVT("EVT_BLE: Security Re-Establishment Complete: %s.\n", BoardStr);
                            LOG_AT_EVT("EVT_BLE:                             Status: 0x%02X.\n", Authentication_Event_Data->Authentication_Event_Data.Security_Establishment_Complete.Status);

                            /* If this failed due to a LTK issue then we should*/
                            /* delete the LTK.                                 */
                            if(Authentication_Event_Data->Authentication_Event_Data.Security_Establishment_Complete.Status == QAPI_BLE_GAP_LE_SECURITY_ESTABLISHMENT_STATUS_CODE_LONG_TERM_KEY_ERROR)
                            {
                                if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                                {
                                    /* Clear the flag indicating the LTK is      */
                                    /* valid.                                    */
                                    DeviceInfo->Flags &= ~DEVICE_INFO_FLAGS_LTK_VALID;
                                }
                            }

                            /* Flag the we are no longer                       */
                            /* pairing/re-establishing security with a remote  */
                            /* device.                                         */
                            QAPI_BLE_ASSIGN_BD_ADDR(SecurityRemoteBD_ADDR, 0, 0, 0, 0, 0, 0);
                            break;
                        case QAPI_BLE_LAT_PAIRING_STATUS_E:
                            LOG_AT_EVT("EVT_BLE: Pairing Status: %s.\n", BoardStr);
                            LOG_AT_EVT("EVT_BLE:         Status: 0x%02X.\n", Authentication_Event_Data->Authentication_Event_Data.Pairing_Status.Status);

                            if(Authentication_Event_Data->Authentication_Event_Data.Pairing_Status.Status == QAPI_BLE_GAP_LE_PAIRING_STATUS_NO_ERROR)
                            {
                                LOG_AT_EVT("EVT_BLE:         Key Size: %d.\n", Authentication_Event_Data->Authentication_Event_Data.Pairing_Status.Negotiated_Encryption_Key_Size);
                            }
                            else
                            {
                                /* Disconnect the Link.                         */
                                /* * NOTE * Since we failed to pair, the remote */
                                /*          device information will be deleted  */
                                /*          when the GATT Disconnection event is*/
                                /*          received.                           */
                                qc_drv_ble_GAP_LE_Disconnect(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR);
                            }

                            /* Flag the we are no longer                       */
                            /* pairing/re-establishing security with a remote  */
                            /* device.                                         */
                            QAPI_BLE_ASSIGN_BD_ADDR(SecurityRemoteBD_ADDR, 0, 0, 0, 0, 0, 0);
                            break;
                        case QAPI_BLE_LAT_ENCRYPTION_INFORMATION_REQUEST_E:
                            LOG_AT_EVT("EVT_BLE: Encryption Information Request %s.\n", BoardStr);

                            /* Generate new LTK, EDIV and Rand and respond with*/
                            /* them.                                           */
                            EncryptionInformationRequestResponse(Authentication_Event_Data->BD_ADDR, Authentication_Event_Data->Authentication_Event_Data.Encryption_Request_Information.Encryption_Key_Size, &GAP_LE_Authentication_Response_Information);
                            break;
                        case QAPI_BLE_LAT_IDENTITY_INFORMATION_REQUEST_E:
                            LOG_AT_EVT("EVT_BLE: Identity Information Request %s.\n", BoardStr);

                            /* Store our identity information to send to the   */
                            /* remote device since it has been requested.      */
                            /* * NOTE * This demo will ALWAYS use the local    */
                            /*          public address as the identity address */
                            /*          since it is known to the user.         */
                            GAP_LE_Authentication_Response_Information.GAP_LE_Authentication_Type                            = QAPI_BLE_LAR_IDENTITY_INFORMATION_E;
                            GAP_LE_Authentication_Response_Information.Authentication_Data_Length                            = (uint8_t)QAPI_BLE_GAP_LE_IDENTITY_INFORMATION_DATA_SIZE;
                            GAP_LE_Authentication_Response_Information.Authentication_Data.Identity_Information.Address      = LocalBD_ADDR;
                            GAP_LE_Authentication_Response_Information.Authentication_Data.Identity_Information.Address_Type = QAPI_BLE_LAT_PUBLIC_IDENTITY_E;
                            GAP_LE_Authentication_Response_Information.Authentication_Data.Identity_Information.IRK          = IRK;

                            /* Send the authentication response.               */
                            Result = qc_drv_ble_GAP_LE_Authentication_Response(qc_api_get_qc_drv_context(), BluetoothStackID, Authentication_Event_Data->BD_ADDR, &GAP_LE_Authentication_Response_Information);
                            if(!Result)
                            {
                                LOG_AT_EVT("EVT_BLE:    qapi_BLE_GAP_LE_Authentication_Response (larEncryptionInformation) success.\n");
                            }
                            else
                            {
                                LOG_AT_EVT("EVT_BLE: SM_Generate_Long_Term_Key returned %d.\n", Result);
                            }
                            break;
                        case QAPI_BLE_LAT_ENCRYPTION_INFORMATION_E:
                            /* Display the information from the event.         */
                            LOG_AT_EVT("EVT_BLE:  Encryption Information from RemoteDevice: %s.\n", BoardStr);
                            LOG_AT_EVT("EVT_BLE:                              Key Size: %d.\n", Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.Encryption_Key_Size);

                            /* Search for the entry for this slave to store the*/
                            /* information into.                               */
                            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                            {
                                memcpy(&(DeviceInfo->LTK), &(Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.LTK), sizeof(DeviceInfo->LTK));
                                DeviceInfo->EDIV              = Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.EDIV;
                                memcpy(&(DeviceInfo->Rand), &(Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.Rand), sizeof(DeviceInfo->Rand));
                                DeviceInfo->EncryptionKeySize = Authentication_Event_Data->Authentication_Event_Data.Encryption_Information.Encryption_Key_Size;
                                DeviceInfo->Flags            |= DEVICE_INFO_FLAGS_LTK_VALID;
                            }
                            else
                            {
                                LOG_AT_EVT("EVT_BLE: No Key Info Entry for this device.\n");
                            }
                            break;
                        case QAPI_BLE_LAT_IDENTITY_INFORMATION_E:
                            /* Display the information from the event.         */
                            LOG_AT_EVT("EVT_BLE:  Identity Information from RemoteDevice: %s.\n", BoardStr);

                            /* Search for the entry for this slave to store the*/
                            /* information into.                               */
                            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, Authentication_Event_Data->BD_ADDR)) != NULL)
                            {
                                /* Store the identity information for the remote*/
                                /* device.                                      */
                                memcpy(&(DeviceInfo->IRK), &(Authentication_Event_Data->Authentication_Event_Data.Identity_Information.IRK), sizeof(DeviceInfo->IRK));
                                DeviceInfo->IdentityAddressBD_ADDR = Authentication_Event_Data->Authentication_Event_Data.Identity_Information.Address;
                                DeviceInfo->IdentityAddressType    = Authentication_Event_Data->Authentication_Event_Data.Identity_Information.Address_Type;
                                DeviceInfo->Flags                 |= DEVICE_INFO_FLAGS_IRK_VALID;

                                /* Setup the resolving list entry to add to the */
                                /* resolving list.                              */
                                DeviceInfo->ResolvingListEntry.Peer_Identity_Address      = DeviceInfo->IdentityAddressBD_ADDR;
                                DeviceInfo->ResolvingListEntry.Peer_Identity_Address_Type = DeviceInfo->IdentityAddressType;
                                DeviceInfo->ResolvingListEntry.Peer_IRK                   = DeviceInfo->IRK;
                                DeviceInfo->ResolvingListEntry.Local_IRK                  = IRK;
                            }
                            else
                            {
                                LOG_AT_EVT("EVT_BLE: No Key Info Entry for this device.\n");
                            }
                            break;
                        default:
                            LOG_AT_EVT("EVT_BLE: Unhandled event: %u\n", Authentication_Event_Data->GAP_LE_Authentication_Event_Type);
                            break;
                    }
                }
                break;
            case QAPI_BLE_ET_LE_DIRECT_ADVERTISING_REPORT_E:
                LOG_AT_EVT("EVT_BLE: etLE_Direct_Advertising_Report with size %d.\n", (int)GAP_LE_Event_Data->Event_Data_Size);
                LOG_AT_EVT("EVT_BLE: %d Responses.\n", GAP_LE_Event_Data->Event_Data.GAP_LE_Direct_Advertising_Report_Event_Data->Number_Device_Entries);

                for(Index = 0; Index < GAP_LE_Event_Data->Event_Data.GAP_LE_Direct_Advertising_Report_Event_Data->Number_Device_Entries; Index++)
                {
                    DirectDeviceEntryPtr = &(GAP_LE_Event_Data->Event_Data.GAP_LE_Direct_Advertising_Report_Event_Data->Direct_Advertising_Data[Index]);

                    /* Display the Address Type.                             */
                    switch(DirectDeviceEntryPtr->Address_Type)
                    {
                        case QAPI_BLE_LAT_PUBLIC_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type: %s.\n", "QAPI_BLE_LAT_PUBLIC_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type: %s.\n", "QAPI_BLE_LAT_RANDOM_E");
                            break;
                        case QAPI_BLE_LAT_PUBLIC_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type: %s.\n", "QAPI_BLE_LAT_PUBLIC_IDENTITY_E");
                            break;
                        case QAPI_BLE_LAT_RANDOM_IDENTITY_E:
                            LOG_AT_EVT("EVT_BLE:   Address Type: %s.\n", "QAPI_BLE_LAT_RANDOM_IDENTITY_E");
                            break;
                        default:
                            LOG_AT_EVT("EVT_BLE:   Address Type: Invalid.\n");
                            break;
                    }

                    /* Display the Device Address.                           */
                    LOG_AT_EVT("EVT_BLE:   Address:      0x%02X%02X%02X%02X%02X%02X.\n", DirectDeviceEntryPtr->BD_ADDR.BD_ADDR5, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR4, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR3, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR2, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR1, DirectDeviceEntryPtr->BD_ADDR.BD_ADDR0);
                    LOG_AT_EVT("EVT_BLE:   RSSI:         %d.\n", (int)(DirectDeviceEntryPtr->RSSI));
                }
                break;
            default:
                DisplayPrompt = false;
                break;
        }

        if(DisplayPrompt)
            QCLI_Display_Prompt();
    }
}

/* Generic Attribute Profile (GATT) Event Callback function          */
/* prototypes.                                                       */

/* The following function is for an GATT Connection Event Callback.  */
/* This function is called for GATT Connection Events that occur on  */
/* the specified Bluetooth Stack.  This function passes to the caller*/
/* the GATT Connection Event Data that occurred and the GATT         */
/* Connection Event Callback Parameter that was specified when this  */
/* Callback was installed.  The caller is free to use the contents of*/
/* the GATT Client Event Data ONLY in the context of this callback.  */
/* If the caller requires the Data for a longer period of time, then */
/* the callback function MUST copy the data into another Data Buffer.*/
/* This function is guaranteed NOT to be invoked more than once      */
/* simultaneously for the specified installed callback (i.e.  this   */
/* function DOES NOT have be reentrant).  It Needs to be noted       */
/* however, that if the same Callback is installed more than once,   */
/* then the callbacks will be called serially.  Because of this, the */
/* processing in this function should be as efficient as possible.   */
/* It should also be noted that this function is called in the Thread*/
/* Context of a Thread that the User does NOT own.  Therefore,       */
/* processing in this function should be as efficient as possible    */
/* (this argument holds anyway because another GATT Event            */
/* (Server/Client or Connection) will not be processed while this    */
/* function call is outstanding).                                    */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_Connection_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GATT_Connection_Event_Data_t *GATT_Connection_Event_Data, uint32_t CallbackParameter)
{
    boolean_t                    DisplayPrompt;
    int                          Result;
    uint16_t                     Credits;
    uint16_t                     MTU;
    BoardStr_t                   BoardStr;
    DeviceInfo_t                *DeviceInfo = NULL;
    uint32_t                     ConnectionID;
    unsigned int                 Index;
    boolean_t                    FoundMatch = FALSE;
    AIOP_Client_Instance_Info_t *ClientInstancePtr;
    unsigned int                 Index1;
    unsigned int                 Index2;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GATT_Connection_Event_Data))
    {
        DisplayPrompt = true;

        /* Determine the Connection Event that occurred.                  */
        switch(GATT_Connection_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_GATT_CONNECTION_DEVICE_CONNECTION_E:
                if(GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data)
                {
                    /* Save the Connection ID for later use.                 */
                    ConnectionID = GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->ConnectionID;

                    LOG_AT_EVT("EVT_BLE: etGATT_Connection_Device_Connection with size %u: \n", GATT_Connection_Event_Data->Event_Data_Size);
                    BD_ADDRToStr(GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:   %u.\n", GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type: %s.\n", ((GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
                    LOG_AT_EVT("EVT_BLE:    Remote Device:   %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Connection MTU:  %u.\n", GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->MTU);

                    /* Let's try to find the remote device information.  This*/
                    /* will be the case if we previously connected and bonded*/
                    /* with the remote device.                               */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice)) == NULL)
                    {
                        /* This MUST be a new remote device so we will create */
                        /* a remote device information entry.                 */
                        if((DeviceInfo = CreateNewDeviceInfoEntry(&DeviceInfoList, GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice)) == NULL)
                            LOG_AT_EVT("EVT_BLE: Failed to create remote device information.\n");
                    }

                    /* Make sure we found the remote device information entry*/
                    /* or created it.                                        */
                    if(DeviceInfo)
                    {
                        /* Increment the number of connected remote devices.  */
                        ConnectionCount++;

                        /* The connected remote device will always become the */
                        /* selected remote device.                            */
                        SelectedRemoteBD_ADDR = GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice;

                        /* Inform the user of the selected remote device.     */
                        LOG_AT_EVT("EVT_BLE: \nSelected Remote Device:\n");
                        LOG_AT_EVT("EVT_BLE:    Address:       %s\n", BoardStr);
                        LOG_AT_EVT("EVT_BLE:    ID:            %u\n", ConnectionID);

                        /* Store the information for the remote device.       */
                        /* * NOTE * The LocalDeviceIsMaster and               */
                        /*          RemoteAddressType are temporary globals   */
                        /*          that hold information from the GAP LE     */
                        /*          Connection Complete event that MUST be    */
                        /*          stored in the remote device infromation.  */
                        /* * NOTE * The ConnectionID is a unique value for    */
                        /*          every GATT Connection and will be used to */
                        /*          update the selected remote device.        */
                        DeviceInfo->RemoteDeviceIsMaster = (LocalDeviceIsMaster) ? FALSE : TRUE;
                        DeviceInfo->RemoteAddressType    = RemoteAddressType;
                        DeviceInfo->ConnectionID         = ConnectionID;

                        /* Set the HIDS Protocol Mode to Report by default.   */
                        HIDS_Protocol_Mode = QAPI_BLE_PM_REPORT_E;

                        /* Initialize the Transmit and Receive Buffers.       */
                        InitializeBuffer(&(DeviceInfo->ReceiveBuffer));
                        InitializeBuffer(&(DeviceInfo->TransmitBuffer));

                        /* Initialize the Transmit Credits count.             */
                        DeviceInfo->TransmitCredits = 0;

                        /* Attempt to update the MTU to the maximum supported.*/
                        if(!qc_drv_ble_GATT_Query_Maximum_Supported_MTU(qc_api_get_qc_drv_context(), BluetoothStackID, &MTU))
                            qapi_BLE_GATT_Exchange_MTU_Request(BluetoothStackID, DeviceInfo->ConnectionID, MTU, GATT_ClientEventCallback_GAPS, 0);

                        /* Check to see if we are bonded and the Tx Credit    */
                        /* notifications have been enabled.                   */
                        if((DeviceInfo->Flags & (DEVICE_INFO_FLAGS_LTK_VALID | DEVICE_INFO_FLAGS_SPPLE_SERVER)) == (DEVICE_INFO_FLAGS_LTK_VALID | DEVICE_INFO_FLAGS_SPPLE_SERVER))
                        {
                            if(DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor & QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                            {
                                /* Send the Initial Credits if the Rx Credit CCD*/
                                /* is already configured (for a bonded device   */
                                /* this could be the case).                     */
                                SendCredits(DeviceInfo, DeviceInfo->ReceiveBuffer.BytesFree);
                            }
                        }
                    }
                    else
                    {
                        /* Simply disconnect the remote device since an error */
                        /* occured.                                           */
                        if((Result = qc_drv_ble_GAP_LE_Disconnect(qc_api_get_qc_drv_context(), BluetoothStackID, GATT_Connection_Event_Data->Event_Data.GATT_Device_Connection_Data->RemoteDevice)) != 0)
                            LOG_AT_EVT("EVT_BLE: qapi_BLE_GAP_LE_Disconnect returned %d.\n", Result);
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Connection Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CONNECTION_DEVICE_DISCONNECTION_E:
                if(GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data)
                {
                    LOG_AT_EVT("EVT_BLE: etGATT_Connection_Device_Disconnection with size %u: \n", GATT_Connection_Event_Data->Event_Data_Size);
                    BD_ADDRToStr(GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", ((GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
                    LOG_AT_EVT("EVT_BLE:    Remote Device:   %s.\n", BoardStr);

                    /* Get the remote device information.                    */
                    /* * NOTE * If the stack is shutting down, then the      */
                    /*          ConnectionCount will be reset to zero.       */
                    /*          CloseStack() will send a disconnection       */
                    /*          request to each connected remote device.  It */
                    /*          will also free the remote device information */
                    /*          entries, so we do not need to handle it here.*/
                    if((ConnectionCount) && (DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Connection_Event_Data->Event_Data.GATT_Device_Disconnection_Data->RemoteDevice)) != NULL)
                    {
                        /* Decrement the number of connected remote devices.  */
                        ConnectionCount--;

                        /* Try to print out the throughput in case it was not */
                        /* printed before the disconnection.                  */
                        DisplayThroughput(DeviceInfo);

                        /* If we have paired with the remote device, then the */
                        /* LTK will be valid and the device information MUST  */
                        /* persist between connections.                       */
                        if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_LTK_VALID)
                        {
                            /* Flag that no service discovery operation is     */
                            /* outstanding for this device.                    */
                            DeviceInfo->Flags &= ~DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING;

                            /* Reset the GATT Connection ID to indicate that   */
                            /* the remote device is no longer connected.       */
                            DeviceInfo->ConnectionID = 0;
                        }
                        else
                        {
                            /* Remove the remote device information entry from */
                            /* the list since it is no longer needed.          */
                            if((DeviceInfo = DeleteDeviceInfoEntry(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
                            {
                                /* Inform the user the remote device information*/
                                /* is being deleted.                            */
                                LOG_AT_EVT("EVT_BLE: \nThe remote device information has been deleted.\n", BoardStr);

                                /* The entry has been removed from the list so  */
                                /* we just need to free the memory.             */
                                FreeDeviceInfoEntryMemory(DeviceInfo);
                                DeviceInfo = NULL;
                            }
                        }
                    }

                    /* If a remote device is still connected, then the first */
                    /* connected remote device will become the selected      */
                    /* remote device.                                        */
                    if(ConnectionCount)
                    {
                        /* Loop through the device information.               */
                        DeviceInfo = DeviceInfoList;
                        while(DeviceInfo)
                        {
                            /* Simply check if the GATT Connection ID is       */
                            /* non-zero.  If this is the case, then we are     */
                            /* connected to the remote device.                 */
                            if(DeviceInfo->ConnectionID)
                            {
                                /* Update the selected remote device.           */
                                SelectedRemoteBD_ADDR = DeviceInfo->RemoteAddress;

                                /* Inform the user of the selected remote       */
                                /* device.                                      */
                                LOG_AT_EVT("EVT_BLE: \nSelected Remote Device:\n");
                                BD_ADDRToStr(DeviceInfo->RemoteAddress, BoardStr);
                                LOG_AT_EVT("EVT_BLE:    Address:       %s\n", BoardStr);
                                LOG_AT_EVT("EVT_BLE:    ID:            %u\n", DeviceInfo->ConnectionID);

                                /* We are done.                                 */
                                break;
                            }

                            /* Get the next remote device's information.       */
                            DeviceInfo = DeviceInfo->NextDeviceInfoInfoPtr;
                        }
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Disconnection Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CONNECTION_SERVER_NOTIFICATION_E:
                if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data)
                {
                    DisplayPrompt = false;

                    /* Find the Device Info for the device that has sent us  */
                    /* the notification.                                     */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->RemoteDevice)) != NULL)
                    {
                        /* Handle the AIOS notifications.                     */

                        /* We will first loop through the AIOS Digital        */
                        /* Characteristic instances for a matching attribute  */
                        /* handle.                                            */
                        for(Index = 0; (!FoundMatch) && (Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES); Index++)
                        {
                            /* Store a pointer to the AIOS Client's instance   */
                            /* information.                                    */
                            ClientInstancePtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_DIGITAL_E].Instances[Index]);

                            /* If we find a match.                             */
                            if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == ClientInstancePtr->Digital_Characteristic_Handle)
                            {
                                /* Flag that we found a match.                  */
                                FoundMatch = TRUE;

                                /* Decode and display the digital               */
                                /* characteristic.                              */
                                DecodeDisplayDigitalCharacteristic(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue, Index);
                                break;
                            }
                        }

                        /* Loop through the AIOS Analog Characteristic        */
                        /* instances for a matching attribute handle.         */
                        for(Index = 0; (!FoundMatch) && (Index < (unsigned int)AIOP_NUMBER_OF_SUPPORTED_INSTANCES); Index++)
                        {
                            /* Store a pointer to the AIOS Client's instance   */
                            /* information.                                    */
                            ClientInstancePtr = &(DeviceInfo->AIOPClientInfo.Characteristics[QAPI_BLE_ACT_ANALOG_E].Instances[Index]);

                            /* If we find a match.                             */
                            if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == ClientInstancePtr->Analog_Charactersitic_Handle)
                            {
                                /* Flag that we found a match.                  */
                                FoundMatch = TRUE;

                                /* Decode and display the analog characteristic.*/
                                DecodeDisplayAnalogCharacteristic(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue, Index);
                                break;
                            }
                        }

                        /* If a match has been found.                         */
                        if(FoundMatch == TRUE)
                        {
                            /* We found a match so we are done.                */
                            break;
                        }

                        /* Handle the BAS notifications.                      */

                        /* If multiple BAS instances are supported, then we   */
                        /* MUST check each instances attribute handle for a   */
                        /* match.                                             */
                        for(Index = 0; (!FoundMatch) && (Index < (unsigned int)MAX_SUPPORTED_BATTERY_INSTANCES); Index++)
                        {
                            /* Determine if this notification is for the BAS   */
                            /* Battery Level.                                  */
                            if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->BASClientInfo[Index].Battery_Level)
                            {
                                /* Make sure the ValueLength is valid.          */
                                if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength >= (uint16_t)QAPI_BLE_BAS_BATTERY_LEVEL_VALUE_LENGTH)
                                {
                                    /* Display the battery level.                */
                                    /* * NOTE * The battery level is already     */
                                    /*          decoded.                         */
                                    LOG_AT_EVT("EVT_BLE: Battery Level:  %u%%.\n", *(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue));
                                }
                                else
                                    LOG_AT_EVT("EVT_BLE: Invalid length received for the battery level notification.\n");

                                /* Flag that we found a match.                  */
                                FoundMatch = TRUE;
                            }
                        }

                        /* If a match has been found.                         */
                        if(FoundMatch == TRUE)
                        {
                            /* We found a match so we are done.                */
                            break;
                        }

                        /* Handle the HIDS notifications.                     */

                        /* Loop through the HIDS instances to see if this was */
                        /* a HID report Notification.                         */
                        for(Index1 = 0; (!FoundMatch) && (Index1 < MAX_SUPPORTED_HID_INSTANCES); Index1++)
                        {
                            /* Loop through the reports and see if this was a  */
                            /* HID Report Notification.                        */
                            for(Index2 = 0; Index2 < HIDS_MAXIMUM_NUMBER_REPORTS; Index2++)
                            {
                                /* Check the HID report attribute handle.       */
                                if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->HIDSClientInfo[Index1].Reports[Index2].Handle)
                                {
                                    LOG_AT_EVT("EVT_BLE: \nReceived HIDS report notification.\n");

                                    /* Flag that we found a match.               */
                                    FoundMatch = TRUE;

                                    /* We cannot match another attribute handle. */
                                    break;
                                }
                            }
                        }

                        /* If a match has been found.                         */
                        if(FoundMatch == TRUE)
                        {
                            //xxxDisplayreport

                            /* We found a match so we are done.                */
                            break;
                        }

                        /* Handle the HRS notifications.                      */

                        /* If this notification is for the HRS Measurement    */
                        /* Characteristic.                                    */
                        if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->HRSClientInfo.Heart_Rate_Measurement)
                        {
                            /* Simply call the internal function to decode and */
                            /* display the HRS Measurement.                    */
                            DecodeDisplayHeartRate(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue, TRUE);

                            /* We cannot match another attribute handle.       */
                            break;
                        }

                        /* Handle the SCPS notifications.                     */

                        /* If this notification is for the SCPS Scan Refresh  */
                        /* Characteristic.                                    */
                        if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->SCPSClientInfo.Scan_Refresh)
                        {
                            /* Verify that the length of the SCPS Scan Refresh */
                            /* Notification is correct.                        */
                            if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength >= sizeof(uint8_t))
                            {
                                LOG_AT_EVT("EVT_BLE: \nScan Refresh:  %u.\n", *(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue));
                            }
                            else
                                LOG_AT_EVT("EVT_BLE: Invaid length received for the scan refresh notification.\n");

                            /* We cannot match another attribute handle.       */
                            break;
                        }

                        /* Handle the SPPLE notifications.                    */

                        /* If this notification is for the SPPLE Rx Credit    */
                        /* Characteristic.                                    */
                        if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->ClientInfo.Rx_Credit_Characteristic)
                        {
                            /* Verify that the length of the Rx Credit         */
                            /* Notification is correct.                        */
                            if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength == sizeof(uint16_t))
                            {
                                Credits = READ_UNALIGNED_WORD_LITTLE_ENDIAN(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue);

                                /* Handle the received credits event.           */
                                DisplayPrompt = ReceiveCreditEvent(DeviceInfo, Credits);
                            }

                            /* We cannot match another attribute handle.       */
                            break;
                        }

                        /* If this notification is for the SPPLE Tx Credit    */
                        /* Characteristic.                                    */
                        if(GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeHandle == DeviceInfo->ClientInfo.Tx_Characteristic)
                        {
                            /* This is a Tx Characteristic Event.  So call the */
                            /* function to handle the data indication event.   */
                            DisplayPrompt = DataIndicationEvent(DeviceInfo, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValueLength, GATT_Connection_Event_Data->Event_Data.GATT_Server_Notification_Data->AttributeValue);

                            /* We cannot match another attribute handle.       */
                            break;
                        }

                        /* Inform the user we received a notification for an  */
                        /* unknown handle.                                    */
                        LOG_AT_EVT("EVT_BLE: Unknown attribute handle for notification.\n");
                        DisplayPrompt = true;
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Server Notification Data.\n");
                break;
            default:
                DisplayPrompt = false;
                break;
        }

        if(DisplayPrompt)
            QCLI_Display_Prompt();
    }
}

/* The following function is for an GATT Discovery Event Callback.   */
/* This function will be called whenever a GATT Service is discovered*/
/* or a previously started service discovery process is completed.   */
/* This function passes to the caller the GATT Discovery Event Data  */
/* that occurred and the GATT Client Event Callback Parameter that   */
/* was specified when this Callback was installed.  The caller is    */
/* free to use the contents of the GATT Discovery Event Data ONLY in */
/* the context of this callback.  If the caller requires the Data for*/
/* a longer period of time, then the callback function MUST copy the */
/* data into another Data Buffer.  This function is guaranteed NOT to*/
/* be invoked more than once simultaneously for the specified        */
/* installed callback (i.e.  this function DOES NOT have be          */
/* reentrant).  It Needs to be noted however, that if the same       */
/* Callback is installed more than once, then the callbacks will be  */
/* called serially.  Because of this, the processing in this function*/
/* should be as efficient as possible.  It should also be noted that */
/* this function is called in the Thread Context of a Thread that the*/
/* User does NOT own.  Therefore, processing in this function should */
/* be as efficient as possible (this argument holds anyway because   */
/* another GATT Discovery Event will not be processed while this     */
/* function call is outstanding).                                    */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_Service_Discovery_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_GATT_Service_Discovery_Event_Data_t *GATT_Service_Discovery_Event_Data, uint32_t CallbackParameter)
{
    boolean_t     DisplayPrompt;
    DeviceInfo_t *DeviceInfo;

    if((BluetoothStackID) && (GATT_Service_Discovery_Event_Data))
    {
        DisplayPrompt = true;

        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
        {
            switch(GATT_Service_Discovery_Event_Data->Event_Data_Type)
            {
                case QAPI_BLE_ET_GATT_SERVICE_DISCOVERY_INDICATION_E:
                    /* Verify the event data.                                */
                    if(GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data)
                    {
                        LOG_AT_EVT("EVT_BLE: Service 0x%04X - 0x%04X, UUID: ", GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data->ServiceInformation.Service_Handle, GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data->ServiceInformation.End_Group_Handle);
                        DisplayUUID(&(GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data->ServiceInformation.UUID));
                        LOG_AT_EVT("\n");

                        /* Attempt to populate AIOS handles.                  */
                        AIOSPopulateHandles(&(DeviceInfo->AIOPClientInfo), GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                        /* Attempt to populate BAS handles.                   */
                        BASPopulateHandles(DeviceInfo, GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                        /* Attempt to populate the handles for the GAP        */
                        /* Service.                                           */
                        GAPSPopulateHandles(&(DeviceInfo->GAPSClientInfo), GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                        /* Attempt to populate the handles for the HID        */
                        /* Service.                                           */
                        HIDSPopulateHandles(&(DeviceInfo->HIDSClientInfo[HIDSInstanceIDIndex]), GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                        /* Attempt to populate the handles for the HRS        */
                        /* Service.                                           */
                        HRSPopulateHandles(DeviceInfo, GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                        /* Attempt to populate SCPS handles.                  */
                        SCPSPopulateHandles(DeviceInfo, GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);

                        /* Attempt to populate the handles for the SPPLE      */
                        /* Service.                                           */
                        SPPLEPopulateHandles(&(DeviceInfo->ClientInfo), GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Indication_Data);
                    }
                    break;
                case QAPI_BLE_ET_GATT_SERVICE_DISCOVERY_COMPLETE_E:
                    /* Verify the event data.                                */
                    if(GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Complete_Data)
                    {
                        LOG_AT_EVT("EVT_BLE: Service Discovery Operation Complete, Status 0x%02X.\n", GATT_Service_Discovery_Event_Data->Event_Data.GATT_Service_Discovery_Complete_Data->Status);

                        if(SPPLE_CLIENT_INFORMATION_VALID(DeviceInfo->ClientInfo))
                            LOG_AT_EVT("EVT_BLE: Valid SPPLE Service Found.\n");
                        else
                            LOG_AT_EVT("EVT_BLE: No SPPLE Service Found.\n");

                        /* Flag that no service discovery operation is        */
                        /* outstanding for this device.                       */
                        DeviceInfo->Flags &= ~DEVICE_INFO_FLAGS_SERVICE_DISCOVERY_OUTSTANDING;
                    }
                    break;
                default:
                    DisplayPrompt = false;
                    break;
            }
        }

        if(DisplayPrompt)
            QCLI_Display_Prompt();
    }
}

/* Generic Attribute Profile (GATT) Service Event Callback function  */
/* prototypes (Server).                                              */

/* The following is a AIOS Server Event Callback.  This function will*/
/* be called whenever an AIOS Server Profile Event occurs that is    */
/* associated with the specified Bluetooth Stack ID.  This function  */
/* passes to the caller the Bluetooth Stack ID, the AIOS Event Data  */
/* that occurred and the AIOS Event Callback Parameter that was      */
/* specified when this Callback was The caller is free to installed. */
/* use the contents of the AIOS Event Data ONLY in the context If the*/
/* caller requires the Data for a longer period of of this callback. */
/* time, then the callback function MUST copy the data into another  */
/* Data Buffer This function is guaranteed NOT to be invoked more    */
/* than once simultaneously for the specified this function DOES NOT */
/* have be re-entrant).  It needs to be installed callback (i.e.     */
/* noted however, that if the same Callback is installed more than   */
/* once, then the callbacks will Because of be called serially.      */
/* this, the processing in this function should be as It should also */
/* be noted that this function is called in efficient as possible.   */
/* the Thread Context of a Thread that the User does NOT own.        */
/* Therefore, processing in this function should be as efficient as  */
/* possible (this argument holds anyway because another AIOS Event   */
/* will not be processed while this function call is outstanding).   */
/* ** NOTE ** This function MUST NOT Block and wait for events that  */
/*            can only be satisfied by Receiving AIOS Event Packets. */
/*            A Deadlock WILL occur because NO AIOS Event Callbacks  */
/*            will be issued while this function is currently        */
/*            outstanding.                                           */
static void QAPI_BLE_BTPSAPI AIOS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_AIOS_Event_Data_t *AIOS_Event_Data, uint32_t CallbackParameter)
{
    int                                  Result;
    BoardStr_t                           BoardStr;
    DeviceInfo_t                        *DeviceInfo;
    uint32_t                             InstanceID;
    uint32_t                             ConnectionID;
    uint32_t                             TransactionID;
    qapi_BLE_BD_ADDR_t                   RemoteDevice;
    qapi_BLE_GATT_Connection_Type_t      ConnectionType;
    qapi_BLE_AIOS_Characteristic_Info_t *CharacteristicInfo;
    AIOP_Server_Instance_Data_t         *ServerInstancePtr;
    qapi_BLE_AIOS_Characteristic_Data_t  Data;
    uint16_t                             ClientConfiguration;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (AIOS_Event_Data))
    {
        /* Determine the AIOS Event type.                                 */
        switch(AIOS_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_AIOS_SERVER_READ_CHARACTERISTIC_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: \nQAPI_BLE_ET_AIOS_SERVER_READ_CHARACTERISTIC_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
                if(AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data)
                {
                    /* Store event information.                              */
                    InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->InstanceID;
                    ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->ConnectionID;
                    TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->TransactionID;
                    ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->ConnectionType;
                    RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->RemoteDevice;
                    CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Read_Characteristic_Request_Data->CharacteristicInfo);

                    /* Print event information.                              */
                    LOG_AT_EVT("EVT_BLE:    Instance ID:          %u.\n", InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:        %u.\n", ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:       %u.\n", TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
                    BD_ADDRToStr(RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Remote Device:        %s.\n", BoardStr);

                    /* Display the Characteristic Information.               */
                    DisplayAIOSCharacteristicInfo(CharacteristicInfo);

                    /* Determine the Characteristic type so we know how to   */
                    /* format the AIOS Characteristic for the response.      */
                    switch(CharacteristicInfo->Type)
                    {
                        case QAPI_BLE_ACT_DIGITAL_E:
                            /* Store a pointer to the Characteristic instance  */
                            /* data for readability.                           */
                            /* * NOTE * We will use the Characteristic         */
                            /*          information to access it.              */
                            if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                            {
                                /* Get the Digital Characteristic.              */
                                /* * NOTE * This demo uses two octets (8 digital*/
                                /*          signals) for a Digital              */
                                /*          Characteristic instance.            */
                                Data.Digital.Length = 2;
                                Data.Digital.Buffer = ServerInstancePtr->Data.Digital;

                                /* Send the response.                           */
                                if((Result = qc_drv_ble_AIOS_Read_Characteristic_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, ConnectionID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, &Data)) != 0)
                                    DisplayFunctionError("qapi_BLE_AIOS_Read_Characteristic_Request_Response", Result);
                            }
                            else
                            {
                                /* Send the error response.                     */
                                if((Result = qc_drv_ble_AIOS_Read_Characteristic_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, ConnectionID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, NULL)) != 0)
                                    DisplayFunctionError("qapi_BLE_AIOS_Read_Characteristic_Request_Response", Result);
                            }
                            break;
                        case QAPI_BLE_ACT_ANALOG_E:
                            /* Store a pointer to the Characteristic instance  */
                            /* data for readability.                           */
                            /* * NOTE * We will use the Characteristic         */
                            /*          information to access it.              */
                            if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                            {
                                /* Get the Analog Characteristic.               */
                                Data.Analog = ServerInstancePtr->Data.Analog;

                                /* Send the response.                           */
                                if((Result = qc_drv_ble_AIOS_Read_Characteristic_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, ConnectionID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, &Data)) != 0)
                                    DisplayFunctionError("qapi_BLE_AIOS_Read_Characteristic_Request_Response", Result);
                            }
                            else
                            {
                                /* Send the error response.                     */
                                if((Result = qc_drv_ble_AIOS_Read_Characteristic_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, ConnectionID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, NULL)) != 0)
                                    DisplayFunctionError("qapi_BLE_AIOS_Read_Characteristic_Request_Response", Result);
                            }
                            break;
                        default:
                            /* This CANNOT occur the event will not be         */
                            /* received.                                       */
                            break;
                    }
                }
                break;
            case QAPI_BLE_ET_AIOS_SERVER_WRITE_CHARACTERISTIC_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: \nQAPI_BLE_ET_AIOS_SERVER_WRITE_CHARACTERISTIC_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
                if(AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data)
                {
                    /* Store event information.                              */
                    InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->InstanceID;
                    ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->ConnectionID;
                    TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->TransactionID;
                    ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->ConnectionType;
                    RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->RemoteDevice;
                    CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->CharacteristicInfo);
                    Data               = AIOS_Event_Data->Event_Data.AIOS_Write_Characteristic_Request_Data->Data;

                    /* Print event information.                              */
                    LOG_AT_EVT("EVT_BLE:    Instance ID:          %u.\n", InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:        %u.\n", ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:       %u.\n", TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
                    BD_ADDRToStr(RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Remote Device:        %s.\n", BoardStr);

                    /* Display the Characteristic Information.               */
                    DisplayAIOSCharacteristicInfo(CharacteristicInfo);

                    /* Determine the Characteristic type so we know what to  */
                    /* store and print the Characteristic data.              */
                    switch(CharacteristicInfo->Type)
                    {
                        case QAPI_BLE_ACT_DIGITAL_E:
                            /* Store a pointer to the Characteristic instance  */
                            /* data for readability.                           */
                            /* * NOTE * We will use the Characteristic         */
                            /*          information to access it.              */
                            if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                            {
                                /* Make sure we have room to store the Digital  */
                                /* Characteristic.                              */
                                /* * NOTE * This demo uses two octets (8 digital*/
                                /*          signals) for a Digital              */
                                /*          Characteristic instance.            */
                                if(Data.Digital.Length == 2)
                                {
                                    /* Simply copy the buffer that contains the  */
                                    /* Digital Characteristic array to store the */
                                    /* Digital Characteristic.                   */
                                    memcpy(ServerInstancePtr->Data.Digital, Data.Digital.Buffer, Data.Digital.Length);

                                    /* Display the Digital Characteristic.       */
                                    DisplayDigitalCharacteristic(&(Data.Digital), CharacteristicInfo->ID);

                                    /* Send the write request response.         */
                                    if((Result = qc_drv_ble_AIOS_Write_Characteristic_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo)) != 0)
                                        DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                                }
                                else
                                {
                                    /* We will simply reject the write request   */
                                    /* since the Digital Characteristic being    */
                                    /* written has an invalid length.            */
                                    if((Result = qc_drv_ble_AIOS_Write_Characteristic_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_ATTRIBUTE_VALUE_LENGTH, CharacteristicInfo)) != 0)
                                        DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                                }
                            }
                            else
                            {
                                /* Send the error response.                     */
                                if((Result = qc_drv_ble_AIOS_Write_Characteristic_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo)) != 0)
                                    DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                            }
                            break;
                        case QAPI_BLE_ACT_ANALOG_E:
                            /* Store a pointer to the Characteristic instance  */
                            /* data for readability.                           */
                            /* * NOTE * We will use the Characteristic         */
                            /*          information to access it.              */
                            if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                            {
                                /* Store the Analog Characteristic.             */
                                ServerInstancePtr->Data.Analog = Data.Analog;

                                /* Display the Analog Characteristic.           */
                                DisplayAnalogCharacteristic(ServerInstancePtr->Data.Analog, CharacteristicInfo->ID);

                                /* Send the write request response.             */
                                if((Result = qc_drv_ble_AIOS_Write_Characteristic_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo)) != 0)
                                    DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                            }
                            else
                            {
                                /* Send the error response.                     */
                                if((Result = qc_drv_ble_AIOS_Write_Characteristic_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo)) != 0)
                                    DisplayFunctionError("qapi_BLE_AIOS_Write_Characteristic_Request_Response", Result);
                            }
                            break;
                        default:
                            /* This CANNOT occur the event will not be         */
                            /* received.                                       */
                            break;
                    }
                }
                break;
            case QAPI_BLE_ET_AIOS_SERVER_READ_CCCD_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: \nQAPI_BLE_ET_AIOS_SERVER_READ_CCCD_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
                if(AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data)
                {
                    /* Store event information.                              */
                    InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->InstanceID;
                    ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->ConnectionID;
                    TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->TransactionID;
                    ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->ConnectionType;
                    RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->RemoteDevice;
                    CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Read_CCCD_Request_Data->CharacteristicInfo);

                    /* Print event information.                              */
                    LOG_AT_EVT("EVT_BLE:    Instance ID:          %u.\n", InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:        %u.\n", ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:       %u.\n", TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
                    BD_ADDRToStr(RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Remote Device:        %s.\n", BoardStr);

                    /* Display the Characteristic Information.               */
                    DisplayAIOSCharacteristicInfo(CharacteristicInfo);

                    /* Make sure we can get the device information.          */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, RemoteDevice)) != NULL)
                    {
                        /* Determine the Characteristic type so we know what  */
                        /* CCCD to send in the response.                      */
                        switch(CharacteristicInfo->Type)
                        {
                            case QAPI_BLE_ACT_DIGITAL_E:
                            case QAPI_BLE_ACT_ANALOG_E:
                                /* Intentional fall through.                    */
                                ClientConfiguration = DeviceInfo->AIOPServerConfiguration;

                                /* Send the response.                           */
                                if((Result = qc_drv_ble_AIOS_Read_CCCD_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, ClientConfiguration)) != 0)
                                    DisplayFunctionError("qapi_BLE_AIOS_Read_CCCD_Request_Response", Result);
                                break;
                            default:
                                /* This CANNOT occur the event will not be      */
                                /* received.                                    */
                                break;
                        }
                    }
                    else
                    {
                        LOG_AT_EVT("EVT_BLE: \nError - Unknown device.\n");

                        /* Send the error response.                           */
                        if((Result = qc_drv_ble_AIOS_Read_CCCD_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, 0)) != 0)
                            DisplayFunctionError("qapi_BLE_AIOS_Read_CCCD_Request_Response", Result);
                    }
                }
                break;
            case QAPI_BLE_ET_AIOS_SERVER_WRITE_CCCD_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: \nQAPI_BLE_ET_AIOS_SERVER_WRITE_CCCD_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
                if(AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data)
                {
                    /* Store event information.                              */
                    InstanceID          = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->InstanceID;
                    ConnectionID        = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->ConnectionID;
                    TransactionID       = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->TransactionID;
                    ConnectionType      = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->ConnectionType;
                    RemoteDevice        = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->RemoteDevice;
                    CharacteristicInfo  = &(AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->CharacteristicInfo);
                    ClientConfiguration = AIOS_Event_Data->Event_Data.AIOS_Write_CCCD_Request_Data->ClientConfiguration;

                    /* Print event information.                              */
                    LOG_AT_EVT("EVT_BLE:    Instance ID:          %u.\n", InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:        %u.\n", ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:       %u.\n", TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
                    BD_ADDRToStr(RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Remote Device:        %s.\n", BoardStr);

                    /* Display the Characteristic Information.               */
                    DisplayAIOSCharacteristicInfo(CharacteristicInfo);

                    /* Display the received configuration.                   */
                    LOG_AT_EVT("EVT_BLE:    Client Configuration: 0x%04X.\n", ClientConfiguration);

                    /* Determine the Characteristic type so we know how to   */
                    /* verify the CCCD and where to store it.  where to store*/
                    /* the new CCCD.                                         */
                    switch(CharacteristicInfo->Type)
                    {
                        case QAPI_BLE_ACT_DIGITAL_E:
                        case QAPI_BLE_ACT_ANALOG_E:
                            /* Make sure we can get the device information.    */
                            if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, RemoteDevice)) != NULL)
                            {
                                /* We will only accept notify or disabled (0).  */
                                if((!ClientConfiguration) || (ClientConfiguration & QAPI_BLE_AIOS_CLIENT_CHARACTERISTIC_CONFIGURATION_NOTIFY_ENABLE))
                                {
                                    /* Store the Client Configuration.           */
                                    DeviceInfo->AIOPServerConfiguration = ClientConfiguration;

                                    /* Send the response.                        */
                                    if((Result = qc_drv_ble_AIOS_Write_CCCD_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo)) != 0)
                                        DisplayFunctionError("qapi_BLE_AIOS_Write_CCCD_Request_Response", Result);

                                    /* * NOTE * The user should send a           */
                                    /*          notification of this             */
                                    /*          Characteristic if notifications  */
                                    /*          have been enabled.               */
                                }
                                else
                                {
                                    /* Reject the write request since the CCCD is*/
                                    /* improperly configured.                    */
                                    if((Result = qc_drv_ble_AIOS_Write_CCCD_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_CCCD_IMPROPERLY_CONFIGURED, CharacteristicInfo)) != 0)
                                        DisplayFunctionError("qapi_BLE_AIOS_Write_CCCD_Request_Response", Result);
                                }
                            }
                            else
                            {
                                LOG_AT_EVT("EVT_BLE: \nError - Unknown device.\n");

                                /* Send the error response.                     */
                                if((Result = qc_drv_ble_AIOS_Write_CCCD_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo)) != 0)
                                    DisplayFunctionError("qapi_BLE_AIOS_Write_CCCD_Request_Response", Result);
                            }
                            break;
                        default:
                            /* This CANNOT occur the event will not be         */
                            /* received.                                       */
                            break;
                    }
                }
                break;
            case QAPI_BLE_ET_AIOS_SERVER_READ_PRESENTATION_FORMAT_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: \nQAPI_BLE_ET_AIOS_SERVER_READ_PRESENTATION_FORMAT_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
                if(AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data)
                {
                    /* Store event information.                              */
                    InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->InstanceID;
                    ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->ConnectionID;
                    TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->TransactionID;
                    ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->ConnectionType;
                    RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->RemoteDevice;
                    CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Read_Presentation_Format_Request_Data->CharacteristicInfo);

                    /* Print event information.                              */
                    LOG_AT_EVT("EVT_BLE:    Instance ID:          %u.\n", InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:        %u.\n", ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:       %u.\n", TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
                    BD_ADDRToStr(RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Remote Device:        %s.\n", BoardStr);

                    /* Display the Characteristic Information.               */
                    DisplayAIOSCharacteristicInfo(CharacteristicInfo);

                    /* Store a pointer to the Characteristic instance data   */
                    /* for readability.                                      */
                    /* * NOTE * We will use the Characteristic information to*/
                    /*          access it.                                   */
                    if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                    {
                        /* Send the response.                                 */
                        if((Result = qc_drv_ble_AIOS_Read_Presentation_Format_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, &(ServerInstancePtr->Presentation_Format))) != 0)
                            DisplayFunctionError("qapi_BLE_AIOS_Read_Presentation_Format_Request_Response", Result);
                    }
                    else
                    {
                        /* Send the error response.                           */
                        if((Result = qc_drv_ble_AIOS_Read_Presentation_Format_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, NULL)) != 0)
                            DisplayFunctionError("qapi_BLE_AIOS_Read_Presentation_Format_Request_Response", Result);
                    }
                }
                break;
            case QAPI_BLE_ET_AIOS_SERVER_READ_NUMBER_OF_DIGITALS_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: \nQAPI_BLE_ET_AIOS_SERVER_READ_NUMBER_OF_DIGITALS_REQUEST_E with size %u.\n", AIOS_Event_Data->Event_Data_Size);
                if(AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data)
                {
                    /* Print event information.                              */
                    InstanceID         = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->InstanceID;
                    ConnectionID       = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->ConnectionID;
                    TransactionID      = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->TransactionID;
                    ConnectionType     = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->ConnectionType;
                    RemoteDevice       = AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->RemoteDevice;
                    CharacteristicInfo = &(AIOS_Event_Data->Event_Data.AIOS_Read_Number_Of_Digitals_Request_Data->CharacteristicInfo);

                    /* Print event information.                              */
                    LOG_AT_EVT("EVT_BLE:    Instance ID:          %u.\n", InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:        %u.\n", ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:       %u.\n", TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:      %s.\n", ((ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR"));
                    BD_ADDRToStr(RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Remote Device:        %s.\n", BoardStr);

                    /* Display the characteristic Information.               */
                    DisplayAIOSCharacteristicInfo(CharacteristicInfo);

                    /* Store a pointer to the Characteristic instance data   */
                    /* for readability.                                      */
                    /* * NOTE * We will use the Characteristic information to*/
                    /*          access it.                                   */
                    if((ServerInstancePtr = GetAIOSServerInstanceInfoPtr(CharacteristicInfo)) != NULL)
                    {
                        /* Send the response.                                 */
                        if((Result = qc_drv_ble_AIOS_Read_Number_Of_Digitals_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_AIOS_ERROR_CODE_SUCCESS, CharacteristicInfo, ServerInstancePtr->Number_Of_Digitals)) != 0)
                            DisplayFunctionError("qapi_BLE_AIOS_Read_Number_Of_Digitals_Request_Response", Result);
                    }
                    else
                    {
                        /* Send the error response.                           */
                        /* * NOTE * We pass zero in for the Number Of Digitals*/
                        /*          since it will be ignored.                 */
                        if((Result = qc_drv_ble_AIOS_Read_Number_Of_Digitals_Request_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, TransactionID, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR, CharacteristicInfo, 0)) != 0)
                            DisplayFunctionError("qapi_BLE_AIOS_Read_Number_Of_Digitals_Request_Response", Result);
                    }
                }
                break;
            default:
                LOG_AT_EVT("EVT_BLE: \nUnknown AIOS Event\n");
                break;
        }
    }
    else
    {
        /* There was an error with one or more of the input parameters.   */
        LOG_AT("\n");

        LOG_AT_EVT("EVT_BLE: AIOS Callback Data: Event_Data = NULL.\n");
    }
}

/* The following is a BAS Server Event Callback.  This function will */
/* be called whenever an BAS Server Profile Event occurs that is     */
/* associated with the specified Bluetooth Stack ID.  This function  */
/* passes to the caller the Bluetooth Stack ID, the BAS Event Data   */
/* that occurred and the BAS Event Callback Parameter that was       */
/* specified when this Callback was installed.  The caller is free to*/
/* use the contents of the BAS Event Data ONLY in the context of this*/
/* callback.  If the caller requires the Data for a longer period of */
/* time, then the callback function MUST copy the data into another  */
/* Data Buffer This function is guaranteed NOT to be invoked more    */
/* than once simultaneously for the specified installed callback     */
/* (i.e.  this function DOES NOT have be re-entrant).  It needs to be*/
/* noted however, that if the same Callback is installed more than   */
/* once, then the callbacks will be called serially.  Because of     */
/* this, the processing in this function should be as efficient as   */
/* possible.  It should also be noted that this function is called in*/
/* the Thread Context of a Thread that the User does NOT own.        */
/* Therefore, processing in this function should be as efficient as  */
/* possible (this argument holds anyway because another BAS Event    */
/* will not be processed while this function call is outstanding).   */
/* ** NOTE ** This function MUST NOT Block and wait for events that  */
/*            can only be satisfied by Receiving BAS Event Packets.  */
/*            A Deadlock WILL occur because NO BAS Event Callbacks   */
/*            will be issued while this function is currently        */
/*            outstanding.                                           */
static void QAPI_BLE_BTPSAPI BAS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_BAS_Event_Data_t *BAS_Event_Data, uint32_t CallbackParameter)
{
    int           Result;
    BoardStr_t    BoardStr;
    unsigned int  InstanceID;
    unsigned int  TransactionID;
    DeviceInfo_t *DeviceInfo;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (BAS_Event_Data))
    {
        switch(BAS_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_BAS_SERVER_READ_CLIENT_CONFIGURATION_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: etBAS_Server_Read_Client_Configuration_Request with size %u.\n", BAS_Event_Data->Event_Data_Size);

                if(BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data)
                {
                    BD_ADDRToStr(BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->RemoteDevice, BoardStr);
                    InstanceID = BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->InstanceID;

                    LOG_AT_EVT("EVT_BLE: Instance ID:      %u.\n", InstanceID);
                    LOG_AT_EVT("EVT_BLE: Connection ID:    %u.\n", BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:   %u.\n", BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type:  %s.\n", ((BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
                    LOG_AT_EVT("EVT_BLE: Remote Device:    %s.\n", BoardStr);

                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->RemoteDevice)) != NULL)
                    {
                        switch(BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->ClientConfigurationType)
                        {
                            case QAPI_BLE_CT_BATTERY_LEVEL_E:
                                LOG_AT_EVT("EVT_BLE: Config Type:      ctBatteryLevel.\n");

                                Result = qc_drv_ble_BAS_Read_Client_Configuration_Response(qc_api_get_qc_drv_context(), BluetoothStackID, InstanceID, BAS_Event_Data->Event_Data.BAS_Read_Client_Configuration_Data->TransactionID, DeviceInfo->BASServerInfo[InstanceID-1].Battery_Level_Client_Configuration);
                                break;
                            default:
                                LOG_AT_EVT("EVT_BLE: Config Type:      Unknown.\n");

                                Result = 0;
                                break;
                        }

                        if(Result)
                            DisplayFunctionError("BAS_Read_Client_Configuration_Response", Result);
                    }
                    else
                        LOG_AT_EVT("EVT_BLE: \nUnknown Client.\n");
                }
                break;
            case QAPI_BLE_ET_BAS_SERVER_CLIENT_CONFIGURATION_UPDATE_E:
                LOG_AT_EVT("EVT_BLE: etBAS_Server_Client_Configuration_Update with size %u.\n", BAS_Event_Data->Event_Data_Size);

                if(BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data)
                {
                    BD_ADDRToStr(BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->RemoteDevice, BoardStr);
                    InstanceID = BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->InstanceID;

                    LOG_AT_EVT("EVT_BLE: Instance ID:      %u.\n", InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:    %u.\n", BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:  %s.\n", ((BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
                    LOG_AT_EVT("EVT_BLE:    Remote Device:    %s.\n", BoardStr);

                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->RemoteDevice)) != NULL)
                    {
                        switch(BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->ClientConfigurationType)
                        {
                            case QAPI_BLE_CT_BATTERY_LEVEL_E:
                                LOG_AT_EVT("EVT_BLE:    Config Type:      ctBatteryLevel.\n");
                                if(BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->Notify)
                                    DeviceInfo->BASServerInfo[InstanceID-1].Battery_Level_Client_Configuration |= QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE;
                                else
                                    DeviceInfo->BASServerInfo[InstanceID-1].Battery_Level_Client_Configuration &= ~QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE;
                                break;
                            default:
                                LOG_AT_EVT("EVT_BLE:    Config Type:      Unknown.\n");
                                break;
                        }

                        LOG_AT_EVT("EVT_BLE: Value:            0x%04X.\n", (uint16_t)BAS_Event_Data->Event_Data.BAS_Client_Configuration_Update_Data->Notify);
                    }
                    else
                    {
                        LOG_AT_EVT("EVT_BLE: \nUnknown Client.\n");
                    }
                }
                break;
            case QAPI_BLE_ET_BAS_SERVER_READ_BATTERY_LEVEL_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: etBAS_Server_Read_Battery_Level_Request EVENT received \n");

                InstanceID    = BAS_Event_Data->Event_Data.BAS_Read_Battery_Level_Data->InstanceID;
                TransactionID = BAS_Event_Data->Event_Data.BAS_Read_Battery_Level_Data->TransactionID;

                Result        = qapi_BLE_BAS_Battery_Level_Read_Request_Response(BluetoothStackID, TransactionID, BatteryLevel[InstanceID-1]);

                LOG_AT_EVT("EVT_BLE: Result:    %d.\n", Result);
                break;
            default:
                LOG_AT_EVT("EVT_BLE: Unknown BAS Event\n");
                break;
        }
    }
    else
    {
        /* There was an error with one or more of the input parameters.   */
        LOG_AT("\n");

        LOG_AT_EVT("EVT_BLE: BAS Callback Data: Event_Data = NULL.\n");
    }
}

/* The following is a HID Server Event Callback.  This function will */
/* be called whenever an HID Server Profile Event occurs that is     */
/* associated with the specified Bluetooth Stack ID.  This function  */
/* passes to the caller the Bluetooth Stack ID, the HIDS Event Data  */
/* that occurred and the HIDS Profile Event Callback Parameter that  */
/* was specified when this Callback was installed.  The caller is    */
/* free to use the contents of the HIDS Profile Event Data ONLY in   */
/* the context of this callback.  If the caller requires the Data for*/
/* a longer period of time, then the callback function MUST copy the */
/* data into another Data Buffer This function is guaranteed NOT to  */
/* be invoked more than once simultaneously for the specified        */
/* installed callback (i.e. this function DOES NOT have be           */
/* re-entrant).  It needs to be noted however, that if the same      */
/* Callback is installed more than once, then the callbacks will be  */
/* called serially.  Because of this, the processing in this function*/
/* should be as efficient as possible.  It should also be noted that */
/* this function is called in the Thread Context of a Thread that the*/
/* User does NOT own.  Therefore, processing in this function should */
/* be as efficient as possible (this argument holds anyway because   */
/* another HIDS Profile Event will not be processed while this       */
/* function call is outstanding).                                    */
/* ** NOTE ** This function MUST NOT Block and wait for events that  */
/*            can only be satisfied by Receiving HIDS Profile Event  */
/*            Packets.  A Deadlock WILL occur because NO HIDS Event  */
/*            Callbacks will be issued while this function is        */
/*            currently outstanding.                                 */
static void QAPI_BLE_BTPSAPI HIDS_Event_Callback(uint32_t BluetoothStackID, qapi_BLE_HIDS_Event_Data_t *HIDS_Event_Data, uint32_t CallbackParameter)
{
    int                                      Result;
    uint8_t                                  ErrorCode;
    uint8_t                                 *ReportData;
    uint8_t                                  ReportBuffer[HID_KEYBOARD_INPUT_REPORT_SIZE];
    uint16_t                                 Configuration;
    DeviceInfo_t                            *DeviceInfo;
    unsigned int                             ReportDataLength;
    unsigned int                             Index;
    qapi_BLE_GAP_Encryption_Mode_t           GAPEncryptionMode;
    qapi_BLE_HIDS_Get_Report_Request_Data_t *GetReportRequestData;
    qapi_BLE_HIDS_Set_Report_Request_Data_t *SetReportRequestData;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (HIDS_Event_Data))
    {
        switch(HIDS_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_HIDS_SERVER_READ_CLIENT_CONFIGURATION_REQUEST_E:
                if(HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data)
                {
                    /* Search for the Device entry.                          */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data->RemoteDevice)) != NULL)
                    {
                        LOG_AT_EVT("EVT_BLE: HIDS Read Client Configuration Request: %u.\n", HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data->ReportType);

                        if(HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E)
                            Configuration = DeviceInfo->HIDSServerInfo.BootKeyboardInputConfiguration;
                        else
                            Configuration = DeviceInfo->HIDSServerInfo.ReportKeyboardInputConfiguration;

                        /* Respond to the read request.                       */
                        Result = qc_drv_ble_HIDS_Read_Client_Configuration_Response(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID, HIDS_Event_Data->Event_Data.HIDS_Read_Client_Configuration_Data->TransactionID, Configuration);
                        if(Result)
                            LOG_AT_EVT("EVT_BLE: qapi_BLE_HIDS_Read_Client_Configuration_Response() %d.\n", Result);
                    }
                }
                break;
            case QAPI_BLE_ET_HIDS_SERVER_CLIENT_CONFIGURATION_UPDATE_REQUEST_E:
                if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data)
                {
                    LOG_AT_EVT("EVT_BLE: HIDS Client Configuration Update: %u.\n", HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportType);

                    /* Search for the Device entry.                          */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->RemoteDevice)) != NULL)
                    {
                        if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E)
                        {
                            DeviceInfo->HIDSServerInfo.BootKeyboardInputConfiguration = HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ClientConfiguration;

                            LOG_AT_EVT("EVT_BLE: Boot Keyboard Input Report Configuration 0x%04X.\n", DeviceInfo->HIDSServerInfo.BootKeyboardInputConfiguration);
                        }
                        else
                        {
                            if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT)
                            {
                                DeviceInfo->HIDSServerInfo.BootMouseInputConfiguration = HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ClientConfiguration;

                                LOG_AT_EVT("EVT_BLE: Boot Mouse Input Report Configuration 0x%04X.\n", DeviceInfo->HIDSServerInfo.BootMouseInputConfiguration);
                            }
                            else
                            {
                                if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportType == QAPI_BLE_RT_REPORT_E)
                                {
                                    if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportReferenceData.ReportID == HID_KEYBOARD_INPUT_REPORT_ID)
                                    {
                                        DeviceInfo->HIDSServerInfo.ReportKeyboardInputConfiguration = HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ClientConfiguration;

                                        LOG_AT_EVT("EVT_BLE: Report Keyboard Input Report Configuration 0x%04X.\n", DeviceInfo->HIDSServerInfo.ReportKeyboardInputConfiguration);
                                    }
                                    else
                                    {
                                        if(HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ReportReferenceData.ReportID == HID_MOUSE_INPUT_REPORT_ID)
                                        {
                                            DeviceInfo->HIDSServerInfo.ReportMouseInputConfiguration = HIDS_Event_Data->Event_Data.HIDS_Client_Configuration_Update_Data->ClientConfiguration;

                                            LOG_AT_EVT("EVT_BLE: Report Mouse Input Report Configuration 0x%04X.\n", DeviceInfo->HIDSServerInfo.ReportMouseInputConfiguration);
                                        }
                                        else
                                            LOG_AT_EVT("EVT_BLE: Unknown Client Configuration.\n");
                                    }
                                }
                                else
                                    LOG_AT_EVT("EVT_BLE: Unknown Client Configuration.\n");
                            }
                        }
                    }
                }
                break;
            case QAPI_BLE_ET_HIDS_SERVER_GET_PROTOCOL_MODE_REQUEST_E:
                if(HIDS_Event_Data->Event_Data.HIDS_Get_Protocol_Mode_Request_Data)
                {
                    LOG_AT_EVT("EVT_BLE: HIDS Get Protocol Mode Request.\n");

                    /* Note that security is required to read this           */
                    /* characteristic.                                       */
                    if((qc_drv_ble_GAP_LE_Query_Encryption_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, HIDS_Event_Data->Event_Data.HIDS_Get_Protocol_Mode_Request_Data->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                        ErrorCode = 0;
                    else
                        ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION;

                    /* Respond the Get Protocol Mode request.                */
                    Result = qc_drv_ble_HIDS_Get_Protocol_Mode_Response(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID, HIDS_Event_Data->Event_Data.HIDS_Get_Protocol_Mode_Request_Data->TransactionID, ErrorCode, HIDS_Protocol_Mode);
                    if(Result)
                        LOG_AT_EVT("EVT_BLE: qapi_BLE_HIDS_Get_Protocol_Mode_Response() %d.\n", Result);
                }
                break;
            case QAPI_BLE_ET_HIDS_SERVER_SET_PROTOCOL_MODE_REQUEST_E:
                if(HIDS_Event_Data->Event_Data.HIDS_Set_Protocol_Mode_Request_Data)
                {
                    LOG_AT_EVT("EVT_BLE: HIDS Set Protocol Mode Request: %s.\n", (HIDS_Event_Data->Event_Data.HIDS_Set_Protocol_Mode_Request_Data->ProtocolMode == QAPI_BLE_PM_BOOT_E)?"Boot":"Report");

                    /* Note that security is required to write this          */
                    /* characteristic.                                       */
                    if((qc_drv_ble_GAP_LE_Query_Encryption_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, HIDS_Event_Data->Event_Data.HIDS_Set_Protocol_Mode_Request_Data->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                        HIDS_Protocol_Mode = HIDS_Event_Data->Event_Data.HIDS_Set_Protocol_Mode_Request_Data->ProtocolMode;
                }
                break;
            case QAPI_BLE_ET_HIDS_SERVER_GET_REPORT_MAP_REQUEST_E:
                if(HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data)
                {
                    LOG_AT_EVT("EVT_BLE: HIDS Get Report Map Request: Offset = %u.\n", HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->ReportMapOffset);

                    /* Note that security is required to read this           */
                    /* characteristic.                                       */
                    if((qc_drv_ble_GAP_LE_Query_Encryption_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                    {
                        /* Initialize the return value to success.            */
                        ErrorCode = 0;

                        /* Verify that the offset being read is valid.        */
                        if(HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->ReportMapOffset < (sizeof(KeyboardReportDescriptor)))
                        {
                            /* Get a pointer to the report map to return.      */
                            ReportDataLength = (sizeof(KeyboardReportDescriptor) - HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->ReportMapOffset);
                            ReportData       = &(KeyboardReportDescriptor[HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->ReportMapOffset]);
                        }
                        else
                        {
                            ErrorCode        = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_OFFSET;
                            ReportDataLength = 0;
                            ReportData       = NULL;
                        }
                    }
                    else
                    {
                        ErrorCode        = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION;
                        ReportDataLength = 0;
                        ReportData       = NULL;
                    }

                    /* Respond the Get Report Map request.                   */
                    Result = qc_drv_ble_HIDS_Get_Report_Map_Response(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID, HIDS_Event_Data->Event_Data.HIDS_Get_Report_Map_Data->TransactionID, ErrorCode, ReportDataLength, ReportData);
                    if(Result)
                        LOG_AT_EVT("EVT_BLE: qapi_BLE_HIDS_Get_Report_Map_Response() %d.\n", Result);
                }
                break;
            case QAPI_BLE_ET_HIDS_SERVER_GET_REPORT_REQUEST_E:
                if(HIDS_Event_Data->Event_Data.HIDS_Get_Report_Request_Data)
                {
                    GetReportRequestData = HIDS_Event_Data->Event_Data.HIDS_Get_Report_Request_Data;

                    LOG_AT_EVT("EVT_BLE: \nHID Get Report Request: Type %u.\n", GetReportRequestData->ReportType);

                    /* Note that security is required to read this           */
                    /* characteristic.                                       */
                    if((qc_drv_ble_GAP_LE_Query_Encryption_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, GetReportRequestData->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                    {
                        /* Flag that no error has occurred.                   */
                        ErrorCode = 0;

                        /* Determine what report the Host is attempting to    */
                        /* read.                                              */
                        if((GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E) || ((GetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT) && (GetReportRequestData->ReportReferenceData.ReportID == HID_KEYBOARD_INPUT_REPORT_ID)))
                        {
                            /* Respond with the Keyboard Input Report.  Note   */
                            /* that since our Report Mode Report is identical  */
                            /* to the Boot Mode Report we do not need to       */
                            /* differentiate here.                             */
                            ReportDataLength = KeyboardInputReportSize;

                            if(sizeof(ReportBuffer) >= KeyboardInputReportSize)
                                memcpy(ReportBuffer, KeyboardInputReport, KeyboardInputReportSize);
                            else
                            {
                                LOG_AT_EVT("EVT_BLE: Responding to Get Report Request - Insufficient Resources.\n");
                                ReportDataLength = 0;
                            }

                            if(GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E)
                                LOG_AT_EVT("EVT_BLE:    Boot Keyboard Input Report:\n");
                            else
                                LOG_AT_EVT("EVT_BLE:    Keyboard Input Report:\n");
                        }
                        else
                        {
                            if((GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT) || ((GetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT) && (GetReportRequestData->ReportReferenceData.ReportID == HID_MOUSE_INPUT_REPORT_ID)))
                            {
                                /* Respond with the Mouse Input Report.  Note   */
                                /* that since our Report Mode Report is         */
                                /* identical to the Boot Mode Report we do not  */
                                /* need to differentiate here.                  */
                                ReportDataLength = MouseInputReportSize;

                                if(sizeof(ReportBuffer) >= MouseInputReportSize)
                                    memcpy(ReportBuffer, MouseInputReport, MouseInputReportSize);
                                else
                                {
                                    LOG_AT_EVT("EVT_BLE: Responding to Get Report Request - Insufficient Resources.\n");
                                    ReportDataLength = 0;
                                }

                                if(GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT)
                                    LOG_AT_EVT("EVT_BLE:    Boot Mouse Input Report:\n");
                                else
                                    LOG_AT_EVT("EVT_BLE:    Mouse Input Report:\n");
                            }
                            else
                            {
                                if((GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E) || ((GetReportRequestData->ReportType == QAPI_BLE_RT_REPORT_E) && (GetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT)))
                                {
                                    /* Respond with the Keyboard Output Report.  */
                                    /* Note that since our Report Mode Report is */
                                    /* identical to the Boot Mode Report we do   */
                                    /* not need to differentiate here.           */
                                    ReportDataLength = KeyboardOutputReportSize;

                                    if(sizeof(ReportBuffer) >= KeyboardOutputReportSize)
                                        memcpy(ReportBuffer, KeyboardOutputReport, KeyboardOutputReportSize);
                                    else
                                    {
                                        LOG_AT_EVT("EVT_BLE: Responding to Get Report Request - Insufficient Resources.\n");
                                        ReportDataLength = 0;
                                    }

                                    if(GetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E)
                                        LOG_AT_EVT("EVT_BLE:    Boot Keyboard Output Report:\n");
                                    else
                                        LOG_AT_EVT("EVT_BLE:    Keyboard Output Report:\n");
                                }
                                else
                                {
                                    ErrorCode        = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR;
                                    ReportDataLength = 0;
                                }
                            }
                        }
                    }
                    else
                    {
                        ErrorCode        = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION;
                        ReportDataLength = 0;
                    }

                    LOG_AT_EVT("EVT_BLE:       Report Length: %d.\n", ReportDataLength);

                    LOG_AT_EVT("EVT_BLE:       Report Value:  ");
                    for(Index = 0; Index < ReportDataLength; Index++)
                        LOG_AT_EVT("EVT_BLE: 0x%02X ", ReportBuffer[Index]);
                    LOG_AT_EVT("EVT_BLE: \n");

                    /* Respond to the Get Report Request.                    */
                    Result = qc_drv_ble_HIDS_Get_Report_Response(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID, GetReportRequestData->TransactionID, GetReportRequestData->ReportType, &(GetReportRequestData->ReportReferenceData), ErrorCode, ReportDataLength, ReportBuffer);
                    if(Result)
                        LOG_AT_EVT("EVT_BLE: qapi_BLE_HIDS_Get_Report_Response() %d.\n", Result);
                }
                break;
            case QAPI_BLE_ET_HIDS_SERVER_SET_REPORT_REQUEST_E:
                if(HIDS_Event_Data->Event_Data.HIDS_Set_Report_Request_Data)
                {
                    SetReportRequestData = HIDS_Event_Data->Event_Data.HIDS_Set_Report_Request_Data;

                    LOG_AT_EVT("EVT_BLE: HID Set Report Request: Type %u.\n", HIDS_Event_Data->Event_Data.HIDS_Set_Report_Request_Data->ReportType);

                    /* Note that security is required to write this          */
                    /* characteristic.                                       */
                    if((qc_drv_ble_GAP_LE_Query_Encryption_Mode(qc_api_get_qc_drv_context(), BluetoothStackID, SetReportRequestData->RemoteDevice, &GAPEncryptionMode) == 0) && (GAPEncryptionMode == QAPI_BLE_EM_ENABLED_E))
                    {
                        /* Flag that no error has occurred.                   */
                        ErrorCode = 0;

                        /* Determine what report the Host is attempting to    */
                        /* write.                                             */
                        if((SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E) || (SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E) || (SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT) || ((SetReportRequestData->ReportType == QAPI_BLE_RT_REPORT_E) && (SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT)) || ((SetReportRequestData->ReportType == QAPI_BLE_RT_REPORT_E) && (SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT)))
                        {
                            /* Handle the set keyboard output report request.  */
                            if((SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E) || ((SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT) && (SetReportRequestData->ReportReferenceData.ReportID == HID_KEYBOARD_OUTPUT_REPORT_ID)))
                            {
                                if(SetReportRequestData->ReportLength <= HID_KEYBOARD_OUTPUT_REPORT_SIZE)
                                {
                                    KeyboardOutputReportSize = SetReportRequestData->ReportLength;
                                    memcpy(KeyboardOutputReport, SetReportRequestData->Report, SetReportRequestData->ReportLength);

                                    if(SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_OUTPUT_REPORT_E)
                                        LOG_AT_EVT("EVT_BLE:    Boot Keyboard Output Report:\n");
                                    else
                                        LOG_AT_EVT("EVT_BLE:    Keyboard Output Report:\n");

                                    /* Set the LEDs appropriately.               */
                                    if(KeyboardOutputReport[0] & HID_KEYBOARD_OUTPUT_REPORT_CAPS_LOCK)
                                        LOG_AT_EVT("EVT_BLE:       Caps Lock Pressed.\n");

                                    if(KeyboardOutputReport[0] & HID_KEYBOARD_OUTPUT_REPORT_NUM_LOCK)
                                        LOG_AT_EVT("EVT_BLE:       Num Lock Pressed.\n");
                                }
                                else
                                    ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_RESOURCES;
                            }
                            else
                            {
                                /* Store the keyboard input report data.        */
                                if((SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E) || ((SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT) && (SetReportRequestData->ReportReferenceData.ReportID == HID_KEYBOARD_INPUT_REPORT_ID)))
                                {
                                    if(SetReportRequestData->ReportLength <= HID_KEYBOARD_INPUT_REPORT_SIZE)
                                    {
                                        KeyboardInputReportSize = SetReportRequestData->ReportLength;
                                        memcpy(KeyboardInputReport, SetReportRequestData->Report, SetReportRequestData->ReportLength);

                                        if(SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_KEYBOARD_INPUT_REPORT_E)
                                            LOG_AT_EVT("EVT_BLE:    Boot Keyboard Input Report:\n");
                                        else
                                            LOG_AT_EVT("EVT_BLE:    Keyboard Input Report:\n");
                                    }
                                    else
                                        ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_RESOURCES;
                                }
                                else
                                {
                                    /* Store the mouse input report data.        */
                                    if((SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT) || ((SetReportRequestData->ReportReferenceData.ReportType == QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT) && (SetReportRequestData->ReportReferenceData.ReportID == HID_MOUSE_INPUT_REPORT_ID)))
                                    {
                                        if(SetReportRequestData->ReportLength <= HID_MOUSE_INPUT_REPORT_SIZE)
                                        {
                                            MouseInputReportSize = SetReportRequestData->ReportLength;
                                            memcpy(MouseInputReport, SetReportRequestData->Report, SetReportRequestData->ReportLength);

                                            if(SetReportRequestData->ReportType == QAPI_BLE_RT_BOOT_MOUSE_INPUT_REPORT)
                                                LOG_AT_EVT("EVT_BLE:    Boot Mouse Input Report:\n");
                                            else
                                                LOG_AT_EVT("EVT_BLE:    Mouse Input Report:\n");
                                        }
                                        else
                                            ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_RESOURCES;
                                    }
                                }
                            }
                        }
                        else
                            ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_UNLIKELY_ERROR;
                    }
                    else
                        ErrorCode = QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INSUFFICIENT_ENCRYPTION;

                    LOG_AT_EVT("EVT_BLE:       Report Length: %d.\n", SetReportRequestData->ReportLength);

                    /* Output the report value.                              */
                    LOG_AT_EVT("EVT_BLE:       Report Value:  ");
                    for(Index = 0; Index < SetReportRequestData->ReportLength; Index++)
                        LOG_AT_EVT("EVT_BLE: 0x%02X ", SetReportRequestData->Report[Index]);
                    LOG_AT_EVT("EVT_BLE: \n");

                    /* Respond to the Set Report Request.                    */
                    Result = qc_drv_ble_HIDS_Set_Report_Response(qc_api_get_qc_drv_context(), BluetoothStackID, HIDSInstanceID, SetReportRequestData->TransactionID, SetReportRequestData->ReportType, &(SetReportRequestData->ReportReferenceData), ErrorCode);
                    if(Result)
                        LOG_AT_EVT("EVT_BLE: qapi_BLE_HIDS_Set_Report_Response() %d.\n", Result);
                }
                break;
            case QAPI_BLE_ET_HIDS_SERVER_CONTROL_POINT_COMMAND_INDICATION_E:
                if(HIDS_Event_Data->Event_Data.HIDS_Control_Point_Command_Data)
                    LOG_AT_EVT("EVT_BLE: HID Control Point Command: %s (%u).\n", ((HIDS_Event_Data->Event_Data.HIDS_Control_Point_Command_Data->ControlPointCommand == QAPI_BLE_PC_SUSPEND_E)?"Suspend":"Exit Suspend"), (unsigned int)HIDS_Event_Data->Event_Data.HIDS_Control_Point_Command_Data->ControlPointCommand);
                break;
            default:
                LOG_AT_EVT("EVT_BLE: Unknown HIDS Event\n");
                break;
        }
    }
    else
    {
        /* There was an error with one or more of the input parameters.   */
        LOG_AT("\n");

        LOG_AT_EVT("EVT_BLE: \nHIDS Callback Data: Event_Data = NULL.\n");
    }
}
/* The following is a SCPS Server Event Callback.  This function will*/
/* be called whenever an SCPS Server Profile Event occurs that is    */
/* associated with the specified Bluetooth Stack ID.  This function  */
/* passes to the caller the Bluetooth Stack ID, the SCPS Event Data  */
/* that occurred and the SCPS Event Callback Parameter that was      */
/* specified when this Callback was installed.  The caller is free to*/
/* use the contents of the SCPS Event Data ONLY in the context of    */
/* this callback.  If the caller requires the Data for a longer      */
/* period of time, then the callback function MUST copy the data     */
/* into another Data Buffer This function is guaranteed NOT to be    */
/* invoked more than once simultaneously for the specified installed */
/* callback (i.e.  this function DOES NOT have be re-entrant). It    */
/* needs to be noted however, that if the same Callback is installed */
/* more than once, then the callbacks will be called serially.       */
/* Because of this, the processing in this function should be as     */
/* efficient as possible.  It should also be noted that this function*/
/* is called in the Thread Context of a Thread that the User does NOT*/
/* own. Therefore, processing in this function should be as efficient*/
/* as possible (this argument holds anyway because another SCPS Event*/
/* will not be processed while this function call is outstanding).   */
/* ** NOTE ** This function MUST NOT Block and wait for events that  */
/*            can only be satisfied by Receiving SCPS Event Packets. */
/*            A Deadlock WILL occur because NO SCPS Event Callbacks  */
/*            will be issued while this function is currently        */
/*            outstanding.                                           */
static void QAPI_BLE_BTPSAPI SCPS_EventCallback(uint32_t BluetoothStackID, qapi_BLE_SCPS_Event_Data_t *SCPS_Event_Data, uint32_t CallbackParameter)
{
    int           Result;
    BoardStr_t    BoardStr;
    DeviceInfo_t *DeviceInfo;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (SCPS_Event_Data))
    {
        switch(SCPS_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_SCPS_SERVER_READ_CLIENT_CONFIGURATION_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: etSCPS_Server_Read_Client_Configuration_Request with size %u.\n", SCPS_Event_Data->Event_Data_Size);

                if(SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data)
                {
                    BD_ADDRToStr(SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->RemoteDevice, BoardStr);

                    LOG_AT_EVT("EVT_BLE:    Instance ID:      %u.\n", SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:    %u.\n", SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:   %u.\n", SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:  %s.\n", ((SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
                    LOG_AT_EVT("EVT_BLE:    Remote Device:    %s.\n", BoardStr);

                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->RemoteDevice)) != NULL)
                    {
                        if(SCPSInstanceID == SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->InstanceID)
                        {
                            switch(SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->ClientConfigurationType)
                            {
                                case QAPI_BLE_CT_SCAN_REFRESH_E:
                                    LOG_AT_EVT("EVT_BLE: Config Type:      QAPI_BLE_CT_SCAN_REFRESH_E.\n");

                                    Result = qc_drv_ble_SCPS_Read_Client_Configuration_Response(qc_api_get_qc_drv_context(), BluetoothStackID, SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->InstanceID, SCPS_Event_Data->Event_Data.SCPS_Read_Client_Configuration_Data->TransactionID, DeviceInfo->SCPSServerInfo.Scan_Refresh_Client_Configuration);
                                    break;

                                default:
                                    Result = 0;
                                    LOG_AT_EVT("EVT_BLE: Config Type:      Unknown.\n");
                                    break;
                            }

                            if(Result)
                                DisplayFunctionError("qapi_BLE_SCPS_Read_Client_Configuration_Response", Result);
                        }
                        else
                        {
                            LOG_AT_EVT("EVT_BLE: \nInvalid Event data.\n");
                        }
                    }
                    else
                    {
                        LOG_AT_EVT("EVT_BLE: \nUnknown Client.\n");
                    }
                }
                break;
            case QAPI_BLE_ET_SCPS_SERVER_UPDATE_CLIENT_CONFIGURATION_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: etSCPS_Server_Update_Client_Configuration_Request with size %u.\n", SCPS_Event_Data->Event_Data_Size);

                if(SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data)
                {
                    BD_ADDRToStr(SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->RemoteDevice, BoardStr);

                    LOG_AT_EVT("EVT_BLE:    Instance ID:      %u.\n", SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:    %u.\n", SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:  %s.\n", ((SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
                    LOG_AT_EVT("EVT_BLE:    Remote Device:    %s.\n", BoardStr);

                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->RemoteDevice)) != NULL)
                    {
                        if(SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->InstanceID == SCPSInstanceID)
                        {
                            switch(SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ClientConfigurationType)
                            {
                                case QAPI_BLE_CT_SCAN_REFRESH_E:
                                    LOG_AT_EVT("EVT_BLE:    Config Type:      QAPI_BLE_CT_SCAN_REFRESH_E.\n");

                                    DeviceInfo->SCPSServerInfo.Scan_Refresh_Client_Configuration = SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ClientConfiguration;
                                    break;
                                default:
                                    LOG_AT_EVT("EVT_BLE:    Config Type:      Unknown.\n");
                                    break;
                            }

                            LOG_AT_EVT("EVT_BLE: Value:            0x%04X.\n", (uint16_t)SCPS_Event_Data->Event_Data.SCPS_Client_Configuration_Update_Data->ClientConfiguration);
                        }
                        else
                        {
                            LOG_AT_EVT("EVT_BLE: \nInvalid Event data.\n");
                        }
                    }
                    else
                    {
                        LOG_AT_EVT("EVT_BLE: \nUnknown Client.\n");
                    }
                }
                break;
            case QAPI_BLE_ET_SCPS_SERVER_WRITE_SCAN_INTERVAL_WINDOW_REQUEST_E:
                LOG_AT_EVT("EVT_BLE: etSCPS_Server_Write_Scan_Interval_Window_Request with size %u.\n", SCPS_Event_Data->Event_Data_Size);

                if(SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data)
                {
                    BD_ADDRToStr(SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Instance ID:      %u.\n", SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->InstanceID);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:    %u.\n", SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:  %s.\n", ((SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR"));
                    LOG_AT_EVT("EVT_BLE:    Remote Device:    %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE:    LE Scan Interval: %d.\n", SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->ScanIntervalWindowData.LE_Scan_Interval);
                    LOG_AT_EVT("EVT_BLE:    LE Scan Window:   %d.\n", SCPS_Event_Data->Event_Data.SCPS_Write_Scan_Interval_Window_Data->ScanIntervalWindowData.LE_Scan_Window);
                }
                break;
            default:
                LOG_AT_EVT("EVT_BLE: Unknown SCPS Event\n");
                break;
        }
    }
    else
    {
        /* There was an error with one or more of the input parameters.   */
        LOG_AT("\n");

        LOG_AT_EVT("EVT_BLE: SCPS Callback Data: Event_Data = NULL.\n");
    }
}

/* The following function is for an GATT Server Event Callback.  This*/
/* function will be called whenever a GATT Request is made to the    */
/* server who registers this function that cannot be handled         */
/* internally by GATT.  This function passes to the caller the GATT  */
/* Server Event Data that occurred and the GATT Server Event Callback*/
/* Parameter that was specified when this Callback was installed.    */
/* The caller is free to use the contents of the GATT Server Event   */
/* Data ONLY in the context of this callback.  If the caller requires*/
/* the Data for a longer period of time, then the callback function  */
/* MUST copy the data into another Data Buffer.  This function is    */
/* guaranteed NOT to be invoked more than once simultaneously for the*/
/* specified installed callback (i.e.  this function DOES NOT have be*/
/* reentrant).  It Needs to be noted however, that if the same       */
/* Callback is installed more than once, then the callbacks will be  */
/* called serially.  Because of this, the processing in this function*/
/* should be as efficient as possible.  It should also be noted that */
/* this function is called in the Thread Context of a Thread that the*/
/* User does NOT own.  Therefore, processing in this function should */
/* be as efficient as possible (this argument holds anyway because   */
/* another GATT Event (Server/Client or Connection) will not be      */
/* processed while this function call is outstanding).               */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ServerEventCallback_SPPLE(uint32_t BluetoothStackID, qapi_BLE_GATT_Server_Event_Data_t *GATT_ServerEventData, uint32_t CallbackParameter)
{
    boolean_t     DisplayPrompt;
    uint8_t       Temp[2];
    uint16_t      Value;
    uint16_t      PreviousValue;
    uint16_t      AttributeOffset;
    uint16_t      AttributeLength;
    DeviceInfo_t *DeviceInfo;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GATT_ServerEventData))
    {
        DisplayPrompt = false;

        /* Grab the device for the currently connected device.            */
        if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, SelectedRemoteBD_ADDR)) != NULL)
        {
            switch(GATT_ServerEventData->Event_Data_Type)
            {
                case QAPI_BLE_ET_GATT_SERVER_READ_REQUEST_E:
                    /* Verify that the Event Data is valid.                  */
                    if(GATT_ServerEventData->Event_Data.GATT_Read_Request_Data)
                    {
                        if(GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->AttributeValueOffset == 0)
                        {
                            /* Determine which request this read is coming for.*/
                            switch(GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->AttributeOffset)
                            {
                                case SPPLE_TX_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET:
                                    ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(Temp, DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor);
                                    break;
                                case SPPLE_TX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET:
                                    ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(Temp, DeviceInfo->TransmitCredits);
                                    break;
                                case SPPLE_RX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET:
                                    ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(Temp, DeviceInfo->ReceiveBuffer.BytesFree);
                                    break;
                                case SPPLE_RX_CREDITS_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET:
                                    ASSIGN_HOST_WORD_TO_LITTLE_ENDIAN_UNALIGNED_WORD(Temp, DeviceInfo->ServerInfo.Rx_Credit_Client_Configuration_Descriptor);
                                    break;
                            }

                            qapi_BLE_GATT_Read_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->TransactionID, sizeof(Temp), Temp);
                        }
                        else
                            qapi_BLE_GATT_Error_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->TransactionID, GATT_ServerEventData->Event_Data.GATT_Read_Request_Data->AttributeOffset, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_ATTRIBUTE_NOT_LONG);
                    }
                    else
                    {
                        LOG_AT_EVT("EVT_BLE: Invalid Read Request Event Data.\n");
                        DisplayPrompt = true;
                    }
                    break;
                case QAPI_BLE_ET_GATT_SERVER_WRITE_REQUEST_E:
                    /* Verify that the Event Data is valid.                  */
                    if(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data)
                    {
                        if(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValueOffset == 0)
                        {
                            /* Cache the Attribute Offset.                     */
                            AttributeOffset = GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeOffset;
                            AttributeLength = GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValueLength;

                            /* Check to see if this write is OK for our role.  */
                            if((AttributeOffset == SPPLE_TX_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET) || (AttributeOffset == SPPLE_RX_CREDITS_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET))
                            {
                                /* Check to see if we know if we are the Client */
                                /* or Server.                                   */
                                if(!(DeviceInfo->Flags & (DEVICE_INFO_FLAGS_SPPLE_CLIENT | DEVICE_INFO_FLAGS_SPPLE_SERVER)))
                                {
                                    /* We will be the Server for this device.    */
                                    DeviceInfo->Flags |= DEVICE_INFO_FLAGS_SPPLE_SERVER;
                                }
                                else
                                {
                                    /* This indicates that we are acting as a    */
                                    /* Server.  Error the request if we are a    */
                                    /* Client                                    */
                                    if(DeviceInfo->Flags & DEVICE_INFO_FLAGS_SPPLE_CLIENT)
                                    {
                                        /* Cause the Request to be invalid.       */
                                        AttributeLength = 0;
                                    }
                                }
                            }

                            /* Verify that the value is of the correct length. */
                            if((AttributeOffset == SPPLE_RX_CHARACTERISTIC_ATTRIBUTE_OFFSET) || ((AttributeLength) && (AttributeLength <= sizeof(uint16_t))))
                            {
                                /* Since the value appears valid go ahead and   */
                                /* accept the write request.                    */
                                qapi_BLE_GATT_Write_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->TransactionID);

                                /* If this is not a write to the Rx             */
                                /* Characteristic we will read the data here.   */
                                if(AttributeOffset != SPPLE_RX_CHARACTERISTIC_ATTRIBUTE_OFFSET)
                                {
                                    if(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValueLength == sizeof(uint16_t))
                                        Value = READ_UNALIGNED_WORD_LITTLE_ENDIAN(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValue);
                                    else
                                        Value = READ_UNALIGNED_BYTE_LITTLE_ENDIAN(GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValue);
                                }
                                else
                                    Value = 0;

                                /* Determine which attribute this write request */
                                /* is for.                                      */
                                switch(AttributeOffset)
                                {
                                    case SPPLE_TX_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET:
                                        /* Client has updated the Tx CCCD.  Now we*/
                                        /* need to check if we have any data to   */
                                        /* send.                                  */
                                        DeviceInfo->ServerInfo.Tx_Client_Configuration_Descriptor = Value;

                                        /* If may be possible for transmit queued */
                                        /* data now.  So fake a Receive Credit    */
                                        /* event with 0 as the received credits.  */
                                        DisplayPrompt = ReceiveCreditEvent(DeviceInfo, 0);
                                        break;
                                    case SPPLE_TX_CREDITS_CHARACTERISTIC_ATTRIBUTE_OFFSET:
                                        /* Client has sent updated credits.       */
                                        DisplayPrompt = ReceiveCreditEvent(DeviceInfo, Value);
                                        break;
                                    case SPPLE_RX_CHARACTERISTIC_ATTRIBUTE_OFFSET:
                                        /* Client has sent data, so we should     */
                                        /* handle this as a data indication event.*/
                                        DisplayPrompt = DataIndicationEvent(DeviceInfo, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValueLength, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeValue);
                                        break;
                                    case SPPLE_RX_CREDITS_CHARACTERISTIC_CCD_ATTRIBUTE_OFFSET:
                                        /* Cache the previous CCD Value.          */
                                        PreviousValue = DeviceInfo->ServerInfo.Rx_Credit_Client_Configuration_Descriptor;

                                        /* Note the updated Rx CCCD Value.        */
                                        DeviceInfo->ServerInfo.Rx_Credit_Client_Configuration_Descriptor = Value;

                                        /* If we were not previously configured   */
                                        /* for notifications send the initial     */
                                        /* credits to the device.                 */
                                        if(PreviousValue != QAPI_BLE_GATT_CLIENT_CONFIGURATION_CHARACTERISTIC_NOTIFY_ENABLE)
                                        {
                                            /* Send the initial credits to the     */
                                            /* device.                             */
                                            SendCredits(DeviceInfo, DeviceInfo->ReceiveBuffer.BytesFree);
                                        }
                                        break;
                                }
                            }
                            else
                                qapi_BLE_GATT_Error_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->TransactionID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeOffset, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_ATTRIBUTE_VALUE_LENGTH);
                        }
                        else
                            qapi_BLE_GATT_Error_Response(BluetoothStackID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->TransactionID, GATT_ServerEventData->Event_Data.GATT_Write_Request_Data->AttributeOffset, QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_ATTRIBUTE_NOT_LONG);
                    }
                    else
                    {
                        LOG_AT_EVT("EVT_BLE: Invalid Write Request Event Data.\n");
                        DisplayPrompt = true;
                    }
                    break;
                default:
                    break;
            }
        }

        if(DisplayPrompt)
            QCLI_Display_Prompt();
    }
}

/* Generic Attribute Profile (GATT) Service Event Callback function  */
/* prototypes (Client).                                              */

/* The following function is for an GATT Client Event Callback.  This*/
/* function will be called whenever a GATT Response is received for a*/
/* request that was made when this function was registered.  This    */
/* function passes to the caller the GATT Client Event Data that     */
/* occurred and the GATT Client Event Callback Parameter that was    */
/* specified when this Callback was installed.  The caller is free to*/
/* use the contents of the GATT Client Event Data ONLY in the context*/
/* of this callback.  If the caller requires the Data for a longer   */
/* period of time, then the callback function MUST copy the data into*/
/* another Data Buffer.  This function is guaranteed NOT to be       */
/* invoked more than once simultaneously for the specified installed */
/* callback (i.e.  this function DOES NOT have be reentrant).  It    */
/* Needs to be noted however, that if the same Callback is installed */
/* more than once, then the callbacks will be called serially.       */
/* Because of this, the processing in this function should be as     */
/* efficient as possible.  It should also be noted that this function*/
/* is called in the Thread Context of a Thread that the User does NOT*/
/* own.  Therefore, processing in this function should be as         */
/* efficient as possible (this argument holds anyway because another */
/* GATT Event (Server/Client or Connection) will not be processed    */
/* while this function call is outstanding).                         */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_AIOS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
    int                                         Result;
    DeviceInfo_t                               *DeviceInfo;
    BoardStr_t                                  BoardStr;
    uint32_t                                    ConnectionID;
    uint32_t                                    TransactionID;
    qapi_BLE_GATT_Connection_Type_t             ConnectionType;
    qapi_BLE_BD_ADDR_t                          RemoteDevice;
    uint16_t                                    ValueLength;
    uint8_t                                    *Value;
    uint16_t                                    BytesWritten;
    qapi_BLE_GATT_Request_Error_Type_t          ErrorType;
    AIOP_Client_Instance_Info_t                *InstanceInfoPtr = NULL;
    union
    {
        qapi_BLE_AIOS_Characteristic_Data_t      Data;
        uint16_t                                 CCCD;
        qapi_BLE_AIOS_Presentation_Format_Data_t PresentationFormat;
    } ReadResponseData;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GATT_Client_Event_Data))
    {
        /* Determine the event that occurred.                             */
        switch(GATT_Client_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
                LOG_AT_EVT("EVT_BLE: QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E\n");
                if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
                {
                    /* Store the event data.                                 */
                    ConnectionID   = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID;
                    RemoteDevice   = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice;
                    TransactionID  = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID;
                    ConnectionType = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType;
                    ErrorType      = GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType;

                    LOG_AT_EVT("EVT_BLE:    Connection ID:    %u.\n", ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:   %u.\n", TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:  %s.\n", (ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR");
                    BD_ADDRToStr(RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    BD_ADDR:          %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Error Type:       %s.\n", (ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E) ? "Response Error" : "Response Timeout");

                    /* Only print out the rest if it is valid.               */
                    if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
                    {
                        LOG_AT_EVT("EVT_BLE:    Request Opcode:   0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                        LOG_AT_EVT("EVT_BLE:    Request Handle:   0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                        LOG_AT_EVT("EVT_BLE:    Error Code:       0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);

                        /* Print common error codes.                          */
                        switch(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode)
                        {
                            case QAPI_BLE_AIOS_ERROR_CODE_TRIGGER_CONDITION_VALUE_NOT_SUPPORTED:
                                LOG_AT_EVT("EVT_BLE:    Error Mesg:       AIOS_ERROR_CODE_TRIGGER_CONDITION_VALUE_NOT_SUPPORTED\n");
                                break;
                            default:
                                if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode < NUMBER_OF_ERROR_CODES)
                                {
                                    LOG_AT_EVT("EVT_BLE: Mesg:       %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
                                }
                                else
                                {
                                    LOG_AT_EVT("EVT_BLE: Mesg:       Unknown.\n");
                                }
                                break;
                        }
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Error Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
                LOG_AT_EVT("EVT_BLE: QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E\n");
                if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
                {
                    /* Store the event data.                                 */
                    ConnectionID   = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionID;
                    RemoteDevice   = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice;
                    TransactionID  = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->TransactionID;
                    ConnectionType = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionType;
                    ValueLength    = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength;
                    Value          = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue;

                    /* Print the event data.                                 */
                    LOG_AT_EVT("EVT_BLE:    Connection ID:    %u.\n", ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:   %u.\n", TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:  %s.\n", (ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR");
                    BD_ADDRToStr(RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    BD_ADDR:          %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Handle:           0x%04X.\n", CallbackParameter);
                    LOG_AT_EVT("EVT_BLE:    Value Length:     %u.\n", ValueLength);

                    /* Make sure we can get the device information.          */
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, RemoteDevice)) != NULL)
                    {
                        /* Process the request depending on the attribute     */
                        /* handle type we set before issuing the read request.*/
                        switch(DeviceInfo->AIOPClientInfo.Client_Request_Info.AttributeHandleType)
                        {
                            case ahtCharacteristic:
                                /* We need to determine the type of AIOS        */
                                /* Characteristic to properly decode the value. */
                                switch(DeviceInfo->AIOPClientInfo.Client_Request_Info.Type)
                                {
                                    case QAPI_BLE_ACT_DIGITAL_E:
                                        /* Call the function to decode and display*/
                                        /* the Digital Characteristic.            */
                                        DecodeDisplayDigitalCharacteristic(ValueLength, Value, DeviceInfo->AIOPClientInfo.Client_Request_Info.ID);
                                        break;
                                    case QAPI_BLE_ACT_ANALOG_E:
                                        /* Call the function to decode and display*/
                                        /* the Analog Characteristic.             */
                                        DecodeDisplayAnalogCharacteristic(ValueLength, Value, DeviceInfo->AIOPClientInfo.Client_Request_Info.ID);
                                        break;
                                    default:
                                        LOG_AT_EVT("EVT_BLE: \nError - Invalid Characteristic type.\n");
                                        break;
                                }
                                break;
                            case ahtPresentationFormat:
                                /* Simply call the AIOS Client API to decode the*/
                                /* Presentation Format.                         */
                                if((Result = qc_drv_ble_AIOS_Decode_Presentation_Format(qc_api_get_qc_drv_context(), ValueLength, Value, &ReadResponseData.PresentationFormat)) == 0)
                                {
                                    /* Simply call the internal function to      */
                                    /* display the Presentation Format           */
                                    /* descriptor.                               */
                                    DisplayAIOSPresentationFormatData(&ReadResponseData.PresentationFormat);
                                }
                                else
                                    DisplayFunctionError("qapi_BLE_AIOS_Decode_Presentation_Format",  Result);
                                break;
                            case ahtNumberOfDigitals:
                                /* Display the descriptor type.                 */
                                LOG_AT_EVT("EVT_BLE: \nNumber Of Digitals:\n");

                                /* Verify the length of the number of digitals. */
                                /* * NOTE * At least one octet, or 4 possible   */
                                /*          digital signals MUST be present.    */
                                if(ValueLength >= (uint16_t)QAPI_BLE_NON_ALIGNED_BYTE_SIZE)
                                {
                                    /* Let's get the instance information based  */
                                    /* on the Type and ID we previously stored   */
                                    /* when the request was sent so we can store */
                                    /* the Number of Digitals value in the       */
                                    /* instance's information.                   */
                                    InstanceInfoPtr = GetAIOSClientInstanceInfoPtr(&(DeviceInfo->AIOPClientInfo));
                                    if(InstanceInfoPtr)
                                    {
                                        /* Decode the value.                      */
                                        InstanceInfoPtr->Number_Of_Digitals = READ_UNALIGNED_BYTE_LITTLE_ENDIAN(Value);

                                        /* Display the value.                     */
                                        LOG_AT_EVT("EVT_BLE:    Value:  %u\n", InstanceInfoPtr->Number_Of_Digitals);
                                    }
                                    else
                                        LOG_AT_EVT("EVT_BLE: \nError - Could not find the Characteristic instance's information.\n");
                                }
                                else
                                    LOG_AT_EVT("EVT_BLE:    Value:  Invalid length.\n");
                                break;
                            default:
                                LOG_AT_EVT("EVT_BLE: Invalid attribute handle type.\n");
                                break;
                        }
                    }
                    else
                        LOG_AT_EVT("EVT_BLE: Unknown device.\n");
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Read Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
                LOG_AT_EVT("EVT_BLE: etGATT_Client_Write_Response.\n");
                if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
                {
                    /* Store the event data.                                 */
                    ConnectionID   = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID;
                    RemoteDevice   = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice;
                    TransactionID  = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID;
                    ConnectionType = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType;
                    BytesWritten   = GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten;

                    /* Print the event data.                                 */
                    LOG_AT_EVT("EVT_BLE:    Connection ID:    %u.\n", ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:   %u.\n", TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type:  %s.\n", (ConnectionType == QAPI_BLE_GCT_LE_E) ? "LE" : "BR/EDR");
                    BD_ADDRToStr(RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    BD_ADDR:          %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Bytes Written:    %u.\n", BytesWritten);
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Write Response Data.\n");
                break;
            default:
                /* Prevent compiler warnings.                               */
                break;
        }
    }
    else
    {
        /* There was an error with one or more of the input parameters.   */
        LOG_AT("\n");

        LOG_AT_EVT("EVT_BLE: GATT Callback Data: Event_Data = NULL.\n");
    }
}

/* The following function is for an GATT Client Event Callback.  This*/
/* function will be called whenever a GATT Response is received for a*/
/* request that was made when this function was registered.  This    */
/* function passes to the caller the GATT Client Event Data that     */
/* occurred and the GATT Client Event Callback Parameter that was    */
/* specified when this Callback was installed.  The caller is free to*/
/* use the contents of the GATT Client Event Data ONLY in the context*/
/* of this callback.  If the caller requires the Data for a longer   */
/* period of time, then the callback function MUST copy the data into*/
/* another Data Buffer.  This function is guaranteed NOT to be       */
/* invoked more than once simultaneously for the specified installed */
/* callback (i.e.  this function DOES NOT have be reentrant).  It    */
/* Needs to be noted however, that if the same Callback is installed */
/* more than once, then the callbacks will be called serially.       */
/* Because of this, the processing in this function should be as     */
/* efficient as possible.  It should also be noted that this function*/
/* is called in the Thread Context of a Thread that the User does NOT*/
/* own.  Therefore, processing in this function should be as         */
/* efficient as possible (this argument holds anyway because another */
/* GATT Event (Server/Client or Connection) will not be processed    */
/* while this function call is outstanding).                         */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_BAS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
    int                                      Result;
    uint8_t                                  BatteryLevel;
    uint16_t                                 ValueLength;
    uint16_t                                 Index;
    BoardStr_t                               BoardStr;
    DeviceInfo_t                            *DeviceInfo;
    qapi_BLE_BAS_Presentation_Format_Data_t  BatteryLevelFormatData;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GATT_Client_Event_Data))
    {
        /* Determine the event that occurred.                             */
        switch(GATT_Client_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Error Response: %02X\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE:    Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE:    Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE:    Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE:    BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

                    /* Only print out the rest if it is valid.               */
                    if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
                    {
                        LOG_AT_EVT("EVT_BLE:    Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                        LOG_AT_EVT("EVT_BLE:    Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                        LOG_AT_EVT("EVT_BLE: Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                        LOG_AT_EVT("EVT_BLE: Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Error Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Read Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Data Length:     %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength);

                    /* If we know about this device and a callback parameter */
                    /* exists, then check if we know what read response this */
                    /* is.                                                   */
                    ValueLength = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength;
                    if(ValueLength != 0)
                    {
                        if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                        {
                            if(IsBatteryLevelHandle((uint16_t)CallbackParameter, DeviceInfo))
                            {
                                if(ValueLength == QAPI_BLE_BAS_BATTERY_LEVEL_VALUE_LENGTH)
                                {
                                    BatteryLevel = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue[0];
                                    if(QAPI_BLE_BAS_VALID_BATTERY_LEVEL(BatteryLevel))
                                        LOG_AT_EVT("EVT_BLE: \n   Battery Level: %u%%.\n", (uint16_t)BatteryLevel);
                                    else
                                        LOG_AT_EVT("EVT_BLE: Battery Level has been corrupted %d\n", BatteryLevel);
                                }
                                else
                                    LOG_AT_EVT("EVT_BLE: Invalid length (%u) for Battery Level response\n", ValueLength);
                            }
                            else
                            {
                                if(IsBatteryLevelPresentationFormatHandle((uint16_t)CallbackParameter,DeviceInfo))
                                {
                                    if(ValueLength == QAPI_BLE_BAS_PRESENTATION_FORMAT_SIZE)
                                    {
                                        if((Result = qc_drv_ble_BAS_Decode_Characteristic_Presentation_Format(qc_api_get_qc_drv_context(), GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue, &BatteryLevelFormatData)) == 0)
                                        {
                                            LOG_AT_EVT("EVT_BLE: \n   Format: %u.\n",      BatteryLevelFormatData.Format);
                                            LOG_AT_EVT("EVT_BLE: \n   Exponent: %u.\n",    BatteryLevelFormatData.Exponent);
                                            LOG_AT_EVT("EVT_BLE: \n   Unit: %u.\n",        BatteryLevelFormatData.Unit);
                                            LOG_AT_EVT("EVT_BLE: \n   NameSpace: %u.\n",   BatteryLevelFormatData.NameSpace);
                                            LOG_AT_EVT("EVT_BLE: \n   Description: %u.\n", BatteryLevelFormatData.Description);
                                        }
                                        else
                                            DisplayFunctionError("qapi_BLE_BAS_Decode_Characteristic_Presentation_Format", Result);
                                    }
                                    else
                                        LOG_AT_EVT("EVT_BLE: Invalid length (%u) for Battery Level Presentation Format response.\n", ValueLength);
                                }
                                else
                                {
                                    /* Could not find a descriptor to match the  */
                                    /* read response, so display raw data        */
                                    CallbackParameter = 0;
                                }
                            }
                        }

                        /* If the data has not been decoded and displayed,    */
                        /* then just display the raw data                     */
                        if((DeviceInfo == NULL) || (CallbackParameter == 0))
                        {
                            LOG_AT_EVT("EVT_BLE: Data:            { ");
                            for(Index = 0; Index < (ValueLength - 1); Index++)
                                LOG_AT_EVT("EVT_BLE: 0x%02x, ", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue[Index]);

                            LOG_AT_EVT("EVT_BLE: 0x%02x }\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue[Index]);
                        }
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Read Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Write Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);

                    /* If we know about this device and a callback parameter */
                    /* exists, then check if we know what write response this*/
                    /* is.                                                   */
                    if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                    {
                        if(IsBASClientConfigurationHandle((uint16_t)CallbackParameter, DeviceInfo))
                            LOG_AT_EVT("EVT_BLE: \nWrite Battery Level CC Compete.\n");
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Write Response Data.\n");
                break;
            default:
                break;
        }
    }
    else
    {
        /* There was an error with one or more of the input parameters.   */
        LOG_AT("\n");

        LOG_AT_EVT("EVT_BLE: GATT Callback Data: Event_Data = NULL.\n");
    }
}

/* The following function is for an GATT Client Event Callback. This */
/* function will be called whenever a GATT Response is received for  */
/* a request that was made when this function was registered. This   */
/* function passes to the caller the GATT Client Event Data that     */
/* occurred and the GATT Client Event Callback Parameter that was    */
/* specified when this Callback was installed. The caller is free to */
/* use the contents of the GATT Client Event Data ONLY in the        */
/* context of this callback. If the caller requires the Data for a   */
/* longer period of time, then the callback function MUST copy the   */
/* data into another Data Buffer. This function is guaranteed NOT to */
/* be invoked more than once simultaneously for the specified        */
/* installed callback (i.e. this function DOES NOT have be           */
/* reentrant). It Needs to be noted however, that if the same        */
/* Callback is installed more than once, then the callbacks will be  */
/* called serially. Because of this, the processing in this function */
/* should be as efficient as possible. It should also be noted that  */
/* this function is called in the Thread Context of a Thread that    */
/* the User does NOT own. Therefore, processing in this function     */
/* should be as efficient as possible (this argument holds anyway    */
/* because another GATT Event (Server/Client or Connection) will not */
/* be processed while this function call is outstanding).            */
/* * NOTE * This function MUST NOT Block and wait for Events that    */
/*          can only be satisfied by Receiving a Bluetooth Event     */
/*          Callback. A Deadlock WILL occur because NO Bluetooth     */
/*          Callbacks will be issued while this function is          */
/*          currently outstanding.                                   */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_HIDS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
    int                 Result;
    uint8_t            *ReportMap;
    uint8_t            *AttributeValue;
    uint16_t            AttributeValueLength;
    uint16_t            Index;
    boolean_t           CallbackParameterFound = FALSE;
    BoardStr_t          BoardStr;
    unsigned int        InstanceIndex;
    DeviceInfo_t       *DeviceInfo;
    HIDS_Client_Info_t *ClientInfo             = NULL;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GATT_Client_Event_Data))
    {
        /* Determine the event that occurred.                             */
        switch(GATT_Client_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
                {
                    /* Get the device info.                                  */
                    if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                    {
                        /* Loop through the HIDS client information array and */
                        /* find the service for this callback parameter.      */
                        for(Index = 0; Index < MAX_SUPPORTED_HID_INSTANCES; Index++)
                        {
                            if((CallbackParameter >= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Starting_Handle) && (CallbackParameter <= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Ending_Handle))
                            {
                                ClientInfo = &DeviceInfo->HIDSClientInfo[Index];
                                InstanceIndex = Index;
                                break;
                            }
                        }

                        /* Make sure the HIDS client information was found.   */
                        if(ClientInfo)
                        {
                            /* Output the error data unless this is an invalid */
                            /* offset error for the report map, as sometimes   */
                            /* this will mark the end of the attribute value.  */
                            if((CallbackParameter != ClientInfo->ReportMapHandle) || ((CallbackParameter == ClientInfo->ReportMapHandle) && (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode != QAPI_BLE_ATT_PROTOCOL_ERROR_CODE_INVALID_OFFSET)))
                            {
                                LOG_AT_EVT("EVT_BLE: Error Response.\n");
                                BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
                                LOG_AT_EVT("EVT_BLE:    Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
                                LOG_AT_EVT("EVT_BLE:    Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
                                LOG_AT_EVT("EVT_BLE:    Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                                LOG_AT_EVT("EVT_BLE:    BD_ADDR:         %s.\n", BoardStr);
                                LOG_AT_EVT("EVT_BLE: Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

                                /* Only print out the rest if it is valid.      */
                                if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
                                {
                                    LOG_AT_EVT("EVT_BLE:    Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                                    LOG_AT_EVT("EVT_BLE:    Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                                    LOG_AT_EVT("EVT_BLE: Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);

                                    if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode < NUMBER_OF_ERROR_CODES)
                                        LOG_AT_EVT("EVT_BLE: Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
                                }
                            }

                            /* Handle the report map callback.                 */
                            if(CallbackParameter == ClientInfo->ReportMapHandle)
                            {
                                /* Output the data if it exists.                */
                                if((ClientInfo->ReportMap) && (ClientInfo->ReportMapLength))
                                {
                                    LOG_AT_EVT("EVT_BLE: \nHIDS Report Map:\n");

                                    LOG_AT_EVT("EVT_BLE:    Report Map Length:  %d\n", ClientInfo->ReportMapLength);
                                    LOG_AT_EVT("EVT_BLE:    Report Map:         { ");
                                    for(Index = 0; Index < (ClientInfo->ReportMapLength-1); Index++)
                                        LOG_AT_EVT("EVT_BLE: 0x%02x, ", ClientInfo->ReportMap[Index]);

                                    LOG_AT_EVT("EVT_BLE: 0x%02x }\n\nRead HIDS information complete.\n", ClientInfo->ReportMap[Index]);
                                }

                                /* Read the next HID service information if it  */
                                /* exists.                                      */
                                if((InstanceIndex < (MAX_SUPPORTED_HID_INSTANCES - 1)) && (DeviceInfo->HIDSClientInfo[InstanceIndex+1].ReportMapHandle))
                                {
                                    LOG_AT_EVT("EVT_BLE: \nAttempting to read HIDS information (Instance ID %u)\n", InstanceIndex + 2);
                                    ReadHIDSInfo(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID, &(DeviceInfo->HIDSClientInfo[InstanceIndex+1]));
                                }
                            }
                            else
                            {
                                /* Handle the Boot Keyboard Input Report CCCD   */
                                /* callback.                                    */
                                if(CallbackParameter == ClientInfo->BootKeyboardInputReport_CCCD)
                                    LOG_AT_EVT("EVT_BLE: \nWrite HIDS Boot Keyboard Input Report CCCD failure.\n");
                                else
                                {
                                    /* Handle the Boot Mouse Input Report CCCD   */
                                    /* callback.                                 */
                                    if(CallbackParameter == ClientInfo->BootMouseInputReport_CCCD)
                                        LOG_AT_EVT("EVT_BLE: \nWrite HIDS Boot Mouse Input Report CCCD failure.\n");
                                    else
                                    {
                                        /* Handle an external report reference    */
                                        /* callback by looping through the list   */
                                        /* of external report references.         */
                                        for(Index=0; Index < HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES; Index++)
                                        {
                                            /* See if the callback exists as an    */
                                            /* external report reference handle.   */
                                            if(CallbackParameter == ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle)
                                            {
                                                LOG_AT_EVT("EVT_BLE: Read HIDS External Report Reference Data failure.\n");

                                                break;
                                            }
                                        }

                                        /* Handle a report reference callback by  */
                                        /* looping through the list of reports.   */
                                        for(Index=0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                                        {
                                            /* See if the callback exists as a     */
                                            /* report CCCD handle.                 */
                                            if(CallbackParameter == ClientInfo->Reports[Index].CCCDHandle)
                                            {
                                                LOG_AT_EVT("EVT_BLE: \nWrite HIDS Report ID %d CCCD failure.\n", ClientInfo->Reports[Index].ReportReferenceData.ReportID);
                                                break;
                                            }

                                            /* See if the callback exists as a     */
                                            /* report reference handle.            */
                                            if(CallbackParameter == ClientInfo->Reports[Index].ReportReferenceHandle)
                                            {
                                                LOG_AT_EVT("EVT_BLE: \nRead HIDS Report Reference Data failure.\n");
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Error Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_READ_LONG_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data)
                {
                    AttributeValue       = GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data->AttributeValue;
                    AttributeValueLength = GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data->AttributeValueLength;

                    /* If we know about this device and a callback parameter */
                    /* exists, then check if we know what read long response */
                    /* this is.                                              */
                    if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                    {
                        /* Loop through the HIDS client information array and */
                        /* find the service for this callback parameter.      */
                        for(Index = 0; Index < MAX_SUPPORTED_HID_INSTANCES; Index++)
                        {
                            if((CallbackParameter >= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Starting_Handle) && (CallbackParameter <= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Ending_Handle))
                            {
                                ClientInfo = &DeviceInfo->HIDSClientInfo[Index];
                                InstanceIndex = Index;
                                break;
                            }
                        }

                        /* Make sure the HIDS client information was found.   */
                        if(ClientInfo)
                        {
                            /* Handle the report map callback.                 */
                            if(CallbackParameter == ClientInfo->ReportMapHandle)
                            {
                                /* Handle any report map data returned.         */
                                if(AttributeValueLength != 0)
                                {
                                    /* Make sure the report map was previously   */
                                    /* allocated.                                */
                                    if(ClientInfo->ReportMap)
                                    {
                                        /* Allocate a buffer to hold the previuos */
                                        /* and the new report map data.           */
                                        if((ReportMap = malloc(AttributeValueLength + ClientInfo->ReportMapLength)) != NULL)
                                        {
                                            /* Copy the old data into the buffer.  */
                                            memcpy(ReportMap, ClientInfo->ReportMap, ClientInfo->ReportMapLength);

                                            /* Append the new data into the        */
                                            /* buffer.                             */
                                            memcpy((ReportMap + ClientInfo->ReportMapLength), AttributeValue, AttributeValueLength);

                                            /* Free the old data and increment the */
                                            /* report map length.                  */
                                            free(ClientInfo->ReportMap);
                                            ClientInfo->ReportMapLength += AttributeValueLength;

                                            /* Allocate the static buffer to the   */
                                            /* new size to hold the data we just   */
                                            /* copied.                             */
                                            if((ClientInfo->ReportMap = malloc(ClientInfo->ReportMapLength)) != NULL)
                                            {
                                                /* Copy the old and new data into   */
                                                /* the static buffer.               */
                                                memcpy(ClientInfo->ReportMap, ReportMap, ClientInfo->ReportMapLength);

                                                /* Try to read the next blob of     */
                                                /* report map data.                 */
                                                Result = qc_drv_ble_GATT_Read_Long_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, ClientInfo->ReportMapHandle, ClientInfo->ReportMapLength, GATT_ClientEventCallback_HIDS, ClientInfo->ReportMapHandle);
                                            }
                                            else
                                                LOG_AT_EVT("EVT_BLE: Read report map failure: Insufficient Buffer Space.\n");

                                            /* Free the local buffer.              */
                                            free(ReportMap);
                                        }
                                        else
                                            LOG_AT_EVT("EVT_BLE: Read report map failure: Insufficient Buffer Space.\n");
                                    }
                                }
                                else
                                {
                                    /* Handle zero data received, marking the    */
                                    /* end of the report map.                    */
                                    if(ClientInfo->ReportMapLength)
                                    {
                                        /* Print the data.                        */
                                        LOG_AT_EVT("EVT_BLE: \nHIDS Report Map:\n");

                                        LOG_AT_EVT("EVT_BLE:    Report Map Length:  %d\n", ClientInfo->ReportMapLength);
                                        LOG_AT_EVT("EVT_BLE:    Report Map:         { ");
                                        for(Index = 0; Index < (ClientInfo->ReportMapLength-1); Index++)
                                            LOG_AT_EVT("EVT_BLE: 0x%02x, ", ClientInfo->ReportMap[Index]);

                                        LOG_AT_EVT("EVT_BLE: 0x%02x }\n\nRead HIDS information complete.\n", ClientInfo->ReportMap[Index]);

                                        /* Read the next HID service information  */
                                        /* if it exists.                          */
                                        if((InstanceIndex < (MAX_SUPPORTED_HID_INSTANCES - 1)) && (DeviceInfo->HIDSClientInfo[InstanceIndex+1].ReportMapHandle))
                                        {
                                            LOG_AT_EVT("EVT_BLE: \nAttempting to read HIDS information (Instance ID %u)\n", InstanceIndex + 2);
                                            ReadHIDSInfo(GATT_Client_Event_Data->Event_Data.GATT_Read_Long_Response_Data->ConnectionID, &(DeviceInfo->HIDSClientInfo[InstanceIndex + 1]));
                                        }
                                    }
                                }
                            }
                            else
                            {
                                /* Could not find a descriptor to match the     */
                                /* read response, so display raw data           */
                                CallbackParameter = 0;
                            }

                            /* If the data has not been decoded and displayed, */
                            /* then just display the raw data                  */
                            if((DeviceInfo == NULL) || (CallbackParameter == 0))
                            {
                                LOG_AT_EVT("EVT_BLE:    Data:            { ");
                                for(Index = 0; Index < (AttributeValueLength - 1); Index++)
                                    LOG_AT_EVT("EVT_BLE: 0x%02x, ", AttributeValue[Index]);

                                LOG_AT_EVT("EVT_BLE: 0x%02x }\n", AttributeValue[Index]);
                            }
                        }
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: \nError - Null Read Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
                {
                    AttributeValue       = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue;
                    AttributeValueLength = GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength;

                    /* If we know about this device and a callback parameter */
                    /* exists, then check if we know what read response this */
                    /* is.                                                   */
                    if(AttributeValueLength != 0)
                    {
                        /* Get the device info.                               */
                        if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                        {
                            /* Loop through the HIDS client information array  */
                            /* and find the service for this callback          */
                            /* parameter.                                      */
                            for(Index = 0; Index < MAX_SUPPORTED_HID_INSTANCES; Index++)
                            {
                                if((CallbackParameter >= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Starting_Handle) && (CallbackParameter <= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Ending_Handle))
                                {
                                    ClientInfo = &DeviceInfo->HIDSClientInfo[Index];
                                    InstanceIndex = Index;
                                    break;
                                }
                            }

                            /* Make sure the HIDS client information was       */
                            /* found.                                          */
                            if(ClientInfo)
                            {
                                /* Handle the HID Information callback.         */
                                if(CallbackParameter == ClientInfo->HIDSInformationHandle)
                                {
                                    /* Check the value length.                   */
                                    if(AttributeValueLength == QAPI_BLE_HIDS_HID_INFORMATION_SIZE)
                                    {
                                        /* Decode the HID Information value.      */
                                        if((Result = qc_drv_ble_HIDS_Decode_HID_Information(qc_api_get_qc_drv_context(), AttributeValueLength, AttributeValue, &ClientInfo->HIDSInformation)) == 0)
                                        {
                                            /* Print out the information.          */
                                            LOG_AT_EVT("EVT_BLE: \nHIDS Information:\n");
                                            LOG_AT_EVT("EVT_BLE: Version:              %d\n", ClientInfo->HIDSInformation.Version);
                                            LOG_AT_EVT("EVT_BLE: Country Code:         %d\n", ClientInfo->HIDSInformation.CountryCode);
                                            LOG_AT_EVT("EVT_BLE: Remote Wake:          %s\n", ((ClientInfo->HIDSInformation.Flags & QAPI_BLE_HIDS_HID_INFORMATION_FLAGS_REMOTE_WAKE) ? "Supported" : "Not Supported"));
                                            LOG_AT_EVT("EVT_BLE: Normally Connectable: %s\n", ((ClientInfo->HIDSInformation.Flags & QAPI_BLE_HIDS_HID_INFORMATION_FLAGS_REMOTE_WAKE) ? "Yes" : "No"));
                                        }
                                        else
                                            DisplayFunctionError("HIDS_Decode_HID_Information", Result);
                                    }
                                    else
                                        LOG_AT_EVT("EVT_BLE: \nError - Invalid length (%u) for HID Information response.\n", AttributeValueLength);
                                }
                                else
                                {
                                    /* Handle the Report Map callback.           */
                                    if(CallbackParameter == ClientInfo->ReportMapHandle)
                                    {
                                        if(ClientInfo->ReportMap)
                                            free(ClientInfo->ReportMap);

                                        if((ClientInfo->ReportMap = malloc(AttributeValueLength)) != NULL)
                                        {
                                            ClientInfo->ReportMapLength = AttributeValueLength;
                                            memcpy(ClientInfo->ReportMap, AttributeValue, ClientInfo->ReportMapLength);

                                            Result = qc_drv_ble_GATT_Read_Long_Value_Request(qc_api_get_qc_drv_context(), BluetoothStackID, DeviceInfo->ConnectionID, ClientInfo->ReportMapHandle, ClientInfo->ReportMapLength, GATT_ClientEventCallback_HIDS, ClientInfo->ReportMapHandle);
                                        }
                                        else
                                            LOG_AT_EVT("EVT_BLE: Read report map failure: Insufficient Buffer Space.\n");
                                    }
                                    else
                                    {
                                        /* Handle the Protocol Mode callback.     */
                                        if(CallbackParameter == ClientInfo->ProtocolModeHandle)
                                        {
                                            if(AttributeValueLength == QAPI_BLE_HIDS_PROTOCOL_MODE_VALUE_LENGTH)
                                            {
                                                ClientInfo->ProtocolMode = READ_UNALIGNED_BYTE_LITTLE_ENDIAN(AttributeValue);

                                                LOG_AT_EVT("EVT_BLE: \nHIDS Protocol Mode:\n");
                                                LOG_AT_EVT("EVT_BLE:    Protocol Mode:        %s\n", (ClientInfo->ProtocolMode ? "Report" : "Boot"));
                                            }
                                            else
                                                LOG_AT_EVT("EVT_BLE: Invalid length (%u) for HID Protocol Mode response.\n", AttributeValueLength);
                                        }
                                        else
                                        {
                                            /* Handle a report reference callback  */
                                            /* by looping through the list of      */
                                            /* reports.                            */
                                            for(Index=0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                                            {
                                                if(CallbackParameter == ClientInfo->Reports[Index].ReportReferenceHandle)
                                                {
                                                    /* Decode the report reference.  */
                                                    if((Result = qc_drv_ble_HIDS_Decode_Report_Reference(qc_api_get_qc_drv_context(), AttributeValueLength, AttributeValue, &ClientInfo->Reports[Index].ReportReferenceData)) == 0)
                                                    {
                                                        LOG_AT_EVT("EVT_BLE: \nHIDS Report Reference:\n");
                                                        LOG_AT_EVT("EVT_BLE:    Report ID:            %d\n", ClientInfo->Reports[Index].ReportReferenceData.ReportID);

                                                        /* Print the report type.     */
                                                        switch(ClientInfo->Reports[Index].ReportReferenceData.ReportType)
                                                        {
                                                            case QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_INPUT_REPORT:
                                                                LOG_AT_EVT("EVT_BLE:    Report Type:          Input Report\n");
                                                                break;
                                                            case QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_OUTPUT_REPORT:
                                                                LOG_AT_EVT("EVT_BLE:    Report Type:          Output Report\n");
                                                                break;
                                                            case QAPI_BLE_HIDS_REPORT_REFERENCE_REPORT_TYPE_FEATURE_REPORT:
                                                                LOG_AT_EVT("EVT_BLE:    Report Type:          Feature Report\n");
                                                                break;
                                                            default:
                                                                LOG_AT_EVT("EVT_BLE:    Report Type:          Unknown.\n");
                                                                break;
                                                        }
                                                    }
                                                    else
                                                        DisplayFunctionError("HIDS_Decode_Report_Reference", Result);

                                                    CallbackParameterFound = TRUE;

                                                    break;
                                                }
                                            }

                                            /* Handle an external report reference */
                                            /* callback by looping through the     */
                                            /* list of external report references. */
                                            for(Index=0; Index < HIDS_MAXIMUM_NUMBER_EXTERNAL_REPORT_REFERENCES; Index++)
                                            {
                                                if(CallbackParameter == ClientInfo->ExternalReportReferences[Index].ExternalReportReferenceHandle)
                                                {
                                                    /* Decode the external report    */
                                                    /* reference.                    */
                                                    if((Result = qc_drv_ble_HIDS_Decode_External_Report_Reference(qc_api_get_qc_drv_context(), AttributeValueLength, AttributeValue, &ClientInfo->ExternalReportReferences[Index].ExternalReportReference)) == 0)
                                                    {
                                                        LOG_AT_EVT("EVT_BLE: \nHIDS External Report Reference:\n");

                                                        /* Print the UUID and type.   */
                                                        switch(ClientInfo->ExternalReportReferences[Index].ExternalReportReference.UUID_Type)
                                                        {
                                                            case QAPI_BLE_GU_UUID_16_E:
                                                                LOG_AT_EVT("EVT_BLE:    UUID Type:            UUID 16\n");
                                                                break;
                                                            case QAPI_BLE_GU_UUID_128_E:
                                                                LOG_AT_EVT("EVT_BLE:    UUID Type:            UUID 128\n");
                                                                break;
                                                            default:
                                                                break;
                                                        }
                                                        LOG_AT_EVT("EVT_BLE:    UUID:                 ");
                                                        DisplayUUID(&ClientInfo->ExternalReportReferences[Index].ExternalReportReference);
                                                    }
                                                    else
                                                        DisplayFunctionError("HIDS_Decode_External_Report_Reference", Result);

                                                    CallbackParameterFound = TRUE;

                                                    break;
                                                }
                                            }

                                            if(!CallbackParameterFound)
                                            {
                                                /* Could not find a descriptor to   */
                                                /* match the read response, so      */
                                                /* display raw data                 */
                                                CallbackParameter = 0;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        /* If the data has not been decoded and displayed,    */
                        /* then just display the raw data                     */
                        if((DeviceInfo == NULL) || (CallbackParameter == 0))
                        {
                            LOG_AT_EVT("EVT_BLE: \nRead Response.\n");
                            BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice, BoardStr);
                            LOG_AT_EVT("EVT_BLE:    Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionID);
                            LOG_AT_EVT("EVT_BLE:    Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->TransactionID);
                            LOG_AT_EVT("EVT_BLE:    Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                            LOG_AT_EVT("EVT_BLE:    BD_ADDR:         %s.\n", BoardStr);
                            LOG_AT_EVT("EVT_BLE:    Data Length:     %u.\n", AttributeValueLength);

                            LOG_AT_EVT("EVT_BLE:    Data:            { ");
                            for(Index = 0; Index < (AttributeValueLength - 1); Index++)
                                LOG_AT_EVT("EVT_BLE: 0x%02x, ", AttributeValue[Index]);

                            LOG_AT_EVT("EVT_BLE: 0x%02x }\n", AttributeValue[Index]);
                        }
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Read Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
                {
                    /* If we know about this device and a callback parameter */
                    /* exists, then check if we know what write response     */
                    /* this is.                                              */
                    if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                    {
                        /* Loop through the HIDS client information array and */
                        /* find the service for this callback parameter.      */
                        for(Index = 0; Index < MAX_SUPPORTED_HID_INSTANCES; Index++)
                        {
                            if((CallbackParameter >= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Starting_Handle) && (CallbackParameter <= DeviceInfo->HIDSClientInfo[Index].ServiceHandleRange.Ending_Handle))
                            {
                                ClientInfo    = &(DeviceInfo->HIDSClientInfo[Index]);
                                InstanceIndex = Index;
                                break;
                            }
                        }

                        /* Make sure the HIDS client information was found.   */
                        if(ClientInfo)
                        {
                            /* Handle a Boot Keyboard Input Report CCCD write. */
                            if(CallbackParameter == ClientInfo->BootKeyboardInputReport_CCCD)
                                LOG_AT_EVT("EVT_BLE: Write HIDS Boot Keyboard Input Report CCCD complete.\n");
                            else
                            {
                                /* Handle a Boot Mouse Input Report CCCD write. */
                                if(CallbackParameter == ClientInfo->BootMouseInputReport_CCCD)
                                    LOG_AT_EVT("EVT_BLE: Write HIDS Boot Mouse Input Report CCCD complete.\n");
                                else
                                {
                                    CallbackParameterFound = FALSE;

                                    /* Handle a Report CCCD write by looping     */
                                    /* through the reports.                      */
                                    for(Index=0; Index < HIDS_MAXIMUM_NUMBER_REPORTS; Index++)
                                    {
                                        if(CallbackParameter == ClientInfo->Reports[Index].CCCDHandle)
                                        {
                                            LOG_AT_EVT("EVT_BLE: Write HIDS Report ID %d CCCD complete.\n", ClientInfo->Reports[Index].ReportReferenceData.ReportID);
                                            CallbackParameterFound = TRUE;
                                            break;
                                        }
                                    }

                                    if(!CallbackParameterFound)
                                    {
                                        LOG_AT_EVT("EVT_BLE: \nWrite Response.\n");
                                        BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
                                        LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
                                        LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
                                        LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                                        LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                                        LOG_AT_EVT("EVT_BLE: Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);
                                    }
                                }
                            }
                        }
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Write Response Data.\n");
                break;
            default:
                break;
        }
    }
    else
    {
        /* There was an error with one or more of the input parameters.   */
        LOG_AT("\n");

        LOG_AT_EVT("EVT_BLE: GATT Callback Data: Event_Data = NULL.\n");
    }
}

/* The following function is for an GATT Client Event Callback.  This*/
/* function will be called whenever a GATT Response is received for a*/
/* request that was made when this function was registered.  This    */
/* function passes to the caller the GATT Client Event Data that     */
/* occurred and the GATT Client Event Callback Parameter that was    */
/* specified when this Callback was installed.  The caller is free to*/
/* use the contents of the GATT Client Event Data ONLY in the context*/
/* of this callback.  If the caller requires the Data for a longer   */
/* period of time, then the callback function MUST copy the data into*/
/* another Data Buffer.  This function is guaranteed NOT to be       */
/* invoked more than once simultaneously for the specified installed */
/* callback (i.e.  this function DOES NOT have be reentrant).  It    */
/* Needs to be noted however, that if the same Callback is installed */
/* more than once, then the callbacks will be called serially.       */
/* Because of this, the processing in this function should be as     */
/* efficient as possible.  It should also be noted that this function*/
/* is called in the Thread Context of a Thread that the User does NOT*/
/* own.  Therefore, processing in this function should be as         */
/* efficient as possible (this argument holds anyway because another */
/* GATT Event (Server/Client or Connection) will not be processed    */
/* while this function call is outstanding).                         */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_GAPS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
    boolean_t     DisplayPrompt;
    char         *NameBuffer;
    uint16_t      Appearance;
    BoardStr_t    BoardStr;
    DeviceInfo_t *DeviceInfo;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GATT_Client_Event_Data))
    {
        DisplayPrompt = true;

        /* Determine the event that occurred.                             */
        switch(GATT_Client_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Error Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

                    /* Only print out the rest if it is valid.               */
                    if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
                    {
                        LOG_AT_EVT("EVT_BLE: Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                        LOG_AT_EVT("EVT_BLE: Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                        LOG_AT_EVT("EVT_BLE: Error Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                        LOG_AT_EVT("EVT_BLE: Error Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Error Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_EXCHANGE_MTU_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Exchange MTU Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: MTU:             %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Exchange_MTU_Response_Data->ServerMTU);
                }
                else
                {
                    LOG_AT_EVT("EVT_BLE: Null Write Response Data.\n");
                }
                break;
            case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
                {
                    DisplayPrompt = false;
                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL)
                    {
                        if((uint16_t)CallbackParameter == DeviceInfo->GAPSClientInfo.DeviceNameHandle)
                        {
                            /* Display the remote device name.                 */
                            if((NameBuffer = (char *)malloc(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength+1)) != NULL)
                            {
                                memset(NameBuffer, 0, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength+1);
                                memcpy(NameBuffer, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength);

                                LOG_AT_EVT("EVT_BLE: Remote Device Name: %s.\n", NameBuffer);
                                DisplayPrompt = true;

                                free(NameBuffer);
                            }
                        }
                        else
                        {
                            if((uint16_t)CallbackParameter == DeviceInfo->GAPSClientInfo.DeviceAppearanceHandle)
                            {
                                if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength == QAPI_BLE_GAP_DEVICE_APPEARANCE_VALUE_LENGTH)
                                {
                                    Appearance = READ_UNALIGNED_WORD_LITTLE_ENDIAN(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue);
                                    if(AppearanceToString(Appearance, &NameBuffer))
                                        LOG_AT_EVT("EVT_BLE: Remote Device Appearance: %s(%u).\n", NameBuffer, Appearance);
                                    else
                                        LOG_AT_EVT("EVT_BLE: Remote Device Appearance: Unknown(%u).\n", Appearance);
                                }
                                else
                                    LOG_AT_EVT("EVT_BLE: Invalid Remote Appearance Value Length %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength);

                                DisplayPrompt = true;
                            }
                        }
                    }
                }
                else
                {
                    LOG_AT_EVT("EVT_BLE: Null Read Response Data.\n");
                }
                break;
            default:
                break;
        }

        if(DisplayPrompt)
            QCLI_Display_Prompt();
    }
}

/* The following function is for an GATT Client Event Callback.  This*/
/* function will be called whenever a GATT Response is received for a*/
/* request that was made when this function was registered.  This    */
/* function passes to the caller the GATT Client Event Data that     */
/* occurred and the GATT Client Event Callback Parameter that was    */
/* specified when this Callback was installed.  The caller is free to*/
/* use the contents of the GATT Client Event Data ONLY in the context*/
/* of this callback.  If the caller requires the Data for a longer   */
/* period of time, then the callback function MUST copy the data into*/
/* another Data Buffer.  This function is guaranteed NOT to be       */
/* invoked more than once simultaneously for the specified installed */
/* callback (i.e.  this function DOES NOT have be reentrant).  It    */
/* Needs to be noted however, that if the same Callback is installed */
/* more than once, then the callbacks will be called serially.       */
/* Because of this, the processing in this function should be as     */
/* efficient as possible.  It should also be noted that this function*/
/* is called in the Thread Context of a Thread that the User does NOT*/
/* own.  Therefore, processing in this function should be as         */
/* efficient as possible (this argument holds anyway because another */
/* GATT Event (Server/Client or Connection) will not be processed    */
/* while this function call is outstanding).                         */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_HRS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
    BoardStr_t    BoardStr;
    DeviceInfo_t *DeviceInfo;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GATT_Client_Event_Data))
    {
        /* Determine the event that occurred.                             */
        switch(GATT_Client_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Error Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

                    /* Only print out the rest if it is valid.               */
                    if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
                    {
                        LOG_AT_EVT("EVT_BLE:    Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                        LOG_AT_EVT("EVT_BLE:    Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                        LOG_AT_EVT("EVT_BLE: Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                        LOG_AT_EVT("EVT_BLE: Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Error Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Write Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);

                    /* If we know about this device and a callback parameter */
                    /* exists, then check if we know what write response this*/
                    /* is.                                                   */
                    if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                    {
                        if(CallbackParameter == DeviceInfo->HRSClientInfo.Heart_Rate_Measurement_Client_Configuration)
                            LOG_AT_EVT("EVT_BLE: \nWrite HRS Measurement CC Complete.\n");
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Write Response Data.\n");
                break;
            default:
                break;
        }
    }
    else
    {
        /* There was an error with one or more of the input parameters.   */
        LOG_AT("\n");

        LOG_AT_EVT("EVT_BLE: GATT Callback Data: Event_Data = NULL.\n");
    }
}

/* The following function is for an GATT Client Event Callback.  This*/
/* function will be called whenever a GATT Response is received for a*/
/* request that was made when this function was registered.  This    */
/* function passes to the caller the GATT Client Event Data that     */
/* occurred and the GATT Client Event Callback Parameter that was    */
/* specified when this Callback was installed.  The caller is free to*/
/* use the contents of the GATT Client Event Data ONLY in the context*/
/* of this callback.  If the caller requires the Data for a longer   */
/* period of time, then the callback function MUST copy the data into*/
/* another Data Buffer.  This function is guaranteed NOT to be       */
/* invoked more than once simultaneously for the specified installed */
/* callback (i.e.  this function DOES NOT have be reentrant).  It    */
/* Needs to be noted however, that if the same Callback is installed */
/* more than once, then the callbacks will be called serially.       */
/* Because of this, the processing in this function should be as     */
/* efficient as possible.  It should also be noted that this function*/
/* is called in the Thread Context of a Thread that the User does NOT*/
/* own.  Therefore, processing in this function should be as         */
/* efficient as possible (this argument holds anyway because another */
/* GATT Event (Server/Client or Connection) will not be processed    */
/* while this function call is outstanding).                         */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_SCPS(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
    BoardStr_t    BoardStr;
    DeviceInfo_t *DeviceInfo;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GATT_Client_Event_Data))
    {
        /* Determine the event that occurred.                             */
        switch(GATT_Client_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Error Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

                    /* Only print out the rest if it is valid.               */
                    if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
                    {
                        LOG_AT_EVT("EVT_BLE:    Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                        LOG_AT_EVT("EVT_BLE:    Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                        LOG_AT_EVT("EVT_BLE: Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                        LOG_AT_EVT("EVT_BLE: Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Error Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Read Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: AttributeValue:  %u.\n", ((uint16_t)(*(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue))));
                    LOG_AT_EVT("EVT_BLE: Data Length:     %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength);
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Read Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Write Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);

                    /* If we know about this device and a callback parameter */
                    /* exists, then check if we know what write response this*/
                    /* is.                                                   */
                    if(((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL) && (CallbackParameter != 0))
                    {
                        if(CallbackParameter == DeviceInfo->SCPSClientInfo.Scan_Refresh_Client_Configuration)
                            LOG_AT_EVT("EVT_BLE: Write Refresh Scan CC Complete.\n");
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Write Response Data.\n");
                break;
            default:
                break;
        }
    }
    else
    {
        /* There was an error with one or more of the input parameters.   */
        LOG_AT("\n");

        LOG_AT_EVT("EVT_BLE: GATT Callback Data: Event_Data = NULL.\n");
    }
}

/* The following function is for an GATT Client Event Callback.  This*/
/* function will be called whenever a GATT Response is received for a*/
/* request that was made when this function was registered.  This    */
/* function passes to the caller the GATT Client Event Data that     */
/* occurred and the GATT Client Event Callback Parameter that was    */
/* specified when this Callback was installed.  The caller is free to*/
/* use the contents of the GATT Client Event Data ONLY in the context*/
/* of this callback.  If the caller requires the Data for a longer   */
/* period of time, then the callback function MUST copy the data into*/
/* another Data Buffer.  This function is guaranteed NOT to be       */
/* invoked more than once simultaneously for the specified installed */
/* callback (i.e.  this function DOES NOT have be reentrant).  It    */
/* Needs to be noted however, that if the same Callback is installed */
/* more than once, then the callbacks will be called serially.       */
/* Because of this, the processing in this function should be as     */
/* efficient as possible.  It should also be noted that this function*/
/* is called in the Thread Context of a Thread that the User does NOT*/
/* own.  Therefore, processing in this function should be as         */
/* efficient as possible (this argument holds anyway because another */
/* GATT Event (Server/Client or Connection) will not be processed    */
/* while this function call is outstanding).                         */
/* * NOTE * This function MUST NOT Block and wait for Events that can*/
/*          only be satisfied by Receiving a Bluetooth Event         */
/*          Callback.  A Deadlock WILL occur because NO Bluetooth    */
/*          Callbacks will be issued while this function is currently*/
/*          outstanding.                                             */
static void QAPI_BLE_BTPSAPI GATT_ClientEventCallback_SPPLE(uint32_t BluetoothStackID, qapi_BLE_GATT_Client_Event_Data_t *GATT_Client_Event_Data, uint32_t CallbackParameter)
{
    boolean_t     DisplayPrompt;
    uint16_t      Credits;
    BoardStr_t    BoardStr;
    DeviceInfo_t *DeviceInfo;

    /* Verify that all parameters to this callback are Semi-Valid.       */
    if((BluetoothStackID) && (GATT_Client_Event_Data))
    {
        DisplayPrompt = true;

        /* Determine the event that occurred.                             */
        switch(GATT_Client_Event_Data->Event_Data_Type)
        {
            case QAPI_BLE_ET_GATT_CLIENT_ERROR_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Error Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Error Type:      %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)?"Response Error":"Response Timeout");

                    /* Only print out the rest if it is valid.               */
                    if(GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorType == QAPI_BLE_RET_ERROR_RESPONSE_E)
                    {
                        LOG_AT_EVT("EVT_BLE: Request Opcode:  0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestOpCode);
                        LOG_AT_EVT("EVT_BLE: Request Handle:  0x%04X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->RequestHandle);
                        LOG_AT_EVT("EVT_BLE: Error Code:      0x%02X.\n", GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode);
                        LOG_AT_EVT("EVT_BLE: Error Mesg:      %s.\n", ErrorCodeStr[GATT_Client_Event_Data->Event_Data.GATT_Request_Error_Data->ErrorCode]);
                    }
                }
                else
                    LOG_AT_EVT("EVT_BLE: Null Error Response Data.\n");
                break;
            case QAPI_BLE_ET_GATT_CLIENT_READ_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data)
                {
                    DisplayPrompt = false;

                    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->RemoteDevice)) != NULL)
                    {
                        if((uint16_t)CallbackParameter == DeviceInfo->ClientInfo.Rx_Credit_Characteristic)
                        {
                            if(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValueLength == sizeof(uint16_t))
                            {
                                /* Display the credits we just received.        */
                                Credits = READ_UNALIGNED_WORD_LITTLE_ENDIAN(GATT_Client_Event_Data->Event_Data.GATT_Read_Response_Data->AttributeValue);
                                LOG_AT_EVT("EVT_BLE: Received %u Initial Credits.\n", Credits);

                                DisplayPrompt = true;

                                /* We have received the initial credits from the*/
                                /* device so go ahead and handle a Receive      */
                                /* Credit Event.                                */
                                ReceiveCreditEvent(DeviceInfo, Credits);
                            }
                        }
                    }
                }
                else
                {
                    LOG_AT_EVT("EVT_BLE: Null Read Response Data.\n");
                }
                break;
            case QAPI_BLE_ET_GATT_CLIENT_WRITE_RESPONSE_E:
                if(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data)
                {
                    LOG_AT_EVT("EVT_BLE: Write Response.\n");
                    BD_ADDRToStr(GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->RemoteDevice, BoardStr);
                    LOG_AT_EVT("EVT_BLE: Connection ID:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionID);
                    LOG_AT_EVT("EVT_BLE: Transaction ID:  %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->TransactionID);
                    LOG_AT_EVT("EVT_BLE: Connection Type: %s.\n", (GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->ConnectionType == QAPI_BLE_GCT_LE_E)?"LE":"BR/EDR");
                    LOG_AT_EVT("EVT_BLE: BD_ADDR:         %s.\n", BoardStr);
                    LOG_AT_EVT("EVT_BLE: Bytes Written:   %u.\n", GATT_Client_Event_Data->Event_Data.GATT_Write_Response_Data->BytesWritten);
                }
                else
                {
                    LOG_AT_EVT("EVT_BLE: Null Write Response Data.\n");
                }
                break;
            default:
                break;
        }

        if(DisplayPrompt)
            QCLI_Display_Prompt();
    }
}

/******************************************************************************/
/**  EventCallback(uint32_t, HCI_Event_Data_t *, uint32_t)                   **/
/******************************************************************************/
/**  EventCallback Function.                                                 **/
/******************************************************************************/
static void EventCallback(uint32_t BluetoothStackID, qapi_BLE_HCI_Event_Data_t *HCI_Event_Data, uint32_t CallbackParameter)
{
    int          i;
    int          Event;
    uint16_t     Connection_Handle;
    unsigned int _NumberPackets;

    if((BluetoothStackID) && (HCI_Event_Data))
    {
        Event = (int)HCI_Event_Data->Event_Data_Type;
        switch(Event)
        {
            case QAPI_BLE_ET_NUMBER_OF_COMPLETED_PACKETS_EVENT_E:
                if((CurrentTest == CURRENT_TEST_TX_ACL) || (CurrentTest == CURRENT_TEST_PERIODIC))
                {
                    for(i=0; i < HCI_Event_Data->Event_Data.HCI_Number_Of_Completed_Packets_Event_Data->Number_of_Handles; i++)
                    {
                        /* Iterate through all of the handles and determine   */
                        /* the number of packets that have been sent for each */
                        /* connection.                                        */
                        Connection_Handle = HCI_Event_Data->Event_Data.HCI_Number_Of_Completed_Packets_Event_Data->HCI_Number_Of_Completed_Packets_Data[i].Connection_Handle;

                        if(Connection_Handle == ConnectionHandle)
                        {
                            /* Debit the number of packets sent for this       */
                            /* connection handle and Credit the number of      */
                            /* packets that can now be sent.                   */
                            _NumberPackets = HCI_Event_Data->Event_Data.HCI_Number_Of_Completed_Packets_Event_Data->HCI_Number_Of_Completed_Packets_Data[i].HC_Num_Of_Completed_Packets;

                            if(_NumberPackets > NumberOutstandingACLPackets)
                                _NumberPackets = NumberOutstandingACLPackets;

                            NumberOutstandingACLPackets -= _NumberPackets;

                            if(CurrentTest == CURRENT_TEST_TX_ACL)
                                SendACLData(PacketLength, TestBuffer);
                            break;
                        }
                    }
                }
                break;
            case QAPI_BLE_ET_DISCONNECTION_COMPLETE_EVENT_E:
                if(ConnectionHandle == HCI_Event_Data->Event_Data.HCI_Disconnection_Complete_Event_Data->Connection_Handle)
                {
                    ConnectionHandle            = QAPI_BLE_HCI_CONNECTION_HANDLE_INVALID_VALUE;
                    CurrentTest                 = CURRENT_TEST_NONE;
                    NumberOutstandingACLPackets = 0;
                }
                break;
        }
    }
}

/******************************************************************************/
/**  ACLDataCallback()                                                       **/
/******************************************************************************/
/**  ACLDataCallback Function.                                               **/
/******************************************************************************/
static void ACLDataCallback(uint32_t BluetoothStackID, uint16_t Connection_Handle, uint16_t Flags, uint16_t ACLDataLength, uint8_t *ACLData, uint32_t CallbackParameter)
{
    if((BluetoothStackID) && (CurrentTest == CURRENT_TEST_RX_ACL))
    {
        /* This callback assumes the data coming in are L2CAP packets,    */
        /* since that is what it sends.                                   */

        /* First check to see if this is a ACL packet we are interested   */
        /* in.                                                            */
        if(Connection_Handle == ConnectionHandle)
        {
            if(!StartTime)
                StartTime = (uint32_t)qurt_timer_get_ticks();

            NumberBytes += ACLDataLength;
        }
    }
}

/* This function is used to register the SPPLE Command Group with    */
/* QCLI.                                                             */
void Initialize_SPPLE_Demo(void)
{
    boolean_t Error = FALSE;

    /* Attempt to reqister the BLE Command Group with the qcli framework.*/
    ble_group = QCLI_Register_Command_Group(NULL, &ble_cmd_group);
    if(ble_group)
    {

#ifdef V2

        /* Attempt to register the BT5 sub-group.                         */
        bt5_group = QCLI_Register_Command_Group(ble_group, &bt5_cmd_group);
        if(bt5_group == NULL)
        {
            LOG_ERR("failed to register BT5 sub group with QCLI.\n");

            Error = TRUE;
        }

#endif

        /* Attempt to register the Automation IO Service (AIOS) sub-group.*/
        aios_group = QCLI_Register_Command_Group(ble_group, &aios_cmd_group);
        if(aios_group == NULL)
        {
            LOG_ERR("failed to register AIOS sub group with QCLI.\n");

            Error = TRUE;
        }

        /* Attempt to register the Battery Alert Service (BAS) sub-group. */
        bas_group = QCLI_Register_Command_Group(ble_group, &bas_cmd_group);
        if(bas_group == NULL)
        {
            LOG_ERR("failed to register BAS sub group with QCLI.\n");

            Error = TRUE;
        }

        /* Attempt to register the Generic Access Profile Service (GAPS)  */
        /* sub-group.                                                     */
        gaps_group = QCLI_Register_Command_Group(ble_group, &gaps_cmd_group);
        if(gaps_group == NULL)
        {
            LOG_ERR("failed to register GAPS sub group with QCLI.\n");

            Error = TRUE;
        }

        /* Attempt to register the HID over GATT service sub-group.       */
        hids_group = QCLI_Register_Command_Group(ble_group, &hogp_cmd_group);
        if(hids_group == NULL)
        {
            LOG_ERR("failed to register HOGP sub group with QCLI.\n");

            Error = TRUE;
        }

        /* Attempt to register the Heart Rate Service sub-group.          */
        hrs_group = QCLI_Register_Command_Group(ble_group, &hrs_cmd_group);
        if(hrs_group == NULL)
        {
            LOG_ERR("failed to register HRS sub group with QCLI.\n");

            Error = TRUE;
        }

        /* Attempt to register the Device Information Service sub-group.          */
        dis_group = QCLI_Register_Command_Group(ble_group, &dis_cmd_group);
        if(dis_group == NULL)
        {
            LOG_ERR("failed to register DIS sub group with QCLI.\n");

            Error = TRUE;
        }

        /* Attempt to register the Transport Power Service sub-group.          */
        tps_group = QCLI_Register_Command_Group(ble_group, &tps_cmd_group);
        if(tps_group == NULL)
        {
            LOG_ERR("failed to register TPS sub group with QCLI.\n");

            Error = TRUE;
        }
        /* Attempt to register the Scan Parameter service sub-group.      */
        scps_group = QCLI_Register_Command_Group(ble_group, &scps_cmd_group);
        if(scps_group == NULL)
        {
            LOG_ERR("failed to register SCPS sub group with QCLI.\n");

            Error = TRUE;
        }

        /* Attempt to register the SPPLE sub-group.                       */
        spple_group = QCLI_Register_Command_Group(ble_group, &spple_cmd_group);
        if(spple_group == NULL)
        {
            LOG_ERR("failed to register SPPLE sub group with QCLI.\n");

            Error = TRUE;
        }

        /* Check to see if all sub-groups were registered successfully.   */
        if(!Error)
        {
            /* Initialize the BLE Parameters.                              */
            memset(&BLEParameters, 0, sizeof(BLEParameters));

            /* Set the HCI driver information.                             */
            QAPI_BLE_HCI_DRIVER_SET_COMM_INFORMATION(&HCI_DriverInformation, 1, 115200, QAPI_BLE_COMM_PROTOCOL_UART_E);
        }
        else
        {
            /* Un-register the BLE Group.                                  */
            QCLI_Unregister_Command_Group(ble_group);

            ble_group      = NULL;
            aios_group     = NULL;
            bas_group      = NULL;
            gaps_group     = NULL;
            scps_group     = NULL;
            spple_group    = NULL;
        }
    }
}

/* Returns the current Bluetooth Stack ID.                           */
uint32_t GetBluetoothStackID(void)
{
    return(BluetoothStackID);
}

/* Returns the current Bluetooth Stack ID.                           */
unsigned int GetConnectionID(qapi_BLE_BD_ADDR_t RemoteDevice)
{
    unsigned int  RetVal = 0;
    DeviceInfo_t *DeviceInfo;

    /* Get the device info for the remote device.                        */
    if((DeviceInfo = SearchDeviceInfoEntryByBD_ADDR(&DeviceInfoList, RemoteDevice)) != NULL)
        RetVal = DeviceInfo->ConnectionID;
    return(RetVal);
}

/* The following function is responsible for the specified string    */
/* into data of type BD_ADDR.  The first parameter of this function  */
/* is the BD_ADDR string to be converted to a BD_ADDR.  The second   */
/* parameter of this function is a pointer to the BD_ADDR in which   */
/* the converted BD_ADDR String is to be stored.                     */
void StrToBD_ADDR(char *BoardStr, qapi_BLE_BD_ADDR_t *Board_Address)
{
    char Buffer[5];

    if((BoardStr) && (strlen(BoardStr) == sizeof(qapi_BLE_BD_ADDR_t)*2) && (Board_Address))
    {
        Buffer[0] = '0';
        Buffer[1] = 'x';
        Buffer[4] = '\0';

        Buffer[2] = BoardStr[0];
        Buffer[3] = BoardStr[1];
        Board_Address->BD_ADDR5 = (uint8_t)StringToUnsignedInteger(Buffer);

        Buffer[2] = BoardStr[2];
        Buffer[3] = BoardStr[3];
        Board_Address->BD_ADDR4 = (uint8_t)StringToUnsignedInteger(Buffer);

        Buffer[2] = BoardStr[4];
        Buffer[3] = BoardStr[5];
        Board_Address->BD_ADDR3 = (uint8_t)StringToUnsignedInteger(Buffer);

        Buffer[2] = BoardStr[6];
        Buffer[3] = BoardStr[7];
        Board_Address->BD_ADDR2 = (uint8_t)StringToUnsignedInteger(Buffer);

        Buffer[2] = BoardStr[8];
        Buffer[3] = BoardStr[9];
        Board_Address->BD_ADDR1 = (uint8_t)StringToUnsignedInteger(Buffer);

        Buffer[2] = BoardStr[10];
        Buffer[3] = BoardStr[11];
        Board_Address->BD_ADDR0 = (uint8_t)StringToUnsignedInteger(Buffer);
    }
    else
    {
        if(Board_Address)
            memset(Board_Address, 0, sizeof(qapi_BLE_BD_ADDR_t));
    }
}
